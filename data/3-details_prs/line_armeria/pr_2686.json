{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNTY5MjEx", "number": 2686, "title": "Support servlet API", "bodyText": "Motivation:\nIt will be nice if Armeria supports servlet.\nModifications:\n\nAdded servlet4 module and implemented the minimum features.\n\nResult:\n\nSupport the part of servlet APIs", "createdAt": "2020-05-03T08:35:47Z", "url": "https://github.com/line/armeria/pull/2686", "merged": true, "mergeCommit": {"oid": "d9d87df82fc6d6848c36dea43f08cd5b7666fcb7"}, "closed": true, "closedAt": "2020-07-29T01:28:28Z", "author": {"login": "dominhhien"}, "timelineItems": {"totalCount": 103, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc46cl_AH2gAyNDEyNTY5MjExOjJhOWQzZDAwOTViYzEwNjE1MWFkOTdmYTE0Mjc2ODBlMTNhMzYyYWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5ZHrrgFqTQ1NjgxMjcxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/2a9d3d0095bc106151ad97fa1427680e13a362aa", "committedDate": "2020-07-27T04:51:34Z", "message": "Rename module servlet to servlet4"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NTI3MTQ0", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-455527144", "createdAt": "2020-07-27T07:19:07Z", "commit": {"oid": "2a9d3d0095bc106151ad97fa1427680e13a362aa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2ODEyNzE1", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-456812715", "createdAt": "2020-07-28T16:35:47Z", "commit": {"oid": "2a9d3d0095bc106151ad97fa1427680e13a362aa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0Nzg1MjM3", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-404785237", "createdAt": "2020-05-04T08:16:45Z", "commit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwODoxNjo0N1rOGP2low==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwODo0NzoxMVrOGP3ipw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3NjE5NQ==", "bodyText": "Because this class is not used, could you remove this?", "url": "https://github.com/line/armeria/pull/2686#discussion_r419276195", "createdAt": "2020-05-04T08:16:47Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/AbstractChannelHandler.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.internal.TypeParameterMatcher;\n+\n+/**\n+ *  An abstract netty ChannelHandler.\n+ */\n+public abstract class AbstractChannelHandler<I,O> extends ChannelDuplexHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3Nzk4OA==", "bodyText": "This could be final.", "url": "https://github.com/line/armeria/pull/2686#discussion_r419277988", "createdAt": "2020-05-04T08:20:24Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3ODEzMg==", "bodyText": "It doesn't look nullable. Is it?", "url": "https://github.com/line/armeria/pull/2686#discussion_r419278132", "createdAt": "2020-05-04T08:20:44Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3Nzk4OA=="}, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3ODYzMQ==", "bodyText": "This must not be a field because of concurrency. How about just passing it when calling process method?", "url": "https://github.com/line/armeria/pull/2686#discussion_r419278631", "createdAt": "2020-05-04T08:21:43Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3OTIxOA==", "bodyText": "We use of for this purpose.\nServletHttpExchange.of(...)", "url": "https://github.com/line/armeria/pull/2686#discussion_r419279218", "createdAt": "2020-05-04T08:22:59Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            servletHttpExchange = ServletHttpExchange.newInstance(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MDMyMg==", "bodyText": "We don't need to do the type-casting.", "url": "https://github.com/line/armeria/pull/2686#discussion_r419280322", "createdAt": "2020-05-04T08:25:02Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            servletHttpExchange = ServletHttpExchange.newInstance(\n+                    servletContext, (DefaultServiceRequestContext) ctx, aReq);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MDY5OA==", "bodyText": "Let's handle a case where cause is not null.", "url": "https://github.com/line/armeria/pull/2686#discussion_r419280698", "createdAt": "2020-05-04T08:25:44Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MjQ3Mw==", "bodyText": "Shouldn't we return here if dispatcher is null", "url": "https://github.com/line/armeria/pull/2686#discussion_r419282473", "createdAt": "2020-05-04T08:29:11Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            servletHttpExchange = ServletHttpExchange.newInstance(\n+                    servletContext, (DefaultServiceRequestContext) ctx, aReq);\n+            process(res);\n+            return null;\n+        });\n+        return res;\n+    }\n+\n+    private void process(HttpResponseWriter res) {\n+        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n+        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n+        try {\n+            final ServletRequestDispatcher dispatcher =\n+                    servletHttpExchange.getServletContext()\n+                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n+            if (dispatcher == null) {\n+                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MzIxNw==", "bodyText": "ctx is not used. Could you remove that?", "url": "https://github.com/line/armeria/pull/2686#discussion_r419283217", "createdAt": "2020-05-04T08:30:37Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n+     */\n+    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NTUwNQ==", "bodyText": "This is not used.", "url": "https://github.com/line/armeria/pull/2686#discussion_r419285505", "createdAt": "2020-05-04T08:35:15Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NjAzNg==", "bodyText": "How about passing and creating(if needed) all parameters so that we can make these all final?", "url": "https://github.com/line/armeria/pull/2686#discussion_r419286036", "createdAt": "2020-05-04T08:36:14Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NjgzNQ==", "bodyText": "I don't see any code calling this what is this for?", "url": "https://github.com/line/armeria/pull/2686#discussion_r419286835", "createdAt": "2020-05-04T08:37:48Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4Njg5NA==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r419286894", "createdAt": "2020-05-04T08:37:54Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4Nzg1OQ==", "bodyText": "It's never null, so we don't need this check", "url": "https://github.com/line/armeria/pull/2686#discussion_r419287859", "createdAt": "2020-05-04T08:39:43Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4ODA3OQ==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r419288079", "createdAt": "2020-05-04T08:40:09Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4OTA4Mw==", "bodyText": "Is it always use HTTP/1.1?", "url": "https://github.com/line/armeria/pull/2686#discussion_r419289083", "createdAt": "2020-05-04T08:42:11Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n+     */\n+    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n+                                                          AggregatedHttpRequest request) {\n+        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n+        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n+                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MTgxNQ==", "bodyText": "I decided to keep io.netty.handler.codec.http.FullHttpRequest because I don't want to clone all parsing APIs and decoding APIs from Netty project. I reused these APIs. I implemented servlet OutputStream, servlet PrintWriter.\n\nWe have the corresponding parsing and decoding APIs. If we don't we can add the APIs. The Netty HttpRequest is already converted to Armeria HttpRequest before it gets here and changing it back is not reasonable. We should not use that.", "url": "https://github.com/line/armeria/pull/2686#discussion_r419291815", "createdAt": "2020-05-04T08:47:11Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n+     */\n+    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n+                                                          AggregatedHttpRequest request) {\n+        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n+        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df04b46e91943150374f7889d7be7fe56b8c2fe5"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDQ1OTQy", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-405445942", "createdAt": "2020-05-05T01:15:08Z", "commit": {"oid": "54698fb02e529a7a51ceee92199eb76db6155006"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMToxNTowOFrOGQXkNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMToxNTowOFrOGQXkNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxNjUwMA==", "bodyText": "I add new class ServletMultipartRequest here because Armeria HttpRequest is not support multipart. I will create another pull request to fix #253 Add HTTP multipart content support and refactor this code later.", "url": "https://github.com/line/armeria/pull/2686#discussion_r419816500", "createdAt": "2020-05-05T01:15:08Z", "author": {"login": "dominhhien"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,1053 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.RequestDispatcher;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletRequestAttributeEvent;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.ServletSecurityElement;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.StringUtil;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.CodecException;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.multipart.Attribute;\n+import io.netty.handler.codec.http.multipart.FileUpload;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.handler.codec.http.multipart.HttpPostMultipartRequestDecoder;\n+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\n+import io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder;\n+import io.netty.handler.codec.http.multipart.InterfaceHttpData;\n+import io.netty.handler.codec.http.multipart.InterfaceHttpPostRequestDecoder;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final Locale[] DEFAULT_LOCALS = {Locale.getDefault()};\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n+\n+    private ServletHttpExchange servletHttpExchange;\n+    private String protocol;\n+    private String scheme;\n+    private String servletPath;\n+    private String queryString;\n+    private String pathInfo;\n+    private String requestURI;\n+    private String characterEncoding;\n+    private String sessionId;\n+    private SessionTrackingMode sessionIdSource;\n+    private MultipartConfigElement multipartConfigElement;\n+    private ServletSecurityElement servletSecurityElement;\n+    private boolean decodePathsFlag;\n+    private boolean decodeCookieFlag;\n+    private boolean decodeParameterByUrlFlag;\n+    private InterfaceHttpPostRequestDecoder postRequestDecoder;\n+    private boolean remoteSchemeFlag;\n+    private boolean usingInputStreamFlag;\n+    private BufferedReader reader;\n+    private AggregatedHttpRequest httpRequest;\n+    private ServletInputStreamWrapper inputStream = new ServletInputStreamWrapper();\n+    private Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n+    private Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n+            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n+            for (Entry<String,List<String>> entry : entries) {\n+                final List<String> value = entry.getValue();\n+                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n+                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String[] get(Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[value.size()]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return parameterMap.containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Cookie[] cookies;\n+    private Locale[] locales;\n+    private Boolean asyncSupportedFlag;\n+    private ServletRequestDispatcher dispatcher;\n+\n+    protected ServletHttpRequest() {}\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpRequest of(ServletHttpExchange servletHttpExchange,\n+                                        AggregatedHttpRequest request) {\n+        final ServletHttpRequest instance = new ServletHttpRequest();\n+        instance.servletHttpExchange = servletHttpExchange;\n+        instance.httpRequest = request;\n+        instance.inputStream.wrap(Unpooled.wrappedBuffer(request.content().array()));\n+        instance.getParameterMap();\n+        instance.getCookies();\n+        instance.getLocale();\n+        instance.getProtocol();\n+        instance.getScheme();\n+        return instance;\n+    }\n+\n+    void setDispatcher(ServletRequestDispatcher dispatcher) {\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    void setMultipartConfigElement(MultipartConfigElement multipartConfigElement) {\n+        this.multipartConfigElement = multipartConfigElement;\n+    }\n+\n+    void setServletSecurityElement(ServletSecurityElement servletSecurityElement) {\n+        this.servletSecurityElement = servletSecurityElement;\n+    }\n+\n+    void setAsyncSupportedFlag(Boolean asyncSupportedFlag) {\n+        this.asyncSupportedFlag = asyncSupportedFlag;\n+    }\n+\n+    /**\n+     * Get servlet http exchange.\n+     */\n+    public ServletHttpExchange getServletHttpExchange() {\n+        return servletHttpExchange;\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    public AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse request scheme.\n+     */\n+    private void decodeScheme() {\n+        scheme = httpRequest.scheme();\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private void decodeLocale() {\n+        final Locale[] locales;\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue == null) {\n+            locales = DEFAULT_LOCALS;\n+        } else {\n+            final String[] values = headerValue.split(\",\");\n+            final int length = values.length;\n+            locales = new Locale[length];\n+            for (int i = 0; i < length; i++) {\n+                final String value = values[i];\n+                final String[] valueSp = value.split(\";\");\n+                final Locale locale;\n+                if (valueSp.length > 0) {\n+                    locale = Locale.forLanguageTag(valueSp[0]);\n+                } else {\n+                    locale = Locale.forLanguageTag(value);\n+                }\n+                locales[i] = locale;\n+            }\n+        }\n+        this.locales = locales;\n+    }\n+\n+    /**\n+     * Parsing coding.\n+     */\n+    private void decodeCharacterEncoding() {\n+        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        if (characterEncoding == null) {\n+            characterEncoding = getServletContext().getRequestCharacterEncoding();\n+        }\n+       this.characterEncoding = characterEncoding;\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody(boolean bodyPartFlag) {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        final HttpDataFactory factory = getServletContext().getHttpDataFactory(charset);\n+        int discardThreshold = 0;\n+        if (multipartConfigElement != null) {\n+            factory.setMaxLimit(multipartConfigElement.getMaxFileSize());\n+            discardThreshold = multipartConfigElement.getFileSizeThreshold();\n+        }\n+\n+        final HttpRequest request = new ServletMultipartRequest(httpRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54698fb02e529a7a51ceee92199eb76db6155006"}, "originalPosition": 272}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MDkyMTE2", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-407092116", "createdAt": "2020-05-07T01:26:14Z", "commit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMToyNjoxNFrOGRrITg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjoxNDoyMFrOGRr7zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTYxNA==", "bodyText": "Can remove @Nullable.", "url": "https://github.com/line/armeria/pull/2686#discussion_r421185614", "createdAt": "2020-05-07T01:26:14Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTY0Nw==", "bodyText": "nit: final", "url": "https://github.com/line/armeria/pull/2686#discussion_r421185647", "createdAt": "2020-05-07T01:26:20Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTY3MQ==", "bodyText": "nit: final", "url": "https://github.com/line/armeria/pull/2686#discussion_r421185671", "createdAt": "2020-05-07T01:26:27Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NjEwNw==", "bodyText": "requireNonNull(serverBuilder, \"serverBuilder\");", "url": "https://github.com/line/armeria/pull/2686#discussion_r421186107", "createdAt": "2020-05-07T01:28:01Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        servletContext = new ServletContextImpl();\n+        this.serverBuilder = serverBuilder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NjQzNQ==", "bodyText": "requireNonNull(path, \"path\");\nrequireNonNull(httpServlet, \"httpServlet\");", "url": "https://github.com/line/armeria/pull/2686#discussion_r421186435", "createdAt": "2020-05-07T01:29:12Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        servletContext = new ServletContextImpl();\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link DefaultServletService}.\n+     */\n+    public ServerBuilder build() {\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet of the {@link DefaultServletService}.\n+     */\n+    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTE3Mg==", "bodyText": "Question: Is this class from Servlet spec? or did you implement this class just for convenience?", "url": "https://github.com/line/armeria/pull/2686#discussion_r421189172", "createdAt": "2020-05-07T01:38:49Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletRequestAttributeEvent;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestEvent;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+/**\n+ * Servlet global event listener.\n+ */\n+public class ServletEventListenerManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTE5Mg==", "bodyText": "Question: Is this class from Servlet spec? or did you implement it just for convenience?", "url": "https://github.com/line/armeria/pull/2686#discussion_r421189192", "createdAt": "2020-05-07T01:38:54Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletRequestAttributeEvent;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestEvent;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+/**\n+ * Servlet global event listener.\n+ */\n+public class ServletEventListenerManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTY1Mw==", "bodyText": "Can remove javax.servlet.ServletRegistration because Dynamic extends it.", "url": "https://github.com/line/armeria/pull/2686#discussion_r421189653", "createdAt": "2020-05-07T01:40:33Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration\n+        implements javax.servlet.ServletRegistration, Dynamic {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDEwMQ==", "bodyText": "Question: Does this have to be Dynamic? If all parameters are set when it's added, could be just ServletRegistration?", "url": "https://github.com/line/armeria/pull/2686#discussion_r421190101", "createdAt": "2020-05-07T01:42:20Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        servletContext = new ServletContextImpl();\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link DefaultServletService}.\n+     */\n+    public ServerBuilder build() {\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet of the {@link DefaultServletService}.\n+     */\n+    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {\n+        final ServletRegistration.Dynamic sd = servletContext.addServlet(path, httpServlet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDUxNw==", "bodyText": "Please add static final. Also we just use ServleteContextImpl.class.\nprivate static final Logger logger = LoggerFactory.getLogger(ServleteContextImpl.class);", "url": "https://github.com/line/armeria/pull/2686#discussion_r421190517", "createdAt": "2020-05-07T01:43:51Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDc2Mg==", "bodyText": "Let's rename to DefaultServletContext.", "url": "https://github.com/line/armeria/pull/2686#discussion_r421190762", "createdAt": "2020-05-07T01:44:45Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MTU3NA==", "bodyText": "Let's add these fields to ServletBuilder so that a user change the values.", "url": "https://github.com/line/armeria/pull/2686#discussion_r421191574", "createdAt": "2020-05-07T01:47:46Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MTg2NA==", "bodyText": "After that. We can get all properties from the constructor and make all properties as final.", "url": "https://github.com/line/armeria/pull/2686#discussion_r421191864", "createdAt": "2020-05-07T01:48:44Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MTU3NA=="}, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjAzOQ==", "bodyText": "this.classLoader = requireNonNull(classLoader, \"classLoader\");", "url": "https://github.com/line/armeria/pull/2686#discussion_r421192039", "createdAt": "2020-05-07T01:49:22Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjQ2Ng==", "bodyText": "requireNonNull(absoluteUri, \"absoluteUri\");", "url": "https://github.com/line/armeria/pull/2686#discussion_r421192466", "createdAt": "2020-05-07T01:50:44Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n+    }\n+\n+    /**\n+     * Get servlet event listener manager.\n+     */\n+    public ServletEventListenerManager getServletEventListenerManager() {\n+        return servletEventListenerManager;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        return servletUrlMapper.getServletPath(absoluteUri);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5Mzc3NA==", "bodyText": "checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout)", "url": "https://github.com/line/armeria/pull/2686#discussion_r421193774", "createdAt": "2020-05-07T01:55:06Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n+    }\n+\n+    /**\n+     * Get servlet event listener manager.\n+     */\n+    public ServletEventListenerManager getServletEventListenerManager() {\n+        return servletEventListenerManager;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        if (sessionTimeout <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NTQwOA==", "bodyText": "Is there any reason to make ServletHttpExchange?\nWe have ServletContextImpl already, couldn't we just make ServletHttpRequest and ServletHttpResponse directly?", "url": "https://github.com/line/armeria/pull/2686#discussion_r421195408", "createdAt": "2020-05-07T02:01:13Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            if (cause != null) {\n+                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n+                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n+                    res.close();\n+                }\n+                return null;\n+            }\n+            process(res, ServletHttpExchange.of(servletContext, ctx, aReq));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw==", "bodyText": "If we add the ServletService one by one, https://github.com/line/armeria/pull/2686/files#diff-6b0e2525eb80747c141e9fb8daa2c3adR56, we don't need this dispatcher\nbecause Armeria server will handle the routing.", "url": "https://github.com/line/armeria/pull/2686#discussion_r421198343", "createdAt": "2020-05-07T02:12:33Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            if (cause != null) {\n+                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n+                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n+                    res.close();\n+                }\n+                return null;\n+            }\n+            process(res, ServletHttpExchange.of(servletContext, ctx, aReq));\n+            return null;\n+        });\n+        return res;\n+    }\n+\n+    private void process(HttpResponseWriter res, ServletHttpExchange servletHttpExchange) {\n+        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n+        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n+        try {\n+            final ServletRequestDispatcher dispatcher =\n+                    servletHttpExchange.getServletContext()\n+                                       .getRequestDispatcher(httpServletRequest.getRequestURI());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODY1MQ==", "bodyText": "Please use requireNonNull through out this PR if the parameter is not annotated with @Nullable.", "url": "https://github.com/line/armeria/pull/2686#discussion_r421198651", "createdAt": "2020-05-07T02:13:48Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n+    }\n+\n+    /**\n+     * Get servlet event listener manager.\n+     */\n+    public ServletEventListenerManager getServletEventListenerManager() {\n+        return servletEventListenerManager;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        return servletUrlMapper.getServletPath(absoluteUri);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjQ2Ng=="}, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODc5Ng==", "bodyText": "Please validate the parameter through out this PR.", "url": "https://github.com/line/armeria/pull/2686#discussion_r421198796", "createdAt": "2020-05-07T02:14:20Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n+    }\n+\n+    /**\n+     * Get servlet event listener manager.\n+     */\n+    public ServletEventListenerManager getServletEventListenerManager() {\n+        return servletEventListenerManager;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        if (sessionTimeout <= 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5Mzc3NA=="}, "originalCommit": {"oid": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NzUwMDQ3", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-409750047", "createdAt": "2020-05-12T06:59:30Z", "commit": {"oid": "df2377dcecf31a1b82bc4ebed6bb802065c38069"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNjo1OTozMFrOGT4pJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzoyODo0NFrOGT5kTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ==", "bodyText": "There is no way to set these properties.\nHow about adding it to ServletBuilder?\nServletBuilder servletBuilder = ...\nservletBuilder.requestCharacterEncoding(...)\n...\nservletBuilder.build(); // DefaultServletContext is created at this point based on the properties set so far.", "url": "https://github.com/line/armeria/pull/2686#discussion_r423504165", "createdAt": "2020-05-12T06:59:30Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private final MimeMappings mimeMappings = new MimeMappings();\n+    private final ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private ClassLoader classLoader = getClass().getClassLoader();\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2377dcecf31a1b82bc4ebed6bb802065c38069"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxODE4Nw==", "bodyText": "Because we are just handling sync servlet (we are going to handle the async servlets later) we must use blockingTaskExecutor.\nctx.blockingTaskExecutor().execute(() -> {\n    ...\n});\n// or we just can do it in handle.\nreq.aggregate().handleAsync((aReq, cause) -> {\n    ...\n}, ctx.blockingTaskExecutor());", "url": "https://github.com/line/armeria/pull/2686#discussion_r423518187", "createdAt": "2020-05-12T07:26:48Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final DefaultServletContext servletContext;\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private ServiceRequestContext serviceRequestContext;\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public DefaultServletContext getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public ServiceRequestContext getServiceRequestContext() {\n+        return serviceRequestContext;\n+    }\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(DefaultServletContext servletContext) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(req, \"req\");\n+        serviceRequestContext = ctx;\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            if (cause != null) {\n+                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n+                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n+                    res.close();\n+                }\n+                return null;\n+            }\n+            process(res, aReq);\n+            return null;\n+        });\n+        return res;\n+    }\n+\n+    private void process(HttpResponseWriter res, AggregatedHttpRequest req) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2377dcecf31a1b82bc4ebed6bb802065c38069"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxOTMwOA==", "bodyText": "These three properties can be here. Please imagine a situation that this DefaultServletService handles multiple thousands requests.", "url": "https://github.com/line/armeria/pull/2686#discussion_r423519308", "createdAt": "2020-05-12T07:28:44Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final DefaultServletContext servletContext;\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private ServiceRequestContext serviceRequestContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2377dcecf31a1b82bc4ebed6bb802065c38069"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMjk1OTEz", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-412295913", "createdAt": "2020-05-15T01:51:53Z", "commit": {"oid": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMTo1MTo1M1rOGVz1uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNDoxNzozM1rOGV18vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMjYxNg==", "bodyText": "Let's split this constructor into two:\npublic ServletBuilder(ServerBuilder serverBuilder) {\n    this(serverBuilder, \"\");\n}\n\npublic ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n    requireNonNull(serverBuilder, \"serverBuilder\");\n    requireNonNull(contextPath, \"contextPath\");\n    ...\n}", "url": "https://github.com/line/armeria/pull/2686#discussion_r425522616", "createdAt": "2020-05-15T01:51:53Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMjk2OQ==", "bodyText": "Please note that the contextPath could be: /x/y/z\nSo we should do contextPath.charAt(contextPath.length() - 1) != '/'", "url": "https://github.com/line/armeria/pull/2686#discussion_r425522969", "createdAt": "2020-05-15T01:53:15Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        if (Objects.isNull(contextPath)) {\n+            contextPath = \"\";\n+        }\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.charAt(0) == '/' && !contextPath.substring(1).contains(\"/\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ==", "bodyText": "I think we can just add one DefaultServletService when ServletBuilder.build() is called.\nserverBuilder.serviceUnder(contextPath, new DefaultServletService(servletContext));\n\nBecause we use context.getRequestDispacher(path) in DefaultServletService to find the corresponding Servlet.", "url": "https://github.com/line/armeria/pull/2686#discussion_r425556981", "createdAt": "2020-05-15T04:16:39Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        if (Objects.isNull(contextPath)) {\n+            contextPath = \"\";\n+        }\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.charAt(0) == '/' && !contextPath.substring(1).contains(\"/\"),\n+                          \"Context path have to start with / and contains only one /\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!\"\".equals(contextPath)) {\n+            path = \"/\".equals(path) ? contextPath : contextPath + path;\n+        }\n+        ServletRegistration sd = null;\n+        if (servlet instanceof String) {\n+            sd = servletContext.addServlet(path, (String) servlet);\n+        } else {\n+            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n+        }\n+        sd.addMapping(path);\n+        serverBuilder.service(path, new DefaultServletService(servletContext));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NzE4MA==", "bodyText": "Question: Should we allow to add a servlet after the Server is started?", "url": "https://github.com/line/armeria/pull/2686#discussion_r425557180", "createdAt": "2020-05-15T04:17:33Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,570 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            filterList.add(registration);\n+        }\n+        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            for (String servletName : registration.getServletNameMappings()) {\n+                if (servletName.equals(name)) {\n+                    filterList.add(registration);\n+                }\n+            }\n+        }\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        final List<Servlet> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getServlet());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        final List<String> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getName());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f"}, "originalPosition": 356}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "committedDate": "2020-05-19T03:09:56Z", "message": "Merge branch 'master' of https://github.com/dominhhien/armeria"}, "afterCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "committedDate": "2020-05-15T11:10:35Z", "message": "Fix servlet context path, prevent add servlet, filter after server is started"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MDg3Njgz", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-414087683", "createdAt": "2020-05-19T04:08:14Z", "commit": {"oid": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7"}, "state": "COMMENTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNDowODoxNFrOGXPJMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoyOToxNVrOGXRlsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ==", "bodyText": "https://github.com/eclipse-ee4j/servlet-api/blob/master/spec/src/main/asciidoc/servlet-spec-body.adoc#35--request-path-elements\nI don't see any regulation that the path should not end with /.", "url": "https://github.com/line/armeria/pull/2686#discussion_r427018545", "createdAt": "2020-05-19T04:08:14Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (path.isEmpty()) {\n+            rootServletAdded = true;\n+        } else {\n+            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODg2OQ==", "bodyText": "Can remove this line and just do\nserverBuilder.serviceUnder(contextPath + '/', servletService);\nbecause / is always appended if the path prefix does not end with /", "url": "https://github.com/line/armeria/pull/2686#discussion_r427018869", "createdAt": "2020-05-19T04:09:40Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxOTMxNQ==", "bodyText": "context format can be /x/y, /x/y/z/foo or whatever so we should change this.\ncheckArgument(contextPath.charAt(0) == '/' && contextPath.charAt(contextPath.length() - 1) != '/',\n\"contextPath must start with / and must not end with /. contextPath: %s\", contextPath);", "url": "https://github.com/line/armeria/pull/2686#discussion_r427019315", "createdAt": "2020-05-19T04:11:28Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMDc2Ng==", "bodyText": "Let's remove this method and just add the servlet from the above:\npublic ServletBuilder servlet(String path, HttpServlet httpServlet) {\n    requireNonNull(path, \"path\");\n    requireNonNull(httpServlet, \"httpServlet\");\n    validatePath(path);\n    servletContext.addServlet(path, httpServlet);\n    return this;\n}\n\nPlease note that I didn't do sd.addMapping(path); because the path can be added in ServletContext.", "url": "https://github.com/line/armeria/pull/2686#discussion_r427020766", "createdAt": "2020-05-19T04:18:16Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMTI5MQ==", "bodyText": "The value can be null, right?", "url": "https://github.com/line/armeria/pull/2686#discussion_r427021291", "createdAt": "2020-05-19T04:20:35Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            filterList.add(registration);\n+        }\n+        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            for (String servletName : registration.getServletNameMappings()) {\n+                if (servletName.equals(name)) {\n+                    filterList.add(registration);\n+                }\n+            }\n+        }\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        final List<Servlet> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getServlet());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        final List<String> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getName());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMTY3MQ==", "bodyText": "How about making a separate PR for filter related code?", "url": "https://github.com/line/armeria/pull/2686#discussion_r427021671", "createdAt": "2020-05-19T04:22:02Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (path.isEmpty()) {\n+            rootServletAdded = true;\n+        } else {\n+            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',\n+                          \"Servlet path format is /x/y/z\", path);\n+        }\n+        path = contextPath + path;\n+        final ServletRegistration sd;\n+        if (servlet instanceof String) {\n+            sd = servletContext.addServlet(path, (String) servlet);\n+        } else {\n+            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n+        }\n+        sd.addMapping(path);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the session timeout in minutes for this ServletContext.\n+     * @param sessionTimeout session timeout in minutes.\n+     */\n+    public ServletBuilder sessionTimeout(int sessionTimeout) {\n+        servletContext.setSessionTimeout(sessionTimeout);\n+        return this;\n+    }\n+\n+    /**\n+     * Set attribute value.\n+     */\n+    public ServletBuilder attribute(String key, @Nullable Object value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setAttribute(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Set init parameter.\n+     */\n+    public ServletBuilder initParameter(String key, @Nullable String value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setInitParameter(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Add filter.\n+     */\n+    public ServletBuilder filter(String filterName, Filter filter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzQ5Nw==", "bodyText": "Can remove this it not used.", "url": "https://github.com/line/armeria/pull/2686#discussion_r427023497", "createdAt": "2020-05-19T04:30:22Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzY1OA==", "bodyText": "if contextPath is /x/y/z, servletContextName will be xyz. Is this what you intended?", "url": "https://github.com/line/armeria/pull/2686#discussion_r427023658", "createdAt": "2020-05-19T04:30:57Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNDcwMQ==", "bodyText": "We can set this when we call ServletBuilder.build().\nOf course, the name should be changed such as isInitailized?", "url": "https://github.com/line/armeria/pull/2686#discussion_r427024701", "createdAt": "2020-05-19T04:35:33Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNTU3MA==", "bodyText": "Let's remove this and setServerAddress.", "url": "https://github.com/line/armeria/pull/2686#discussion_r427025570", "createdAt": "2020-05-19T04:39:00Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNTgzOA==", "bodyText": "return serviceRequestContext.localAddress().toString();", "url": "https://github.com/line/armeria/pull/2686#discussion_r427025838", "createdAt": "2020-05-19T04:40:00Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,871 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.ServletSecurityElement;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault()};\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private String protocol;\n+    private String scheme;\n+    private String servletPath;\n+    private String queryString;\n+    private String pathInfo;\n+    private String requestURI;\n+    private String characterEncoding;\n+    private SessionTrackingMode sessionIdSource;\n+    private MultipartConfigElement multipartConfigElement;\n+    private ServletSecurityElement servletSecurityElement;\n+    private boolean usingInputStreamFlag;\n+    private BufferedReader reader;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n+    private final Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n+            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n+            for (Entry<String,List<String>> entry : entries) {\n+                final List<String> value = entry.getValue();\n+                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n+                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String[] get(Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[value.size()]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Cookie[] cookies;\n+    private Locale[] locales;\n+    private Boolean asyncSupportedFlag;\n+    private ServletRequestDispatcher dispatcher;\n+\n+    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                                 DefaultServletContext servletContext,\n+                                 AggregatedHttpRequest request) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(request, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        httpRequest = request;\n+        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n+        if (servletContext.getServerAddress() == null) {\n+            servletContext.setServerAddress(\n+                    serviceRequestContext.remoteAddress());\n+        }\n+        decodeUrlParameter();\n+        decodeBody();\n+        decodeCookie();\n+        decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        decodePaths();\n+    }\n+\n+    void setDispatcher(ServletRequestDispatcher dispatcher) {\n+        requireNonNull(dispatcher, \"dispatcher\");\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    void setMultipartConfigElement(@Nullable MultipartConfigElement multipartConfigElement) {\n+        this.multipartConfigElement = multipartConfigElement;\n+    }\n+\n+    void setServletSecurityElement(@Nullable ServletSecurityElement servletSecurityElement) {\n+        this.servletSecurityElement = servletSecurityElement;\n+    }\n+\n+    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n+        this.asyncSupportedFlag = asyncSupportedFlag;\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    public AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private void decodeLocale() {\n+        final Locale[] locales;\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue == null) {\n+            locales = DEFAULT_LOCALS;\n+        } else {\n+            final String[] values = headerValue.split(\",\");\n+            final int length = values.length;\n+            locales = new Locale[length];\n+            for (int i = 0; i < length; i++) {\n+                final String value = values[i];\n+                final String[] valueSp = value.split(\";\");\n+                final Locale locale;\n+                if (valueSp.length > 0) {\n+                    locale = Locale.forLanguageTag(valueSp[0]);\n+                } else {\n+                    locale = Locale.forLanguageTag(value);\n+                }\n+                locales[i] = locale;\n+            }\n+        }\n+        this.locales = locales;\n+    }\n+\n+    /**\n+     * Parsing coding.\n+     */\n+    private void decodeCharacterEncoding() {\n+        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        if (characterEncoding == null) {\n+            characterEncoding = getServletContext().getRequestCharacterEncoding();\n+        }\n+       this.characterEncoding = characterEncoding;\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpHeaderConstants.POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            parameterMap = ServletUtil.decodeBody(\n+                    parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    private void decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (value != null && value.length() > 0) {\n+            final Collection<Cookie> nettyCookieSet = ServletUtil.decodeCookie(value);\n+            if (nettyCookieSet.size() > 0) {\n+                cookies = nettyCookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private void decodePaths() {\n+        String requestURI = httpRequest.path();\n+        final String queryString;\n+        final int queryInx = requestURI.indexOf('?');\n+        if (queryInx > -1) {\n+            queryString = requestURI.substring(queryInx + 1);\n+            requestURI = requestURI.substring(0, queryInx);\n+        } else {\n+            queryString = null;\n+        }\n+        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n+            requestURI = requestURI.substring(1);\n+        }\n+\n+        this.requestURI = requestURI;\n+        this.queryString = queryString;\n+    }\n+\n+    @Override\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) throws IllegalArgumentException {\n+        requireNonNull(name, \"name\");\n+        final String value = getHeader(name);\n+        if (value == null || \"\".equals(value)) {\n+            return -1;\n+        }\n+\n+        final DateFormat[] formats = FORMATS_TEMPLATE;\n+        Date date = null;\n+        for (int i = 0; (date == null) && (i < formats.length); i++) {\n+            try {\n+                date = formats[i].parse(value);\n+            } catch (ParseException e) {\n+                logger.info(\"Cannot parse \" + value + \" to date type\");\n+            }\n+        }\n+        if (date == null) {\n+            throw new IllegalArgumentException(value);\n+        }\n+        return date.getTime();\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = httpRequest.headers().get(name);\n+        return value == null ? null : String.valueOf(value);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        final Set nameSet = httpRequest.headers().names();\n+        return new Enumeration<String>() {\n+            private Iterator iterator = nameSet.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = HttpHeaderConstants.HTTP_PORT;\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((HttpHeaderConstants.HTTP.equals(scheme) && (port != HttpHeaderConstants.HTTP_PORT)) ||\n+            (HttpHeaderConstants.HTTPS.equals(scheme) && (port != HttpHeaderConstants.HTTPS_PORT))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        if (this.servletPath == null) {\n+            String servletPath = getServletContext().getServletPath(getRequestURI());\n+            final String contextPath = getServletContext().getContextPath();\n+            if (contextPath.length() > 0) {\n+                servletPath = servletPath.replaceFirst(contextPath,\"\");\n+            }\n+            this.servletPath = servletPath;\n+        }\n+        return this.servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        return null;\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        final Collection collection = httpRequest.headers().getAll(name);\n+        return new Enumeration<String>() {\n+            private Iterator iterator = collection.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (headerStringValue == null) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return getServletContext().getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+                sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(getAttributeMap().keySet());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        if (characterEncoding == null) {\n+            decodeCharacterEncoding();\n+        }\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        requireNonNull(env, \"env\");\n+        characterEncoding = env;\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n+                .replace(\"[\", \"\").replace(\"]\", \"\"));\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        usingInputStreamFlag = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(getParameterMap().keySet());\n+    }\n+\n+    @Override\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return unmodifiableParameterMap;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        if (protocol == null) {\n+            protocol = serviceRequestContext.sessionProtocol().uriText();\n+        }\n+        return protocol;\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        if (scheme == null) {\n+            scheme = httpRequest.scheme();\n+        }\n+        return scheme;\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.localAddress();\n+        if (inetSocketAddress != null) {\n+            return inetSocketAddress.getAddress().getHostAddress();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return Integer.parseInt(getHeader(\":authority\").split(\":\")[1]);\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (usingInputStreamFlag) {\n+            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n+        }\n+        if (reader == null) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    String charset = getCharacterEncoding();\n+                    if (charset == null) {\n+                        charset = getServletContext().getRequestCharacterEncoding();\n+                    }\n+                    reader = new BufferedReader(new InputStreamReader(getInputStream(),charset));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        final InetAddress inetAddress = inetSocketAddress.getAddress();\n+        if (inetAddress == null) {\n+            return null;\n+        }\n+        return inetAddress.getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        return inetSocketAddress.getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        getAttributeMap().put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        getAttributeMap().remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        final Locale[] locales = this.locales;\n+        if (locales == null || locales.length == 0) {\n+            return null;\n+        }\n+        return locales[0];\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        if (this.locales == null) {\n+            decodeLocale();\n+        }\n+        return new Enumeration<Locale>() {\n+            private int index;\n+            @Override\n+            public boolean hasMoreElements() {\n+                return index < locales.length;\n+            }\n+\n+            @Override\n+            public Locale nextElement() {\n+                final Locale locale = locales[index];\n+                index++;\n+                return locale;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return HttpHeaderConstants.HTTPS.equals(getScheme());\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return getServletContext().getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        requireNonNull(path, \"path\");\n+        return getServletContext().getRealPath(path);\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return getServletContext().getServerAddress().getHostName();\n+    }\n+\n+    @Override\n+    public String getLocalAddr() {\n+        return getServletContext().getServerAddress().getAddress().getHostAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 740}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNTg1OQ==", "bodyText": "return serviceRequestContext.config().server().defaultHostname();", "url": "https://github.com/line/armeria/pull/2686#discussion_r427025859", "createdAt": "2020-05-19T04:40:03Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,871 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.ServletSecurityElement;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault()};\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private String protocol;\n+    private String scheme;\n+    private String servletPath;\n+    private String queryString;\n+    private String pathInfo;\n+    private String requestURI;\n+    private String characterEncoding;\n+    private SessionTrackingMode sessionIdSource;\n+    private MultipartConfigElement multipartConfigElement;\n+    private ServletSecurityElement servletSecurityElement;\n+    private boolean usingInputStreamFlag;\n+    private BufferedReader reader;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n+    private final Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n+            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n+            for (Entry<String,List<String>> entry : entries) {\n+                final List<String> value = entry.getValue();\n+                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n+                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String[] get(Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[value.size()]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Cookie[] cookies;\n+    private Locale[] locales;\n+    private Boolean asyncSupportedFlag;\n+    private ServletRequestDispatcher dispatcher;\n+\n+    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                                 DefaultServletContext servletContext,\n+                                 AggregatedHttpRequest request) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(request, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        httpRequest = request;\n+        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n+        if (servletContext.getServerAddress() == null) {\n+            servletContext.setServerAddress(\n+                    serviceRequestContext.remoteAddress());\n+        }\n+        decodeUrlParameter();\n+        decodeBody();\n+        decodeCookie();\n+        decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        decodePaths();\n+    }\n+\n+    void setDispatcher(ServletRequestDispatcher dispatcher) {\n+        requireNonNull(dispatcher, \"dispatcher\");\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    void setMultipartConfigElement(@Nullable MultipartConfigElement multipartConfigElement) {\n+        this.multipartConfigElement = multipartConfigElement;\n+    }\n+\n+    void setServletSecurityElement(@Nullable ServletSecurityElement servletSecurityElement) {\n+        this.servletSecurityElement = servletSecurityElement;\n+    }\n+\n+    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n+        this.asyncSupportedFlag = asyncSupportedFlag;\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    public AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private void decodeLocale() {\n+        final Locale[] locales;\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue == null) {\n+            locales = DEFAULT_LOCALS;\n+        } else {\n+            final String[] values = headerValue.split(\",\");\n+            final int length = values.length;\n+            locales = new Locale[length];\n+            for (int i = 0; i < length; i++) {\n+                final String value = values[i];\n+                final String[] valueSp = value.split(\";\");\n+                final Locale locale;\n+                if (valueSp.length > 0) {\n+                    locale = Locale.forLanguageTag(valueSp[0]);\n+                } else {\n+                    locale = Locale.forLanguageTag(value);\n+                }\n+                locales[i] = locale;\n+            }\n+        }\n+        this.locales = locales;\n+    }\n+\n+    /**\n+     * Parsing coding.\n+     */\n+    private void decodeCharacterEncoding() {\n+        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        if (characterEncoding == null) {\n+            characterEncoding = getServletContext().getRequestCharacterEncoding();\n+        }\n+       this.characterEncoding = characterEncoding;\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpHeaderConstants.POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            parameterMap = ServletUtil.decodeBody(\n+                    parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    private void decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (value != null && value.length() > 0) {\n+            final Collection<Cookie> nettyCookieSet = ServletUtil.decodeCookie(value);\n+            if (nettyCookieSet.size() > 0) {\n+                cookies = nettyCookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private void decodePaths() {\n+        String requestURI = httpRequest.path();\n+        final String queryString;\n+        final int queryInx = requestURI.indexOf('?');\n+        if (queryInx > -1) {\n+            queryString = requestURI.substring(queryInx + 1);\n+            requestURI = requestURI.substring(0, queryInx);\n+        } else {\n+            queryString = null;\n+        }\n+        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n+            requestURI = requestURI.substring(1);\n+        }\n+\n+        this.requestURI = requestURI;\n+        this.queryString = queryString;\n+    }\n+\n+    @Override\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) throws IllegalArgumentException {\n+        requireNonNull(name, \"name\");\n+        final String value = getHeader(name);\n+        if (value == null || \"\".equals(value)) {\n+            return -1;\n+        }\n+\n+        final DateFormat[] formats = FORMATS_TEMPLATE;\n+        Date date = null;\n+        for (int i = 0; (date == null) && (i < formats.length); i++) {\n+            try {\n+                date = formats[i].parse(value);\n+            } catch (ParseException e) {\n+                logger.info(\"Cannot parse \" + value + \" to date type\");\n+            }\n+        }\n+        if (date == null) {\n+            throw new IllegalArgumentException(value);\n+        }\n+        return date.getTime();\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = httpRequest.headers().get(name);\n+        return value == null ? null : String.valueOf(value);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        final Set nameSet = httpRequest.headers().names();\n+        return new Enumeration<String>() {\n+            private Iterator iterator = nameSet.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = HttpHeaderConstants.HTTP_PORT;\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((HttpHeaderConstants.HTTP.equals(scheme) && (port != HttpHeaderConstants.HTTP_PORT)) ||\n+            (HttpHeaderConstants.HTTPS.equals(scheme) && (port != HttpHeaderConstants.HTTPS_PORT))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        if (this.servletPath == null) {\n+            String servletPath = getServletContext().getServletPath(getRequestURI());\n+            final String contextPath = getServletContext().getContextPath();\n+            if (contextPath.length() > 0) {\n+                servletPath = servletPath.replaceFirst(contextPath,\"\");\n+            }\n+            this.servletPath = servletPath;\n+        }\n+        return this.servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        return null;\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        final Collection collection = httpRequest.headers().getAll(name);\n+        return new Enumeration<String>() {\n+            private Iterator iterator = collection.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (headerStringValue == null) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return getServletContext().getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+                sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(getAttributeMap().keySet());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        if (characterEncoding == null) {\n+            decodeCharacterEncoding();\n+        }\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        requireNonNull(env, \"env\");\n+        characterEncoding = env;\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n+                .replace(\"[\", \"\").replace(\"]\", \"\"));\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        usingInputStreamFlag = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(getParameterMap().keySet());\n+    }\n+\n+    @Override\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return unmodifiableParameterMap;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        if (protocol == null) {\n+            protocol = serviceRequestContext.sessionProtocol().uriText();\n+        }\n+        return protocol;\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        if (scheme == null) {\n+            scheme = httpRequest.scheme();\n+        }\n+        return scheme;\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.localAddress();\n+        if (inetSocketAddress != null) {\n+            return inetSocketAddress.getAddress().getHostAddress();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return Integer.parseInt(getHeader(\":authority\").split(\":\")[1]);\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (usingInputStreamFlag) {\n+            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n+        }\n+        if (reader == null) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    String charset = getCharacterEncoding();\n+                    if (charset == null) {\n+                        charset = getServletContext().getRequestCharacterEncoding();\n+                    }\n+                    reader = new BufferedReader(new InputStreamReader(getInputStream(),charset));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        final InetAddress inetAddress = inetSocketAddress.getAddress();\n+        if (inetAddress == null) {\n+            return null;\n+        }\n+        return inetAddress.getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        return inetSocketAddress.getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        getAttributeMap().put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        getAttributeMap().remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        final Locale[] locales = this.locales;\n+        if (locales == null || locales.length == 0) {\n+            return null;\n+        }\n+        return locales[0];\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        if (this.locales == null) {\n+            decodeLocale();\n+        }\n+        return new Enumeration<Locale>() {\n+            private int index;\n+            @Override\n+            public boolean hasMoreElements() {\n+                return index < locales.length;\n+            }\n+\n+            @Override\n+            public Locale nextElement() {\n+                final Locale locale = locales[index];\n+                index++;\n+                return locale;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return HttpHeaderConstants.HTTPS.equals(getScheme());\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return getServletContext().getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        requireNonNull(path, \"path\");\n+        return getServletContext().getRealPath(path);\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return getServletContext().getServerAddress().getHostName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 735}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjMxOQ==", "bodyText": "What is the default value for sessionTimeout?", "url": "https://github.com/line/armeria/pull/2686#discussion_r427026319", "createdAt": "2020-05-19T04:42:05Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjYxNA==", "bodyText": "Seems like we don't support this yet. Let's throw UnsupportedOperationException, right now.", "url": "https://github.com/line/armeria/pull/2686#discussion_r427026614", "createdAt": "2020-05-19T04:43:19Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjc4NA==", "bodyText": "Shouldn't we target for 4?", "url": "https://github.com/line/armeria/pull/2686#discussion_r427026784", "createdAt": "2020-05-19T04:44:02Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzU5NQ==", "bodyText": "extension.isEmpty()", "url": "https://github.com/line/armeria/pull/2686#discussion_r427027595", "createdAt": "2020-05-19T04:47:11Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzY0MQ==", "bodyText": "Should add @Nullable", "url": "https://github.com/line/armeria/pull/2686#discussion_r427027641", "createdAt": "2020-05-19T04:47:23Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzg3Nw==", "bodyText": "Let's add TODO", "url": "https://github.com/line/armeria/pull/2686#discussion_r427027877", "createdAt": "2020-05-19T04:48:20Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyODE2Mw==", "bodyText": "Could fix this by referring one of the ServletContext implementations in other frameworks?", "url": "https://github.com/line/armeria/pull/2686#discussion_r427028163", "createdAt": "2020-05-19T04:49:36Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyOTY4MQ==", "bodyText": "Shouldn't we check if the file exists or not first?", "url": "https://github.com/line/armeria/pull/2686#discussion_r427029681", "createdAt": "2020-05-19T04:55:25Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzY0MQ=="}, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzIwMA==", "bodyText": "Let's remove filter related code right now.", "url": "https://github.com/line/armeria/pull/2686#discussion_r427047200", "createdAt": "2020-05-19T05:57:55Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ==", "bodyText": "We should make the list as immutable not just for getServlets(), but also for getServletNames(), getInitParameterNames(), getAttributeNames() etc.\nreturn Collections.enumeration(servletRegistrationMap.values()\n                                                     .stream()\n                                                     .map(ServletRegistration::getServlet)\n                                                     .collect(toImmutableList()));\n\nAlso, one thing we have to think about is that if the field is unmodifiable after DefaultServletContext is initialized, we can pass it when we create DefaultServletContext.\nFor example, initParamMap can't be changed after DefaultServiceContext is initialized.\nSo we can do something like:\nclass ServletBuilder {\n\n    // Introduce a new class \n    private final DefaultServletContextBuilder servletContextBuilder;\n\n    ServletBuilder(ServerBuilder serverBuiler, String contextPath) {\n        servletContextBuilder = new DefaultServletContextBuilder(contextPath);\n    }\n\n    public ServletBuilder initParameter(String key, @Nullable String value) {\n        requireNonNull(key, \"key\");\n        servletContextBuilder.setInitParameter(key, value);\n        return this;\n    }\n\n    public ServerBuilder build() {\n        new DefaultServletService(servletContextBuilder.build());\n        ...\n    }\n    ...\n}\n\nclass ServletContext {\n\n    ServletContext(String contextPath, Map<String, String> initParamMap ...) {\n        this.initParamMap = ImmutableMap.copyOf(initParamMap);\n        ...\n    }\n}", "url": "https://github.com/line/armeria/pull/2686#discussion_r427058611", "createdAt": "2020-05-19T06:29:15Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            filterList.add(registration);\n+        }\n+        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            for (String servletName : registration.getServletNameMappings()) {\n+                if (servletName.equals(name)) {\n+                    filterList.add(registration);\n+                }\n+            }\n+        }\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        final List<Servlet> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getServlet());\n+        }\n+        return Collections.enumeration(list);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "197d92c3d0161a57379a0ba6b4c3a25a08653781"}, "originalPosition": 276}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2bb6c6ea96a2d285a36cf0242e2fc0dc71385a73", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/2bb6c6ea96a2d285a36cf0242e2fc0dc71385a73", "committedDate": "2020-05-24T09:00:12Z", "message": "Add context path tests and throw exception after server is initialized"}, "afterCommit": {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "committedDate": "2020-05-21T08:02:27Z", "message": "Merge branch 'master' into master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ac78da8c1615e6bfbc7d5f1d4ad9d299c35941b", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/8ac78da8c1615e6bfbc7d5f1d4ad9d299c35941b", "committedDate": "2020-05-25T00:46:37Z", "message": "fix tests address already in use"}, "afterCommit": {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "committedDate": "2020-05-21T08:02:27Z", "message": "Merge branch 'master' into master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec488dcf6b96f68763097d799c3297cfd20ce5d1", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/ec488dcf6b96f68763097d799c3297cfd20ce5d1", "committedDate": "2020-05-25T02:01:02Z", "message": "Add context path tests and throw exception after server is initialized"}, "afterCommit": {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "committedDate": "2020-05-21T08:02:27Z", "message": "Merge branch 'master' into master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "13adffe241275b315a08048d8ede5911e9295cda", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/13adffe241275b315a08048d8ede5911e9295cda", "committedDate": "2020-05-26T05:12:48Z", "message": "Add servlet path tests and throw exception after server is initialized"}, "afterCommit": {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "committedDate": "2020-05-21T08:02:27Z", "message": "Merge branch 'master' into master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "05754862278afe20ee1d167daa7c3069b0c4a85e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/05754862278afe20ee1d167daa7c3069b0c4a85e", "committedDate": "2020-05-26T05:39:30Z", "message": "Add servlet path tests and throw exception after server is initialized"}, "afterCommit": {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "committedDate": "2020-05-20T06:57:30Z", "message": "Add immutable, servletPath / at last, and refactor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0d7c8ae0eaf317e3ec592b675ae69429dcde976d", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/0d7c8ae0eaf317e3ec592b675ae69429dcde976d", "committedDate": "2020-05-27T01:10:46Z", "message": "Resolve conflict settings.gradle"}, "afterCommit": {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "committedDate": "2020-05-20T06:57:30Z", "message": "Add immutable, servletPath / at last, and refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4ODExMTA1", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-418811105", "createdAt": "2020-05-27T02:14:02Z", "commit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "state": "COMMENTED", "comments": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMjoxNDowMlrOGa3H6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDoyNDoxN1rOGa482g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgxOTMwNQ==", "bodyText": "We only need this dependencies block, in this gradle file. Please remove others.", "url": "https://github.com/line/armeria/pull/2686#discussion_r430819305", "createdAt": "2020-05-27T02:14:02Z", "author": {"login": "minwoox"}, "path": "servlet/build.gradle", "diffHunk": "@@ -0,0 +1,14 @@\n+plugins {\n+    id 'java'\n+}\n+\n+group 'com.linecorp.armeria'\n+version '0.99.4-SNAPSHOT'\n+\n+repositories {\n+    mavenCentral()\n+}\n+\n+dependencies {\n+    api 'javax.servlet:javax.servlet-api'\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyNTU5Mg==", "bodyText": "two spaces before =. Please use auto-formatting before you commit.", "url": "https://github.com/line/armeria/pull/2686#discussion_r430825592", "createdAt": "2020-05-27T02:39:06Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyNzk5OA==", "bodyText": "This is checking the state not the argument.\nAlso, we can make a private method to use together.\n@Override\npublic void setSessionTimeout(int sessionTimeout) {\n    ensureUninitialized(\"sessionTimeout\");\n    checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n    this.sessionTimeout = sessionTimeout;\n}\n\nprivate void ensureUninitialized(String name) {\n    checkState(!initialized, \"Can't set %s after the servlet context is initialized.\", name);\n}\n\n// We can use ensureUninitialized() in all other setters too.", "url": "https://github.com/line/armeria/pull/2686#discussion_r430827998", "createdAt": "2020-05-27T02:49:08Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyOTIzMw==", "bodyText": "Let's add @Nullable.\nCould you check all the methods and parameters if we forgot to add @Nullable, please?", "url": "https://github.com/line/armeria/pull/2686#discussion_r430829233", "createdAt": "2020-05-27T02:53:55Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMjQ1Ng==", "bodyText": "Then, let's throw UnsupportedOperationException.\nAlso, could you check all other methods whether to throw UnsupportedOperationException, please?", "url": "https://github.com/line/armeria/pull/2686#discussion_r430832456", "createdAt": "2020-05-27T03:07:17Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzg3Nw=="}, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMzUwNQ==", "bodyText": "So you don't want to make a separate PR for the filter?", "url": "https://github.com/line/armeria/pull/2686#discussion_r430833505", "createdAt": "2020-05-27T03:12:06Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzIwMA=="}, "originalCommit": {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDEwMA==", "bodyText": "If we pass the element and path when creating ServletRequestDispatcher, we can make the fields final and we don't need the setter.\nnew ServletRequestDispatcher(element, path);", "url": "https://github.com/line/armeria/pull/2686#discussion_r430834100", "createdAt": "2020-05-27T03:14:45Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA==", "bodyText": "Could you add test cases that cover this logic?", "url": "https://github.com/line/armeria/pull/2686#discussion_r430834668", "createdAt": "2020-05-27T03:17:19Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNzk5Ng==", "bodyText": "A user might want to log use different level, so we should use the LogLevel and use it:\nprivate final LogLevel level;\n...\nlevel.log(logger, msg);", "url": "https://github.com/line/armeria/pull/2686#discussion_r430837996", "createdAt": "2020-05-27T03:31:46Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTQ2Mw==", "bodyText": "indentation. This should be:\nServletUtil.getServerInfo()\n           .concat(\"(JDK \")\n           ...\nAlso we can just use + instead of concat. And, please use cache for this.\n@Nullable\nprivate String serverInfo;\n\n...\n@Override\npublic String getServerInfo() {\n    if (serverInfo != null) {\n        return serverInfo;\n    }\n    ...\n}\n```java", "url": "https://github.com/line/armeria/pull/2686#discussion_r430839463", "createdAt": "2020-05-27T03:38:36Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTc2NA==", "bodyText": "ensureUninitialized(\"initParameter\");", "url": "https://github.com/line/armeria/pull/2686#discussion_r430839764", "createdAt": "2020-05-27T03:40:07Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTkzMw==", "bodyText": "need a space after ,. Please use auto-formatting.", "url": "https://github.com/line/armeria/pull/2686#discussion_r430839933", "createdAt": "2020-05-27T03:40:54Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MDc1NQ==", "bodyText": "I think we can raise an error instead logging.\nthrow new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e)", "url": "https://github.com/line/armeria/pull/2686#discussion_r430840755", "createdAt": "2020-05-27T03:44:38Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 353}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTA2MA==", "bodyText": "ensureUninitialized(\"initParameter\");", "url": "https://github.com/line/armeria/pull/2686#discussion_r430841060", "createdAt": "2020-05-27T03:45:50Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NTAzMg==", "bodyText": "Please address this #2686 (comment)", "url": "https://github.com/line/armeria/pull/2686#discussion_r430845032", "createdAt": "2020-05-27T04:04:09Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTc2NA=="}, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjQyOQ==", "bodyText": "newInstance is deprecated.\nclazz.getDeclaredConstructor().newInstance()", "url": "https://github.com/line/armeria/pull/2686#discussion_r430846429", "createdAt": "2020-05-27T04:10:32Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 389}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjU2Mg==", "bodyText": "throw new RuntimeException(\"Failed to create a serlvet: \" + class.getSimpleName() +, e)", "url": "https://github.com/line/armeria/pull/2686#discussion_r430846562", "createdAt": "2020-05-27T04:11:16Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Njg2MQ==", "bodyText": "We should return an immutable map so that a user does not modify this.", "url": "https://github.com/line/armeria/pull/2686#discussion_r430846861", "createdAt": "2020-05-27T04:12:43Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODI2NQ==", "bodyText": "We can just return sessionTrackingModeSet if we do\nprivate Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\nAlso we can do:\nprivate static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n        Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848265", "createdAt": "2020-05-27T04:19:53Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 483}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODMyOQ==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848329", "createdAt": "2020-05-27T04:20:07Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 508}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODM0OA==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848348", "createdAt": "2020-05-27T04:20:13Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 510}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODYxMg==", "bodyText": "We do not need this", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848612", "createdAt": "2020-05-27T04:21:21Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 522}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODYzNQ==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848635", "createdAt": "2020-05-27T04:21:28Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+        .concat(\" (localhost\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 533}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0OTE5Ng==", "bodyText": "We can just return requestCharacterEncoding if we do:\nprivate String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name()", "url": "https://github.com/line/armeria/pull/2686#discussion_r430849196", "createdAt": "2020-05-27T04:24:05Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+        .concat(\" (localhost\")\n+        .concat(\":\")\n+        .concat(SystemPropertyUtil.get(\"user.name\"))\n+        .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getRequestCharacterEncoding() {\n+        if (requestCharacterEncoding == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 541}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0OTI0Mg==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r430849242", "createdAt": "2020-05-27T04:24:17Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+        .concat(\" (localhost\")\n+        .concat(\":\")\n+        .concat(SystemPropertyUtil.get(\"user.name\"))\n+        .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getRequestCharacterEncoding() {\n+        if (requestCharacterEncoding == null) {\n+            return HttpConstants.DEFAULT_CHARSET.name();\n+        }\n+        return requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n+        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n+        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n+        this.requestCharacterEncoding = requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public String getResponseCharacterEncoding() {\n+        if (responseCharacterEncoding == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ec5418684d17c89e9b4c241b8a56af6389252fc"}, "originalPosition": 556}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0972eeeef02610133bf60db44a46d6b02fdc392", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/a0972eeeef02610133bf60db44a46d6b02fdc392", "committedDate": "2020-05-28T03:14:51Z", "message": "Merge branch 'master' of https://github.com/dominhhien/armeria"}, "afterCommit": {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "committedDate": "2020-05-20T06:57:30Z", "message": "Add immutable, servletPath / at last, and refactor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d387f43d054eaaf8c603a3d043c74bf63a620749", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/d387f43d054eaaf8c603a3d043c74bf63a620749", "committedDate": "2020-05-28T03:34:04Z", "message": "Merge branch 'master' into master"}, "afterCommit": {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "committedDate": "2020-05-20T06:57:30Z", "message": "Add immutable, servletPath / at last, and refactor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4cc982bb7ecac5ffba89cddd058f306e573b904d", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4cc982bb7ecac5ffba89cddd058f306e573b904d", "committedDate": "2020-05-28T10:32:19Z", "message": "Merge branch 'master' into master"}, "afterCommit": {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "committedDate": "2020-05-20T06:57:30Z", "message": "Add immutable, servletPath / at last, and refactor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb438e6638f750e378d19a4f257361f7e73958f4", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/eb438e6638f750e378d19a4f257361f7e73958f4", "committedDate": "2020-05-29T04:12:34Z", "message": "Merge branch 'master' into master"}, "afterCommit": {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "committedDate": "2020-05-20T06:57:30Z", "message": "Add immutable, servletPath / at last, and refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNzA5MDk3", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-420709097", "createdAt": "2020-05-29T07:20:34Z", "commit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "state": "COMMENTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoyMDozNFrOGcRf1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODowMjowNlrOGcSupw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5OTk5MQ==", "bodyText": "public class -> final class", "url": "https://github.com/line/armeria/pull/2686#discussion_r432299991", "createdAt": "2020-05-29T07:20:34Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMTA3NQ==", "bodyText": "For tomcat, this value is 30 minutes by default. Could you tell me where you brought?", "url": "https://github.com/line/armeria/pull/2686#discussion_r432301075", "createdAt": "2020-05-29T07:22:54Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMTQ0Nw==", "bodyText": "Please move this up right down to logger so that private static final fields are located together.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432301447", "createdAt": "2020-05-29T07:23:39Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDc3OA==", "bodyText": "Please use SystemInfo first to get the information.\nAlso, please leave a comment in the code if you copy any source from another repository.\n// Forked from https://github.com/a/b/c...", "url": "https://github.com/line/armeria/pull/2686#discussion_r432304778", "createdAt": "2020-05-29T07:30:46Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDkxNA==", "bodyText": "Can remove public.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432304914", "createdAt": "2020-05-29T07:31:01Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjI2OQ==", "bodyText": "Constructor -> Creates a new instance.\nIf you find trouble writing Javadoc, please refer to other classes and copy the phrases.\nThat'll help the reviewers a lot. \ud83d\ude47\u200d\u2642\ufe0f", "url": "https://github.com/line/armeria/pull/2686#discussion_r432306269", "createdAt": "2020-05-29T07:33:58Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjM1Mg==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r432306352", "createdAt": "2020-05-29T07:34:14Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjg5OA==", "bodyText": "ditto can remove public.\nPlease remove the public modifier of the methods that didn't override in this class.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432306898", "createdAt": "2020-05-29T07:35:26Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNzcxMw==", "bodyText": "Can just init(). (No need boolean initialized).", "url": "https://github.com/line/armeria/pull/2686#discussion_r432307713", "createdAt": "2020-05-29T07:37:10Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwODg5OQ==", "bodyText": "This is not adding just setting because it replaces the previous MimeMappings set.\nWe can just rename this setMimeMappings.\n(We usually name the method without set such as mimeMappings. However, the interface is already using the setX, so let's follow it.)", "url": "https://github.com/line/armeria/pull/2686#discussion_r432308899", "createdAt": "2020-05-29T07:39:40Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwOTg3Mg==", "bodyText": "We don't need this because element.getObject() is not Nullable.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432309872", "createdAt": "2020-05-29T07:41:36Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDM0MQ==", "bodyText": "We can just return without assigning the local variable.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432310341", "createdAt": "2020-05-29T07:42:29Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDgxMw==", "bodyText": "Please annotated @Nullable if a method returns null.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432310813", "createdAt": "2020-05-29T07:43:13Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMTY1MA==", "bodyText": "There's no need to unpack this. Let's remove this method.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432311650", "createdAt": "2020-05-29T07:44:57Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMTkzMw==", "bodyText": "We should remove this method and move the logic inside init() method.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432311933", "createdAt": "2020-05-29T07:45:30Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMzYwMQ==", "bodyText": "Let's return the immutable view of the set so that a user cannot arbitrary modify the set.\nCollections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));", "url": "https://github.com/line/armeria/pull/2686#discussion_r432313601", "createdAt": "2020-05-29T07:48:54Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNDIzNw==", "bodyText": "please add\n//noinspection unchecked", "url": "https://github.com/line/armeria/pull/2686#discussion_r432314237", "createdAt": "2020-05-29T07:50:09Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNTEyOA==", "bodyText": "We just can\nfinal ServletRegistration servletRegistration =\n    new ServletRegistration(servletName, servlet, this, servletUrlMapper);", "url": "https://github.com/line/armeria/pull/2686#discussion_r432315128", "createdAt": "2020-05-29T07:51:59Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 383}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNTcxOQ==", "bodyText": "What happened if two different servlets are registered using one servletName?", "url": "https://github.com/line/armeria/pull/2686#discussion_r432315719", "createdAt": "2020-05-29T07:53:10Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNjcxNg==", "bodyText": "Ditto. please remove uncheck cast warning", "url": "https://github.com/line/armeria/pull/2686#discussion_r432316716", "createdAt": "2020-05-29T07:55:06Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 428}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg==", "bodyText": "ditto What happened if two different filters are registered using the same name?", "url": "https://github.com/line/armeria/pull/2686#discussion_r432317306", "createdAt": "2020-05-29T07:56:17Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 441}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzc0NQ==", "bodyText": "We should check the name is empty or not.\nWe can use isNullOrEmpty.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432317745", "createdAt": "2020-05-29T07:57:10Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 437}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODM1Mw==", "bodyText": "If the name is empty, we should throw an exception.\n* @throws IllegalArgumentException if <code>servletName</code> is null\n* or an empty String", "url": "https://github.com/line/armeria/pull/2686#discussion_r432318353", "createdAt": "2020-05-29T07:58:25Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 379}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODk4OQ==", "bodyText": "sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModes);", "url": "https://github.com/line/armeria/pull/2686#discussion_r432318989", "createdAt": "2020-05-29T07:59:40Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a filter: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        ensureUninitialized(\"setSessionTrackingModes\");\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        sessionTrackingModeSet = sessionTrackingModes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 487}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxOTkwNw==", "bodyText": "please just use + instead of concat as the IDE suggested.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432319907", "createdAt": "2020-05-29T08:01:32Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a filter: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        ensureUninitialized(\"setSessionTrackingModes\");\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a listener: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+                          .concat(\" (localhost\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMDE2Nw==", "bodyText": "We should not just append null when SystemPropertyUtil.get(\"user.name\") is null.", "url": "https://github.com/line/armeria/pull/2686#discussion_r432320167", "createdAt": "2020-05-29T08:02:06Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a filter: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        ensureUninitialized(\"setSessionTrackingModes\");\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a listener: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+                          .concat(\" (localhost\")\n+                          .concat(\":\")\n+                          .concat(SystemPropertyUtil.get(\"user.name\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91"}, "originalPosition": 545}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "482e763f053528311fdf9c4d5c0192c326035c91", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/482e763f053528311fdf9c4d5c0192c326035c91", "committedDate": "2020-05-29T06:52:09Z", "message": "Merge branch 'master' into master"}, "afterCommit": {"oid": "aa96a87ae69c06c7263c85ffd6bd380dd5cac309", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/aa96a87ae69c06c7263c85ffd6bd380dd5cac309", "committedDate": "2020-04-14T09:34:08Z", "message": "Update the project version to 0.99.4-SNAPSHOT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "891afd85893d0037e20b6b463f10bd868ea64aa9", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/891afd85893d0037e20b6b463f10bd868ea64aa9", "committedDate": "2020-05-30T15:33:31Z", "message": "Add servlet service and servlet context"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d6daa7900aec1c0979c770627091cd2dc7cbf84", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/2d6daa7900aec1c0979c770627091cd2dc7cbf84", "committedDate": "2020-05-30T15:35:15Z", "message": "Add servlet registration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3901c7b1d501836fdfef54d306e0538c2aabda5", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/f3901c7b1d501836fdfef54d306e0538c2aabda5", "committedDate": "2020-05-30T15:35:56Z", "message": "Add filter registration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86f784aaa9a6d816ba866ff077b0129488d38cf1", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/86f784aaa9a6d816ba866ff077b0129488d38cf1", "committedDate": "2020-05-30T15:36:30Z", "message": "Add http header constants"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6f44acb772037593f35a6c4904ed6217db98c85", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/d6f44acb772037593f35a6c4904ed6217db98c85", "committedDate": "2020-05-30T15:38:04Z", "message": "Add multi value map for http header"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a0aeba630fc8bd1cf6cf9373223cb5cf5ed1faa", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/7a0aeba630fc8bd1cf6cf9373223cb5cf5ed1faa", "committedDate": "2020-05-30T15:38:29Z", "message": "Add mime mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42fea96e1d37d19f69dbc2b5be7945398a85d227", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/42fea96e1d37d19f69dbc2b5be7945398a85d227", "committedDate": "2020-05-30T15:39:05Z", "message": "Add package info"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a371fbcc69c998ca7d0fafc2f719a74c7a19107f", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/a371fbcc69c998ca7d0fafc2f719a74c7a19107f", "committedDate": "2020-05-30T15:39:36Z", "message": "Add servlet util"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f36779f5469e7ee81b3bf518e417bac1c4d82184", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/f36779f5469e7ee81b3bf518e417bac1c4d82184", "committedDate": "2020-05-30T15:39:55Z", "message": "Add string util"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efdb71dfc7616c73e624fbe0d6dcc4be56a77d01", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/efdb71dfc7616c73e624fbe0d6dcc4be56a77d01", "committedDate": "2020-05-30T15:40:14Z", "message": "Add url mapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3599f5fa15fc3cc1670693f892f758c8c3b0dc49", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/3599f5fa15fc3cc1670693f892f758c8c3b0dc49", "committedDate": "2020-05-30T15:40:38Z", "message": "Add default servlet input stream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cf936d20cff5de77151e68b5b7dac2c599d6f69", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/0cf936d20cff5de77151e68b5b7dac2c599d6f69", "committedDate": "2020-05-30T15:41:01Z", "message": "Add default servlet output stream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30971c4a0616ca2f84b89800a651a6fcc3200ab8", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/30971c4a0616ca2f84b89800a651a6fcc3200ab8", "committedDate": "2020-05-30T15:42:11Z", "message": "Add servlet builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40e2b348ccd45a199902c0116ca90f7e26fd407f", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/40e2b348ccd45a199902c0116ca90f7e26fd407f", "committedDate": "2020-05-30T15:42:29Z", "message": "Add servlet http request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1be8fac1f6a25ae7c9929070e2eb7161dd387ca4", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/1be8fac1f6a25ae7c9929070e2eb7161dd387ca4", "committedDate": "2020-05-30T15:42:53Z", "message": "Add servlet http response"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab4051a3f126fd2261a72e97c15de823f566c0c6", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/ab4051a3f126fd2261a72e97c15de823f566c0c6", "committedDate": "2020-05-30T15:43:15Z", "message": "Add servlet print writer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e06eed7c534e79419592b013002fdd20436e8bfb", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/e06eed7c534e79419592b013002fdd20436e8bfb", "committedDate": "2020-05-30T15:43:35Z", "message": "Add servlet request dispatcher"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e580df0b5c205936a4300fe2810e0f42e9d6981", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/7e580df0b5c205936a4300fe2810e0f42e9d6981", "committedDate": "2020-05-30T15:44:52Z", "message": "Add servlet service test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61114dc7236136fa84094a3ff944a23d1f3e7686", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/61114dc7236136fa84094a3ff944a23d1f3e7686", "committedDate": "2020-05-30T15:45:29Z", "message": "Add servlet context path test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7265ab94ab9a4b3a75f7bf000a152368849f925f", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/7265ab94ab9a4b3a75f7bf000a152368849f925f", "committedDate": "2020-05-30T15:45:58Z", "message": "Add empty context path test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edbc50c7a39c65a2c694db6a0b406b026a6a0f97", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/edbc50c7a39c65a2c694db6a0b406b026a6a0f97", "committedDate": "2020-05-30T15:46:49Z", "message": "Add example servlet project"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c6bdd6a4af3f39307a12c0565d97e9da2f1b472", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/2c6bdd6a4af3f39307a12c0565d97e9da2f1b472", "committedDate": "2020-05-30T16:44:06Z", "message": "Remove filter code, auto formating code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "479451c48b73830f25bf2e1cf758c18d2e811d5f", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/479451c48b73830f25bf2e1cf758c18d2e811d5f", "committedDate": "2020-05-31T09:04:38Z", "message": "Remove http header constants"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "committedDate": "2020-05-31T12:00:31Z", "message": "Set private access"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzA5OTcz", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-422309973", "createdAt": "2020-06-02T02:58:23Z", "commit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "state": "COMMENTED", "comments": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMjo1ODoyM1rOGdgekQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMzo1MDo0M1rOGdhJwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NDAwMQ==", "bodyText": "Because this class is package-private now, we can remove public modifier from the methods which is not overriding.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433594001", "createdAt": "2020-06-02T02:58:23Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NTkzOQ==", "bodyText": "Could be just \"servletName is empty\" in this case.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433595939", "createdAt": "2020-06-02T03:07:37Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()), path, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo();\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NjQwNQ==", "bodyText": "I think we can call this in the constructor of ServletRegistration.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433596405", "createdAt": "2020-06-02T03:09:48Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()), path, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo();\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        servletName = servletName.trim();\n+        final ServletRegistration servletRegistration =\n+                new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NzQzMw==", "bodyText": "Could remove public?\nCould be final?\nDefaultServletRegistration because ServletRegistration is the name of the interface?", "url": "https://github.com/line/armeria/pull/2686#discussion_r433597433", "createdAt": "2020-06-02T03:14:35Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODMxNQ==", "bodyText": "Should we pass the initMap to ServletRegistration?", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598315", "createdAt": "2020-06-02T03:18:27Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()), path, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo();\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        servletName = servletName.trim();\n+        final ServletRegistration servletRegistration =\n+                new ServletRegistration(servletName, servlet, this, servletUrlMapper);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 358}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODYyMg==", "bodyText": "Can remove ServletRegistration.this.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598622", "createdAt": "2020-06-02T03:20:01Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODY1Ng==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598656", "createdAt": "2020-06-02T03:20:08Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODgwOQ==", "bodyText": "return initParameterMap.get(name);", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598809", "createdAt": "2020-06-02T03:20:48Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5OTAwMQ==", "bodyText": "When this method is used? If this is not used now, can we add this when we need?", "url": "https://github.com/line/armeria/pull/2686#discussion_r433599001", "createdAt": "2020-06-02T03:21:49Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5OTAyNA==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r433599024", "createdAt": "2020-06-02T03:21:54Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5OTQ3MA==", "bodyText": "Can we remove this method and make this registration is initialized when it created?", "url": "https://github.com/line/armeria/pull/2686#discussion_r433599470", "createdAt": "2020-06-02T03:23:50Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDE4Mw==", "bodyText": "It seems like we need to return the mappingSet that urlPatterns are added before.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600183", "createdAt": "2020-06-02T03:27:04Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDQ3Mw==", "bodyText": "Question: Don't we need to validate the value before assigning?", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600473", "createdAt": "2020-06-02T03:28:22Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    public Collection<String> getMappings() {\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getRunAsRole() {\n+        return roleName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return servletName;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return servlet.getClass().getName();\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        throw new IllegalStateException(\"Can't set init parameter after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParameterMap.get(name);\n+    }\n+\n+    @Override\n+    public Set<String> setInitParameters(Map<String, String> initParameters) {\n+        throw new IllegalStateException(\"Can't set init parameters after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    public Map<String, String> getInitParameters() {\n+        return initParameterMap;\n+    }\n+\n+    @Override\n+    public void setLoadOnStartup(int loadOnStartup) {\n+        this.loadOnStartup = loadOnStartup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDcxNQ==", "bodyText": "ditto:\n* @return the (possibly empty) Set of URL patterns that were already\n* the exact target of a <code>security-constraint</code> that was\n* established via the portable deployment descriptor. This method\n* has no effect on the patterns included in the returned set", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600715", "createdAt": "2020-06-02T03:29:35Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    public Collection<String> getMappings() {\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getRunAsRole() {\n+        return roleName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return servletName;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return servlet.getClass().getName();\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        throw new IllegalStateException(\"Can't set init parameter after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParameterMap.get(name);\n+    }\n+\n+    @Override\n+    public Set<String> setInitParameters(Map<String, String> initParameters) {\n+        throw new IllegalStateException(\"Can't set init parameters after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    public Map<String, String> getInitParameters() {\n+        return initParameterMap;\n+    }\n+\n+    @Override\n+    public void setLoadOnStartup(int loadOnStartup) {\n+        this.loadOnStartup = loadOnStartup;\n+    }\n+\n+    @Override\n+    public Set<String> setServletSecurity(ServletSecurityElement constraint) {\n+        requireNonNull(constraint, \"constraint\");\n+        servletSecurityElement = constraint;\n+        return new HashSet<>(servletSecurityElement.getMethodNames());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDg1Mw==", "bodyText": "We can just do this in one line: this.roleName = requireNonNull(roleName, \"roleName\");", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600853", "createdAt": "2020-06-02T03:30:11Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    public Collection<String> getMappings() {\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getRunAsRole() {\n+        return roleName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return servletName;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return servlet.getClass().getName();\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        throw new IllegalStateException(\"Can't set init parameter after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParameterMap.get(name);\n+    }\n+\n+    @Override\n+    public Set<String> setInitParameters(Map<String, String> initParameters) {\n+        throw new IllegalStateException(\"Can't set init parameters after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    public Map<String, String> getInitParameters() {\n+        return initParameterMap;\n+    }\n+\n+    @Override\n+    public void setLoadOnStartup(int loadOnStartup) {\n+        this.loadOnStartup = loadOnStartup;\n+    }\n+\n+    @Override\n+    public Set<String> setServletSecurity(ServletSecurityElement constraint) {\n+        requireNonNull(constraint, \"constraint\");\n+        servletSecurityElement = constraint;\n+        return new HashSet<>(servletSecurityElement.getMethodNames());\n+    }\n+\n+    @Override\n+    public void setMultipartConfig(MultipartConfigElement multipartConfig) {\n+        requireNonNull(multipartConfig, \"multipartConfig\");\n+        multipartConfigElement = multipartConfig;\n+    }\n+\n+    @Override\n+    public void setRunAsRole(String roleName) {\n+        requireNonNull(roleName, \"roleName\");\n+        this.roleName = roleName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMTUwMw==", "bodyText": "If the class is used only in the package we can make it as package-private.\nAlso, the methods are as well. We do not need the public modifier.\nCould you check all classes, please?", "url": "https://github.com/line/armeria/pull/2686#discussion_r433601503", "createdAt": "2020-06-02T03:33:30Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjExMw==", "bodyText": "DefaultHttpServletRequest ?", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602113", "createdAt": "2020-06-02T03:36:34Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjM3Nw==", "bodyText": "We can use HttpMethod.POST.toString() instead.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602377", "createdAt": "2020-06-02T03:38:00Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";\n+    private static final String POST = \"POST\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjU1Ng==", "bodyText": "We can use SessionProtocol.HTTP.uriText() instead.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602556", "createdAt": "2020-06-02T03:38:53Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjU3Ng==", "bodyText": "We can use SessionProtocol.HTTPS.uriText() instead.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602576", "createdAt": "2020-06-02T03:39:00Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjk4OQ==", "bodyText": "We can use SessionProtocol.HTTP.defaultPort() instead.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602989", "createdAt": "2020-06-02T03:41:11Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMzAxMA==", "bodyText": "We can use SessionProtocol.HTTPS.defaultPort() instead.", "url": "https://github.com/line/armeria/pull/2686#discussion_r433603010", "createdAt": "2020-06-02T03:41:17Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwNDkzMg==", "bodyText": "Let's make this variable as final because we can extract this value when the ServletHttpRequest is initialized.\nfinal Charset charset = httpRequest.headers().contentType().charset();\nif (charset != null) {\n    ...\n} else {\n    ...\n}", "url": "https://github.com/line/armeria/pull/2686#discussion_r433604932", "createdAt": "2020-06-02T03:50:11Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";\n+    private static final String POST = \"POST\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+\n+    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Boolean asyncSupportedFlag = true;\n+\n+    @Nullable\n+    private String servletPath;\n+    @Nullable\n+    private String queryString;\n+    @Nullable\n+    private String pathInfo;\n+    @Nullable\n+    private String requestURI;\n+    @Nullable\n+    private String characterEncoding;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwNTA1Nw==", "bodyText": "Please consider all other fields if we can do the same approach. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2686#discussion_r433605057", "createdAt": "2020-06-02T03:50:43Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";\n+    private static final String POST = \"POST\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+\n+    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Boolean asyncSupportedFlag = true;\n+\n+    @Nullable\n+    private String servletPath;\n+    @Nullable\n+    private String queryString;\n+    @Nullable\n+    private String pathInfo;\n+    @Nullable\n+    private String requestURI;\n+    @Nullable\n+    private String characterEncoding;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwNDkzMg=="}, "originalCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c"}, "originalPosition": 110}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32f2859f410f758a5c827c12473ab2ebd1670dc3", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/32f2859f410f758a5c827c12473ab2ebd1670dc3", "committedDate": "2020-06-02T12:17:46Z", "message": "Set final class, final field"}, "afterCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "committedDate": "2020-05-31T12:00:31Z", "message": "Set private access"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f24056bd95fab4f5490023c866cae6172168616d", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/f24056bd95fab4f5490023c866cae6172168616d", "committedDate": "2020-06-03T03:02:51Z", "message": "Set final classes and final fields"}, "afterCommit": {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "committedDate": "2020-05-31T12:00:31Z", "message": "Set private access"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMjM2NTUy", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-423236552", "createdAt": "2020-06-03T05:53:00Z", "commit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNTo1MzowMFrOGeM-ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNjowNzo1NVrOGeNRMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzEwNw==", "bodyText": "The Javadoc says that this will return null if the header does not exist.\nLet's just return httpRequest.headers().get(name); and add @Nullable", "url": "https://github.com/line/armeria/pull/2686#discussion_r434323107", "createdAt": "2020-06-03T05:53:00Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String pathInfo;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final String queryString;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final String encoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        characterEncoding = encoding != null ? encoding : servletContext.getRequestCharacterEncoding();\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue.isEmpty()) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = httpRequest.headers().get(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNjk0Mg==", "bodyText": "yes, each servlet have one ServletRegistration to addMapping multiple urlPatterns to one servletName such as: urlPattern (\"/home\", \"/home/user\", \"/home/*\") map to servletName (\"home\").\nI think, mappingSet is returned to check which urlPatterns were mapped.\n\nSo this shouldn't be:\nrequireNonNull(urlPatterns, \"urlPatterns\");\nfinal Set<String> current = ImmutableSet.copyOf(mappingSet);\nmappingSet.addAll(Arrays.asList(urlPatterns));\nfor (String pattern : urlPatterns) {\n    urlMapper.addMapping(pattern, this, servletName);\n}\nreturn current;\n?", "url": "https://github.com/line/armeria/pull/2686#discussion_r434326942", "createdAt": "2020-06-03T06:05:05Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+final class DefaultServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final UrlMapper<DefaultServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<DefaultServletRegistration> urlMapper,\n+                               Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return initParameterMap.get(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+        addMapping(servletName);\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzU3Mw==", "bodyText": "Is there any chances that two thread access this map?", "url": "https://github.com/line/armeria/pull/2686#discussion_r434327573", "createdAt": "2020-06-03T06:07:03Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzg1OQ==", "bodyText": "please remove this and just return ImmutableMap.copyOf(parameterMap) where it used.", "url": "https://github.com/line/armeria/pull/2686#discussion_r434327859", "createdAt": "2020-06-03T06:07:55Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String pathInfo;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final String queryString;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MDYxNDEz", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-424061413", "createdAt": "2020-06-04T02:34:32Z", "commit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjozNDozMlrOGezxRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMzoyMDowNFrOGe0cZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1ODY2MQ==", "bodyText": "Let's assign this value in the constructor and return it so that we don't have to parse every time it needs", "url": "https://github.com/line/armeria/pull/2686#discussion_r434958661", "createdAt": "2020-06-04T02:34:32Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 490}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1ODgyNQ==", "bodyText": "We should return -1 if the length is greater than Integer.MAX_VALUE", "url": "https://github.com/line/armeria/pull/2686#discussion_r434958825", "createdAt": "2020-06-04T02:35:06Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 485}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTAxNA==", "bodyText": "Let's just do HttpMethod.POST == httpRequest.method()", "url": "https://github.com/line/armeria/pull/2686#discussion_r434959014", "createdAt": "2020-06-04T02:35:54Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTQyOQ==", "bodyText": "We should call this only when the content type is MediaType.FORM_DATA?", "url": "https://github.com/line/armeria/pull/2686#discussion_r434959429", "createdAt": "2020-06-04T02:37:39Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MjQxNw==", "bodyText": "serviceRequestContext.path() does not contain the query", "url": "https://github.com/line/armeria/pull/2686#discussion_r434962417", "createdAt": "2020-06-04T02:49:59Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NzE5Nw==", "bodyText": "We have the logic for decoding cookies already. Let's use that:\nfinal String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\nif (cookieValue != null) {\n    final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n    this.cookies = cookies.stream().map(c -> {\n        final Cookie cookie = new Cookie(c.name(), c.value());\n        cookie.setDomain(c.domain());\n        cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n        cookie.setHttpOnly(c.isHttpOnly());\n        ... // more settings\n        return new Cookie(c.name(), c.value());\n    }).toArray(Cookie[]::new);\n} else {\n    this.cookies = COOKIES;\n}", "url": "https://github.com/line/armeria/pull/2686#discussion_r434967197", "createdAt": "2020-06-04T03:09:18Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTMxOA==", "bodyText": "Let's remove decodeUrlParameter and decodeBody.\nWe can use QueryParam for this purpose.\nFirst we need to move this logic to an internal public class to use together.\npackage com.linecorp.armeria.internal.server;\n\npublic final class QueryParamUtil {\n    ...\n}\nThen, we can use the method to parse assign to the field QueryParams queryParams.\nSo we can remove parameterMap and unmodifiableParameterMap.", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969318", "createdAt": "2020-06-04T03:18:20Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTQyNA==", "bodyText": "Then we can simple do queryParams.get(name);", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969424", "createdAt": "2020-06-04T03:18:53Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTQ3Mg==", "bodyText": "return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969472", "createdAt": "2020-06-04T03:19:05Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 521}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTUzNw==", "bodyText": "return queryParams.getAll(name).toArray(String[]::new);", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969537", "createdAt": "2020-06-04T03:19:22Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 528}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTcwMg==", "bodyText": "We can build this using the queryParam. This will be expensive so we might create this one time in the constructor and reuse it.", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969702", "createdAt": "2020-06-04T03:20:04Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return unmodifiableParameterMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2afebf424f796fd96f5d5c188dbb668992eed379"}, "originalPosition": 533}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dcc4fb3bfa9bf86c4b4922b55e9fd01843c917f5", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/dcc4fb3bfa9bf86c4b4922b55e9fd01843c917f5", "committedDate": "2020-06-04T11:19:01Z", "message": "Add query param util"}, "afterCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "154831245d41f630a746323b97740163940ebc9a", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/154831245d41f630a746323b97740163940ebc9a", "committedDate": "2020-06-04T15:51:21Z", "message": "Add query parameters util"}, "afterCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTkzNTg0", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-425193584", "createdAt": "2020-06-05T10:47:53Z", "commit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDo0Nzo1M1rOGfpssw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMzowOTo0M1rOGft0dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MjIyNw==", "bodyText": "public abstract-> public final\nAnd we need to add a private constructor\nprivate QueryParamUtil() {}", "url": "https://github.com/line/armeria/pull/2686#discussion_r435842227", "createdAt": "2020-06-05T10:47:53Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+\n+/**\n+ * Parse query parameters.\n+ */\n+public abstract class QueryParamUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MzQ5NQ==", "bodyText": "The reason that I wanted you to put this class in this package was that I wanted to have the parsing logic here only so that we can remove the duplicate code.\nIs there any reason that you cannot move queryParamsOf() in AnnotatedValueResolver?", "url": "https://github.com/line/armeria/pull/2686#discussion_r435843495", "createdAt": "2020-06-05T10:50:55Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+\n+/**\n+ * Parse query parameters.\n+ */\n+public abstract class QueryParamUtil {\n+\n+    /**\n+     * Parse aggregated http request to query parameters.\n+     */\n+    public static QueryParams parse(AggregatedHttpRequest request) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NzA5MA==", "bodyText": "x.split(\";\") happend twice.", "url": "https://github.com/line/armeria/pull/2686#discussion_r435847090", "createdAt": "2020-06-05T10:58:55Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0ODk4NA==", "bodyText": "It seems like the parsing locale logic is a little bit complex. We also have to consider quality as well.\nIf you want we can make a separate PR for this. If you want to include it in this PR, how about referring what other frameworks do? For example: https://github.com/apache/tomcat/blob/master/java/org/apache/catalina/connector/Request.java#L3329", "url": "https://github.com/line/armeria/pull/2686#discussion_r435848984", "createdAt": "2020-06-05T11:03:01Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MDcxNg==", "bodyText": "Seems like we don't need these?\ngetProtocol();\ngetScheme();", "url": "https://github.com/line/armeria/pull/2686#discussion_r435850716", "createdAt": "2020-06-05T11:06:55Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4ODY4Mw==", "bodyText": "We can remove queryString and just use serviceRequestContext.query().", "url": "https://github.com/line/armeria/pull/2686#discussion_r435888683", "createdAt": "2020-06-05T12:29:46Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4OTg3MQ==", "bodyText": "We do not have to use replace which is a bit heavy computation because we know that the requestURI starts with the context path. So we can do:\nrequestURI.substring(servletContext.getContextPath().length());", "url": "https://github.com/line/armeria/pull/2686#discussion_r435889871", "createdAt": "2020-06-05T12:32:08Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MzY5MA==", "bodyText": "This should be null when there's no path info.\nFrom the implementation this is always an empty string. Could you check this out by making unit tests please?", "url": "https://github.com/line/armeria/pull/2686#discussion_r435893690", "createdAt": "2020-06-05T12:39:42Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5Mzk4Nw==", "bodyText": "Do not have to call requestURI.replaceFirst(getContextPath(), \"\") here again. We already did.", "url": "https://github.com/line/armeria/pull/2686#discussion_r435893987", "createdAt": "2020-06-05T12:40:12Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjE5Ng==", "bodyText": "I think we don't have to check this because queryParams does not have duplicate keys.\nAlso we can use immutable map builder from the first.\nfinal Builder<String, String[]> builder = ImmutableMap.builder();\nqueryParams.forEach(x -> builder.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0])));\nparameters = builder.build();", "url": "https://github.com/line/armeria/pull/2686#discussion_r435896196", "createdAt": "2020-06-05T12:44:25Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjY4NQ==", "bodyText": "Please add @VisibleForTesting when the method is not private to use in tests.", "url": "https://github.com/line/armeria/pull/2686#discussion_r435896685", "createdAt": "2020-06-05T12:45:19Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjkxMg==", "bodyText": "We can completely remove this method.", "url": "https://github.com/line/armeria/pull/2686#discussion_r435896912", "createdAt": "2020-06-05T12:45:45Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMTkzMg==", "bodyText": "We can use httpRequest.authority() instead of getServerName() and port.", "url": "https://github.com/line/armeria/pull/2686#discussion_r435901932", "createdAt": "2020-06-05T12:55:07Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMjg0Mw==", "bodyText": "These two line can be merged into one.", "url": "https://github.com/line/armeria/pull/2686#discussion_r435902843", "createdAt": "2020-06-05T12:56:48Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzc2Nw==", "bodyText": "contentType can be null.\nWe should check it before call toString() on it.", "url": "https://github.com/line/armeria/pull/2686#discussion_r435903767", "createdAt": "2020-06-05T12:58:36Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNDU5Mw==", "bodyText": "We should check if getInputStream() is called or not as we did it in getInputStream().", "url": "https://github.com/line/armeria/pull/2686#discussion_r435904593", "createdAt": "2020-06-05T13:00:01Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getServerName() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 466}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNTQxNg==", "bodyText": "We can do serviceRequestContext.config().virtualHost().defaultHostname()\nand this is not nullable.", "url": "https://github.com/line/armeria/pull/2686#discussion_r435905416", "createdAt": "2020-06-05T13:01:24Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getServerName() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 456}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwOTc1MA==", "bodyText": "Could just do serviceRequestContext.sessionProtocol().isTls()", "url": "https://github.com/line/armeria/pull/2686#discussion_r435909750", "createdAt": "2020-06-05T13:09:43Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getServerName() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    reader = new BufferedReader(\n+                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        getAttributeMap().put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        getAttributeMap().remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        return locales[0];\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return SessionProtocol.HTTPS.uriText().equals(getScheme());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377"}, "originalPosition": 520}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "committedDate": "2020-06-05T01:23:07Z", "message": "Add query parameters util"}, "afterCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42c46421dbc87bb68b9cf6fcdb4bafb3302d2d2b", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/42c46421dbc87bb68b9cf6fcdb4bafb3302d2d2b", "committedDate": "2020-06-06T10:09:10Z", "message": "Add @CheckReturnValue check tryWrite"}, "afterCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ea2383dd2a58731e91c6461e3e4df459a7bcf898", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/ea2383dd2a58731e91c6461e3e4df459a7bcf898", "committedDate": "2020-06-07T08:41:01Z", "message": "Add QueryParams, tests for PathInfo"}, "afterCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NjgxMTI0", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-427681124", "createdAt": "2020-06-10T03:11:05Z", "commit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMzoxMTowNVrOGhjXSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMzoyNzoyNlrOGhjl1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNTU5NQ==", "bodyText": "I think this is not nullable.", "url": "https://github.com/line/armeria/pull/2686#discussion_r437835595", "createdAt": "2020-06-10T03:11:05Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.UrlMapper.Element;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<DefaultServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<DefaultFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, DefaultFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Check servlet context is initialized.\n+     */\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    @Nullable\n+    String getServletPath(String uri) {\n+        final Element element = servletUrlMapper.getMapping(StringUtil.normalizePath(uri));\n+        return element == null ? null : element.path.substring(contextPath.length());\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<DefaultServletRegistration> element =\n+                servletUrlMapper.getMapping(StringUtil.normalizePath(path));\n+        if (element == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()),\n+                                            element.pattern, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        name = StringUtil.normalizePath(name);\n+        final DefaultServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final DefaultServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(DefaultServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(DefaultServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + \";\" + SystemInfo.osType().name() + \")\";\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName), \"servletName is empty)\", servletName);\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        servletName = StringUtil.normalizePath(servletName);\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public DefaultFilterRegistration addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DefaultFilterRegistration addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DefaultFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultFilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + \";\" + SystemInfo.osType().name() + \")\";\n+    }\n+\n+    @Override\n+    public String getRequestCharacterEncoding() {\n+        return requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n+        ensureUninitialized(\"setRequestCharacterEncoding\");\n+        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n+        this.requestCharacterEncoding = requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public String getResponseCharacterEncoding() {\n+        return responseCharacterEncoding;\n+    }\n+\n+    @Override\n+    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n+        ensureUninitialized(\"setResponseCharacterEncoding\");\n+        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n+        this.responseCharacterEncoding = responseCharacterEncoding;\n+    }\n+\n+    @Override\n+    public Dynamic addJspFile(String jspName, String jspFile) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    private void ensureUninitialized(@Nullable String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 527}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNjA5Mw==", "bodyText": "Let's add @Nullable", "url": "https://github.com/line/armeria/pull/2686#discussion_r437836093", "createdAt": "2020-06-10T03:13:14Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNjkyMA==", "bodyText": "Let's just return getTime() right away because Date is Obsolete.", "url": "https://github.com/line/armeria/pull/2686#discussion_r437836920", "createdAt": "2020-06-10T03:16:37Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNzU0Nw==", "bodyText": "This can log three times for just one header.\nHow about logging it after all parsing fails?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437837547", "createdAt": "2020-06-10T03:19:34Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzODA5MQ==", "bodyText": "We might consider caching all this sort of heavy operation later. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2686#discussion_r437838091", "createdAt": "2020-06-10T03:21:44Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzODU1MQ==", "bodyText": "queryParams.getAll(name).isEmpty()", "url": "https://github.com/line/armeria/pull/2686#discussion_r437838551", "createdAt": "2020-06-10T03:24:03Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        useInputStream = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 416}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzODc3MA==", "bodyText": "If useInputStream is true, I think we need to raise an exception.", "url": "https://github.com/line/armeria/pull/2686#discussion_r437838770", "createdAt": "2020-06-10T03:25:06Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        useInputStream = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null && !useInputStream) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzOTMxNw==", "bodyText": "We should return the remote port:\n((InetSocketAddress) serviceRequestContext.remoteAddress()).getPort()", "url": "https://github.com/line/armeria/pull/2686#discussion_r437839317", "createdAt": "2020-06-10T03:27:26Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        useInputStream = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null && !useInputStream) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    reader = new BufferedReader(\n+                            new InputStreamReader(inputStream, getCharacterEncoding()));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 473}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Njg4NDM0", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-427688434", "createdAt": "2020-06-10T03:37:37Z", "commit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMzozNzozN1rOGhjudQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDoxMjo0MVrOGhkNaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0MTUyNQ==", "bodyText": "We can just do headersBuilder.contentType(MediaType.HTML_UTF_8);", "url": "https://github.com/line/armeria/pull/2686#discussion_r437841525", "createdAt": "2020-06-10T03:37:37Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0MTY3Mw==", "bodyText": "Shouldn't this be getResponseCharacterEncoding()?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437841673", "createdAt": "2020-06-10T03:38:12Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0Mjk5OA==", "bodyText": "How about removing this method and add cookie every time addCookie() is called?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437842998", "createdAt": "2020-06-10T03:44:26Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw==", "bodyText": "This does nothing. Could you use PathAndQuery.encodeToPercents()?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437844007", "createdAt": "2020-06-10T03:48:56Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NTgyMQ==", "bodyText": "Looks like we should set \"text/html\" as the content type.\nHow about making a new headers and send it?\nfinal ResponseHeaders headers =\n        ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\nif (responseWriter.tryWrite(headers)) {\n    if (msg != null) {\n        if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n            return;\n        }\n    }\n    responseWriter.close();\n}", "url": "https://github.com/line/armeria/pull/2686#discussion_r437845821", "createdAt": "2020-06-10T03:56:53Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjA5Ng==", "bodyText": "Seems like we need to use 302.", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846096", "createdAt": "2020-06-10T03:58:09Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjEzOQ==", "bodyText": "Can remove toString()", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846139", "createdAt": "2020-06-10T03:58:20Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjQyMg==", "bodyText": "Can do just set(name, value);", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846422", "createdAt": "2020-06-10T03:59:31Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjU0Mw==", "bodyText": "Can do just add(name, value);", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846543", "createdAt": "2020-06-10T04:00:03Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjY1NA==", "bodyText": "setLong?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846654", "createdAt": "2020-06-10T04:00:29Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjY4NQ==", "bodyText": "addLong?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846685", "createdAt": "2020-06-10T04:00:37Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0Njk3OA==", "bodyText": "Could just call directly headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\nSo we don't have to call toString", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846978", "createdAt": "2020-06-10T04:01:48Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NzY3Nw==", "bodyText": "We can add @Nullable and return null. Javadoc says so.", "url": "https://github.com/line/armeria/pull/2686#discussion_r437847677", "createdAt": "2020-06-10T04:04:58Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0Nzk1NQ==", "bodyText": "if (sm == null) {\n    headersBuilder.status(HttpStatus.valueOf(sc));\n} else {\n    headersBuilder.status(new HttpStatus(sc, sm));\n}", "url": "https://github.com/line/armeria/pull/2686#discussion_r437847955", "createdAt": "2020-06-10T04:06:16Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODk4Mg==", "bodyText": "final MediaType mediaType = headersBuilder.contentType();\nif (mediaType != null && mediaType.charset() != null) {\n    return mediaType.charset().toString();\n} \nreturn defaultCharacterEncoding;", "url": "https://github.com/line/armeria/pull/2686#discussion_r437848982", "createdAt": "2020-06-10T04:10:46Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            sm = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, sm));\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return getContentType().split(\";\")[1].trim();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTQ1MQ==", "bodyText": "final MediaType mediaType = headersBuilder.contentType();\nif (mediaType != null) {\n    headersBuilder.contentType(mediaType.withCharset(Charset.forName(charset)));\n}", "url": "https://github.com/line/armeria/pull/2686#discussion_r437849451", "createdAt": "2020-06-10T04:12:41Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            sm = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, sm));\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return getContentType().split(\";\")[1].trim();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        return writer;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String charset) {\n+        requireNonNull(charset, \"charset\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6554bf4298cac330209a372b85a258294035f1"}, "originalPosition": 275}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75eb0bfd4c6c68dea8060d497d13b7743fbf2786", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/75eb0bfd4c6c68dea8060d497d13b7743fbf2786", "committedDate": "2020-06-10T04:08:43Z", "message": "Check input stream or reader was used"}, "afterCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8622be94bbd03306a83bebfd29e88ec5b1d358a1", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/8622be94bbd03306a83bebfd29e88ec5b1d358a1", "committedDate": "2020-06-10T04:27:24Z", "message": "Add QueryParams, add PathInfo tests"}, "afterCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9098aa90f52c044194ccc943b2dd2ebb05cd623d", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/9098aa90f52c044194ccc943b2dd2ebb05cd623d", "committedDate": "2020-06-10T07:24:55Z", "message": "Add QueryParams, add PathInfo tests"}, "afterCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/411299338b7890ed2174698df4430c1cfe74a3f6", "committedDate": "2020-06-10T07:32:53Z", "message": "Add QueryParams, add PathInfo tests"}, "afterCommit": {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "committedDate": "2020-06-03T04:10:42Z", "message": "Set final classes and final fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5091a50bbda625835e16f194fab4004b1b11659a", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/5091a50bbda625835e16f194fab4004b1b11659a", "committedDate": "2020-06-10T08:08:41Z", "message": "Add QueryParams, add PathInfo tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Nzg5NjU1", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-427789655", "createdAt": "2020-06-10T07:40:30Z", "commit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzo0MDozMVrOGhooaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODoxNDoyMVrOGhp45g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ==", "bodyText": "It seems like we don't override this method because it's implemented in ServletInputStream?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437921899", "createdAt": "2020-06-10T07:40:31Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzMTYyNw==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r437931627", "createdAt": "2020-06-10T07:56:06Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return source.readableBytes() != 0;\n+    }\n+\n+    @Override\n+    public void setReadListener(ReadListener readListener) {\n+        requireNonNull(readListener, \"readListener\");\n+    }\n+\n+    @Override\n+    public long skip(long n) throws IOException {\n+        final long skipLen = Math.min(source.readableBytes(), n);\n+        source.skipBytes((int) skipLen);\n+        return skipLen;\n+    }\n+\n+    @Override\n+    public int available() throws IOException {\n+        return source.readableBytes();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+\n+    @Override\n+    public int read(byte[] bytes, int off, int len) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzMjMzMQ==", "bodyText": "This doesn't do anthing?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437932331", "createdAt": "2020-06-10T07:57:15Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return source.readableBytes() != 0;\n+    }\n+\n+    @Override\n+    public void setReadListener(ReadListener readListener) {\n+        requireNonNull(readListener, \"readListener\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNDY2MA==", "bodyText": "Could be source.isReadable()?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437934660", "createdAt": "2020-06-10T08:01:15Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return source.readableBytes() != 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNDgxMQ==", "bodyText": "Could be !source.isReadable()?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437934811", "createdAt": "2020-06-10T08:01:29Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNTY4Ng==", "bodyText": "Could be response.getResponseWriter().isOpen()?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437935686", "createdAt": "2020-06-10T08:03:05Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNTk1NQ==", "bodyText": "Could be response.getResponseWriter().close();?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437935955", "createdAt": "2020-06-10T08:03:34Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setWriteListener(WriteListener listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg==", "bodyText": "What happens to the second right? A user can do it?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437937722", "createdAt": "2020-06-10T08:06:26Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setWriteListener(WriteListener listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        final byte[] bytes = new byte[1];\n+        bytes[0] = (byte) b;\n+        write(bytes);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        requireNonNull(b, \"b\");\n+        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n+        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n+        response.write(HttpData.copyOf(Arrays.copyOfRange(b, off, len)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "411299338b7890ed2174698df4430c1cfe74a3f6"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0MTg5MA==", "bodyText": "Is this not supported?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437941890", "createdAt": "2020-06-10T08:13:20Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ *  Printing flow.\n+ */\n+final class ServletPrintWriter extends PrintWriter {\n+    private final String lineSeparator = System.lineSeparator();\n+    private final DefaultServletHttpResponse response;\n+\n+    private boolean error;\n+\n+    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n+        super(out);\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public void flush() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5091a50bbda625835e16f194fab4004b1b11659a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0MjUwMg==", "bodyText": "ditto write can only happen once?", "url": "https://github.com/line/armeria/pull/2686#discussion_r437942502", "createdAt": "2020-06-10T08:14:21Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ *  Printing flow.\n+ */\n+final class ServletPrintWriter extends PrintWriter {\n+    private final String lineSeparator = System.lineSeparator();\n+    private final DefaultServletHttpResponse response;\n+\n+    private boolean error;\n+\n+    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n+        super(out);\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public void flush() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean checkError() {\n+        return error;\n+    }\n+\n+    @Override\n+    protected void setError() {\n+        error = true;\n+    }\n+\n+    @Override\n+    protected void clearError() {\n+        error = false;\n+    }\n+\n+    @Override\n+    public void write(int c) {\n+        write(String.valueOf(c));\n+    }\n+\n+    @Override\n+    public void write(char[] buf, int off, int len) {\n+        requireNonNull(buf, \"buf\");\n+        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n+        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n+        write(String.valueOf(buf, off, len));\n+    }\n+\n+    @Override\n+    public void write(char[] buf) {\n+        requireNonNull(buf, \"buf\");\n+        write(String.valueOf(buf));\n+    }\n+\n+    @Override\n+    public void write(String s, int off, int len) {\n+        requireNonNull(s, \"s\");\n+        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n+        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n+        final String writeStr;\n+        if (off == 0 && s.length() == len) {\n+            writeStr = s;\n+        } else {\n+            writeStr = s.substring(off, off + len);\n+        }\n+        response.write(HttpData.ofUtf8(writeStr));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5091a50bbda625835e16f194fab4004b1b11659a"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ec6c88b5b42c7dcd1fa50ef46f042fadc8d1c12", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/2ec6c88b5b42c7dcd1fa50ef46f042fadc8d1c12", "committedDate": "2020-06-10T10:57:43Z", "message": "Check already sent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/9bc785005f71847396060d5b461d0f552a374b08", "committedDate": "2020-06-11T01:07:52Z", "message": "Cache written bytes, write multiple time"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NDg5Nzgy", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-429489782", "createdAt": "2020-06-12T06:25:31Z", "commit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNjoyNTozMlrOGi4duw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNjo0MDoyNVrOGi4yWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyOTg4Mw==", "bodyText": "We can do:\nfinal String dateHeader = getHeader(name);\nif (dateHeader == null) {\n    return -1;\n}\nfor (DateFormat x : FORMATS_TEMPLATE) {\n    try {\n        return x.parse(dateHeader).getTime();\n    } catch (Exception e) {\n        // ignored.\n    }\n}\nthrow new IllegalArgumentException(\"failed to parse a date header: \" + dateHeader);", "url": "https://github.com/line/armeria/pull/2686#discussion_r439229883", "createdAt": "2020-06-12T06:25:32Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMTg3Mg==", "bodyText": "We should not call the deprecated method. The deprecated isRequestedSessionIdFromUrl() should call this method.", "url": "https://github.com/line/armeria/pull/2686#discussion_r439231872", "createdAt": "2020-06-12T06:31:11Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMjIzMw==", "bodyText": "Shouldn't we return false at the moment because this method checks whether the requested session ID was conveyed to the server as part of the request URL?", "url": "https://github.com/line/armeria/pull/2686#discussion_r439232233", "createdAt": "2020-06-12T06:32:09Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMjg1MQ==", "bodyText": "Can't we just call return parameters.get(name);?", "url": "https://github.com/line/armeria/pull/2686#discussion_r439232851", "createdAt": "2020-06-12T06:33:59Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 406}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNDgxOA==", "bodyText": "I think we can do:\nfinal InetSocketAddress socketAddress = serviceRequestContext.localAddress();\nreturn socketAddress.getPort();", "url": "https://github.com/line/armeria/pull/2686#discussion_r439234818", "createdAt": "2020-06-12T06:39:24Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNTEzMg==", "bodyText": "This is not supported at the moment.", "url": "https://github.com/line/armeria/pull/2686#discussion_r439235132", "createdAt": "2020-06-12T06:40:20Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return serviceRequestContext.sessionProtocol().isTls();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return servletContext.getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return serviceRequestContext.config().server().defaultHostname();\n+    }\n+\n+    @Override\n+    public String getLocalAddr() {\n+        return serviceRequestContext.localAddress().toString();\n+    }\n+\n+    @Override\n+    public int getLocalPort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public DefaultServletContext getServletContext() {\n+        return servletContext;\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isAsyncStarted() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAsyncSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public AsyncContext getAsyncContext() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DispatcherType getDispatcherType() {\n+        return DispatcherType.REQUEST;\n+    }\n+\n+    @Override\n+    public String getPathTranslated() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getAuthType() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteUser() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isUserInRole(String role) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Principal getUserPrincipal() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void login(String username, String password) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void logout() throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Collection<Part> getParts() throws IOException, ServletException {\n+        return fileUploadList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 589}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNTE2MA==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r439235160", "createdAt": "2020-06-12T06:40:25Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return serviceRequestContext.sessionProtocol().isTls();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return servletContext.getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return serviceRequestContext.config().server().defaultHostname();\n+    }\n+\n+    @Override\n+    public String getLocalAddr() {\n+        return serviceRequestContext.localAddress().toString();\n+    }\n+\n+    @Override\n+    public int getLocalPort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public DefaultServletContext getServletContext() {\n+        return servletContext;\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isAsyncStarted() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAsyncSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public AsyncContext getAsyncContext() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DispatcherType getDispatcherType() {\n+        return DispatcherType.REQUEST;\n+    }\n+\n+    @Override\n+    public String getPathTranslated() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getAuthType() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteUser() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isUserInRole(String role) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Principal getUserPrincipal() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void login(String username, String password) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void logout() throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Collection<Part> getParts() throws IOException, ServletException {\n+        return fileUploadList;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Part getPart(String name) throws IOException, ServletException {\n+        requireNonNull(name, \"name\");\n+        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 596}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NDk2ODAx", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-429496801", "createdAt": "2020-06-12T06:41:34Z", "commit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNjo0MTozNFrOGi4z-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzoxMjo0NFrOGi5iAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNTU3Ng==", "bodyText": "Could you add an empty line here so that private static final stands alone?", "url": "https://github.com/line/armeria/pull/2686#discussion_r439235576", "createdAt": "2020-06-12T06:41:34Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNzc5Ng==", "bodyText": "I think the value can be negative. So we do not need this check.", "url": "https://github.com/line/armeria/pull/2686#discussion_r439237796", "createdAt": "2020-06-12T06:47:35Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNzgzMQ==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2686#discussion_r439237831", "createdAt": "2020-06-12T06:47:40Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0MDI2Mg==", "bodyText": "Shouldn't we check if getWriter() is called?", "url": "https://github.com/line/armeria/pull/2686#discussion_r439240262", "createdAt": "2020-06-12T06:54:32Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0MDQzMA==", "bodyText": "Shouldn't we check if getOutputStream() is called?", "url": "https://github.com/line/armeria/pull/2686#discussion_r439240430", "createdAt": "2020-06-12T06:54:57Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        return writer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NTg4NQ==", "bodyText": "Should return return servletContext.getResponseCharacterEncoding();", "url": "https://github.com/line/armeria/pull/2686#discussion_r439245885", "createdAt": "2020-06-12T07:09:03Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NzM2MA==", "bodyText": "throw new IllegalStateException(\"must set content type before setting a charset\")", "url": "https://github.com/line/armeria/pull/2686#discussion_r439247360", "createdAt": "2020-06-12T07:12:44Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        return writer;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String charset) {\n+        requireNonNull(charset, \"charset\");\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null) {\n+            headersBuilder.contentType(mediaType.withCharset(Charset.forName(charset)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 306}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NTIzMDcx", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-429523071", "createdAt": "2020-06-12T07:33:47Z", "commit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzozMzo0N1rOGi6EOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzozMzo0N1rOGi6EOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA==", "bodyText": "How about using ByteBufs and storing them in an array?\nSo that we can write when close() is called?\nprivate final List<ByteBuf> byteBufs = new ArrayList<>();\n\n...\n\n@Override\npublic void close() throws IOException {\n    if (!byteBufs.isEmpty()) {\n        response.getResponseWriter().write(\n                HttpData.wrap(Unpooled.wrappedBuffer(byteBufs.toArray(new ByteBuf[0]))));\n        byteBufs.clear();\n    }\n}\n\n@Override\npublic void write(int b) throws IOException {\n    byteBufs.add(Unpooled.copyInt(b));\n}\n\n@Override\npublic void write(byte[] b, int off, int len) throws IOException {\n    byteBufs.add(Unpooled.copiedBuffer(b, off, len));\n}\n\n@Override\npublic void write(byte[] b) throws IOException {\n    byteBufs.add(Unpooled.copiedBuffer(b));\n}\nAlso, I think we can just ignore flush() call because we do not support streaming response in servlet.", "url": "https://github.com/line/armeria/pull/2686#discussion_r439256120", "createdAt": "2020-06-12T07:33:47Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return response.getResponseWriter().isOpen();\n+    }\n+\n+    @Override\n+    public void setWriteListener(WriteListener listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        response.flush();\n+        response.getResponseWriter().close();\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        response.flush();\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        final byte[] bytes = new byte[1];\n+        bytes[0] = (byte) b;\n+        write(bytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc785005f71847396060d5b461d0f552a374b08"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06c030125256d45391f5c6cbaf4020a12ea0b9ac", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/06c030125256d45391f5c6cbaf4020a12ea0b9ac", "committedDate": "2020-06-12T10:50:16Z", "message": "Check use output stream or writer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMzExMDcz", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-430311073", "createdAt": "2020-06-15T04:11:42Z", "commit": {"oid": "06c030125256d45391f5c6cbaf4020a12ea0b9ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNDoxMTo0MlrOGjirMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNDoxMTo0MlrOGjirMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyMTQ1Nw==", "bodyText": "Is there any reason that you overridden methods in this class?\nIt seems like we can just use the methods in PrintWriter?", "url": "https://github.com/line/armeria/pull/2686#discussion_r439921457", "createdAt": "2020-06-15T04:11:42Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ *  Printing flow.\n+ */\n+final class ServletPrintWriter extends PrintWriter {\n+    private final String lineSeparator = System.lineSeparator();\n+    private final DefaultServletHttpResponse response;\n+\n+    private boolean error;\n+\n+    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n+        super(out);\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public void flush() {\n+    }\n+\n+    @Override\n+    public void close() {\n+        response.close();\n+    }\n+\n+    @Override\n+    public boolean checkError() {\n+        return error;\n+    }\n+\n+    @Override\n+    protected void setError() {\n+        error = true;\n+    }\n+\n+    @Override\n+    protected void clearError() {\n+        error = false;\n+    }\n+\n+    @Override\n+    public void write(int c) {\n+        write(String.valueOf(c));\n+    }\n+\n+    @Override\n+    public void write(char[] buf, int off, int len) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c030125256d45391f5c6cbaf4020a12ea0b9ac"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMzc3Mjc4", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-430377278", "createdAt": "2020-06-15T07:16:52Z", "commit": {"oid": "06c030125256d45391f5c6cbaf4020a12ea0b9ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoxNjo1MlrOGjl3Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoxNjo1MlrOGjl3Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MzcwNw==", "bodyText": "The allToken is always * so we do not want to specify it.\nThe class StringUtil is a bit complex because it's for ANT mapping. How about just using Pattern for simplicity?\nWe can just consider three cases:\n\nThe path that ends with *. (e.g /foo/bar/*)\nImplicit mapping. (e.g *.bop)\nExact path matching.\n\nWe might revisit this to optimize later though.", "url": "https://github.com/line/armeria/pull/2686#discussion_r439973707", "createdAt": "2020-06-15T07:16:52Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Url mapping\n+ * Mapping specification\n+ * In the web application deployment descriptor.\n+ */\n+final class UrlMapper<T> {\n+    private final boolean singlePattern;\n+    private final List<Element<T>> elementList = new ArrayList<>();\n+    private final StringUtil stringUtil = new StringUtil();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    UrlMapper(boolean singlePattern) {\n+        this.singlePattern = singlePattern;\n+    }\n+\n+    /**\n+     * Add mapping.\n+     */\n+    void addMapping(String urlPattern, T object, String objectName) {\n+        requireNonNull(urlPattern, \"urlPattern\");\n+        requireNonNull(object, \"object\");\n+        requireNonNull(objectName, \"objectName\");\n+        if (elementList.stream()\n+                       .filter(x -> singlePattern && x.name.equals(objectName))\n+                       .findAny().orElse(null) != null) {\n+            throw new IllegalArgumentException(\"The [\" + objectName + \"] mapping exist!\");\n+        }\n+\n+        final Element element = elementList.stream()\n+                                           .filter(x -> x.pattern.equals(urlPattern))\n+                                           .findFirst().orElse(null);\n+        if (element != null) {\n+            element.name = objectName;\n+            element.object = object;\n+        } else {\n+            elementList.add(new Element<>(urlPattern, object, objectName));\n+        }\n+    }\n+\n+    /**\n+     * Gets a mapping object.\n+     */\n+    @Nullable\n+    Element<T> getMapping(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return elementList.stream()\n+                          .filter(x -> stringUtil.match(x.pattern, absoluteUri, \"*\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c030125256d45391f5c6cbaf4020a12ea0b9ac"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMzgwNDky", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-430380492", "createdAt": "2020-06-15T07:22:20Z", "commit": {"oid": "06c030125256d45391f5c6cbaf4020a12ea0b9ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoyMjoyMFrOGjmBWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoyMjoyMFrOGjmBWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjI4Mg==", "bodyText": "We should not expose this setter because MimeMappings is a package-private class.\nHow about adding a method for adding mime mapping in this class:\npublic void addMimeMapping(String extension, String mimeType) {\n    ...\n}", "url": "https://github.com/line/armeria/pull/2686#discussion_r439976282", "createdAt": "2020-06-15T07:22:20Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.charAt(0) == '/' && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"contextPath must start with / and must not end with /. contextPath: %s\",\n+                          contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        servletContext.init();\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        validatePath(path);\n+        servletContext.addServlet(contextPath + path, httpServlet);\n+        return this;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        validatePath(path);\n+        servletContext.addServlet(contextPath + path, servletClass);\n+        return this;\n+    }\n+\n+    /**\n+     * Validate servlet path.\n+     */\n+    public void validatePath(String path) {\n+        if (path.isEmpty() || \"/\".equals(path)) {\n+            rootServletAdded = true;\n+        } else {\n+            checkArgument(path.charAt(0) == '/',\n+                          \"servletPath must start with /. servletPath: %s\",\n+                          path);\n+        }\n+    }\n+\n+    /**\n+     * Set attribute value.\n+     */\n+    public ServletBuilder attribute(String key, @Nullable Object value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setAttribute(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Set init parameter.\n+     */\n+    public ServletBuilder initParameter(String key, @Nullable String value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setInitParameter(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c030125256d45391f5c6cbaf4020a12ea0b9ac"}, "originalPosition": 133}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbfb666e1e951343b807c5aeb8bb8ac4ea86cc90", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/bbfb666e1e951343b807c5aeb8bb8ac4ea86cc90", "committedDate": "2020-06-15T11:09:27Z", "message": "Remove StringUtil and ServletPrintWriter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "323f468dd12536b300d87e38f9beb5fae4f1c63f", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/323f468dd12536b300d87e38f9beb5fae4f1c63f", "committedDate": "2020-06-16T05:06:12Z", "message": "Change setMimeMapping parameter type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a098372f4657d629ac03734e205fb507b6736adb", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/a098372f4657d629ac03734e205fb507b6736adb", "committedDate": "2020-06-19T01:37:26Z", "message": "Merge branch 'master' into pr-2686.20200619103717"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5823076cb36a800794484e4077e02b26c0da36e5", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/5823076cb36a800794484e4077e02b26c0da36e5", "committedDate": "2020-06-19T01:56:51Z", "message": "Remove mimeMapping class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82799785f19432ecafe9b04670987afc618ff70c", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/82799785f19432ecafe9b04670987afc618ff70c", "committedDate": "2020-06-19T02:26:07Z", "message": "Remove DefaultFilterRegistration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31c425d2478dd365ec98ebde765110aa7f25bdb3", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/31c425d2478dd365ec98ebde765110aa7f25bdb3", "committedDate": "2020-06-19T02:30:35Z", "message": "Remove useless javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476", "committedDate": "2020-06-19T03:30:17Z", "message": "Fix to use CompletableFuture"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzg2MDY5", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-433786069", "createdAt": "2020-06-19T03:54:57Z", "commit": {"oid": "4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzo1NDo1OFrOGmHOQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzo1NDo1OFrOGmHOQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxNzQwOQ==", "bodyText": "@dominhhien What is singlePattern? Could you explain please?", "url": "https://github.com/line/armeria/pull/2686#discussion_r442617409", "createdAt": "2020-06-19T03:54:58Z", "author": {"login": "minwoox"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n+\n+final class UrlMapper<T> {\n+    private final boolean singlePattern;\n+    private final List<Element<T>> elementList = new ArrayList<>();\n+\n+    UrlMapper(boolean singlePattern) {\n+        this.singlePattern = singlePattern;\n+    }\n+\n+    void addMapping(String urlPattern, T object, String objectName) {\n+        requireNonNull(urlPattern, \"urlPattern\");\n+        requireNonNull(object, \"object\");\n+        requireNonNull(objectName, \"objectName\");\n+        if (elementList.stream()\n+                       .filter(x -> singlePattern && x.name.equals(objectName))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf555513f7660a9439bda08539b4c286b67be545", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/bf555513f7660a9439bda08539b4c286b67be545", "committedDate": "2020-06-22T09:20:40Z", "message": "Various fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODI1ODc0", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-434825874", "createdAt": "2020-06-22T11:14:02Z", "commit": {"oid": "bf555513f7660a9439bda08539b4c286b67be545"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToxNDowM1rOGm8PrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToxNDowM1rOGm8PrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjEyNA==", "bodyText": "I think we should throw UnsupportedOperationException here. Let me fix this.", "url": "https://github.com/line/armeria/pull/2686#discussion_r443486124", "createdAt": "2020-06-22T11:14:03Z", "author": {"login": "dominhhien"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final DefaultServletRegistration registration = servletUrlMapper.getMapping(path);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(registration), registration.getName());\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final DefaultServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    void addServlet(String servletName, String className, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, className);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, HttpServlet httpServlet, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, httpServlet);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, Class<? extends Servlet> servletClass, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, servletClass);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    private void addUrlPatterns(String servletName, @Nullable DefaultServletRegistration registration,\n+                                String... urlPatterns) {\n+        if (registration == null) {\n+            return;\n+        }\n+        final Set<String> conflicts = registration.addMapping(urlPatterns);\n+        if (!conflicts.isEmpty()) {\n+            servletRegistrations.remove(servletName);\n+            throw new IllegalArgumentException(conflicts + \" are mapped already in urlPatterns: \" +\n+                                               Arrays.toString(urlPatterns));\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", className: \" + className, e);\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (servletRegistrations.containsKey(servletName)) {\n+            logger.warn(\"{} is registered already.\", servletName);\n+            return null;\n+        }\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        if (servletRegistrations.containsValue(servletRegistration)) {\n+            logger.warn(\"{} is registered already.\", servlet);\n+            return null;\n+        }\n+        servletRegistrations.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", servletClass: \" + servletClass, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new ServletException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrations.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrations;\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Nullable\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf555513f7660a9439bda08539b4c286b67be545"}, "originalPosition": 432}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODI2MzE4", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-434826318", "createdAt": "2020-06-22T11:14:43Z", "commit": {"oid": "bf555513f7660a9439bda08539b4c286b67be545"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToxNDo0M1rOGm8Q8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToxNDo0M1rOGm8Q8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjQ0OA==", "bodyText": "I think we should throw UnsupportedOperationException here. Let me fix this.", "url": "https://github.com/line/armeria/pull/2686#discussion_r443486448", "createdAt": "2020-06-22T11:14:43Z", "author": {"login": "dominhhien"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final DefaultServletRegistration registration = servletUrlMapper.getMapping(path);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(registration), registration.getName());\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final DefaultServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    void addServlet(String servletName, String className, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, className);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, HttpServlet httpServlet, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, httpServlet);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, Class<? extends Servlet> servletClass, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, servletClass);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    private void addUrlPatterns(String servletName, @Nullable DefaultServletRegistration registration,\n+                                String... urlPatterns) {\n+        if (registration == null) {\n+            return;\n+        }\n+        final Set<String> conflicts = registration.addMapping(urlPatterns);\n+        if (!conflicts.isEmpty()) {\n+            servletRegistrations.remove(servletName);\n+            throw new IllegalArgumentException(conflicts + \" are mapped already in urlPatterns: \" +\n+                                               Arrays.toString(urlPatterns));\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", className: \" + className, e);\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (servletRegistrations.containsKey(servletName)) {\n+            logger.warn(\"{} is registered already.\", servletName);\n+            return null;\n+        }\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        if (servletRegistrations.containsValue(servletRegistration)) {\n+            logger.warn(\"{} is registered already.\", servlet);\n+            return null;\n+        }\n+        servletRegistrations.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", servletClass: \" + servletClass, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new ServletException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrations.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrations;\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Nullable\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return null;\n+    }\n+\n+    @Override\n+    public Map<String, ? extends FilterRegistration> getFilterRegistrations() {\n+        return ImmutableMap.of();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf555513f7660a9439bda08539b4c286b67be545"}, "originalPosition": 438}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODMxOTY2", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-434831966", "createdAt": "2020-06-22T11:23:58Z", "commit": {"oid": "bf555513f7660a9439bda08539b4c286b67be545"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToyMzo1OFrOGm8hvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToyMzo1OFrOGm8hvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5MDc1MQ==", "bodyText": "I think\nrequestURI.substring(servletContext.getContextPath().length() + 1) = servletPath + pathInfo\n=> servletPath != requestURI.substring(servletContext.getContextPath().length() + 1)\nLet me fix this.", "url": "https://github.com/line/armeria/pull/2686#discussion_r443490751", "createdAt": "2020-06-22T11:23:58Z", "author": {"login": "dominhhien"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -111,7 +107,7 @@\n         requestURI = serviceRequestContext.path();\n         queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n         cookies = decodeCookie();\n-        servletPath = servletContext.getServletPath(requestURI);\n+        servletPath = requestURI.substring(servletContext.getContextPath().length() + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf555513f7660a9439bda08539b4c286b67be545"}, "originalPosition": 16}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2a613f70f9260e7b32489198b5cfc3dca40a8345", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/2a613f70f9260e7b32489198b5cfc3dca40a8345", "committedDate": "2020-06-23T03:32:19Z", "message": "Remove FilterTest"}, "afterCommit": {"oid": "bf555513f7660a9439bda08539b4c286b67be545", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/bf555513f7660a9439bda08539b4c286b67be545", "committedDate": "2020-06-22T09:20:40Z", "message": "Various fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13391fc73f02de293ac84a27377c76184192ed49", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/13391fc73f02de293ac84a27377c76184192ed49", "committedDate": "2020-06-24T15:42:16Z", "message": "Fix decode servlet path and test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b445960fd75b05820cce7adb6bcb90e4ec93a367", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/b445960fd75b05820cce7adb6bcb90e4ec93a367", "committedDate": "2020-07-07T11:48:52Z", "message": "Merge branch 'master' into pr-2686"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/598e25baa3d9caaab5aca80a66ba284bb6a643d5", "committedDate": "2020-07-10T08:20:28Z", "message": "Fix ServletRequestDispatcher to have servletPath and pathInfo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MjE0NTgw", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-446214580", "createdAt": "2020-07-10T08:23:49Z", "commit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoyMzo0OVrOGvufLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoyMzo0OVrOGvufLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NzkwMg==", "bodyText": "What is this for?", "url": "https://github.com/line/armeria/pull/2686#discussion_r452697902", "createdAt": "2020-07-10T08:23:49Z", "author": {"login": "minwoox"}, "path": "servlet/build.gradle", "diffHunk": "@@ -0,0 +1,4 @@\n+dependencies {\n+    api 'javax.servlet:javax.servlet-api:4.0.1'\n+    implementation 'org.apache.commons:commons-lang3:3.10'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MjAxOTQ0", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-447201944", "createdAt": "2020-07-13T12:26:05Z", "commit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjoyNjowNVrOGwmRQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjozNTowNFrOGwmj-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTg0MQ==", "bodyText": "Validation on extension and mimeType?", "url": "https://github.com/line/armeria/pull/2686#discussion_r453611841", "createdAt": "2020-07-13T12:26:05Z", "author": {"login": "trustin"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTk5Mg==", "bodyText": "The keys and values of mappings need validation.", "url": "https://github.com/line/armeria/pull/2686#discussion_r453611992", "createdAt": "2020-07-13T12:26:23Z", "author": {"login": "trustin"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMzYwNg==", "bodyText": "IIRC, many many servlet implementations rely on these operations to load some resources such as templates and properties files, no?", "url": "https://github.com/line/armeria/pull/2686#discussion_r453613606", "createdAt": "2020-07-13T12:29:25Z", "author": {"login": "trustin"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeoutMinutes;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNDM5Ng==", "bodyText": "Is is some sort of specification to return the Java version and OS name in this string?", "url": "https://github.com/line/armeria/pull/2686#discussion_r453614396", "createdAt": "2020-07-13T12:30:49Z", "author": {"login": "trustin"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeoutMinutes;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final Pair<String, DefaultServletRegistration> pair = servletUrlMapper.getMapping(path);\n+        if (pair == null) {\n+            return null;\n+        }\n+\n+        // TODO Integrate this logic into servletUrlMapper.\n+        final String pathPattern = pair.getKey();\n+        final String servletPath;\n+        final String pathInfo;\n+        if (pathPattern.endsWith(\"/*\")) {\n+            // pathPattern: \"/lawn/*\"\n+            // path: \"/lawn/index.html\" then,\n+            // servletPath: \"/lawn\"\n+            // pathInfo: \"/index.html\"\n+            servletPath = pathPattern.substring(0, pathPattern.length() - 2);\n+            pathInfo = path.substring(servletPath.length());\n+        } else {\n+            // pathPattern starts with \"*.\" or exact path.\n+            servletPath = path;\n+            pathInfo = null;\n+        }\n+\n+        return new ServletRequestDispatcher(new ServletFilterChain(pair.getValue()), pair.getValue().getName(),\n+                                            servletPath, pathInfo);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNTY4MA==", "bodyText": "Servlet context listeners are also an important part of Servlet specification many frameworks rely on. Are we sure we do not want to implement this? That would mean it will not work for most code.", "url": "https://github.com/line/armeria/pull/2686#discussion_r453615680", "createdAt": "2020-07-13T12:33:13Z", "author": {"login": "trustin"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeoutMinutes;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final Pair<String, DefaultServletRegistration> pair = servletUrlMapper.getMapping(path);\n+        if (pair == null) {\n+            return null;\n+        }\n+\n+        // TODO Integrate this logic into servletUrlMapper.\n+        final String pathPattern = pair.getKey();\n+        final String servletPath;\n+        final String pathInfo;\n+        if (pathPattern.endsWith(\"/*\")) {\n+            // pathPattern: \"/lawn/*\"\n+            // path: \"/lawn/index.html\" then,\n+            // servletPath: \"/lawn\"\n+            // pathInfo: \"/index.html\"\n+            servletPath = pathPattern.substring(0, pathPattern.length() - 2);\n+            pathInfo = path.substring(servletPath.length());\n+        } else {\n+            // pathPattern starts with \"*.\" or exact path.\n+            servletPath = path;\n+            pathInfo = null;\n+        }\n+\n+        return new ServletRequestDispatcher(new ServletFilterChain(pair.getValue()), pair.getValue().getName(),\n+                                            servletPath, pathInfo);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    private void addUrlPatterns(String servletName, @Nullable DefaultServletRegistration registration,\n+                                String... urlPatterns) {\n+        if (registration == null) {\n+            return;\n+        }\n+        final Set<String> conflicts = registration.addMapping(urlPatterns);\n+        if (!conflicts.isEmpty()) {\n+            servletRegistrations.remove(servletName);\n+            throw new IllegalArgumentException(conflicts + \" are mapped already in urlPatterns: \" +\n+                                               Arrays.toString(urlPatterns));\n+        }\n+    }\n+\n+    void addServlet(String servletName, String className, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, className);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, HttpServlet httpServlet, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, httpServlet);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, Class<? extends Servlet> servletClass, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, servletClass);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", className: \" + className, e);\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (servletRegistrations.containsKey(servletName)) {\n+            logger.warn(\"{} is registered already.\", servletName);\n+            return null;\n+        }\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        if (servletRegistrations.containsValue(servletRegistration)) {\n+            logger.warn(\"{} is registered already.\", servlet);\n+            return null;\n+        }\n+        servletRegistrations.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", servletClass: \" + servletClass, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new ServletException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrations.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrations;\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Nullable\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Map<String, ? extends FilterRegistration> getFilterRegistrations() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNjYzMw==", "bodyText": "At least some sort of minimal session support should exist. It's not easy to find a Servlet application that does not rely on this feature.", "url": "https://github.com/line/armeria/pull/2686#discussion_r453616633", "createdAt": "2020-07-13T12:35:04Z", "author": {"login": "trustin"}, "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,567 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final String servletPath;\n+    @Nullable\n+    private final String pathInfo;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    @Nullable\n+    private final Cookie[] cookies;\n+    private final Map<String, String[]> parameters;\n+\n+    DefaultServletHttpRequest(DefaultServletContext servletContext,\n+                              ServiceRequestContext serviceRequestContext,\n+                              AggregatedHttpRequest httpRequest,\n+                              String servletPath,\n+                              @Nullable String pathInfo) {\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        this.servletPath = servletPath;\n+        this.pathInfo = pathInfo;\n+        requestURI = serviceRequestContext.path();\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String dateHeader = getHeader(name);\n+        if (dateHeader == null) {\n+            return -1;\n+        }\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(dateHeader).getTime();\n+            } catch (Exception e) {\n+                // ignored.\n+            }\n+        }\n+        throw new IllegalArgumentException(\"failed to parse a date header: \" + dateHeader);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5"}, "originalPosition": 221}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0bdc96dce8764b213ddbd6508f6532b7b4eddfdb", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/0bdc96dce8764b213ddbd6508f6532b7b4eddfdb", "committedDate": "2020-07-14T09:21:19Z", "message": "Remove @NonNullByDefault to fix build tool"}, "afterCommit": {"oid": "3ca62c43618d7e894500dcd37a4d60e5b68617ee", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/3ca62c43618d7e894500dcd37a4d60e5b68617ee", "committedDate": "2020-07-14T08:49:26Z", "message": "Add MimeType validation, use Map.Entry instead of Pair"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb39d0cf798a0b315794eeeb43d3e0975ff21d50", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/eb39d0cf798a0b315794eeeb43d3e0975ff21d50", "committedDate": "2020-07-14T09:55:37Z", "message": "Fix build failed"}, "afterCommit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/598e25baa3d9caaab5aca80a66ba284bb6a643d5", "committedDate": "2020-07-10T08:20:28Z", "message": "Fix ServletRequestDispatcher to have servletPath and pathInfo"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1646475c75f098e360ce926a812dcf81ccbc16c3", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/1646475c75f098e360ce926a812dcf81ccbc16c3", "committedDate": "2020-07-15T08:18:35Z", "message": "Add core project to dependencies"}, "afterCommit": {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/598e25baa3d9caaab5aca80a66ba284bb6a643d5", "committedDate": "2020-07-10T08:20:28Z", "message": "Fix ServletRequestDispatcher to have servletPath and pathInfo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e35fd9e69503351e45dcb30a621f2bc992b12a6", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e35fd9e69503351e45dcb30a621f2bc992b12a6", "committedDate": "2020-07-15T10:00:53Z", "message": "Merge pull request #1 from line/master\n\nUpdate new source code"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "de703b0b684266fbe110d24c95cedb3407e48d14", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/de703b0b684266fbe110d24c95cedb3407e48d14", "committedDate": "2020-07-15T10:04:41Z", "message": "Add MimeType validation, use Map.Entry instead of Pair, change servlet-container to servlet-adapter"}, "afterCommit": {"oid": "4e35fd9e69503351e45dcb30a621f2bc992b12a6", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e35fd9e69503351e45dcb30a621f2bc992b12a6", "committedDate": "2020-07-15T10:00:53Z", "message": "Merge pull request #1 from line/master\n\nUpdate new source code"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64e30440b4f61265cc1f4bcca2e7919837a90122", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/64e30440b4f61265cc1f4bcca2e7919837a90122", "committedDate": "2020-07-15T10:11:11Z", "message": "MimeType validation, Pair -> Map.Entry, servlet-container -> servlet-adapter"}, "afterCommit": {"oid": "4e35fd9e69503351e45dcb30a621f2bc992b12a6", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/4e35fd9e69503351e45dcb30a621f2bc992b12a6", "committedDate": "2020-07-15T10:00:53Z", "message": "Merge pull request #1 from line/master\n\nUpdate new source code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab174a4244a1a02201cda04c6a29bd1877681d69", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/ab174a4244a1a02201cda04c6a29bd1877681d69", "committedDate": "2020-07-15T10:41:20Z", "message": "MimeType validation, Pair -> Map.Entry, servlet-container -> servlet-adapter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NDUyOTk5", "url": "https://github.com/line/armeria/pull/2686#pullrequestreview-455452999", "createdAt": "2020-07-27T03:38:11Z", "commit": {"oid": "b0ec47e1edb363013a2570f69118d65cf2837ab8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b0ec47e1edb363013a2570f69118d65cf2837ab8", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/b0ec47e1edb363013a2570f69118d65cf2837ab8", "committedDate": "2020-07-27T03:34:03Z", "message": "Remove extra space"}, "afterCommit": {"oid": "ab174a4244a1a02201cda04c6a29bd1877681d69", "author": {"user": {"login": "dominhhien", "name": "Do Minh Hien"}}, "url": "https://github.com/line/armeria/commit/ab174a4244a1a02201cda04c6a29bd1877681d69", "committedDate": "2020-07-15T10:41:20Z", "message": "MimeType validation, Pair -> Map.Entry, servlet-container -> servlet-adapter"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 425, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}