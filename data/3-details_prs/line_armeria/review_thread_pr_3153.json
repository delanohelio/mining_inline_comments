{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1MTUyNTc2", "number": 3153, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzoyMDo1MVrOE1GRBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzoyMDo1MVrOE1GRBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTEyNjQ1OnYy", "diffSide": "RIGHT", "path": "grpc/src/test/java/com/linecorp/armeria/client/grpc/GrpcClientTimeoutTest.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzoyMDo1MVrOHtLnTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMTo1MzozNVrOHtU5qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw==", "bodyText": "If the understanding is correct,\nArmeria gRPC client sets timeout when either option Client.responseTimeout or io.grpc.Stub.withDelay is specified.\nAfter timed out, the client raises DEADLINE_EXCEEDED.\nhttps://github.com/line/armeria/blob/armeria-1.2.0/grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaClientCall.java#L189-L207\nBesides, if the either options of them is specified, the client send grpc-timeout to the server, and the server also set timeout.\nAfter timed out at the server side, the server returns CANCELLED to the client.\nhttps://github.com/line/armeria/blob/armeria-1.2.0/grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaClientCall.java#L398\nhttps://github.com/line/armeria/blob/armeria-1.2.0/grpc/src/main/java/com/linecorp/armeria/server/grpc/FramedGrpcService.java#L190\nSo, I think there are two possibilities of the error code raised by the client.", "url": "https://github.com/line/armeria/pull/3153#discussion_r517138253", "createdAt": "2020-11-04T07:20:51Z", "author": {"login": "okue"}, "path": "grpc/src/test/java/com/linecorp/armeria/client/grpc/GrpcClientTimeoutTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowableOfType;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.grpc.GrpcSerializationFormats;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleRequest;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleResponse;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceBlockingStub;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceImplBase;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.grpc.GrpcService;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.Appender;\n+import io.grpc.Status.Code;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+\n+class GrpcClientTimeoutTest {\n+\n+    private static final ch.qos.logback.classic.Logger rootLogger =\n+            (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n+\n+    @Mock\n+    private Appender<ILoggingEvent> appender;\n+\n+    @Captor\n+    private ArgumentCaptor<ILoggingEvent> loggingEventCaptor;\n+\n+    @BeforeEach\n+    void setupLogger() {\n+        rootLogger.addAppender(appender);\n+    }\n+\n+    @AfterEach\n+    void cleanupLogger() {\n+        rootLogger.detachAppender(appender);\n+    }\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.requestTimeoutMillis(2000);\n+            sb.service(GrpcService.builder()\n+                                  .addService(new SlowService())\n+                                  .build());\n+        }\n+    };\n+\n+    @Test\n+    void clientTimeout() throws InterruptedException {\n+        final TestServiceBlockingStub client =\n+                Clients.newClient(server.httpUri(GrpcSerializationFormats.PROTO),\n+                                  TestServiceBlockingStub.class);\n+        final StatusRuntimeException exception = catchThrowableOfType(() -> {\n+            client.withDeadlineAfter(1000, TimeUnit.MILLISECONDS)\n+                  .unaryCall(SimpleRequest.getDefaultInstance());\n+        }, StatusRuntimeException.class);\n+        assertThat(exception.getStatus().getCode()).isEqualTo(Code.DEADLINE_EXCEEDED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ec6eb970d7ca17c4b519da2d7659376c7df60e4"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1MTcyNw==", "bodyText": "If the understanding is correct,\n\nYes, exactly.\na gRPC client actively raises DEADLINE_EXCEEDED or CANCELLED by retruned status code.", "url": "https://github.com/line/armeria/pull/3153#discussion_r517151727", "createdAt": "2020-11-04T07:52:34Z", "author": {"login": "ikhoon"}, "path": "grpc/src/test/java/com/linecorp/armeria/client/grpc/GrpcClientTimeoutTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowableOfType;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.grpc.GrpcSerializationFormats;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleRequest;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleResponse;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceBlockingStub;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceImplBase;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.grpc.GrpcService;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.Appender;\n+import io.grpc.Status.Code;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+\n+class GrpcClientTimeoutTest {\n+\n+    private static final ch.qos.logback.classic.Logger rootLogger =\n+            (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n+\n+    @Mock\n+    private Appender<ILoggingEvent> appender;\n+\n+    @Captor\n+    private ArgumentCaptor<ILoggingEvent> loggingEventCaptor;\n+\n+    @BeforeEach\n+    void setupLogger() {\n+        rootLogger.addAppender(appender);\n+    }\n+\n+    @AfterEach\n+    void cleanupLogger() {\n+        rootLogger.detachAppender(appender);\n+    }\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.requestTimeoutMillis(2000);\n+            sb.service(GrpcService.builder()\n+                                  .addService(new SlowService())\n+                                  .build());\n+        }\n+    };\n+\n+    @Test\n+    void clientTimeout() throws InterruptedException {\n+        final TestServiceBlockingStub client =\n+                Clients.newClient(server.httpUri(GrpcSerializationFormats.PROTO),\n+                                  TestServiceBlockingStub.class);\n+        final StatusRuntimeException exception = catchThrowableOfType(() -> {\n+            client.withDeadlineAfter(1000, TimeUnit.MILLISECONDS)\n+                  .unaryCall(SimpleRequest.getDefaultInstance());\n+        }, StatusRuntimeException.class);\n+        assertThat(exception.getStatus().getCode()).isEqualTo(Code.DEADLINE_EXCEEDED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}, "originalCommit": {"oid": "1ec6eb970d7ca17c4b519da2d7659376c7df60e4"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1NDc5NA==", "bodyText": "JFYI (I guess you already know this code), the following mappings convert an exception to status code.\n\n  \n    \n      armeria/grpc/src/main/java/com/linecorp/armeria/internal/common/grpc/GrpcStatus.java\n    \n    \n        Lines 78 to 112\n      in\n      1b6d85f\n    \n    \n    \n    \n\n        \n          \n           public static Status fromThrowable(Throwable t) { \n        \n\n        \n          \n               t = unwrap(requireNonNull(t, \"t\")); \n        \n\n        \n          \n            \n        \n\n        \n          \n               final Status s = Status.fromThrowable(t); \n        \n\n        \n          \n               if (s.getCode() != Code.UNKNOWN) { \n        \n\n        \n          \n                   return s; \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (t instanceof ClosedSessionException || t instanceof ClosedChannelException) { \n        \n\n        \n          \n                   // ClosedChannelException is used any time the Netty channel is closed. Proper error \n        \n\n        \n          \n                   // processing requires remembering the error that occurred before this one and using it \n        \n\n        \n          \n                   // instead. \n        \n\n        \n          \n                   return s; \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof ClosedStreamException) { \n        \n\n        \n          \n                   return Status.CANCELLED; \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof UnprocessedRequestException || t instanceof IOException) { \n        \n\n        \n          \n                   return Status.UNAVAILABLE.withCause(t); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof Http2Exception) { \n        \n\n        \n          \n                   if (t instanceof Http2Exception.StreamException && \n        \n\n        \n          \n                       ((Http2Exception.StreamException) t).error() == Http2Error.CANCEL) { \n        \n\n        \n          \n                       return Status.CANCELLED; \n        \n\n        \n          \n                   } \n        \n\n        \n          \n                   return Status.INTERNAL.withCause(t); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof TimeoutException) { \n        \n\n        \n          \n                   return Status.DEADLINE_EXCEEDED.withCause(t); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof ContentTooLargeException) { \n        \n\n        \n          \n                   return Status.RESOURCE_EXHAUSTED.withCause(t); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               return s; \n        \n\n        \n          \n           }", "url": "https://github.com/line/armeria/pull/3153#discussion_r517154794", "createdAt": "2020-11-04T07:59:08Z", "author": {"login": "ikhoon"}, "path": "grpc/src/test/java/com/linecorp/armeria/client/grpc/GrpcClientTimeoutTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowableOfType;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.grpc.GrpcSerializationFormats;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleRequest;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleResponse;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceBlockingStub;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceImplBase;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.grpc.GrpcService;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.Appender;\n+import io.grpc.Status.Code;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+\n+class GrpcClientTimeoutTest {\n+\n+    private static final ch.qos.logback.classic.Logger rootLogger =\n+            (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n+\n+    @Mock\n+    private Appender<ILoggingEvent> appender;\n+\n+    @Captor\n+    private ArgumentCaptor<ILoggingEvent> loggingEventCaptor;\n+\n+    @BeforeEach\n+    void setupLogger() {\n+        rootLogger.addAppender(appender);\n+    }\n+\n+    @AfterEach\n+    void cleanupLogger() {\n+        rootLogger.detachAppender(appender);\n+    }\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.requestTimeoutMillis(2000);\n+            sb.service(GrpcService.builder()\n+                                  .addService(new SlowService())\n+                                  .build());\n+        }\n+    };\n+\n+    @Test\n+    void clientTimeout() throws InterruptedException {\n+        final TestServiceBlockingStub client =\n+                Clients.newClient(server.httpUri(GrpcSerializationFormats.PROTO),\n+                                  TestServiceBlockingStub.class);\n+        final StatusRuntimeException exception = catchThrowableOfType(() -> {\n+            client.withDeadlineAfter(1000, TimeUnit.MILLISECONDS)\n+                  .unaryCall(SimpleRequest.getDefaultInstance());\n+        }, StatusRuntimeException.class);\n+        assertThat(exception.getStatus().getCode()).isEqualTo(Code.DEADLINE_EXCEEDED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}, "originalCommit": {"oid": "1ec6eb970d7ca17c4b519da2d7659376c7df60e4"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2NDE4NQ==", "bodyText": "In this test case, does the client never raise CANCELLED?", "url": "https://github.com/line/armeria/pull/3153#discussion_r517164185", "createdAt": "2020-11-04T08:18:04Z", "author": {"login": "okue"}, "path": "grpc/src/test/java/com/linecorp/armeria/client/grpc/GrpcClientTimeoutTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowableOfType;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.grpc.GrpcSerializationFormats;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleRequest;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleResponse;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceBlockingStub;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceImplBase;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.grpc.GrpcService;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.Appender;\n+import io.grpc.Status.Code;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+\n+class GrpcClientTimeoutTest {\n+\n+    private static final ch.qos.logback.classic.Logger rootLogger =\n+            (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n+\n+    @Mock\n+    private Appender<ILoggingEvent> appender;\n+\n+    @Captor\n+    private ArgumentCaptor<ILoggingEvent> loggingEventCaptor;\n+\n+    @BeforeEach\n+    void setupLogger() {\n+        rootLogger.addAppender(appender);\n+    }\n+\n+    @AfterEach\n+    void cleanupLogger() {\n+        rootLogger.detachAppender(appender);\n+    }\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.requestTimeoutMillis(2000);\n+            sb.service(GrpcService.builder()\n+                                  .addService(new SlowService())\n+                                  .build());\n+        }\n+    };\n+\n+    @Test\n+    void clientTimeout() throws InterruptedException {\n+        final TestServiceBlockingStub client =\n+                Clients.newClient(server.httpUri(GrpcSerializationFormats.PROTO),\n+                                  TestServiceBlockingStub.class);\n+        final StatusRuntimeException exception = catchThrowableOfType(() -> {\n+            client.withDeadlineAfter(1000, TimeUnit.MILLISECONDS)\n+                  .unaryCall(SimpleRequest.getDefaultInstance());\n+        }, StatusRuntimeException.class);\n+        assertThat(exception.getStatus().getCode()).isEqualTo(Code.DEADLINE_EXCEEDED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}, "originalCommit": {"oid": "1ec6eb970d7ca17c4b519da2d7659376c7df60e4"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI4ODI4Nw==", "bodyText": "Good point. It is possible. I think it depends on Operating System scheduling.\n\n\nA client sends a remaining timeout to a server. When the server schedules the timeout, network latency is not considered. Therefore, in most cases, the client will close a stream if a deadline exceeded.\n\n\nHowever, a client CPU is busy and hard to get CPU cycles to schedule a timeout for the deadline, a server timeout scheduler will be triggered and close a stream before the client deadline exceeded.", "url": "https://github.com/line/armeria/pull/3153#discussion_r517288287", "createdAt": "2020-11-04T11:49:15Z", "author": {"login": "ikhoon"}, "path": "grpc/src/test/java/com/linecorp/armeria/client/grpc/GrpcClientTimeoutTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowableOfType;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.grpc.GrpcSerializationFormats;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleRequest;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleResponse;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceBlockingStub;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceImplBase;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.grpc.GrpcService;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.Appender;\n+import io.grpc.Status.Code;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+\n+class GrpcClientTimeoutTest {\n+\n+    private static final ch.qos.logback.classic.Logger rootLogger =\n+            (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n+\n+    @Mock\n+    private Appender<ILoggingEvent> appender;\n+\n+    @Captor\n+    private ArgumentCaptor<ILoggingEvent> loggingEventCaptor;\n+\n+    @BeforeEach\n+    void setupLogger() {\n+        rootLogger.addAppender(appender);\n+    }\n+\n+    @AfterEach\n+    void cleanupLogger() {\n+        rootLogger.detachAppender(appender);\n+    }\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.requestTimeoutMillis(2000);\n+            sb.service(GrpcService.builder()\n+                                  .addService(new SlowService())\n+                                  .build());\n+        }\n+    };\n+\n+    @Test\n+    void clientTimeout() throws InterruptedException {\n+        final TestServiceBlockingStub client =\n+                Clients.newClient(server.httpUri(GrpcSerializationFormats.PROTO),\n+                                  TestServiceBlockingStub.class);\n+        final StatusRuntimeException exception = catchThrowableOfType(() -> {\n+            client.withDeadlineAfter(1000, TimeUnit.MILLISECONDS)\n+                  .unaryCall(SimpleRequest.getDefaultInstance());\n+        }, StatusRuntimeException.class);\n+        assertThat(exception.getStatus().getCode()).isEqualTo(Code.DEADLINE_EXCEEDED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}, "originalCommit": {"oid": "1ec6eb970d7ca17c4b519da2d7659376c7df60e4"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5MDQxMQ==", "bodyText": "Eventually to resolve this problem, as @trustin said in slack channel, we need to unify the timeout.", "url": "https://github.com/line/armeria/pull/3153#discussion_r517290411", "createdAt": "2020-11-04T11:53:35Z", "author": {"login": "ikhoon"}, "path": "grpc/src/test/java/com/linecorp/armeria/client/grpc/GrpcClientTimeoutTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowableOfType;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.grpc.GrpcSerializationFormats;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleRequest;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleResponse;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceBlockingStub;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceImplBase;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.grpc.GrpcService;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.Appender;\n+import io.grpc.Status.Code;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+\n+class GrpcClientTimeoutTest {\n+\n+    private static final ch.qos.logback.classic.Logger rootLogger =\n+            (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n+\n+    @Mock\n+    private Appender<ILoggingEvent> appender;\n+\n+    @Captor\n+    private ArgumentCaptor<ILoggingEvent> loggingEventCaptor;\n+\n+    @BeforeEach\n+    void setupLogger() {\n+        rootLogger.addAppender(appender);\n+    }\n+\n+    @AfterEach\n+    void cleanupLogger() {\n+        rootLogger.detachAppender(appender);\n+    }\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.requestTimeoutMillis(2000);\n+            sb.service(GrpcService.builder()\n+                                  .addService(new SlowService())\n+                                  .build());\n+        }\n+    };\n+\n+    @Test\n+    void clientTimeout() throws InterruptedException {\n+        final TestServiceBlockingStub client =\n+                Clients.newClient(server.httpUri(GrpcSerializationFormats.PROTO),\n+                                  TestServiceBlockingStub.class);\n+        final StatusRuntimeException exception = catchThrowableOfType(() -> {\n+            client.withDeadlineAfter(1000, TimeUnit.MILLISECONDS)\n+                  .unaryCall(SimpleRequest.getDefaultInstance());\n+        }, StatusRuntimeException.class);\n+        assertThat(exception.getStatus().getCode()).isEqualTo(Code.DEADLINE_EXCEEDED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}, "originalCommit": {"oid": "1ec6eb970d7ca17c4b519da2d7659376c7df60e4"}, "originalPosition": 97}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2006, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}