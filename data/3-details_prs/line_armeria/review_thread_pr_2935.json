{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NjQ0Mzc0", "number": 2935, "reviewThreads": {"totalCount": 58, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNTowNDo0OFrOESPKqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNzo0NDo1OVrOE9GW7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NTU4MzE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNTowNDo0OFrOG3TwBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNTo0Nzo1OVrOG3oiSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODQ1NQ==", "bodyText": "I think this option is too early to introduce now. Could we hard-code for now and then add later when we get some user demands?", "url": "https://github.com/line/armeria/pull/2935#discussion_r460648455", "createdAt": "2020-07-27T05:04:48Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -184,6 +185,10 @@\n     public static final ClientFactoryOption<ProxyConfigSelector> PROXY_CONFIG_SELECTOR =\n             ClientFactoryOption.define(\"PROXY_CONFIG_SELECTOR\", ProxyConfigSelector.of(ProxyConfig.direct()));\n \n+    public static final ClientFactoryOption<MeterIdPrefix> DEFAULT_METER_ID_PREFIX =\n+            ClientFactoryOption.define(\"DEFAULT_DNS_METER_ID_PREFIX\",\n+                    new MeterIdPrefix(\"armeria.client.dns.queries\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk4OTAwMw==", "bodyText": "Sounds good. I will make the change.", "url": "https://github.com/line/armeria/pull/2935#discussion_r460989003", "createdAt": "2020-07-27T15:47:59Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -184,6 +185,10 @@\n     public static final ClientFactoryOption<ProxyConfigSelector> PROXY_CONFIG_SELECTOR =\n             ClientFactoryOption.define(\"PROXY_CONFIG_SELECTOR\", ProxyConfigSelector.of(ProxyConfig.direct()));\n \n+    public static final ClientFactoryOption<MeterIdPrefix> DEFAULT_METER_ID_PREFIX =\n+            ClientFactoryOption.define(\"DEFAULT_DNS_METER_ID_PREFIX\",\n+                    new MeterIdPrefix(\"armeria.client.dns.queries\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODQ1NQ=="}, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NTU4NjQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNTowNjo1MFrOG3TyAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNTo0ODowOVrOG3oirg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODk2Mg==", "bodyText": "We never use IXFR or AXFR for DNS queries, so there's no way to tell if it's UDP or TCP. Let's remove protocol tag until the upstream provides a proper way to determine the protocol.", "url": "https://github.com/line/armeria/pull/2935#discussion_r460648962", "createdAt": "2020-07-27T05:06:50Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();\n+    }\n+\n+    private static String getProtocolType(DnsRecordType type) {\n+        if (DnsRecordType.IXFR.equals(type) ||\n+                DnsRecordType.AXFR.equals(type)) {\n+            return \"tcp\";\n+        }\n+        return \"udp\";\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk4OTEwMg==", "bodyText": "Ok. will do.", "url": "https://github.com/line/armeria/pull/2935#discussion_r460989102", "createdAt": "2020-07-27T15:48:09Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();\n+    }\n+\n+    private static String getProtocolType(DnsRecordType type) {\n+        if (DnsRecordType.IXFR.equals(type) ||\n+                DnsRecordType.AXFR.equals(type)) {\n+            return \"tcp\";\n+        }\n+        return \"udp\";\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODk2Mg=="}, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NTU5NDI3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNToxMTo1NFrOG3T2kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODoyOToyOFrOG6AYcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ==", "bodyText": "There are many incorrectness in this block, so I'm not sure how I can advise on this. Please make sure to re-read my suggestions about the names and tags and try re-writing this block completely.\nFor example, you should have different counter for each error code. To do this, you must get the counter lazily in the callback.", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650131", "createdAt": "2020-07-27T05:11:54Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxODMxNA==", "bodyText": "Regarding this - Your original comment -\nAll meters with the same name must have the same set of tags in Prometheus, i.e. this will fail. How about organizing like this:\nTIMER <prefix>{name=<domain name>, result=<success_or_failure>, cause=<cause_of_failure>}\nCOUNTER <prefix>.written{name=<domain_name>, server=<dns_server_ip_address>}\nCOUNTER <prefix>.cancelled{name=<domain_name>}\nCOUNTER <prefix>.cnamed{name=<domain_name>, cname=<name_in_cname_question>}\nCOUNTER <prefix>.redirected{name=<domain_name>, servers=<list_of_name_servers>}\nCOUNTER <prefix>.noanswer{name=<domain_name>, code=<response_code>}\n\nThe prefix here is something default like 'armeria.client.dns.queries'. So .cnamed is the name of the Counter ? and everything inside {} are the tags for that counter? Maybe we can pass the metricRegistry to DefaultDnsQueryLifecycleObserver and use it to instantiate the necessary counters when the appropriate dns lifecycle methods are being called?", "url": "https://github.com/line/armeria/pull/2935#discussion_r462718314", "createdAt": "2020-07-30T03:50:59Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ=="}, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3Njg1MA==", "bodyText": "So .cnamed is the name of the Counter ?\n\nYes, its name will be armeria.client.dns.queries.cnamed and its tags will be name=<....> and cname=<...>. The counter will be increased when queryCNAMEd() method is invoked.\n\neverything inside {} are the tags for that counter?\n\nThat's correct. \ud83d\ude04\n\nMaybe we can pass the metricRegistry to DefaultDnsQueryLifecycleObserver and use it to instantiate the necessary counters when the appropriate dns lifecycle methods are being called?\n\nYes! \ud83d\udc4d", "url": "https://github.com/line/armeria/pull/2935#discussion_r463476850", "createdAt": "2020-07-31T08:29:28Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ=="}, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NTU5NDg4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNToxMjoxOVrOG3T2-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNToxMjoxOVrOG3T2-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDIzNQ==", "bodyText": "Indentation", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650235", "createdAt": "2020-07-27T05:12:19Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,6 +369,7 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             }\n         };\n         return new RefreshingAddressResolverGroup(resolverConfigurator, minTtl, maxTtl, negativeTtl,\n-                                                  queryTimeoutMillis, refreshBackoff, resolvedAddressTypes);\n+                                                  queryTimeoutMillis, refreshBackoff, resolvedAddressTypes,\n+                                                   meterRegistry, meterIdPrefix);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NTU5Njg4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNToxMzo1M1rOG3T4Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzo1NDozMFrOG-Pkfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ==", "bodyText": "When you create a ClientFactory, you can specify a MeterRegistry. Create a new MeterRegistry so that ClientFactory does not use the default MeterRegistry, then check what's recorded in the MeterRegistry you specified. I'd recommend using PrometheusMeterRegistries.newRegistry() to create one.", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650551", "createdAt": "2020-07-27T05:13:53Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void test() throws ExecutionException, InterruptedException {\n+\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk5MDAyNg==", "bodyText": "Ok.", "url": "https://github.com/line/armeria/pull/2935#discussion_r460990026", "createdAt": "2020-07-27T15:49:27Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void test() throws ExecutionException, InterruptedException {\n+\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3NjU3MA==", "bodyText": "Isn't it just setting a new MeterRegistry like\nfinal MeterRegistry registry = PrometheusMeterRegistries.newRegistry():\nClientFactory.builder().meterRegistry(registry)...\n\ninstead of introducing a new MeterRegirstry? \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2935#discussion_r467676570", "createdAt": "2020-08-10T03:51:16Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void test() throws ExecutionException, InterruptedException {\n+\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxNDExNQ==", "bodyText": "Not sure @minwoox. I think the default meter registry in the ClientFactory is used to collect various different stats. See example -\n{armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.connections.lifespan#count{protocol=h1c}=0.0, armeria.client.connections.lifespan#total{protocol=h1c}=0.0, armeria.client.connections.lifespan#max{protocol=h1c}=0.0}\nAre we ok to reuse the same registry for DNS metrics? If yes then it makes sense. Let me know.", "url": "https://github.com/line/armeria/pull/2935#discussion_r467914115", "createdAt": "2020-08-10T13:45:31Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void test() throws ExecutionException, InterruptedException {\n+\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxNDUwMw==", "bodyText": "Example of DNS metric registry --\n{armeria.client.dns.queries.written#count{name=wikipedia.com.,server=/2001:558:feed:0:0:0:0:1}=2.0, armeria.client.dns.queries#count{cause=,name=wikipedia.com.,result=success}=2.0}", "url": "https://github.com/line/armeria/pull/2935#discussion_r467914503", "createdAt": "2020-08-10T13:46:10Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void test() throws ExecutionException, InterruptedException {\n+\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxOTk5OQ==", "bodyText": "Are we ok to reuse the same registry for DNS metrics? If yes then it makes sense. Let me know.\n\nI think so. \ud83d\ude04  We can check whether the metric is recorded correctly or not using the combination of tags. This is an example:\nhttps://github.com/line/armeria/blob/master/grpc/src/test/java/com/linecorp/armeria/it/grpc/GrpcMetricsIntegrationTest.java#L201", "url": "https://github.com/line/armeria/pull/2935#discussion_r467919999", "createdAt": "2020-08-10T13:54:30Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void test() throws ExecutionException, InterruptedException {\n+\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDQyMjUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDozMjo1NVrOG_Rb4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjoxNzoxMVrOHAlTiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTEzNg==", "bodyText": "I don't think we need this at all. We can use the same MeterRegistry for DNS metrics.", "url": "https://github.com/line/armeria/pull/2935#discussion_r468999136", "createdAt": "2020-08-12T04:32:55Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactory.java", "diffHunk": "@@ -177,6 +178,11 @@ static void disableShutdownHook() {\n      */\n     MeterRegistry meterRegistry();\n \n+    /**\n+     * Returns the {@link PrometheusMeterRegistry} that collects various DNS stats.\n+     */\n+    PrometheusMeterRegistry dnsMetricRegistry();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78c156d413430822fe9088f60ea271c3442b3fbc"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM3MzI1OQ==", "bodyText": "I have removed it.", "url": "https://github.com/line/armeria/pull/2935#discussion_r470373259", "createdAt": "2020-08-14T02:17:11Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactory.java", "diffHunk": "@@ -177,6 +178,11 @@ static void disableShutdownHook() {\n      */\n     MeterRegistry meterRegistry();\n \n+    /**\n+     * Returns the {@link PrometheusMeterRegistry} that collects various DNS stats.\n+     */\n+    PrometheusMeterRegistry dnsMetricRegistry();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTEzNg=="}, "originalCommit": {"oid": "78c156d413430822fe9088f60ea271c3442b3fbc"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDQyMzUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDozMzozOVrOG_Rcew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDozMzozOVrOG_Rcew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTI5MQ==", "bodyText": "Ditto - We don't need this.", "url": "https://github.com/line/armeria/pull/2935#discussion_r468999291", "createdAt": "2020-08-12T04:33:39Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -178,6 +180,9 @@\n     public static final ClientFactoryOption<MeterRegistry> METER_REGISTRY =\n             ClientFactoryOption.define(\"METER_REGISTRY\", Metrics.globalRegistry);\n \n+    public static final ClientFactoryOption<PrometheusMeterRegistry> DNS_METRIC_REGISTRY =\n+            ClientFactoryOption.define(\"DNS_METER_REGISTRY\", PrometheusMeterRegistries.newRegistry());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78c156d413430822fe9088f60ea271c3442b3fbc"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY1MjUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMzo1MjoyNlrOHCCXww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMzo1MjoyNlrOHCCXww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODA1MQ==", "bodyText": "You can always do builder.metricRegistry(options.meterRegistry()).build(eventLoopGroup).", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898051", "createdAt": "2020-08-18T03:52:26Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return options.containsKey(ClientFactoryOptions.METER_REGISTRY) ? builder\n+                                .metricRegistry((PrometheusMeterRegistry)\n+                                        options.get(ClientFactoryOptions.METER_REGISTRY).value())\n+                                .build(eventLoopGroup) : builder.build(eventLoopGroup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY1MzA5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMzo1Mjo1MlrOHCCYJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNDoxODoyMFrOHDJlsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODE1MQ==", "bodyText": "You can just accept MeterRegistry here.", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898151", "createdAt": "2020-08-18T03:52:52Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NDg4MA==", "bodyText": "Ok.", "url": "https://github.com/line/armeria/pull/2935#discussion_r473064880", "createdAt": "2020-08-19T14:18:20Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODE1MQ=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY1MzY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMzo1MzoxMlrOHCCYeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNDoxODoxMVrOHDJlRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODIzNA==", "bodyText": "Could you move these fields before the member fields in this class?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898234", "createdAt": "2020-08-18T03:53:12Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NDc3Mw==", "bodyText": "Yes will do.", "url": "https://github.com/line/armeria/pull/2935#discussion_r473064773", "createdAt": "2020-08-19T14:18:11Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODIzNA=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY2NjEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowMTowNlrOHCCfug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowMTowNlrOHCCfug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDA5MA==", "bodyText": "Could you use .getAddress().getHostAddress() because we are only interested in an IP address?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900090", "createdAt": "2020-08-18T04:01:06Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY2NjQ3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowMToxOFrOHCCf8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowMToxOFrOHCCf8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDE0Ng==", "bodyText": "Could you use .getAddress().getHostAddress() because we are only interested in IP addresses?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900146", "createdAt": "2020-08-18T04:01:18Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY2NzgzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowMjoxMVrOHCCgvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDo1MDo1N1rOHLy8OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDM1MA==", "bodyText": "intValue() instead of toString()?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900350", "createdAt": "2020-08-18T04:02:11Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzMTAwMA==", "bodyText": "Done", "url": "https://github.com/line/armeria/pull/2935#discussion_r482131000", "createdAt": "2020-09-02T14:50:57Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDM1MA=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY2OTY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserverFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowMzoyN1rOHCChvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowMzoyN1rOHCChvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDYwNw==", "bodyText": "Ditto - could use MeterRegistry", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900607", "createdAt": "2020-08-18T04:03:27Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserverFactory.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserverFactory;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserverFactory} factory that helps create DnsQueryLifecycleObserver.\n+ */\n+final class DefaultDnsQueryLifecycleObserverFactory implements DnsQueryLifecycleObserverFactory {\n+\n+    private final PrometheusMeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+\n+    DefaultDnsQueryLifecycleObserverFactory(PrometheusMeterRegistry meterRegistry,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY3MTYyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowNDo0NFrOHCCi3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowNDo0NFrOHCCi3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDg5Mw==", "bodyText": "How about \"none\" instead of \"\"?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900893", "createdAt": "2020-08-18T04:04:44Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"\"))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY3MzEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowNTo0MVrOHCCjrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDo1OTozN1rOHOy3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA==", "bodyText": "I'm somewhat concerned about using an exception message as a tag value because it can increase the cardinality dramatically. How about categorizing the exceptions into a few?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901100", "createdAt": "2020-08-18T04:05:41Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYzMjc2MA==", "bodyText": "Can you elaborate on this, please?  If I understand correctly we want to see what is the type of exception and use that to add CAUSE_TAG instead of cause.getMessage()?", "url": "https://github.com/line/armeria/pull/2935#discussion_r481632760", "createdAt": "2020-09-02T03:56:11Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjYzOA==", "bodyText": "If I understand correctly we want to see what is the type of exception and use that to add CAUSE_TAG instead of cause.getMessage()?\n\nYes, if Netty gives different exception type for different causes. If not, we'll have to categorize all possible exception types and messages into a set of well-defined strings. Makes sense?", "url": "https://github.com/line/armeria/pull/2935#discussion_r484202638", "createdAt": "2020-09-07T06:14:14Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0Mjg4Nw==", "bodyText": "Netty will return a runtimeexception of type DnsResolveContext::DnsResolveContextException which is RuntimeException. There are 5 different types of these exceptions defined in https://github.com/netty/netty/blob/fde6bc88859a41b2bdd5aae00beef09b1b17bda7/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java#L65.  We also receive DnsNameResolverTimeoutException exception when there are time outs.", "url": "https://github.com/line/armeria/pull/2935#discussion_r485242887", "createdAt": "2020-09-08T23:06:05Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NTQ0MQ==", "bodyText": "I see. Thanks for looking into. We need to do some text pattern matching in this case. You might want to contribute to Netty so that each case is distinguishable by exception type later, though.", "url": "https://github.com/line/armeria/pull/2935#discussion_r485275441", "createdAt": "2020-09-09T00:59:37Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY3NTkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowNzoyNlrOHCClPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMzo0NDo0MlrOHLT2Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTUwMQ==", "bodyText": "Should accept MeterRegistry.\nCould be package-private?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901501", "createdAt": "2020-08-18T04:07:26Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param metricRegistry {@link PrometheusMeterRegistry}.\n+     * @return DnsResolverGroupBuilder.\n+     */\n+    public DnsResolverGroupBuilder metricRegistry(PrometheusMeterRegistry metricRegistry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYyMTUwNw==", "bodyText": "Done", "url": "https://github.com/line/armeria/pull/2935#discussion_r481621507", "createdAt": "2020-09-02T03:44:42Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param metricRegistry {@link PrometheusMeterRegistry}.\n+     * @return DnsResolverGroupBuilder.\n+     */\n+    public DnsResolverGroupBuilder metricRegistry(PrometheusMeterRegistry metricRegistry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTUwMQ=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY3Njc5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowODowMlrOHCCltQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowODowMlrOHCCltQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTYyMQ==", "bodyText": "@Nonnull is redundant. Everything in our code is nonnull.\nShould accept MeterRegistry\nmetricRegistry -> meterRegistry", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901621", "createdAt": "2020-08-18T04:08:02Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -99,11 +102,13 @@\n     private final Backoff refreshBackoff;\n     private final List<DnsRecordType> dnsRecordTypes;\n     private final Consumer<DnsNameResolverBuilder> resolverConfigurator;\n+    private final PrometheusMeterRegistry metricRegistry;\n \n     RefreshingAddressResolverGroup(Consumer<DnsNameResolverBuilder> resolverConfigurator,\n                                    int minTtl, int maxTtl, int negativeTtl, long queryTimeoutMillis,\n                                    Backoff refreshBackoff,\n-                                   @Nullable ResolvedAddressTypes resolvedAddressTypes) {\n+                                   @Nullable ResolvedAddressTypes resolvedAddressTypes,\n+                                   @Nonnull PrometheusMeterRegistry metricRegistry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY3NzYzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowODoyN1rOHCCmIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDowODoyN1rOHCCmIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTcyOA==", "bodyText": "metricRegistry is always non-null. No need to check nullness.", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901728", "createdAt": "2020-08-18T04:08:27Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +134,11 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        if (metricRegistry != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY4MTQ3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDoxMTowNVrOHCCoSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjozMzoxMVrOHLKh1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjI4Mw==", "bodyText": "Could you use the TestDnsServer instead of using a public DNS server? This way, we can test all life cycle observer callbacks easily.", "url": "https://github.com/line/armeria/pull/2935#discussion_r471902283", "createdAt": "2020-08-18T04:11:05Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+\n+public class DnsMetricsTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2ODg4Ng==", "bodyText": "Done.", "url": "https://github.com/line/armeria/pull/2935#discussion_r481468886", "createdAt": "2020-09-01T22:33:11Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+\n+public class DnsMetricsTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjI4Mw=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTY4MjMyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDoxMTozN1rOHCCowQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDoxMTozN1rOHCCowQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjQwMQ==", "bodyText": "Global comment: ClientFactory must be closed at the end of the test. Use try-with-resources on it.", "url": "https://github.com/line/armeria/pull/2935#discussion_r471902401", "createdAt": "2020-08-18T04:11:37Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void dns_metric_test_for_successful_query_writes() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build();\n+\n+        final WebClient client2 = WebClient.builder()\n+                .factory(factory)\n+                .build();\n+\n+        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n+\n+        final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n+                .getPrometheusRegistry()\n+                .getSampleValue(\"armeria_client_dns_queries_total\",\n+                        new String[] {\"cause\",\"name\",\"result\"},\n+                        new String[] {\"\",\"wikipedia.com.\", \"success\"});\n+        assertThat(count > 1.0).isTrue();\n+    }\n+\n+    @Test\n+    void dns_metric_test_for_query_failures() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build();\n+        try {\n+            final WebClient client2 = WebClient.builder()\n+                    .factory(factory)\n+                    .build();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://googleusercontent.com\")).aggregate().get();\n+        } catch (Exception ex) {\n+            final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n+                    .getPrometheusRegistry()\n+                    .getSampleValue(\"armeria_client_dns_queries_total\",\n+                            new String[] {\"cause\",\"name\",\"result\"},\n+                            new String[] {\"No matching record type found\",\"googleusercontent.com.\", \"failure\"});\n+            assertThat(count > 1.0).isTrue();\n+        }\n+    }\n+\n+    @Test\n+    void no_dns_registry_used_when_not_provided_externally() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODIwODIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNjoxMDoyMVrOHNxTtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDo1NzowNVrOHOy0zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng==", "bodyText": "Could avoid using PrometheusMeterRegistries here, because we don't have a hard dependency on it. It has to be like the following IIUC:\nreturn builder.meterRegistry(options.meterRegistry()).build(eventLoopGroup);", "url": "https://github.com/line/armeria/pull/2935#discussion_r484201396", "createdAt": "2020-09-07T06:10:21Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return builder\n+                                .meterRegistry(options.containsKey(ClientFactoryOptions.METER_REGISTRY) ?\n+                                        (MeterRegistry) options.get(ClientFactoryOptions.METER_REGISTRY).value()\n+                                        : PrometheusMeterRegistries.newRegistry()).build(eventLoopGroup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzMzExNg==", "bodyText": "options is an Map<ClientFactoryOption, ClientFactoryOptionValue> options in this class.   Also the reason I was doing the null check is because there is a static ClientFactory that is being instantiated inside the https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/client/DefaultClientFactory.java#L72 and that does not have the options Map built up.", "url": "https://github.com/line/armeria/pull/2935#discussion_r485233116", "createdAt": "2020-09-08T22:38:02Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return builder\n+                                .meterRegistry(options.containsKey(ClientFactoryOptions.METER_REGISTRY) ?\n+                                        (MeterRegistry) options.get(ClientFactoryOptions.METER_REGISTRY).value()\n+                                        : PrometheusMeterRegistries.newRegistry()).build(eventLoopGroup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng=="}, "originalCommit": {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NDgzMQ==", "bodyText": "Ahh, OK. Then could we use ClientFactoryOptions.of().meterRegistry() instead of PrometheusMeterRegistries.newRegistry(), so that the default registry is chosen automatically?", "url": "https://github.com/line/armeria/pull/2935#discussion_r485274831", "createdAt": "2020-09-09T00:57:05Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return builder\n+                                .meterRegistry(options.containsKey(ClientFactoryOptions.METER_REGISTRY) ?\n+                                        (MeterRegistry) options.get(ClientFactoryOptions.METER_REGISTRY).value()\n+                                        : PrometheusMeterRegistries.newRegistry()).build(eventLoopGroup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng=="}, "originalCommit": {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODIxMjk5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNjoxMjoyMVrOHNxWbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjozODoxMlrOHOwSHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjA5NA==", "bodyText": "Shouldn't SERVER_TAG be replaced with SERVERS_TAG (\"servers\")?", "url": "https://github.com/line/armeria/pull/2935#discussion_r484202094", "createdAt": "2020-09-07T06:12:21Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private final PrometheusMeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = (PrometheusMeterRegistry)meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzMzE4Mg==", "bodyText": "Yes I will make the change", "url": "https://github.com/line/armeria/pull/2935#discussion_r485233182", "createdAt": "2020-09-08T22:38:12Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private final PrometheusMeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = (PrometheusMeterRegistry)meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjA5NA=="}, "originalCommit": {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDI2Njc2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxODo1MlrOHPiVGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxODo1MlrOHPiVGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzE0NA==", "bodyText": "You have to use SERVER_TAG here because this tag is for a single name server. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053144", "createdAt": "2020-09-10T04:18:52Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -61,7 +60,7 @@\n     public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n         meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n                 Arrays.asList(Tag.of(NAME_TAG, question.name()),\n-                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+                        Tag.of(SERVERS_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDI2NzE2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxOToxMFrOHPiVUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzo1NTozMlrOHQNY1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA==", "bodyText": "I do not see any metrics being recorded for this test. Where as if I pass in an external PrometheusMeterRegistries like I did in the other unit tests then I see the counters being incremented. Am I missing something here ?\n{armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.connections.lifespan#count{protocol=h1c}=0.0, armeria.client.connections.lifespan#total{protocol=h1c}=0.0, armeria.client.connections.lifespan#max{protocol=h1c}=0.0, armeria.client.dns.queries.written#count{name=google.com.,servers=2001:558:feed:0:0:0:0:1}=0.0, armeria.client.dns.queries#count{cause=none,name=google.com.,result=success}=0.0}", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053200", "createdAt": "2020-09-10T04:19:10Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1Mzk4Mw==", "bodyText": "No you didn't miss out anything. This is a test case, so we need to specify a concrete meter registry implementation, like you did before. My comment about removing the PrometheusMeterRegistry was for the main sources, not the test sources. Sorry if it was confusing. \ud83d\ude47", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053983", "createdAt": "2020-09-10T04:22:26Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA=="}, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NTIzMw==", "bodyText": "Ok. In a real use case how do we pass the meterRegistry down to the ClientFactory? Currently, we have the ClientFactoryBuilder::buildOptions method is where we set the meterRegistry in the DnsResolverGroupBuilder used for the factory. We do something like this\nbuilder\n.meterRegistry(ClientFactoryOptions.of().meterRegistry())\n.build(eventLoopGroup);\nClientFactoryOptions.of().meterRegistry() uses the default Metrics.globalRegistry.\nFor the UT I was creating DnsResolverGroupBuilder and setting a new PrometheusMeterRegistries into that object. Then I was using the DnsResolverGroupBuilder i just built and doing something like this\ntry (ClientFactory factory = ClientFactory.builder()\n.addressResolverGroupFactory(builder::build", "url": "https://github.com/line/armeria/pull/2935#discussion_r486745233", "createdAt": "2020-09-11T03:00:35Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA=="}, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1ODYxNQ==", "bodyText": "Ah, of course we should use ClientFacrotyOptions.of().meterRegistry() only when a user did not specify one, i.e. should use options.getOrDefault().", "url": "https://github.com/line/armeria/pull/2935#discussion_r486758615", "createdAt": "2020-09-11T03:55:32Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA=="}, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDI2NzU0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxOToyMlrOHPiVfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzowMDo0NVrOHQMkxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzI0NA==", "bodyText": "Bring the assertions back?", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053244", "createdAt": "2020-09-10T04:19:22Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NTI4Nw==", "bodyText": "Yes I will bring it back.", "url": "https://github.com/line/armeria/pull/2935#discussion_r486745287", "createdAt": "2020-09-11T03:00:45Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzI0NA=="}, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDI2OTk1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoyMDo0OVrOHPiWzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoyMDo0OVrOHPiWzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzU4Mg==", "bodyText": "You can still use PrometheusMeterRegistries.newRegistry() here because this class is a test class, i.e. You can revert the changes in this class.", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053582", "createdAt": "2020-09-10T04:20:49Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg3ODIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1MDoyN1rOHr01-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNToyOTowNlrOHsgrMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYwMg==", "bodyText": "How about inlining this method? It's used only in determineDNSExceptionTag.", "url": "https://github.com/line/armeria/pull/2935#discussion_r515716602", "createdAt": "2020-11-02T02:50:27Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDNSExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.DNS_TIMEOUT_EXCEPTION;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.DNS_RESOLVER_TIMEOUT_EXCEPTION;\n+        }\n+        return discoverExceptionType(cause.getMessage());\n+    }\n+\n+    private static DnsExceptionTypes discoverExceptionType(String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNDczOQ==", "bodyText": "Done.", "url": "https://github.com/line/armeria/pull/2935#discussion_r516434739", "createdAt": "2020-11-03T05:29:06Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDNSExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.DNS_TIMEOUT_EXCEPTION;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.DNS_RESOLVER_TIMEOUT_EXCEPTION;\n+        }\n+        return discoverExceptionType(cause.getMessage());\n+    }\n+\n+    private static DnsExceptionTypes discoverExceptionType(String message) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYwMg=="}, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg3ODQ0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1MDo0MVrOHr02GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1MDo0MVrOHr02GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYzMw==", "bodyText": "DNS -> Dns (convention)", "url": "https://github.com/line/armeria/pull/2935#discussion_r515716633", "createdAt": "2020-11-02T02:50:41Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDNSExceptionTag(Throwable cause) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg4NzIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1NzowOVrOHr07Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1NzowOVrOHr07Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNzkxMQ==", "bodyText": "How about:\n\nremoving _QUERY_FAILED, _EXCEPTION and DNS_ from all values? e.g.\n\nNX_DOMAIN_QUERY_FAILED_EXCEPTION -> NX_DOMAIN\nDNS_TIMEOUT_EXCEPTION -> TIMEOUT\n\n\nrenaming DNS_EXCEPTION to OTHERS?\nrenaming DNS_TIMEOUT_EXCEPTION to SERVER_TIMEOUT so a user can distinguish it better from RESOLVER_TIMEOUT?\nproviding lower-cased values so we can use them as tag values? i.e.\nprivate enum DnsExceptionTypes {\n    ...;\n\n    final String lowerCasedName;\n\n    DnsExceptionTypes() {\n        tag = Ascii.toLowerCase(name());\n    }\n}\n...\n\nTag.of(CAUSE_TAG, type.lowerCasedName)", "url": "https://github.com/line/armeria/pull/2935#discussion_r515717911", "createdAt": "2020-11-02T02:57:09Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg5NDMzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowMjoxMFrOHr0--A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowMjoxMFrOHr0--A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODkwNA==", "bodyText": "I guess almost all failed queries will end up getting NAME_SERVERS_EXHAUSTED_EXCEPTION, which means it's a kind of duplicate. Could we ignore it until we have a clear reason why we would want to record it?", "url": "https://github.com/line/armeria/pull/2935#discussion_r515718904", "createdAt": "2020-11-02T03:02:10Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg5NzA2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNDozOFrOHr1AoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNDozOFrOHr1AoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxOTMyOQ==", "bodyText": "If we're going to make this class public, we have to hide it from the public API. Could you move this class to internal.client? We could also merge it into internal.client.DnsUtil.", "url": "https://github.com/line/armeria/pull/2935#discussion_r515719329", "createdAt": "2020-11-02T03:04:38Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {\n \n-    static void encodeName(String name, ByteBuf out) {\n+    public static void encodeName(String name, ByteBuf out) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjU4Mzg0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo0MTo0MlrOHsg1KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMTowODoyMVrOHtFx4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ==", "bodyText": "How about just using Metrics.globalRegistry?\nBecause I have to track down which registry will be used if it's not specified.\nfinal MeterRegistry registry;\nfinal ClientFactoryOptionValue<?> opt = options.get(\n        ClientFactoryOptions.METER_REGISTRY);\nif (opt != null) {\n    registry = (MeterRegistry) opt.value();\n} else {\n    registry = Metrics.globalRegistry;\n}\n\nreturn builder.meterRegistry(registry)\n              .build(eventLoopGroup);", "url": "https://github.com/line/armeria/pull/2935#discussion_r516437289", "createdAt": "2020-11-03T05:41:42Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions.METER_REGISTRY", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1NzYwMA==", "bodyText": "It's basically same. I suggested this so that we can use the default MeterRegistry defined in ClientFactoryOptions, but I'm fine with @minwoox's suggestion given our default will not change.", "url": "https://github.com/line/armeria/pull/2935#discussion_r516457600", "createdAt": "2020-11-03T07:02:29Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions.METER_REGISTRY", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODM1OQ==", "bodyText": "I'm fine as it is. \ud83d\ude04  Just don't forget to indent the line. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458359", "createdAt": "2020-11-03T07:05:03Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions.METER_REGISTRY", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MjY1Nw==", "bodyText": "Done.", "url": "https://github.com/line/armeria/pull/2935#discussion_r517042657", "createdAt": "2020-11-04T01:08:21Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions.METER_REGISTRY", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjU5ODkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1MTo0NFrOHsg9pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoyOToxNVrOHvh5FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw==", "bodyText": "THis is not used. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2935#discussion_r516439463", "createdAt": "2020-11-03T05:51:44Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MjcyNQ==", "bodyText": "\ud83d\ude04 Done.", "url": "https://github.com/line/armeria/pull/2935#discussion_r517042725", "createdAt": "2020-11-04T01:08:40Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYwMDQwNQ==", "bodyText": "This needs to be brought back so that it doesn't fall into 'OTHERS' case.", "url": "https://github.com/line/armeria/pull/2935#discussion_r519600405", "createdAt": "2020-11-09T07:29:15Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYxODk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjowNDowMVrOHshIlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzozNTowM1rOHviCNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA==", "bodyText": "I think we should set this in DnsResolverGroupBuilder so that this factory is not overridden by the observer factory that the user configures.", "url": "https://github.com/line/armeria/pull/2935#discussion_r516442260", "createdAt": "2020-11-03T06:04:01Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzM2MQ==", "bodyText": "Can you please elaborate on this? You mean set the dnsQueryLifecycleObserverFactory in the DnsResolverGroupBuilder::build method ?", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043361", "createdAt": "2020-11-04T01:10:55Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0ODE1OQ==", "bodyText": "Sure. \ud83d\ude04\nAfter we set the observer factory resolverConfigurator.accept(builder); at line 139 is called.\nIn that method, another observer factory might be set\nhttps://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java#L332\nSo I think we can do sort of:\nfinal DnsQueryLifecycleObserverFactory defaultObserverFactory =\n        new DefaultDnsQueryLifecycleObserverFactory(\n                meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));\nif (dnsQueryLifecycleObserverFactory == null) {\n    builder.dnsQueryLifecycleObserverFactory(defaultObserverFactory);\n} else {\n    builder.dnsQueryLifecycleObserverFactory(\n            new SomeWrapper(defaultObserverFactory, dnsQueryLifecycleObserverFactory));\n}", "url": "https://github.com/line/armeria/pull/2935#discussion_r517048159", "createdAt": "2020-11-04T01:28:09Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0OTEyMQ==", "bodyText": "And we might need to add a boolean parameter to the setter so that a user can choose the behavior?\nDnsResolverGrouBuilder.dnsQueryLifecycleObserverFactory(observerFactory, overrideDefaultFactory)\nI'm not sure if it's a good idea though. \ud83d\ude05\nDo you have any suggestion? @trustin, @ikhoon", "url": "https://github.com/line/armeria/pull/2935#discussion_r517049121", "createdAt": "2020-11-04T01:31:38Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyNzY2OA==", "bodyText": "@trustin @ikhoon  can you please comment when you get a chance?", "url": "https://github.com/line/armeria/pull/2935#discussion_r518727668", "createdAt": "2020-11-06T12:43:47Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUxNjc2Ng==", "bodyText": "Sorry for the late reply. Let me take a look.", "url": "https://github.com/line/armeria/pull/2935#discussion_r519516766", "createdAt": "2020-11-09T02:04:57Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTA4NA==", "bodyText": "How about moving the modifications in this class to DnsResolverGroupBuilder, so that:\n\nRefreshingAddressResolverGroup doesn't change.\nDnsResolverGroupBuilder creates the default observer factory;\nDnsResolverGroupBuilder.build() creates the resolverConfigurator that calls DnsNameResolverBuilder.dnsQueryLifecycleObserverFactory() with the default observer factory.\n\nUse io.netty.resolver.dns.BiDnsQueryLifecycleObserverFactory to combine the default observer factory and the user-specified observer factory.\n\n\n\nMakes sense?", "url": "https://github.com/line/armeria/pull/2935#discussion_r519599084", "createdAt": "2020-11-09T07:26:26Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYwMjc0Mg==", "bodyText": "I didn't know there was BiDnsQueryLifecycleObserverFactory \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2935#discussion_r519602742", "createdAt": "2020-11-09T07:35:03Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYyMTk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjowNTo0NVrOHshKRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMToxMTowMVrOHtF0sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjY5NQ==", "bodyText": "Let's remove this return statement and just do:\nSets {@link MeterRegistry} to collect the DNS query metrics.", "url": "https://github.com/line/armeria/pull/2935#discussion_r516442695", "createdAt": "2020-11-03T06:05:45Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param meterRegistry {@link MeterRegistry}.\n+     * @return DnsResolverGroupBuilder.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzM3OQ==", "bodyText": "done", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043379", "createdAt": "2020-11-04T01:11:01Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param meterRegistry {@link MeterRegistry}.\n+     * @return DnsResolverGroupBuilder.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjY5NQ=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYyNTIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjowNzo0NFrOHshMJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjowNzo0NFrOHshMJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzE3NQ==", "bodyText": "Could you check the indentation of this class?", "url": "https://github.com/line/armeria/pull/2935#discussion_r516443175", "createdAt": "2020-11-03T06:07:44Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYyNjQwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjowODozNVrOHshM1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMToxMTowOFrOHtF0zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzM1MQ==", "bodyText": "Let's just use + as IDEA suggested which is more readable:\nmeterIdPrefix.name() + \".written\"", "url": "https://github.com/line/armeria/pull/2935#discussion_r516443351", "createdAt": "2020-11-03T06:08:35Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzQwNQ==", "bodyText": "done", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043405", "createdAt": "2020-11-04T01:11:08Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzM1MQ=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYzNjcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjoxMzo1MVrOHshSRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMzo0Mjo0NlrOHtIJDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NDc0MA==", "bodyText": "Perhaps we can make Tag.of(NAME_TAG, question.name()) in the constructor and reuse it?", "url": "https://github.com/line/armeria/pull/2935#discussion_r516444740", "createdAt": "2020-11-03T06:13:51Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4MTM1OA==", "bodyText": "Done", "url": "https://github.com/line/armeria/pull/2935#discussion_r517081358", "createdAt": "2020-11-04T03:42:46Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NDc0MA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjY0MTc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjoxNjo0OVrOHshVBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNzowNTo1OFrOHsiItQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA==", "bodyText": "Can we remove this CAUSE_TAG?", "url": "https://github.com/line/armeria/pull/2935#discussion_r516445444", "createdAt": "2020-11-03T06:16:49Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODA0Mg==", "bodyText": "Can we? queryFailed() uses the same meter name, so we have to keep the same set of tags.", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458042", "createdAt": "2020-11-03T07:04:02Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODY3Nw==", "bodyText": "Oops, I missed that. \ud83d\ude05", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458677", "createdAt": "2020-11-03T07:05:58Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjY0NTExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjoxOTowM1rOHshW8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzowODo0MVrOHvhKRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg==", "bodyText": "How about moving this method and the class to a test class because they are only used by tests?", "url": "https://github.com/line/armeria/pull/2935#discussion_r516445936", "createdAt": "2020-11-03T06:19:03Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "diffHunk": "@@ -98,4 +99,24 @@ public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordT\n     }\n \n     private DnsUtil() {}\n+\n+    public static void encodeName(String name, ByteBuf out) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODUxMA==", "bodyText": "Ahh, never knew that this is used only by test classes. Sorry, @amitvc, but could we revert this?", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458510", "createdAt": "2020-11-03T07:05:25Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "diffHunk": "@@ -98,4 +99,24 @@ public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordT\n     }\n \n     private DnsUtil() {}\n+\n+    public static void encodeName(String name, ByteBuf out) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzU0Nw==", "bodyText": "No problem @trustin. I reverted this particular change.", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043547", "createdAt": "2020-11-04T01:11:38Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "diffHunk": "@@ -98,4 +99,24 @@ public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordT\n     }\n \n     private DnsUtil() {}\n+\n+    public static void encodeName(String name, ByteBuf out) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4ODQyMQ==", "bodyText": "Thanks, @amitvc \ud83d\ude47", "url": "https://github.com/line/armeria/pull/2935#discussion_r519588421", "createdAt": "2020-11-09T07:08:41Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "diffHunk": "@@ -98,4 +99,24 @@ public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordT\n     }\n \n     private DnsUtil() {}\n+\n+    public static void encodeName(String name, ByteBuf out) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzE3ODA0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoxMTo1MVrOHvhO3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMzozMDo1MlrOHxoP0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4OTU5Ng==", "bodyText": "This seems unused as well \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2935#discussion_r519589596", "createdAt": "2020-11-09T07:11:51Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMTY4MA==", "bodyText": "Yes. I have removed it.", "url": "https://github.com/line/armeria/pull/2935#discussion_r521801680", "createdAt": "2020-11-12T03:30:52Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4OTU5Ng=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzE4MTE0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoxMzowMFrOHvhQgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMzozMTowMFrOHxoQJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDAxOA==", "bodyText": "How about keeping the names as member fields so we don't have to do string concatenation every time?", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590018", "createdAt": "2020-11-09T07:13:00Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMTc2Nw==", "bodyText": "Done.", "url": "https://github.com/line/armeria/pull/2935#discussion_r521801767", "createdAt": "2020-11-12T03:31:00Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDAxOA=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzE4MzI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoxMzo0NlrOHvhRsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMzozMTowNlrOHxoQbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDMyMw==", "bodyText": "else is redundant.", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590323", "createdAt": "2020-11-09T07:13:46Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMTgzNg==", "bodyText": "Done.", "url": "https://github.com/line/armeria/pull/2935#discussion_r521801836", "createdAt": "2020-11-12T03:31:06Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDMyMw=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzE4NjQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoxNDozOVrOHvhTgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNDo1NTo0N1rOH0kYsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA==", "bodyText": "Shouldn't we ignore the 'exhausted name servers' error here instead of returning OTHERS, so that the counter doesn't increase?", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590784", "createdAt": "2020-11-09T07:14:39Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.RESOLVER_TIMEOUT;\n+        }\n+        final String message = cause.getMessage();\n+        if (NXDOMAIN_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NX_DOMAIN;\n+        }\n+\n+        if (CNAME_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.CNAME_NOT_FOUND;\n+        }\n+\n+        if (NO_MATCHING_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NO_MATCHING_RECORD;\n+        }\n+\n+        if (UNRECOGNIZED_TYPE_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.UNRECOGNIZED_TYPE;\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMDgzNg==", "bodyText": "Are you suggesting exhausted name servers exception should not be tagged in a counter that is incremented queryFailed callback ?\nI am also noticing this exception is being thrown \"No name servers returned an answer\" but we capture it as other. Don't know what we want to do here.", "url": "https://github.com/line/armeria/pull/2935#discussion_r521800836", "createdAt": "2020-11-12T03:29:38Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.RESOLVER_TIMEOUT;\n+        }\n+        final String message = cause.getMessage();\n+        if (NXDOMAIN_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NX_DOMAIN;\n+        }\n+\n+        if (CNAME_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.CNAME_NOT_FOUND;\n+        }\n+\n+        if (NO_MATCHING_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NO_MATCHING_RECORD;\n+        }\n+\n+        if (UNRECOGNIZED_TYPE_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.UNRECOGNIZED_TYPE;\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3NTEyOQ==", "bodyText": "Are you suggesting exhausted name servers exception should not be tagged in a counter that is incremented queryFailed callback ?\n\nYes, but see below:\n\nI am also noticing this exception is being thrown \"No name servers returned an answer\" but we capture it as other. Don't know what we want to do here.\n\nThat's a good point. Is it possible to count \"No name servers returned an answer\" as a separate counter, and ignore other 'exhausted name servers' exceptions?", "url": "https://github.com/line/armeria/pull/2935#discussion_r523975129", "createdAt": "2020-11-16T08:42:48Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.RESOLVER_TIMEOUT;\n+        }\n+        final String message = cause.getMessage();\n+        if (NXDOMAIN_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NX_DOMAIN;\n+        }\n+\n+        if (CNAME_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.CNAME_NOT_FOUND;\n+        }\n+\n+        if (NO_MATCHING_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NO_MATCHING_RECORD;\n+        }\n+\n+        if (UNRECOGNIZED_TYPE_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.UNRECOGNIZED_TYPE;\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2ODQ4NA==", "bodyText": "I have added a new tag for \"No name servers returned an answer\"", "url": "https://github.com/line/armeria/pull/2935#discussion_r524868484", "createdAt": "2020-11-17T03:55:05Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.RESOLVER_TIMEOUT;\n+        }\n+        final String message = cause.getMessage();\n+        if (NXDOMAIN_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NX_DOMAIN;\n+        }\n+\n+        if (CNAME_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.CNAME_NOT_FOUND;\n+        }\n+\n+        if (NO_MATCHING_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NO_MATCHING_RECORD;\n+        }\n+\n+        if (UNRECOGNIZED_TYPE_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.UNRECOGNIZED_TYPE;\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg4NDE0NA==", "bodyText": "@trustin Sorry for the confusion the \"No name servers returned an answer\" is basically NAME_SERVERS_EXHAUSTED_EXCEPTION returned by the DnsResolveContext[netty class] that we had agreed to ignore.", "url": "https://github.com/line/armeria/pull/2935#discussion_r524884144", "createdAt": "2020-11-17T04:55:47Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.RESOLVER_TIMEOUT;\n+        }\n+        final String message = cause.getMessage();\n+        if (NXDOMAIN_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NX_DOMAIN;\n+        }\n+\n+        if (CNAME_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.CNAME_NOT_FOUND;\n+        }\n+\n+        if (NO_MATCHING_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NO_MATCHING_RECORD;\n+        }\n+\n+        if (UNRECOGNIZED_TYPE_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.UNRECOGNIZED_TYPE;\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzI0MTc5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoyNzo0N1rOHvh22w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo1ODozN1rOH4g_eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ==", "bodyText": "Global comment: Could we also make sure that no other unexpected counters are created or increased for all test cases? e.g. the meter with cause=others should be 0 or non-existent.", "url": "https://github.com/line/armeria/pull/2935#discussion_r519599835", "createdAt": "2020-11-09T07:27:47Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsRecordType.CNAME;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.DnsNameEncoder;\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsRawRecord;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void success() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String successMeterId =\n+                        \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId, successMeterId);\n+\n+                client.get(\"http://foo.com:1/\").aggregate();\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writeMeterId, 1.0)\n+                            .containsEntry(successMeterId, 1.0);\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void timeout() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+        ), new AlwaysTimeoutHandler())) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                        builder.queryTimeout(Duration.ofSeconds(1));\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client2 = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId_ipv4_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=127.0.0.1}\";\n+                final String writeMeterId_ipv6_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\";\n+                final String timeoutMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=resolver_timeout,name=foo.com.,result=failure}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId_ipv4_addr,writeMeterId_ipv6_addr, timeoutMeterId);\n+\n+                assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                        .aggregate().join())\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                        .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsAnyOf(entry(writeMeterId_ipv6_addr, 1.0),\n+                                    entry(writeMeterId_ipv4_addr, 1.0));\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void nxDomain() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NXDOMAIN)\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.searchDomains();\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writtenMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=bar.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String nxDomainMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=nx_domain,name=bar.com.,result=failure}\";\n+                assertThatThrownBy(() -> client.get(\"http://bar.com\").aggregate().join())\n+                        .hasRootCauseInstanceOf(UnknownHostException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writtenMeterId, 2.0)\n+                            .containsEntry(nxDomainMeterId, 2.0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3Mjk1Nw==", "bodyText": "Gentle ping \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2935#discussion_r523972957", "createdAt": "2020-11-16T08:39:03Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsRecordType.CNAME;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.DnsNameEncoder;\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsRawRecord;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void success() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String successMeterId =\n+                        \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId, successMeterId);\n+\n+                client.get(\"http://foo.com:1/\").aggregate();\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writeMeterId, 1.0)\n+                            .containsEntry(successMeterId, 1.0);\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void timeout() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+        ), new AlwaysTimeoutHandler())) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                        builder.queryTimeout(Duration.ofSeconds(1));\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client2 = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId_ipv4_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=127.0.0.1}\";\n+                final String writeMeterId_ipv6_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\";\n+                final String timeoutMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=resolver_timeout,name=foo.com.,result=failure}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId_ipv4_addr,writeMeterId_ipv6_addr, timeoutMeterId);\n+\n+                assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                        .aggregate().join())\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                        .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsAnyOf(entry(writeMeterId_ipv6_addr, 1.0),\n+                                    entry(writeMeterId_ipv4_addr, 1.0));\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void nxDomain() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NXDOMAIN)\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.searchDomains();\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writtenMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=bar.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String nxDomainMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=nx_domain,name=bar.com.,result=failure}\";\n+                assertThatThrownBy(() -> client.get(\"http://bar.com\").aggregate().join())\n+                        .hasRootCauseInstanceOf(UnknownHostException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writtenMeterId, 2.0)\n+                            .containsEntry(nxDomainMeterId, 2.0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2ODc3OQ==", "bodyText": "I ran the test with some debug code to print the metric registry for each UT -\nThe results below confirm we do not see cause=others any more. Please ignore the no_name_server_found log. This output was added before I added fix to ignore no_name_server_found.\n----------------------------------------Running success----------------------------------------\n{armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}=1.0, armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}=1.0}\n----------------------------------------Running timeout----------------------------------------\n{armeria.client.dns.queries#count{cause=no_name_server_found,name=foo.com.,result=failure}=2.0, armeria.client.dns.queries#count{cause=resolver_timeout,name=foo.com.,result=failure}=1.0, armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}=1.0}\n----------------------------------------Running nxDomain----------------------------------------\n{armeria.client.dns.queries#count{cause=nx_domain,name=bar.com.,result=failure}=2.0, armeria.client.dns.queries#count{cause=no_name_server_found,name=bar.com.,result=failure}=3.0, armeria.client.dns.queries.written#count{name=bar.com.,server=0:0:0:0:0:0:0:1}=2.0}\n22:46:37.220 [Test worker] DEBUG c.l.a.i.c.DefaultDnsNameResolver - [bar.com] Sending a DNS query: DnsQuestion(bar.com IN A)\n------------------------------------Running cname----------------------------------------\n{armeria.client.dns.queries.cnamed#count{cname=baz.com.,name=bar.com.}=1.0, armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.dns.queries#count{cause=none,name=bar.com.,result=success}=2.0, armeria.client.dns.queries.written#count{name=bar.com.,server=0:0:0:0:0:0:0:1}=2.0}\n----------------------------------------Running noAnswer----------------------------------------\ncom.linecorp.armeria.client.RefreshingAddressResolver$CacheEntry$$Lambda$595/0x0000000800f9f040@710be18c\n{armeria.client.dns.queries.noanswer#count{code=10,name=bar.com.}=1.0, armeria.client.dns.queries#count{cause=nx_domain,name=bar.com.,result=failure}=1.0, armeria.client.dns.queries#count{cause=no_name_server_found,name=bar.com.,result=failure}=3.0, armeria.client.dns.queries.written#count{name=bar.com.,server=0:0:0:0:0:0:0:1}=2.0}", "url": "https://github.com/line/armeria/pull/2935#discussion_r524868779", "createdAt": "2020-11-17T03:56:15Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsRecordType.CNAME;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.DnsNameEncoder;\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsRawRecord;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void success() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String successMeterId =\n+                        \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId, successMeterId);\n+\n+                client.get(\"http://foo.com:1/\").aggregate();\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writeMeterId, 1.0)\n+                            .containsEntry(successMeterId, 1.0);\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void timeout() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+        ), new AlwaysTimeoutHandler())) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                        builder.queryTimeout(Duration.ofSeconds(1));\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client2 = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId_ipv4_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=127.0.0.1}\";\n+                final String writeMeterId_ipv6_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\";\n+                final String timeoutMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=resolver_timeout,name=foo.com.,result=failure}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId_ipv4_addr,writeMeterId_ipv6_addr, timeoutMeterId);\n+\n+                assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                        .aggregate().join())\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                        .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsAnyOf(entry(writeMeterId_ipv6_addr, 1.0),\n+                                    entry(writeMeterId_ipv4_addr, 1.0));\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void nxDomain() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NXDOMAIN)\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.searchDomains();\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writtenMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=bar.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String nxDomainMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=nx_domain,name=bar.com.,result=failure}\";\n+                assertThatThrownBy(() -> client.get(\"http://bar.com\").aggregate().join())\n+                        .hasRootCauseInstanceOf(UnknownHostException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writtenMeterId, 2.0)\n+                            .containsEntry(nxDomainMeterId, 2.0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYxOTgzMA==", "bodyText": "Great, but could we automate the checks, like adding some assertions?", "url": "https://github.com/line/armeria/pull/2935#discussion_r526619830", "createdAt": "2020-11-19T06:21:16Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsRecordType.CNAME;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.DnsNameEncoder;\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsRawRecord;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void success() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String successMeterId =\n+                        \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId, successMeterId);\n+\n+                client.get(\"http://foo.com:1/\").aggregate();\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writeMeterId, 1.0)\n+                            .containsEntry(successMeterId, 1.0);\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void timeout() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+        ), new AlwaysTimeoutHandler())) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                        builder.queryTimeout(Duration.ofSeconds(1));\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client2 = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId_ipv4_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=127.0.0.1}\";\n+                final String writeMeterId_ipv6_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\";\n+                final String timeoutMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=resolver_timeout,name=foo.com.,result=failure}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId_ipv4_addr,writeMeterId_ipv6_addr, timeoutMeterId);\n+\n+                assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                        .aggregate().join())\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                        .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsAnyOf(entry(writeMeterId_ipv6_addr, 1.0),\n+                                    entry(writeMeterId_ipv4_addr, 1.0));\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void nxDomain() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NXDOMAIN)\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.searchDomains();\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writtenMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=bar.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String nxDomainMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=nx_domain,name=bar.com.,result=failure}\";\n+                assertThatThrownBy(() -> client.get(\"http://bar.com\").aggregate().join())\n+                        .hasRootCauseInstanceOf(UnknownHostException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writtenMeterId, 2.0)\n+                            .containsEntry(nxDomainMeterId, 2.0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMjg0MQ==", "bodyText": "Yes I have added them now.", "url": "https://github.com/line/armeria/pull/2935#discussion_r529022841", "createdAt": "2020-11-23T21:58:37Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsRecordType.CNAME;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.DnsNameEncoder;\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsRawRecord;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void success() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String successMeterId =\n+                        \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId, successMeterId);\n+\n+                client.get(\"http://foo.com:1/\").aggregate();\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writeMeterId, 1.0)\n+                            .containsEntry(successMeterId, 1.0);\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void timeout() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+        ), new AlwaysTimeoutHandler())) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                        builder.queryTimeout(Duration.ofSeconds(1));\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client2 = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId_ipv4_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=127.0.0.1}\";\n+                final String writeMeterId_ipv6_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\";\n+                final String timeoutMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=resolver_timeout,name=foo.com.,result=failure}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId_ipv4_addr,writeMeterId_ipv6_addr, timeoutMeterId);\n+\n+                assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                        .aggregate().join())\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                        .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsAnyOf(entry(writeMeterId_ipv6_addr, 1.0),\n+                                    entry(writeMeterId_ipv4_addr, 1.0));\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void nxDomain() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NXDOMAIN)\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.searchDomains();\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writtenMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=bar.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String nxDomainMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=nx_domain,name=bar.com.,result=failure}\";\n+                assertThatThrownBy(() -> client.get(\"http://bar.com\").aggregate().join())\n+                        .hasRootCauseInstanceOf(UnknownHostException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writtenMeterId, 2.0)\n+                            .containsEntry(nxDomainMeterId, 2.0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTEyMzcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMjoyMjo0OVrOHxmspA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMzoyNDozNVrOHxn_Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NjI5Mg==", "bodyText": "Don't we need \\ after unrecognized?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n          \n          \n            \n                private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");", "url": "https://github.com/line/armeria/pull/2935#discussion_r521776292", "createdAt": "2020-11-12T02:22:49Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc5NzQ3OQ==", "bodyText": "Fixed.", "url": "https://github.com/line/armeria/pull/2935#discussion_r521797479", "createdAt": "2020-11-12T03:24:35Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NjI5Mg=="}, "originalCommit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTEyOTc0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMjoyNTo1MFrOHxmwEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMzoyNDoyOFrOHxn_DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzE2OQ==", "bodyText": "How about creating a singleton instance for Tag.of(RESULT_TAG, \"success\") and reuse?", "url": "https://github.com/line/armeria/pull/2935#discussion_r521777169", "createdAt": "2020-11-12T02:25:50Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc5NzM4OQ==", "bodyText": "Done", "url": "https://github.com/line/armeria/pull/2935#discussion_r521797389", "createdAt": "2020-11-12T03:24:28Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzE2OQ=="}, "originalCommit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTEzMDQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMjoyNjoxNVrOHxmwcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMzoyNDoyNFrOHxn-yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzI2Nw==", "bodyText": "How about creating a singleton instance for Tag.of(RESULT_TAG, \"failure\") and reuse?", "url": "https://github.com/line/armeria/pull/2935#discussion_r521777267", "createdAt": "2020-11-12T02:26:15Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc5NzMyMg==", "bodyText": "Done.", "url": "https://github.com/line/armeria/pull/2935#discussion_r521797322", "createdAt": "2020-11-12T03:24:24Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzI2Nw=="}, "originalCommit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTM4NzM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjoxNDo0NlrOH2J43g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjoxNDo0NlrOH2J43g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0NzE2Ng==", "bodyText": "nit: indentation?", "url": "https://github.com/line/armeria/pull/2935#discussion_r526547166", "createdAt": "2020-11-19T02:14:46Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,16 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions\n+                                .METER_REGISTRY", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTQwNjE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjoyMzo1MlrOH2KD0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjoyMzo1MlrOH2KD0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0OTk3MQ==", "bodyText": "extra slash?", "url": "https://github.com/line/armeria/pull/2935#discussion_r526549971", "createdAt": "2020-11-19T02:23:52Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTQwNjQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjoyMzo1OFrOH2KD-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjoyMzo1OFrOH2KD-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1MDAwOA==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2935#discussion_r526550008", "createdAt": "2020-11-19T02:23:58Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTQwODYxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjoyNDo1M1rOH2KFRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjoyNDo1M1rOH2KFRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1MDM0MA==", "bodyText": "nit: indentation?", "url": "https://github.com/line/armeria/pull/2935#discussion_r526550340", "createdAt": "2020-11-19T02:24:53Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Pattern NO_NS_RETURNED_EXCEPTION = Pattern.compile(\"\\\\bservers returned an answer\\\\b\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+        meterIdPrefixWritten = meterIdPrefix.name() + \".written\";\n+        meterIdPrefixCancelled = meterIdPrefix.name() + \".cancelled\";\n+        meterIdPrefixRedirected = meterIdPrefix.name() + \".redirected\";\n+        meterIdPrefixCnamed = meterIdPrefix.name() + \".cnamed\";\n+        meterIdPrefixNoAnswer = meterIdPrefix.name() + \".noanswer\";\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefixWritten,\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTQzNzgyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjozNjo1MlrOH2KVAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNDoyMTo1NFrOH2MMqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDM2OQ==", "bodyText": "How about making this public?", "url": "https://github.com/line/armeria/pull/2935#discussion_r526554369", "createdAt": "2020-11-19T02:36:52Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -297,6 +302,14 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets {@link MeterRegistry} to collect the DNS query metrics.\n+     */\n+    DnsResolverGroupBuilder meterRegistry(MeterRegistry meterRegistry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4NTAwMw==", "bodyText": "No, because we should use the meterRegistry specified in ClientFactoryBuilder.meterRegistry().", "url": "https://github.com/line/armeria/pull/2935#discussion_r526585003", "createdAt": "2020-11-19T04:21:54Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -297,6 +302,14 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets {@link MeterRegistry} to collect the DNS query metrics.\n+     */\n+    DnsResolverGroupBuilder meterRegistry(MeterRegistry meterRegistry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDM2OQ=="}, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTQ0MDQ3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjozODoxOFrOH2KWkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMzo1MzoyOVrOH3QhrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ==", "bodyText": "Let's add assert meterRegistry != null so that IDE does not complain.\nLet's exctrat\nnew DefaultDnsQueryLifecycleObserverFactory(\n    meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\"))\nbefore line 359", "url": "https://github.com/line/armeria/pull/2935#discussion_r526554771", "createdAt": "2020-11-19T02:38:18Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,8 +356,15 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             if (dnsServerAddressStreamProvider != null) {\n                 builder.nameServerProvider(dnsServerAddressStreamProvider);\n             }\n-            if (dnsQueryLifecycleObserverFactory != null) {\n-                builder.dnsQueryLifecycleObserverFactory(dnsQueryLifecycleObserverFactory);\n+            if (dnsQueryLifecycleObserverFactory == null) {\n+                builder.dnsQueryLifecycleObserverFactory(new DefaultDnsQueryLifecycleObserverFactory(\n+                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM2NjI3OA==", "bodyText": "@minwoox Interesting observation. If I extract the construction of DefaultDnsQueryLifecycleObserverFactory and then pass the same DefaultDnsQueryLifecycleObserverFactory to both cases then the UT break because we are now using the same DnsQueryLifecycleObserverFactory. The UT break because the write counts are 2 times. Question is we should use the same DnsQueryLifecycleObserverFactory and not create it independently in both cases. I think this might be a bug. What do you think? The breaking UT when I extract the creation of dnsQueryLifecycleObserverFactory is below -\nio.micrometer.core.instrument.MeterRegistryjava.lang.String \nExpecting map:\n <{\"armeria.client.connections.lifespan#count{protocol=h2c}\"=0.0, \"armeria.client.connections.lifespan#max{protocol=h2c}\"=0.0, \"armeria.client.connections.lifespan#total{protocol=h2c}\"=0.0, \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\"=2.0, \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\"=2.0}>\nto contain:\n <[MapEntry[key=\"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\", value=1.0]]>\nbut could not find the following map entries:\n <[MapEntry[key=\"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\", value=1.0]]>", "url": "https://github.com/line/armeria/pull/2935#discussion_r527366278", "createdAt": "2020-11-20T03:12:28Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,8 +356,15 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             if (dnsServerAddressStreamProvider != null) {\n                 builder.nameServerProvider(dnsServerAddressStreamProvider);\n             }\n-            if (dnsQueryLifecycleObserverFactory != null) {\n-                builder.dnsQueryLifecycleObserverFactory(dnsQueryLifecycleObserverFactory);\n+            if (dnsQueryLifecycleObserverFactory == null) {\n+                builder.dnsQueryLifecycleObserverFactory(new DefaultDnsQueryLifecycleObserverFactory(\n+                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ=="}, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM3MzM1MA==", "bodyText": "Had a chat with @amitvc and I hope it succeeds this time. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2935#discussion_r527373350", "createdAt": "2020-11-20T03:39:06Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,8 +356,15 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             if (dnsServerAddressStreamProvider != null) {\n                 builder.nameServerProvider(dnsServerAddressStreamProvider);\n             }\n-            if (dnsQueryLifecycleObserverFactory != null) {\n-                builder.dnsQueryLifecycleObserverFactory(dnsQueryLifecycleObserverFactory);\n+            if (dnsQueryLifecycleObserverFactory == null) {\n+                builder.dnsQueryLifecycleObserverFactory(new DefaultDnsQueryLifecycleObserverFactory(\n+                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ=="}, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwNDQ5Mg==", "bodyText": "@minwoox the build is successful I think. https://ci.appveyor.com/project/line/armeria/builds/36414924/job/82eers20is37trhi", "url": "https://github.com/line/armeria/pull/2935#discussion_r527704492", "createdAt": "2020-11-20T13:53:29Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,8 +356,15 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             if (dnsServerAddressStreamProvider != null) {\n                 builder.nameServerProvider(dnsServerAddressStreamProvider);\n             }\n-            if (dnsQueryLifecycleObserverFactory != null) {\n-                builder.dnsQueryLifecycleObserverFactory(dnsQueryLifecycleObserverFactory);\n+            if (dnsQueryLifecycleObserverFactory == null) {\n+                builder.dnsQueryLifecycleObserverFactory(new DefaultDnsQueryLifecycleObserverFactory(\n+                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ=="}, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTQ0ODkyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjo0MjowNFrOH2KbTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNjo0MzoxOVrOH2Oy6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA==", "bodyText": "Let's move this class to a test package. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2935#discussion_r526555980", "createdAt": "2020-11-19T02:42:04Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYyMDMzMw==", "bodyText": "There are classes that depends on this class in armeria.client.endpoint.dns, so moving this class will not help much.", "url": "https://github.com/line/armeria/pull/2935#discussion_r526620333", "createdAt": "2020-11-19T06:22:35Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA=="}, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYyNzU2MA==", "bodyText": "Oops I thought this was in core/src/main....\nPlease forget about the comment. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2935#discussion_r526627560", "createdAt": "2020-11-19T06:43:19Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA=="}, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNTAyMDU4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNzo0MjoyOVrOH5mjuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0MTozN1rOH59-rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MjYxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    final ClientFactoryOptionValue<?> opt = options\n          \n          \n            \n                                            .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n          \n          \n            \n                                            .METER_REGISTRY\n          \n          \n            \n                                            .newValue(ClientFactoryOptions.of().meterRegistry()));\n          \n          \n            \n                                    final ClientFactoryOptionValue<?> opt = options.getOrDefault(\n          \n          \n            \n                                            ClientFactoryOptions.METER_REGISTRY,\n          \n          \n            \n                                            ClientFactoryOptions.METER_REGISTRY.newValue(\n          \n          \n            \n                                                    ClientFactoryOptions.of().meterRegistry()));", "url": "https://github.com/line/armeria/pull/2935#discussion_r530162619", "createdAt": "2020-11-25T07:42:29Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -631,7 +631,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n+                                .METER_REGISTRY\n+                                .newValue(ClientFactoryOptions.of().meterRegistry()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0NjM1MQ==", "bodyText": "Fixed.", "url": "https://github.com/line/armeria/pull/2935#discussion_r530546351", "createdAt": "2020-11-25T17:41:37Z", "author": {"login": "amitvc"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -631,7 +631,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n+                                .METER_REGISTRY\n+                                .newValue(ClientFactoryOptions.of().meterRegistry()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MjYxOQ=="}, "originalCommit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNTAyNzY2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/RefreshingAddressResolverTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNzo0NDo1OVrOH5moDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzozMDo1M1rOH6Kpew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ==", "bodyText": "Could you explain why we have this change? This test case doesn't seem to check and DNS metrics.", "url": "https://github.com/line/armeria/pull/2935#discussion_r530163725", "createdAt": "2020-11-25T07:44:59Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/RefreshingAddressResolverTest.java", "diffHunk": "@@ -405,6 +406,7 @@ private static DnsResolverGroupBuilder builder(TestDnsServer... servers) {\n                         Stream.of(servers).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n         return new DnsResolverGroupBuilder()\n                 .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0NTU3Mw==", "bodyText": "Good question @trustin. The reason is DnsResolverGroupBuilder::build method we expect the meterRegistry to be not null. The question can DnsResolverGroupBuilder be constructed without meterRegistry.", "url": "https://github.com/line/armeria/pull/2935#discussion_r530545573", "createdAt": "2020-11-25T17:40:13Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/RefreshingAddressResolverTest.java", "diffHunk": "@@ -405,6 +406,7 @@ private static DnsResolverGroupBuilder builder(TestDnsServer... servers) {\n                         Stream.of(servers).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n         return new DnsResolverGroupBuilder()\n                 .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ=="}, "originalCommit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1MzkxNQ==", "bodyText": "Ahh, I see. OK!", "url": "https://github.com/line/armeria/pull/2935#discussion_r530753915", "createdAt": "2020-11-26T03:30:53Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/RefreshingAddressResolverTest.java", "diffHunk": "@@ -405,6 +406,7 @@ private static DnsResolverGroupBuilder builder(TestDnsServer... servers) {\n                         Stream.of(servers).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n         return new DnsResolverGroupBuilder()\n                 .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ=="}, "originalCommit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2134, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}