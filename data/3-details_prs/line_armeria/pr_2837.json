{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMDEzMTM4", "number": 2837, "title": "Asynchronous endpoint selection", "bodyText": "Motivation:\nCurrently, sending a request will fail immediately with an\nEmptyEndpointGroupException when the target EndpointGroup is empty\nwithout waiting at all.\nIf we could wait until the EndpointGroup has at least one Endpoint,\nwe will be able to avoid the EmptyEndpointGroupException at least for\nthe case where the Endpoints disappear temporarily.\nModifications:\n\nRename EndpointSelector.select() to selectNow().\nAdd EndpointSelector.select() that performs asynchronous endpoint\nselection with timeout.\nAdd AbstractEndpointSelector that implements the asynchronous\nselect().\nModify DefaultClientRequestContext and ClientUtil to use the new\nasynchronous EndpointSelector.select() if selectNow() returns\nnull, so that it waits up to the connect timeout.\nModify UserClient require futureConverter and errorResponseFunction\nat its construction time.\n\nThe method signatures of protected execute() have been changed.\n\n\nMake AbstractListenable more suitable for frequent updates, so we\ncan add and remove many listeners when an EndpointGroup is empty.\nMiscellaneous:\n\nUpdate web-licenses.txt\n\n\n\nResult:\n\nFixes #1910\n(Breaking) EndpointSelector API has been changed.\n\nIt is not a functional interface anymore.\nselect() has been renamed to selectNow().\nAn asynchronous select() has been added.\n\n\n(Breaking) UserClient API has been changed.\n\nIts constructor requires more parameters.\nexecute() requires less parameters.", "createdAt": "2020-06-25T13:15:24Z", "url": "https://github.com/line/armeria/pull/2837", "merged": true, "mergeCommit": {"oid": "1ebadaefe33be01a6c6c8f13dedf0afea3275b19"}, "closed": true, "closedAt": "2020-06-29T13:45:22Z", "author": {"login": "trustin"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuucL0gH2gAyNDQwMDEzMTM4OmQ3N2U2MDBmZDMxNjI0YzliYmQyNjk0Y2YxYzM2YTdjMmU2YTFjNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcv_mK3AFqTQzOTA1ODMyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d77e600fd31624c9bbd2694cf1c36a7c2e6a1c65", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/d77e600fd31624c9bbd2694cf1c36a7c2e6a1c65", "committedDate": "2020-06-25T13:13:01Z", "message": "Asynchronous endpoint selection\n\nMotivation:\n\nCurrently, sending a request will fail immediately with an\n`EmptyEndpointGroupException` when the target `EndpointGroup` is empty\nwithout waiting at all.\n\nIf we could wait until the `EndpointGroup` has at least one `Endpoint`,\nwe will be able to avoid the `EmptyEndpointGroupException` at least for\nthe case where the `Endpoint`s disappear temporarily.\n\nModifications:\n\n- Rename `EndpointSelector.select()` to `selectNow()`.\n- Add `EndpointSelector.select()` that performs asynchronous endpoint\n  selection with timeout.\n- Add `AbstractEndpointSelector` that implements the asynchronous\n  `select()`.\n- Modify `DefaultClientRequestContext` and `ClientUtil` to use the new\n  asynchronous `EndpointSelector.select()` if `selectNow()` returns\n  `null`, so that it waits up to the connect timeout.\n- Modify `UserClient` require `futureConverter` and `errorResponseFunction`\n  at its construction time.\n  - The method signatures of `protected execute()` have been changed.\n- Make `AbstractListenable` more suitable for frequent updates, so we\n  can add and remove many listeners when an `EndpointGroup` is empty.\n- Miscellaneous:\n  - Update `web-licenses.txt`\n\nResult:\n\n- Fixes #1910\n- (Breaking) `EndpointSelector` API has been changed.\n  - It is not a functional interface anymore.\n  - `select()` has been renamed to `selectNow()`.\n  - An asynchronous `select()` has been added.\n- (Breaking) `UserClient` API has been changed.\n  - Its constructor requires more parameters.\n  - `execute()` requires less parameters."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/6c65d471eb3957dc82a88efb18b1745a856cacd6", "committedDate": "2020-06-26T00:55:54Z", "message": "Cancel timeout tasks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3OTUxNjQx", "url": "https://github.com/line/armeria/pull/2837#pullrequestreview-437951641", "createdAt": "2020-06-26T00:57:31Z", "commit": {"oid": "d77e600fd31624c9bbd2694cf1c36a7c2e6a1c65"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MDI0MzM4", "url": "https://github.com/line/armeria/pull/2837#pullrequestreview-438024338", "createdAt": "2020-06-26T05:35:48Z", "commit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNTozNTo0OFrOGpUP4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNjoyMzo1NVrOGpVFbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk3NjU0Nw==", "bodyText": "Could remove AbstractEndpointSelector.this.?", "url": "https://github.com/line/armeria/pull/2837#discussion_r445976547", "createdAt": "2020-06-26T05:35:48Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/AbstractEndpointSelector.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+\n+/**\n+ * A skeletal {@link EndpointSelector} implementation. This abstract class implements the\n+ * {@link #select(ClientRequestContext, ScheduledExecutorService, long)} method by listening to\n+ * the change events emitted by {@link EndpointGroup} specified at construction time.\n+ */\n+public abstract class AbstractEndpointSelector implements EndpointSelector {\n+\n+    private final EndpointGroup endpointGroup;\n+\n+    /**\n+     * Creates a new instance that selects an {@link Endpoint} from the specified {@link EndpointGroup}.\n+     */\n+    protected AbstractEndpointSelector(EndpointGroup endpointGroup) {\n+        this.endpointGroup = requireNonNull(endpointGroup, \"endpointGroup\");\n+    }\n+\n+    /**\n+     * Returns the {@link EndpointGroup} being selected by this {@link EndpointSelector}.\n+     */\n+    protected final EndpointGroup group() {\n+        return endpointGroup;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<Endpoint> select(ClientRequestContext ctx,\n+                                                    ScheduledExecutorService executor,\n+                                                    long timeoutMillis) {\n+        Endpoint endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        final ListeningFuture listeningFuture = new ListeningFuture(ctx, executor);\n+        endpointGroup.addListener(listeningFuture);\n+\n+        // Try to select again because the EndpointGroup might have been updated\n+        // between selectNow() and addListener() above.\n+        endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            endpointGroup.removeListener(listeningFuture);\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        // Schedule the timeout task.\n+        final ScheduledFuture<?> timeoutFuture =\n+                executor.schedule(() -> listeningFuture.complete(null),\n+                                  timeoutMillis, TimeUnit.MILLISECONDS);\n+        listeningFuture.timeoutFuture = timeoutFuture;\n+\n+        // Cancel the timeout task if necessary, just in case listeningFuture is\n+        // completed even before we assign timeoutFuture to listeningFuture.timeoutFuture.\n+        if (listeningFuture.isDone()) {\n+            timeoutFuture.cancel(false);\n+        }\n+\n+        return listeningFuture;\n+    }\n+\n+    private class ListeningFuture extends CompletableFuture<Endpoint> implements Consumer<List<Endpoint>> {\n+        private final ClientRequestContext ctx;\n+        private final Executor executor;\n+        @Nullable\n+        private volatile Endpoint selectedEndpoint;\n+        @Nullable\n+        private volatile ScheduledFuture<?> timeoutFuture;\n+\n+        ListeningFuture(ClientRequestContext ctx, Executor executor) {\n+            this.ctx = ctx;\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void accept(List<Endpoint> unused) {\n+            if (selectedEndpoint != null || isDone()) {\n+                return;\n+            }\n+\n+            try {\n+                final Endpoint endpoint = AbstractEndpointSelector.this.selectNow(ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk3ODcwMg==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.endpointGroup = null;\n          \n          \n            \n                    endpointGroup = null;", "url": "https://github.com/line/armeria/pull/2837#discussion_r445978702", "createdAt": "2020-06-26T05:44:16Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4MDI2Mg==", "bodyText": "Question: Why thenCompose(Function.identity()) is needed here? \ud83e\uddd0", "url": "https://github.com/line/armeria/pull/2837#discussion_r445980262", "createdAt": "2020-06-26T05:50:17Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();\n+        return endpointGroup.select(this, temporaryEventLoop, connectTimeoutMillis()).handle((e, cause) -> {\n+            updateEndpoint(e);\n+            acquireEventLoop(endpointGroup);\n+\n+            final boolean success;\n+            if (cause != null) {\n+                failEarly(cause);\n+                success = false;\n+            } else {\n+                success = true;\n+            }\n \n-        return true;\n+            final EventLoop acquiredEventLoop = eventLoop();\n+            if (acquiredEventLoop == temporaryEventLoop) {\n+                // We were lucky. No need to hand over to other EventLoop.\n+                return UnmodifiableFuture.completedFuture(success);\n+            } else {\n+                // We need to hand over to the acquired EventLoop.\n+                return CompletableFuture.supplyAsync(() -> success, acquiredEventLoop);\n+            }\n+        }).thenCompose(Function.identity());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4NDE1OA==", "bodyText": "Could merge two lines?", "url": "https://github.com/line/armeria/pull/2837#discussion_r445984158", "createdAt": "2020-06-26T06:03:25Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);\n                 }\n \n-                // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n-                final Throwable cause = ctx.log().partial().requestCause();\n-                assert cause != null;\n-                return fallbackResponseFactory.apply(ctx, cause);\n+                return initContextAndExecuteWithFallback(delegate, ctx, errorResponseFactory, success);\n+            } else {\n+                return futureConverter.apply(initFuture.handle((success, cause) -> {\n+                    try {\n+                        if (cause != null) {\n+                            throw cause;\n+                        }\n+\n+                        return initContextAndExecuteWithFallback(\n+                                delegate, ctx, errorResponseFactory, success);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4NjY4Ng==", "bodyText": "Wrap with UnprocessedRequestException.wrap(e) once #2836 is merged?", "url": "https://github.com/line/armeria/pull/2837#discussion_r445986686", "createdAt": "2020-06-26T06:12:11Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5MDI1Mg==", "bodyText": "Not related to this PR. Could we propagrate the cause to res via res.abort(cause)?", "url": "https://github.com/line/armeria/pull/2837#discussion_r445990252", "createdAt": "2020-06-26T06:23:55Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);\n                 }\n \n-                // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n-                final Throwable cause = ctx.log().partial().requestCause();\n-                assert cause != null;\n-                return fallbackResponseFactory.apply(ctx, cause);\n+                return initContextAndExecuteWithFallback(delegate, ctx, errorResponseFactory, success);\n+            } else {\n+                return futureConverter.apply(initFuture.handle((success, cause) -> {\n+                    try {\n+                        if (cause != null) {\n+                            throw cause;\n+                        }\n+\n+                        return initContextAndExecuteWithFallback(\n+                                delegate, ctx, errorResponseFactory, success);\n+                    } catch (Throwable t) {\n+                        fail(ctx, t);\n+                        return errorResponseFactory.apply(ctx, t);\n+                    }\n+                }));\n             }\n         } catch (Throwable cause) {\n             fail(ctx, cause);\n-            return fallbackResponseFactory.apply(ctx, cause);\n+            return errorResponseFactory.apply(ctx, cause);\n+        }\n+    }\n+\n+    private static <I extends Request, O extends Response, U extends Client<I, O>>\n+    O initContextAndExecuteWithFallback(\n+            U delegate, DefaultClientRequestContext ctx,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory, boolean succeeded)\n+            throws Exception {\n+\n+        if (succeeded) {\n+            return pushAndExecute(delegate, ctx);\n+        } else {\n+            // Context initialization has failed, which means:\n+            // - ctx.log() has been completed with an exception.\n+            // - ctx.request() has been aborted (if not null).\n+            // - the decorator chain was not invoked at all.\n+            // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n+\n+            // Call the decorator chain anyway so that the request is seen by the decorators.\n+            final O res = pushAndExecute(delegate, ctx);\n+\n+            // We will use the fallback response which is created from the exception\n+            // raised in ctx.init(), so the response returned can be aborted.\n+            if (res instanceof StreamMessage) {\n+                ((StreamMessage<?>) res).abort();\n+            }\n+\n+            // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n+            final Throwable cause = ctx.log().partial().requestCause();\n+            assert cause != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MDgwNTUz", "url": "https://github.com/line/armeria/pull/2837#pullrequestreview-438080553", "createdAt": "2020-06-26T07:44:06Z", "commit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0NDowNlrOGpXAbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0ODo1M1rOGpXJMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTc0Mw==", "bodyText": "How about making this private static final and reusing it?", "url": "https://github.com/line/armeria/pull/2837#discussion_r446021743", "createdAt": "2020-06-26T07:44:06Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMjQwOQ==", "bodyText": "Can't we do acquireEventLoop(endpointGroup); first and use the eventLoop?", "url": "https://github.com/line/armeria/pull/2837#discussion_r446022409", "createdAt": "2020-06-26T07:45:28Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMzk4Nw==", "bodyText": "To make CompletableFuture<CompletableFuture<Boolean>> to CompletableFuture<Boolean>?", "url": "https://github.com/line/armeria/pull/2837#discussion_r446023987", "createdAt": "2020-06-26T07:48:53Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();\n+        return endpointGroup.select(this, temporaryEventLoop, connectTimeoutMillis()).handle((e, cause) -> {\n+            updateEndpoint(e);\n+            acquireEventLoop(endpointGroup);\n+\n+            final boolean success;\n+            if (cause != null) {\n+                failEarly(cause);\n+                success = false;\n+            } else {\n+                success = true;\n+            }\n \n-        return true;\n+            final EventLoop acquiredEventLoop = eventLoop();\n+            if (acquiredEventLoop == temporaryEventLoop) {\n+                // We were lucky. No need to hand over to other EventLoop.\n+                return UnmodifiableFuture.completedFuture(success);\n+            } else {\n+                // We need to hand over to the acquired EventLoop.\n+                return CompletableFuture.supplyAsync(() -> success, acquiredEventLoop);\n+            }\n+        }).thenCompose(Function.identity());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4MDI2Mg=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 120}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba5d60b3d1080bc4b3eeee8128163ff5390b3d41", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/ba5d60b3d1080bc4b3eeee8128163ff5390b3d41", "committedDate": "2020-06-26T08:44:56Z", "message": "Merge branch 'master' into async_endpoint_selection"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTA3MzIz", "url": "https://github.com/line/armeria/pull/2837#pullrequestreview-438107323", "createdAt": "2020-06-26T08:26:10Z", "commit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODoyNjoxMFrOGpYQPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo0Njo1MlrOGpY5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0MjE3Mg==", "bodyText": "If so listeningFuture.timeoutFuture = timeoutFuture; this line should move down.\nHowever, I'm wondering if there's a chance that listeningFuture.isDone() is true after we call endpoint = selectNow(ctx); when endpoint is null. \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2837#discussion_r446042172", "createdAt": "2020-06-26T08:26:10Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/AbstractEndpointSelector.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+\n+/**\n+ * A skeletal {@link EndpointSelector} implementation. This abstract class implements the\n+ * {@link #select(ClientRequestContext, ScheduledExecutorService, long)} method by listening to\n+ * the change events emitted by {@link EndpointGroup} specified at construction time.\n+ */\n+public abstract class AbstractEndpointSelector implements EndpointSelector {\n+\n+    private final EndpointGroup endpointGroup;\n+\n+    /**\n+     * Creates a new instance that selects an {@link Endpoint} from the specified {@link EndpointGroup}.\n+     */\n+    protected AbstractEndpointSelector(EndpointGroup endpointGroup) {\n+        this.endpointGroup = requireNonNull(endpointGroup, \"endpointGroup\");\n+    }\n+\n+    /**\n+     * Returns the {@link EndpointGroup} being selected by this {@link EndpointSelector}.\n+     */\n+    protected final EndpointGroup group() {\n+        return endpointGroup;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<Endpoint> select(ClientRequestContext ctx,\n+                                                    ScheduledExecutorService executor,\n+                                                    long timeoutMillis) {\n+        Endpoint endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        final ListeningFuture listeningFuture = new ListeningFuture(ctx, executor);\n+        endpointGroup.addListener(listeningFuture);\n+\n+        // Try to select again because the EndpointGroup might have been updated\n+        // between selectNow() and addListener() above.\n+        endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            endpointGroup.removeListener(listeningFuture);\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        // Schedule the timeout task.\n+        final ScheduledFuture<?> timeoutFuture =\n+                executor.schedule(() -> listeningFuture.complete(null),\n+                                  timeoutMillis, TimeUnit.MILLISECONDS);\n+        listeningFuture.timeoutFuture = timeoutFuture;\n+\n+        // Cancel the timeout task if necessary, just in case listeningFuture is\n+        // completed even before we assign timeoutFuture to listeningFuture.timeoutFuture.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjUwNw==", "bodyText": "Can we make this as an enum? \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2837#discussion_r446052507", "createdAt": "2020-06-26T08:46:33Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/util/IdentityHashStrategy.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.util;\n+\n+import it.unimi.dsi.fastutil.Hash.Strategy;\n+\n+public final class IdentityHashStrategy<T> implements Strategy<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjY2Mw==", "bodyText": "2020?", "url": "https://github.com/line/armeria/pull/2837#discussion_r446052663", "createdAt": "2020-06-26T08:46:52Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/client/ClientRequestContextDelayedInitTest.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright 2019 LINE Corporation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 2}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e80415aab5bdbe9288f20b4ffc21871f15dcab6", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/2e80415aab5bdbe9288f20b4ffc21871f15dcab6", "committedDate": "2020-06-26T08:53:50Z", "message": "Address the comments from @minwoox and @ikhoon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23734dac6177fdd8b01d9ed6a45852423b578790", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/23734dac6177fdd8b01d9ed6a45852423b578790", "committedDate": "2020-06-26T09:11:23Z", "message": "Comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "521cc113489848cf091df86d603642f15927bd8d", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/521cc113489848cf091df86d603642f15927bd8d", "committedDate": "2020-06-26T10:11:03Z", "message": "Merge branch 'master' into async_endpoint_selection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58f7e01faae98a5987189c1b7cb2fef2d18fc280", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/58f7e01faae98a5987189c1b7cb2fef2d18fc280", "committedDate": "2020-06-26T10:15:18Z", "message": "Wrap with `UnprocessedRequestException` as advised by @ikhoon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4OTcxMjk4", "url": "https://github.com/line/armeria/pull/2837#pullrequestreview-438971298", "createdAt": "2020-06-29T08:03:13Z", "commit": {"oid": "58f7e01faae98a5987189c1b7cb2fef2d18fc280"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDU4MzIw", "url": "https://github.com/line/armeria/pull/2837#pullrequestreview-439058320", "createdAt": "2020-06-29T11:46:14Z", "commit": {"oid": "58f7e01faae98a5987189c1b7cb2fef2d18fc280"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 283, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}