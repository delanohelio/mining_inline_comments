{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3MDE2MTk4", "number": 2939, "title": "Add `when*TimingOut` and `when*TimedOut` to `{Service,Client}RequestContext`", "bodyText": "Motivation:\nCurrently, it is hard to listen to the timeout event when a request is timed-out.\nUsers should use set*TimeoutHandler() or request log.\nset*TimeoutHandler() seems a hook, however, it replaces the default timeout task\nwith the specified handler. It must be used with great care. See #2937\nBy adding whenTimingOut() and whenTimedOut(),\nset*TimeoutHandler() could be easily migrated to one of them.\nModifications:\n\nAdd whenResponseTimingOut() and whenResponseTimedOut() to ClientRequestContext\nAdd whenRequestTimingOut() and whenRequestTimedOut() to ServiceRequestContext\nMigirate gRPC code to use whenTimingOut()\nFix a bug where Armeria gRPC client drops nanotime precision of the request deadline.\nDeprecate setRequestTimeoutHandler(Runnable) and requestTimeoutHandler() in ServiceRequestContext\nDeprecate setResponseTimeoutHandler(Runnable) and responseTimeoutHandler() in ClientRequestContext\n\nResult:\n\nYou can now listen to a request timeout event using when*TimingOut(), and when*TimedOut().\nServiceRequestContext ctx = ...;\nctx.whenRequestTimingOut().thenRun(() -> {\n    // Execute a hook when the current request is about to get timed out.\n    // e.g. release some resources.\n    ...\n});\n\nctx.whenRequestTimedOut().thenRun(() -> {\n    // Execute a hook after the current request has been timed out.\n    // e.g. log some message.\n    ...\n});\n\nFixes #2937", "createdAt": "2020-07-27T09:04:21Z", "url": "https://github.com/line/armeria/pull/2939", "merged": true, "mergeCommit": {"oid": "187ad54872e90f7eea3085f5a717460f3fec2daa"}, "closed": true, "closedAt": "2020-07-31T07:30:56Z", "author": {"login": "ikhoon"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc49939AH2gAyNDU3MDE2MTk4OjhjNzM4ZmVlZjg3NDE1MjVmYTFlMzY3MDYwZmE0NzhiOTg5N2YyYWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc6OxG8AH2gAyNDU3MDE2MTk4OjM1NTVmY2E1OWJhNjNjNzZjMjE4ZTllYzE0YTllNjk1OGQ0MDhjYTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8c738feef8741525fa1e367060fa478b9897f2af", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/8c738feef8741525fa1e367060fa478b9897f2af", "committedDate": "2020-07-27T08:57:38Z", "message": "Add `whenTimingOut` and `whenTimedOut` to RequestContext\n\nMotivation:\n\nCurrently, it is hard to listen to the timeout event when a request is timed-out.\nUsers should use `set*TimeoutHandler()` or request log.\n`set*TimeoutHandler()` seems a hook, however, it replaces the default timeout task\nwith the specified handler. It must be used with great care. See #2937\n\nBy adding `whenTimingOut()` and `whenTimedOut()`,\n`set*TimeoutHandler()` could be easily migrated to one of them.\n\nModifications:\n\n- Add `whenTimingOut()` and `whenTimedOut()` to `RequestContext`\n- Fix grpc code to use `whenTimingOut()`\n- Deprecate `ServiceRequestContext.setRequestTimeoutHandler()`\n- Deprecate `ClientRequestContext.setResponseTimeoutHandler()`\n\nResult:\n\n- You can now listen to a request timeout event using `whenTimingOut()`, and `whenTimedOut()`.\n  ```java\n  ServiceRequestContext ctx = ...;\n  ctx.whenTimingOut().thenRun(() -> {\n      // Execute a hook right before the timeout.\n      // e.g. release some resources.\n      ...\n  });\n\n  ctx.whenTimedOut().thenRun(() -> {\n      // Execute a hook right after the timeout\n      // e.g. log some message.\n      ...\n  });\n  ```\n- Fixes #2937"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NjA3Njk2", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-455607696", "createdAt": "2020-07-27T09:10:56Z", "commit": {"oid": "8c738feef8741525fa1e367060fa478b9897f2af"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwOToxMDo1NlrOG3aIkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwOToyNTowMlrOG3aojw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MzA0Mw==", "bodyText": "is about to get timed out?", "url": "https://github.com/line/armeria/pull/2939#discussion_r460753043", "createdAt": "2020-07-27T09:10:56Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -378,6 +378,19 @@\n      */\n     boolean isTimedOut();\n \n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link RequestContext} is timing-out.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c738feef8741525fa1e367060fa478b9897f2af"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MzE5Mg==", "bodyText": "has been timed out?", "url": "https://github.com/line/armeria/pull/2939#discussion_r460753192", "createdAt": "2020-07-27T09:11:14Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -378,6 +378,19 @@\n      */\n     boolean isTimedOut();\n \n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link RequestContext} is timing-out.\n+     */\n+    CompletableFuture<Void> whenTimingOut();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link RequestContext} is timed-out", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c738feef8741525fa1e367060fa478b9897f2af"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MzUyMw==", "bodyText": "volatile and CAS", "url": "https://github.com/line/armeria/pull/2939#discussion_r460753523", "createdAt": "2020-07-27T09:11:53Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -49,9 +52,14 @@\n     private long firstExecutionTimeNanos;\n     private long lastExecutionTimeNanos;\n \n+    private State state = State.INIT;\n+\n     @Nullable\n     private ScheduledFuture<?> timeoutFuture;\n-    private State state = State.INIT;\n+    @Nullable\n+    private CompletableFuture<Void> whenTimingOut;\n+    @Nullable\n+    private CompletableFuture<Void> whenTimedOut;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c738feef8741525fa1e367060fa478b9897f2af"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NTQzMw==", "bodyText": "CAS on whenTimingOut? e.g.\nif (!whenTimingOutUpdater.compareAndSet(this, null, Unmodifiablefuture.completedFuture(null))) {\n    if (timeoutTask.canSchedule()) {\n       whenTimingOut.complete(null);\n    }\n}", "url": "https://github.com/line/armeria/pull/2939#discussion_r460755433", "createdAt": "2020-07-27T09:15:03Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -247,9 +271,27 @@ private void ensureInitialized() {\n \n     private void invokeTimeoutTask() {\n         if (timeoutTask != null) {\n+            if (whenTimingOut != null) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.complete(null);\n+                }\n+            } else {\n+                whenTimingOut = UnmodifiableFuture.completedFuture(null);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c738feef8741525fa1e367060fa478b9897f2af"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NTU2Nw==", "bodyText": "CAS", "url": "https://github.com/line/armeria/pull/2939#discussion_r460755567", "createdAt": "2020-07-27T09:15:16Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -247,9 +271,27 @@ private void ensureInitialized() {\n \n     private void invokeTimeoutTask() {\n         if (timeoutTask != null) {\n+            if (whenTimingOut != null) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.complete(null);\n+                }\n+            } else {\n+                whenTimingOut = UnmodifiableFuture.completedFuture(null);\n+            }\n+\n             // Set TIMED_OUT flag first to prevent duplicate execution\n             state = State.TIMED_OUT;\n-            timeoutTask.run();\n+\n+            // The returned value of `canSchedule()` could be changed by the callbacks of `whenTimedOut`\n+            if (timeoutTask.canSchedule()) {\n+                timeoutTask.run();\n+            }\n+\n+            if (whenTimedOut != null) {\n+                whenTimedOut.complete(null);\n+            } else {\n+                whenTimedOut = UnmodifiableFuture.completedFuture(null);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c738feef8741525fa1e367060fa478b9897f2af"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2MDQxNQ==", "bodyText": "volatile and CAS please", "url": "https://github.com/line/armeria/pull/2939#discussion_r460760415", "createdAt": "2020-07-27T09:23:34Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -39,6 +41,10 @@\n     private EventLoop eventLoop;\n     @Nullable\n     private TimeoutController timeoutController;\n+    @Nullable\n+    private CompletableFuture<Void> timingOutFuture;\n+    @Nullable\n+    private CompletableFuture<Void> timedOutFuture;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c738feef8741525fa1e367060fa478b9897f2af"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2MTIzMQ==", "bodyText": "Consider thread safety - what happens when one thread calls setTimeoutController() and another calls when*() methods above?", "url": "https://github.com/line/armeria/pull/2939#discussion_r460761231", "createdAt": "2020-07-27T09:25:02Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -158,13 +164,54 @@ public boolean isTimedOut() {\n         return timeoutController.isTimedOut();\n     }\n \n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (timeoutController == null) {\n+            if (timingOutFuture == null) {\n+                timingOutFuture = new CompletableFuture<>();\n+            }\n+            return UnmodifiableFuture.wrap(timingOutFuture);\n+        }\n+        if (timingOutFuture == null) {\n+            return timingOutFuture = UnmodifiableFuture.wrap(timeoutController.whenTimingOut());\n+        }\n+        if (timingOutFuture instanceof UnmodifiableFuture) {\n+            return timingOutFuture;\n+        }\n+\n+        return timingOutFuture = UnmodifiableFuture.wrap(timingOutFuture);\n+    }\n+\n+    public CompletableFuture<Void> whenTimedOut() {\n+        if (timeoutController == null) {\n+            if (timedOutFuture == null) {\n+                timedOutFuture = new CompletableFuture<>();\n+            }\n+            return UnmodifiableFuture.wrap(timedOutFuture);\n+        }\n+        if (timedOutFuture == null) {\n+            return timedOutFuture = UnmodifiableFuture.wrap(timeoutController.whenTimedOut());\n+        }\n+        if (timedOutFuture instanceof UnmodifiableFuture) {\n+            return timedOutFuture;\n+        }\n+\n+        return timedOutFuture = UnmodifiableFuture.wrap(timedOutFuture);\n+    }\n+\n     public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n         requireNonNull(timeoutController, \"timeoutController\");\n         requireNonNull(eventLoop, \"eventLoop\");\n         checkState(this.timeoutController == null, \"timeoutController is set already.\");\n+\n+        if (timingOutFuture != null) {\n+            timeoutController.whenTimingOut().thenRun(() -> timingOutFuture.complete(null));\n+        }\n+        if (timedOutFuture != null) {\n+            timeoutController.whenTimedOut().thenRun(() -> timedOutFuture.complete(null));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c738feef8741525fa1e367060fa478b9897f2af"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d667779751d7698ce986985ea0b431d62c446593", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/d667779751d7698ce986985ea0b431d62c446593", "committedDate": "2020-07-27T13:27:08Z", "message": "Address comments by @trustin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1ODMzNzk2", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-455833796", "createdAt": "2020-07-27T14:26:01Z", "commit": {"oid": "d667779751d7698ce986985ea0b431d62c446593"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNDoyNjowMlrOG3k6og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNDozMjo0M1rOG3lOzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkyOTY5OA==", "bodyText": "Too many volatile reads. Please optimize.\nShould we return an UnmodifiableFuture?\n\nHow about making UnmodifiableFuture non-final so we can extend it and call doComplete*(), so we do not have to create two future instances?", "url": "https://github.com/line/armeria/pull/2939#discussion_r460929698", "createdAt": "2020-07-27T14:26:02Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -236,6 +257,24 @@ public boolean isTimedOut() {\n         return state == State.TIMED_OUT;\n     }\n \n+    @Override\n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (whenTimingOut != null) {\n+            return whenTimingOut;\n+        }\n+        whenTimingOutUpdater.compareAndSet(this, null, new CompletableFuture<>());\n+        return whenTimingOut;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenTimedOut() {\n+        if (whenTimedOut != null) {\n+            return whenTimedOut;\n+        }\n+        whenTimedOutUpdater.compareAndSet(this, null, new CompletableFuture<>());\n+        return whenTimedOut;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d667779751d7698ce986985ea0b431d62c446593"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkzNDg2MQ==", "bodyText": "could've been", "url": "https://github.com/line/armeria/pull/2939#discussion_r460934861", "createdAt": "2020-07-27T14:32:43Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -247,9 +286,23 @@ private void ensureInitialized() {\n \n     private void invokeTimeoutTask() {\n         if (timeoutTask != null) {\n+            if (!whenTimingOutUpdater.compareAndSet(this, null, UnmodifiableFuture.completedFuture(null))) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.complete(null);\n+                }\n+            }\n+\n             // Set TIMED_OUT flag first to prevent duplicate execution\n             state = State.TIMED_OUT;\n-            timeoutTask.run();\n+\n+            // The returned value of `canSchedule()` could be changed by the callbacks of `whenTimedOut`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d667779751d7698ce986985ea0b431d62c446593"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3c7573c689f59ecb1727a54c7c12bb8e54f7dc6", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/f3c7573c689f59ecb1727a54c7c12bb8e54f7dc6", "committedDate": "2020-07-28T15:50:53Z", "message": "Remove timeout controller"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb4d700489df7cae255c1987989c8bb8d9592098", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/cb4d700489df7cae255c1987989c8bb8d9592098", "committedDate": "2020-07-28T16:19:31Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "867d7cf808ecca0f67aa2b818f1f6812bb18f266", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/867d7cf808ecca0f67aa2b818f1f6812bb18f266", "committedDate": "2020-07-28T16:54:40Z", "message": "Clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "112ae9bd397dc5efa993a0a66932acc55c6c0817", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/112ae9bd397dc5efa993a0a66932acc55c6c0817", "committedDate": "2020-07-28T17:32:09Z", "message": "Fix flaky"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37fc1bca692a574abc07aa44462ce0418b423d81", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/37fc1bca692a574abc07aa44462ce0418b423d81", "committedDate": "2020-07-29T01:07:23Z", "message": "Fix flaky 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "committedDate": "2020-07-29T02:24:03Z", "message": "Remove assert"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MTU4MDIw", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-457158020", "createdAt": "2020-07-29T02:47:39Z", "commit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMjo0NzozOVrOG4ml1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzowMDo1OFrOG4mz-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTcxNg==", "bodyText": "Merge two lines?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462005716", "createdAt": "2020-07-29T02:47:39Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextBuilder.java", "diffHunk": "@@ -61,11 +61,14 @@ public void run() { /* no-op */ }\n     /**\n      * A timeout controller that has been timed-out.\n      */\n-    private static final DefaultTimeoutController noopTimedOutController =\n-            new DefaultTimeoutController(noopTimeoutTask, ImmediateEventExecutor.INSTANCE);\n+    private static final TimeoutScheduler noopTimedOutScheduler =\n+            new TimeoutScheduler(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTkyOQ==", "bodyText": "Could be done without .execute()?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462005929", "createdAt": "2020-07-29T02:48:32Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextBuilder.java", "diffHunk": "@@ -61,11 +61,14 @@ public void run() { /* no-op */ }\n     /**\n      * A timeout controller that has been timed-out.\n      */\n-    private static final DefaultTimeoutController noopTimedOutController =\n-            new DefaultTimeoutController(noopTimeoutTask, ImmediateEventExecutor.INSTANCE);\n+    private static final TimeoutScheduler noopTimedOutScheduler =\n+            new TimeoutScheduler(0);\n \n     static {\n-        noopTimedOutController.timeoutNow();\n+        ImmediateEventExecutor.INSTANCE.execute(() -> {\n+            noopTimedOutScheduler.init(ImmediateEventExecutor.INSTANCE, noopTimeoutTask, 0);\n+            noopTimedOutScheduler.timeoutNow();\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjE1MQ==", "bodyText": "noopResponseTimeoutScheduler?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462006151", "createdAt": "2020-07-29T02:49:26Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextBuilder.java", "diffHunk": "@@ -61,11 +61,14 @@ public void run() { /* no-op */ }\n     /**\n      * A timeout controller that has been timed-out.\n      */\n-    private static final DefaultTimeoutController noopTimedOutController =\n-            new DefaultTimeoutController(noopTimeoutTask, ImmediateEventExecutor.INSTANCE);\n+    private static final TimeoutScheduler noopTimedOutScheduler =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjIwMA==", "bodyText": "responseTimeoutScheduler?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462006200", "createdAt": "2020-07-29T02:49:38Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextBuilder.java", "diffHunk": "@@ -135,9 +130,27 @@ public ClientRequestContext build() {\n             endpoint = Endpoint.parse(authority());\n         }\n \n+        final TimeoutScheduler timeoutScheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjM5NA==", "bodyText": "responseTimeoutScheduler?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462006394", "createdAt": "2020-07-29T02:50:20Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -172,7 +173,7 @@ private DefaultClientRequestContext(\n             SessionProtocol sessionProtocol, RequestId id, HttpMethod method, String path,\n             @Nullable String query, @Nullable String fragment, ClientOptions options,\n             @Nullable HttpRequest req, @Nullable RpcRequest rpcReq,\n-            @Nullable ServiceRequestContext root,\n+            @Nullable ServiceRequestContext root, @Nullable TimeoutScheduler timeoutScheduler,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjQxNw==", "bodyText": "responseTimeoutScheduler?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462006417", "createdAt": "2020-07-29T02:50:27Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -100,6 +98,7 @@\n     @Nullable\n     private final ServiceRequestContext root;\n \n+    private final ClientOptions options;\n     private final RequestLogBuilder log;\n     private final TimeoutScheduler timeoutScheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNzAwOQ==", "bodyText": "How about removing this field and just checking if ctx is DefaultClientRequestContext when timeoutScheduler is accessed? (Because it's accessed just two times)", "url": "https://github.com/line/armeria/pull/2939#discussion_r462007009", "createdAt": "2020-07-29T02:52:45Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -150,6 +150,9 @@ final boolean needsToDisconnectWhenFinished() {\n         private final DecodedHttpResponse delegate;\n         @Nullable\n         private final ClientRequestContext ctx;\n+        @Nullable\n+        private final TimeoutScheduler timeoutScheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNzE1OQ==", "bodyText": "requestTimeoutScheduler?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462007159", "createdAt": "2020-07-29T02:53:24Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -136,14 +136,15 @@ public DefaultServiceRequestContext(\n             long requestStartTimeNanos, long requestStartTimeMicros) {\n \n         this(cfg, ch, meterRegistry, sessionProtocol, id, routingContext, routingResult, req,\n-             sslSession, proxiedAddresses, clientAddress, requestStartTimeNanos, requestStartTimeMicros,\n-             HttpHeaders.of(), HttpHeaders.of());\n+             sslSession, proxiedAddresses, clientAddress, /* timeoutScheduler */ null,\n+             requestStartTimeNanos, requestStartTimeMicros, HttpHeaders.of(), HttpHeaders.of());\n     }\n \n-    private DefaultServiceRequestContext(\n+    DefaultServiceRequestContext(\n             ServiceConfig cfg, Channel ch, MeterRegistry meterRegistry, SessionProtocol sessionProtocol,\n             RequestId id, RoutingContext routingContext, RoutingResult routingResult, HttpRequest req,\n             @Nullable SSLSession sslSession, ProxiedAddresses proxiedAddresses, InetAddress clientAddress,\n+            @Nullable TimeoutScheduler timeoutScheduler,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODI4NA==", "bodyText": "noopRequestTimeoutScheduler", "url": "https://github.com/line/armeria/pull/2939#discussion_r462008284", "createdAt": "2020-07-29T02:57:22Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContextBuilder.java", "diffHunk": "@@ -78,11 +81,13 @@ public void run() { /* no-op */ }\n     /**\n      * A timeout controller that has been timed-out.\n      */\n-    private static final DefaultTimeoutController noopTimedOutController =\n-            new DefaultTimeoutController(noopTimeoutTask, ImmediateEventExecutor.INSTANCE);\n+    private static final TimeoutScheduler noopTimedOutScheduler = new TimeoutScheduler(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODMzOA==", "bodyText": "requestTimeoutScheduler", "url": "https://github.com/line/armeria/pull/2939#discussion_r462008338", "createdAt": "2020-07-29T02:57:34Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContextBuilder.java", "diffHunk": "@@ -228,21 +233,31 @@ public ServiceRequestContext build() {\n         final InetAddress clientAddress = server.config().clientAddressMapper().apply(proxiedAddresses)\n                                                 .getAddress();\n \n-        final DefaultTimeoutController timeoutController;\n+        final TimeoutScheduler timeoutScheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODY1NA==", "bodyText": "Should we rename this class or merge into TimeoutSchedulerTest?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462008654", "createdAt": "2020-07-29T02:58:44Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/internal/common/DefaultTimeoutControllerTest.java", "diffHunk": "@@ -18,58 +18,51 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n \n import java.time.Duration;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n \n-import javax.annotation.Nullable;\n-\n-import org.junit.jupiter.api.BeforeEach;\n+import org.assertj.core.data.Offset;\n import org.junit.jupiter.api.Test;\n-\n-import com.google.common.util.concurrent.Uninterruptibles;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.linecorp.armeria.common.CommonPools;\n-import com.linecorp.armeria.internal.common.DefaultTimeoutController.State;\n-import com.linecorp.armeria.internal.common.DefaultTimeoutController.TimeoutTask;\n+import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.internal.common.TimeoutScheduler.State;\n+import com.linecorp.armeria.internal.common.TimeoutScheduler.TimeoutTask;\n+\n+import io.netty.util.concurrent.EventExecutor;\n \n class DefaultTimeoutControllerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTEyOQ==", "bodyText": "Could return null by default and delete the old implementations?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462009129", "createdAt": "2020-07-29T03:00:18Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContext.java", "diffHunk": "@@ -426,7 +427,10 @@ default void setResponseTimeout(Duration responseTimeout) {\n      * Returns {@link Response} timeout handler which is executed when\n      * the {@link Response} is not completely received within the allowed {@link #responseTimeoutMillis()}\n      * or the default {@link ClientOptions#RESPONSE_TIMEOUT_MILLIS}.\n+     *\n+     * @deprecated Use {@link #whenResponseTimingOut()} or {@link #whenResponseTimedOut()}\n      */\n+    @Deprecated\n     @Nullable\n     Runnable responseTimeoutHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTMzOQ==", "bodyText": "Could delegate to whenResponseTimingOut().thenRun() and delete the old implementations?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462009339", "createdAt": "2020-07-29T03:00:58Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContext.java", "diffHunk": "@@ -443,9 +447,26 @@ default void setResponseTimeout(Duration responseTimeout) {\n      * });\n      * ...\n      * }</pre>\n+     *\n+     * @deprecated Use {@link #whenResponseTimingOut()} or {@link #whenResponseTimedOut()}\n      */\n+    @Deprecated\n     void setResponseTimeoutHandler(Runnable responseTimeoutHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MTYyOTE3", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-457162917", "createdAt": "2020-07-29T03:04:30Z", "commit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzowNDozMVrOG4m3ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzowNDozMVrOG4m3ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMDIxOA==", "bodyText": "How about removing final so that a subclass can call this method?\nJavadoc", "url": "https://github.com/line/armeria/pull/2939#discussion_r462010218", "createdAt": "2020-07-29T03:04:31Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/UnmodifiableFuture.java", "diffHunk": "@@ -113,7 +113,7 @@ public boolean complete(@Nullable T value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    private void doComplete(@Nullable T value) {\n+    protected final void doComplete(@Nullable T value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MTYyOTQz", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-457162943", "createdAt": "2020-07-29T03:04:38Z", "commit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzowNDozOFrOG4m3gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzowNDozOFrOG4m3gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMDI0Mg==", "bodyText": "How about removing final so that a subclass can call this method?\nJavadoc", "url": "https://github.com/line/armeria/pull/2939#discussion_r462010242", "createdAt": "2020-07-29T03:04:38Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/UnmodifiableFuture.java", "diffHunk": "@@ -125,7 +125,7 @@ public boolean completeExceptionally(Throwable ex) {\n         throw new UnsupportedOperationException();\n     }\n \n-    private void doCompleteExceptionally(Throwable cause) {\n+    protected final void doCompleteExceptionally(Throwable cause) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MTc3MDQ2", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-457177046", "createdAt": "2020-07-29T03:55:43Z", "commit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzo1NTo0NFrOG4npaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzo1NzowNVrOG4nqvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyMzAxNw==", "bodyText": "Should return here?\nAlso we can remove the second line in Javadoc?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462023017", "createdAt": "2020-07-29T03:55:44Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -18,73 +18,194 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n-import static java.util.Objects.requireNonNull;\n \n-import java.util.function.Consumer;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n import javax.annotation.Nullable;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.math.LongMath;\n \n import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n \n import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n \n public final class TimeoutScheduler {\n \n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimingOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimingOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimedOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimedOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, Runnable>\n+            pendingTimeoutTaskUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, Runnable.class, \"pendingTimeoutTask\");\n+\n+    private static final AtomicLongFieldUpdater<TimeoutScheduler> pendingTimeoutNanosUpdater =\n+            AtomicLongFieldUpdater.newUpdater(TimeoutScheduler.class, \"pendingTimeoutNanos\");\n+\n+    private static final TimeoutFuture COMPLETED_FUTURE;\n+\n+    static {\n+        COMPLETED_FUTURE = new TimeoutFuture();\n+        COMPLETED_FUTURE.doComplete();\n+    }\n+\n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        TIMED_OUT\n+    }\n+\n     private long timeoutNanos;\n+    private long firstExecutionTimeNanos;\n+\n+    private State state = State.INIT;\n+\n+    @Nullable\n+    private TimeoutTask timeoutTask;\n+    @Nullable\n+    private ScheduledFuture<?> timeoutFuture;\n+    @Nullable\n+    private EventExecutor eventLoop;\n+\n+    // Updated via whenTimingOutUpdater\n     @Nullable\n-    private Consumer<TimeoutController> pendingTimeoutTask;\n+    private volatile TimeoutFuture whenTimingOut;\n+    // Updated via whenTimedOutUpdater\n     @Nullable\n-    private EventLoop eventLoop;\n+    private volatile TimeoutFuture whenTimedOut;\n+    // Updated via pendingTimeoutTaskUpdater\n     @Nullable\n-    private TimeoutController timeoutController;\n+    private volatile Runnable pendingTimeoutTask;\n+    // Updated via pendingTimeoutNanosUpdater\n+    @SuppressWarnings(\"FieldMayBeFinal\")\n+    private volatile long pendingTimeoutNanos;\n+\n+    private volatile boolean initialized;\n \n     public TimeoutScheduler(long timeoutNanos) {\n         this.timeoutNanos = timeoutNanos;\n+        pendingTimeoutNanos = timeoutNanos;\n+    }\n+\n+    /**\n+     * Initializes this {@link TimeoutScheduler}.\n+     * Note that this method should be called in the specified {@link EventLoop}\n+     * to initialize this scheduler synchronously\n+     */\n+    public void init(EventExecutor eventLoop, TimeoutTask timeoutTask, long initialTimeoutNanos) {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> init(eventLoop, timeoutTask, initialTimeoutNanos));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyMzM1OQ==", "bodyText": "when {@link ClientRequestContext} has been -> after {@link ClientRequestContext} is\nto clarify the difference with whenResponseTimingOut?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462023359", "createdAt": "2020-07-29T03:57:05Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContext.java", "diffHunk": "@@ -443,9 +447,26 @@ default void setResponseTimeout(Duration responseTimeout) {\n      * });\n      * ...\n      * }</pre>\n+     *\n+     * @deprecated Use {@link #whenResponseTimingOut()} or {@link #whenResponseTimedOut()}\n      */\n+    @Deprecated\n     void setResponseTimeoutHandler(Runnable responseTimeoutHandler);\n \n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link ClientRequestContext} is about to\n+     * get timed out.\n+     */\n+    CompletableFuture<Void> whenResponseTimingOut();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link ClientRequestContext} has been", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed493ddd607793de60ccb6bcda70386b85c61079", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/ed493ddd607793de60ccb6bcda70386b85c61079", "committedDate": "2020-07-29T03:59:24Z", "message": "Address comments by @trustin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "203d176794a8dfde91dd3529a923bb9daebad506", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/203d176794a8dfde91dd3529a923bb9daebad506", "committedDate": "2020-07-29T04:07:44Z", "message": "Address comments by @minwoox"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/1be0e6a0e1d4c167d348ba5bccf40caeac45bcae", "committedDate": "2020-07-29T04:26:37Z", "message": "Clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MTgwMTEz", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-457180113", "createdAt": "2020-07-29T04:06:51Z", "commit": {"oid": "ed493ddd607793de60ccb6bcda70386b85c61079"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNDowNjo1MVrOG4n0WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNzo1MTowN1rOG4swzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyNTgxNg==", "bodyText": "final TimeoutFuture whenTimingOut = this.whenTimingOut;\nif (whenTimingOut != null) {\n    return whenTimingOut;\n}\nin order not to access the volatile field twice?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462025816", "createdAt": "2020-07-29T04:06:51Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -97,93 +218,250 @@ private void extendTimeoutNanos(long adjustmentNanos) {\n             return;\n         }\n \n-        final long oldTimeoutNanos = timeoutNanos;\n-        timeoutNanos = LongMath.saturatedAdd(oldTimeoutNanos, adjustmentNanos);\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.extendTimeoutNanos(adjustmentNanos);\n+                unsafeExtendTimeoutNanos(adjustmentNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.extendTimeoutNanos(adjustmentNanos));\n+                eventLoop.execute(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n             }\n         } else {\n-            addPendingTimeoutTask(controller -> controller.extendTimeoutNanos(adjustmentNanos));\n+            addPendingTimeoutNanos(adjustmentNanos);\n+            addPendingTimeoutTask(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n+        }\n+    }\n+\n+    private boolean unsafeExtendTimeoutNanos(long adjustmentNanos) {\n+        ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        if (adjustmentNanos == 0) {\n+            return true;\n+        }\n+\n+        final long timeoutNanos = this.timeoutNanos;\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        this.timeoutNanos = LongMath.saturatedAdd(timeoutNanos, adjustmentNanos);\n+\n+        if (timeoutNanos <= 0) {\n+            invokeTimeoutTask();\n+            return true;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask,\n+                                           LongMath.saturatedAdd(timeoutNanos, adjustmentNanos),\n+                                           TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n-    private void setTimeoutAfterNanos(long timeoutNanos) {\n+    private void setTimeoutNanosFromNow(long timeoutNanos) {\n         checkArgument(timeoutNanos > 0, \"timeoutNanos: %s (expected: > 0)\", timeoutNanos);\n \n-        long passedTimeNanos = 0;\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n-            final Long startTimeNanos = timeoutController.startTimeNanos();\n-            if (startTimeNanos != null) {\n-                passedTimeNanos = System.nanoTime() - startTimeNanos;\n-            }\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.resetTimeoutNanos(timeoutNanos);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.resetTimeoutNanos(timeoutNanos));\n+                eventLoop.execute(() -> unsafeSetTimeoutNanosFromNow(timeoutNanos));\n             }\n         } else {\n             final long startTimeNanos = System.nanoTime();\n-            addPendingTimeoutTask(controller -> {\n+            setPendingTimeoutNanos(timeoutNanos);\n+            addPendingTimeoutTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n-                controller.resetTimeoutNanos(timeoutNanos0);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos0);\n             });\n         }\n+    }\n \n-        this.timeoutNanos = LongMath.saturatedAdd(passedTimeNanos, timeoutNanos);\n+    private boolean unsafeSetTimeoutNanosFromNow(long newTimeoutNanos) {\n+        ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n+\n+        if (newTimeoutNanos <= 0) {\n+            return true;\n+        }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n     public void timeoutNow() {\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.timeoutNow();\n+                unsafeTimeoutNow();\n             } else {\n-                eventLoop.execute(timeoutController::timeoutNow);\n+                eventLoop.execute(this::unsafeTimeoutNow);\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::timeoutNow);\n+            addPendingTimeoutTask(this::unsafeTimeoutNow);\n         }\n     }\n \n-    public boolean isTimedOut() {\n-        if (timeoutController == null) {\n-            return false;\n+    private void unsafeTimeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+\n+        if (!timeoutTask.canSchedule()) {\n+            return;\n+        }\n+\n+        switch (state) {\n+            case TIMED_OUT:\n+                return;\n+            case INIT:\n+            case INACTIVE:\n+                invokeTimeoutTask();\n+                return;\n+            case SCHEDULED:\n+                if (unsafeClearTimeout(false)) {\n+                    invokeTimeoutTask();\n+                }\n+                return;\n+            default:\n+                throw new Error(); // Should not reach here.\n         }\n-        return timeoutController.isTimedOut();\n     }\n \n-    public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n-        requireNonNull(timeoutController, \"timeoutController\");\n-        requireNonNull(eventLoop, \"eventLoop\");\n-        checkState(this.timeoutController == null, \"timeoutController is set already.\");\n-        this.timeoutController = timeoutController;\n-        this.eventLoop = eventLoop;\n+    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n+        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n+            for (;;) {\n+                final Runnable pendingTask = this.pendingTimeoutTask;\n+                final Runnable newPendingTask = () -> {\n+                    pendingTask.run();\n+                    pendingTimeoutTask.run();\n+                };\n+                if (pendingTimeoutTaskUpdater.compareAndSet(this, pendingTask, newPendingTask)) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n \n-        final Consumer<TimeoutController> pendingTimeoutTask = this.pendingTimeoutTask;\n-        if (pendingTimeoutTask != null) {\n-            if (eventLoop.inEventLoop()) {\n-                pendingTimeoutTask.accept(timeoutController);\n-            } else {\n-                eventLoop.execute(() -> pendingTimeoutTask.accept(timeoutController));\n+    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         pendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            final long newPendingTimeoutNanos =\n+                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         newPendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void invokeTimeoutTask() {\n+        if (timeoutTask != null) {\n+            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.doComplete();\n+                }\n+            }\n+\n+            // Set TIMED_OUT flag first to prevent duplicate execution\n+            state = State.TIMED_OUT;\n+\n+            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n+            if (timeoutTask.canSchedule()) {\n+                timeoutTask.run();\n+            }\n+\n+            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                whenTimedOut.doComplete();\n             }\n         }\n     }\n \n+    public boolean isTimedOut() {\n+        return state == State.TIMED_OUT;\n+    }\n+\n     public long timeoutNanos() {\n-        return timeoutNanos;\n+        return initialized ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    private void addPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {\n-        if (this.pendingTimeoutTask == null) {\n-            this.pendingTimeoutTask = pendingTimeoutTask;\n-        } else {\n-            this.pendingTimeoutTask = this.pendingTimeoutTask.andThen(pendingTimeoutTask);\n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (whenTimingOut != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed493ddd607793de60ccb6bcda70386b85c61079"}, "originalPosition": 447}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyNTg1MQ==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2939#discussion_r462025851", "createdAt": "2020-07-29T04:07:00Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -97,93 +218,250 @@ private void extendTimeoutNanos(long adjustmentNanos) {\n             return;\n         }\n \n-        final long oldTimeoutNanos = timeoutNanos;\n-        timeoutNanos = LongMath.saturatedAdd(oldTimeoutNanos, adjustmentNanos);\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.extendTimeoutNanos(adjustmentNanos);\n+                unsafeExtendTimeoutNanos(adjustmentNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.extendTimeoutNanos(adjustmentNanos));\n+                eventLoop.execute(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n             }\n         } else {\n-            addPendingTimeoutTask(controller -> controller.extendTimeoutNanos(adjustmentNanos));\n+            addPendingTimeoutNanos(adjustmentNanos);\n+            addPendingTimeoutTask(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n+        }\n+    }\n+\n+    private boolean unsafeExtendTimeoutNanos(long adjustmentNanos) {\n+        ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        if (adjustmentNanos == 0) {\n+            return true;\n+        }\n+\n+        final long timeoutNanos = this.timeoutNanos;\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        this.timeoutNanos = LongMath.saturatedAdd(timeoutNanos, adjustmentNanos);\n+\n+        if (timeoutNanos <= 0) {\n+            invokeTimeoutTask();\n+            return true;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask,\n+                                           LongMath.saturatedAdd(timeoutNanos, adjustmentNanos),\n+                                           TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n-    private void setTimeoutAfterNanos(long timeoutNanos) {\n+    private void setTimeoutNanosFromNow(long timeoutNanos) {\n         checkArgument(timeoutNanos > 0, \"timeoutNanos: %s (expected: > 0)\", timeoutNanos);\n \n-        long passedTimeNanos = 0;\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n-            final Long startTimeNanos = timeoutController.startTimeNanos();\n-            if (startTimeNanos != null) {\n-                passedTimeNanos = System.nanoTime() - startTimeNanos;\n-            }\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.resetTimeoutNanos(timeoutNanos);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.resetTimeoutNanos(timeoutNanos));\n+                eventLoop.execute(() -> unsafeSetTimeoutNanosFromNow(timeoutNanos));\n             }\n         } else {\n             final long startTimeNanos = System.nanoTime();\n-            addPendingTimeoutTask(controller -> {\n+            setPendingTimeoutNanos(timeoutNanos);\n+            addPendingTimeoutTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n-                controller.resetTimeoutNanos(timeoutNanos0);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos0);\n             });\n         }\n+    }\n \n-        this.timeoutNanos = LongMath.saturatedAdd(passedTimeNanos, timeoutNanos);\n+    private boolean unsafeSetTimeoutNanosFromNow(long newTimeoutNanos) {\n+        ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n+\n+        if (newTimeoutNanos <= 0) {\n+            return true;\n+        }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n     public void timeoutNow() {\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.timeoutNow();\n+                unsafeTimeoutNow();\n             } else {\n-                eventLoop.execute(timeoutController::timeoutNow);\n+                eventLoop.execute(this::unsafeTimeoutNow);\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::timeoutNow);\n+            addPendingTimeoutTask(this::unsafeTimeoutNow);\n         }\n     }\n \n-    public boolean isTimedOut() {\n-        if (timeoutController == null) {\n-            return false;\n+    private void unsafeTimeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+\n+        if (!timeoutTask.canSchedule()) {\n+            return;\n+        }\n+\n+        switch (state) {\n+            case TIMED_OUT:\n+                return;\n+            case INIT:\n+            case INACTIVE:\n+                invokeTimeoutTask();\n+                return;\n+            case SCHEDULED:\n+                if (unsafeClearTimeout(false)) {\n+                    invokeTimeoutTask();\n+                }\n+                return;\n+            default:\n+                throw new Error(); // Should not reach here.\n         }\n-        return timeoutController.isTimedOut();\n     }\n \n-    public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n-        requireNonNull(timeoutController, \"timeoutController\");\n-        requireNonNull(eventLoop, \"eventLoop\");\n-        checkState(this.timeoutController == null, \"timeoutController is set already.\");\n-        this.timeoutController = timeoutController;\n-        this.eventLoop = eventLoop;\n+    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n+        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n+            for (;;) {\n+                final Runnable pendingTask = this.pendingTimeoutTask;\n+                final Runnable newPendingTask = () -> {\n+                    pendingTask.run();\n+                    pendingTimeoutTask.run();\n+                };\n+                if (pendingTimeoutTaskUpdater.compareAndSet(this, pendingTask, newPendingTask)) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n \n-        final Consumer<TimeoutController> pendingTimeoutTask = this.pendingTimeoutTask;\n-        if (pendingTimeoutTask != null) {\n-            if (eventLoop.inEventLoop()) {\n-                pendingTimeoutTask.accept(timeoutController);\n-            } else {\n-                eventLoop.execute(() -> pendingTimeoutTask.accept(timeoutController));\n+    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         pendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            final long newPendingTimeoutNanos =\n+                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         newPendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void invokeTimeoutTask() {\n+        if (timeoutTask != null) {\n+            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.doComplete();\n+                }\n+            }\n+\n+            // Set TIMED_OUT flag first to prevent duplicate execution\n+            state = State.TIMED_OUT;\n+\n+            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n+            if (timeoutTask.canSchedule()) {\n+                timeoutTask.run();\n+            }\n+\n+            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                whenTimedOut.doComplete();\n             }\n         }\n     }\n \n+    public boolean isTimedOut() {\n+        return state == State.TIMED_OUT;\n+    }\n+\n     public long timeoutNanos() {\n-        return timeoutNanos;\n+        return initialized ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    private void addPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {\n-        if (this.pendingTimeoutTask == null) {\n-            this.pendingTimeoutTask = pendingTimeoutTask;\n-        } else {\n-            this.pendingTimeoutTask = this.pendingTimeoutTask.andThen(pendingTimeoutTask);\n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (whenTimingOut != null) {\n+            return whenTimingOut;\n+        }\n+        whenTimingOutUpdater.compareAndSet(this, null, new TimeoutFuture());\n+        return whenTimingOut;\n+    }\n+\n+    public CompletableFuture<Void> whenTimedOut() {\n+        if (whenTimedOut != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed493ddd607793de60ccb6bcda70386b85c61079"}, "originalPosition": 455}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyNTk4Mw==", "bodyText": "nit: @Nullable?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462025983", "createdAt": "2020-07-29T04:07:40Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -97,93 +218,250 @@ private void extendTimeoutNanos(long adjustmentNanos) {\n             return;\n         }\n \n-        final long oldTimeoutNanos = timeoutNanos;\n-        timeoutNanos = LongMath.saturatedAdd(oldTimeoutNanos, adjustmentNanos);\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.extendTimeoutNanos(adjustmentNanos);\n+                unsafeExtendTimeoutNanos(adjustmentNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.extendTimeoutNanos(adjustmentNanos));\n+                eventLoop.execute(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n             }\n         } else {\n-            addPendingTimeoutTask(controller -> controller.extendTimeoutNanos(adjustmentNanos));\n+            addPendingTimeoutNanos(adjustmentNanos);\n+            addPendingTimeoutTask(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n+        }\n+    }\n+\n+    private boolean unsafeExtendTimeoutNanos(long adjustmentNanos) {\n+        ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        if (adjustmentNanos == 0) {\n+            return true;\n+        }\n+\n+        final long timeoutNanos = this.timeoutNanos;\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        this.timeoutNanos = LongMath.saturatedAdd(timeoutNanos, adjustmentNanos);\n+\n+        if (timeoutNanos <= 0) {\n+            invokeTimeoutTask();\n+            return true;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask,\n+                                           LongMath.saturatedAdd(timeoutNanos, adjustmentNanos),\n+                                           TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n-    private void setTimeoutAfterNanos(long timeoutNanos) {\n+    private void setTimeoutNanosFromNow(long timeoutNanos) {\n         checkArgument(timeoutNanos > 0, \"timeoutNanos: %s (expected: > 0)\", timeoutNanos);\n \n-        long passedTimeNanos = 0;\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n-            final Long startTimeNanos = timeoutController.startTimeNanos();\n-            if (startTimeNanos != null) {\n-                passedTimeNanos = System.nanoTime() - startTimeNanos;\n-            }\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.resetTimeoutNanos(timeoutNanos);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.resetTimeoutNanos(timeoutNanos));\n+                eventLoop.execute(() -> unsafeSetTimeoutNanosFromNow(timeoutNanos));\n             }\n         } else {\n             final long startTimeNanos = System.nanoTime();\n-            addPendingTimeoutTask(controller -> {\n+            setPendingTimeoutNanos(timeoutNanos);\n+            addPendingTimeoutTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n-                controller.resetTimeoutNanos(timeoutNanos0);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos0);\n             });\n         }\n+    }\n \n-        this.timeoutNanos = LongMath.saturatedAdd(passedTimeNanos, timeoutNanos);\n+    private boolean unsafeSetTimeoutNanosFromNow(long newTimeoutNanos) {\n+        ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n+\n+        if (newTimeoutNanos <= 0) {\n+            return true;\n+        }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n     public void timeoutNow() {\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.timeoutNow();\n+                unsafeTimeoutNow();\n             } else {\n-                eventLoop.execute(timeoutController::timeoutNow);\n+                eventLoop.execute(this::unsafeTimeoutNow);\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::timeoutNow);\n+            addPendingTimeoutTask(this::unsafeTimeoutNow);\n         }\n     }\n \n-    public boolean isTimedOut() {\n-        if (timeoutController == null) {\n-            return false;\n+    private void unsafeTimeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+\n+        if (!timeoutTask.canSchedule()) {\n+            return;\n+        }\n+\n+        switch (state) {\n+            case TIMED_OUT:\n+                return;\n+            case INIT:\n+            case INACTIVE:\n+                invokeTimeoutTask();\n+                return;\n+            case SCHEDULED:\n+                if (unsafeClearTimeout(false)) {\n+                    invokeTimeoutTask();\n+                }\n+                return;\n+            default:\n+                throw new Error(); // Should not reach here.\n         }\n-        return timeoutController.isTimedOut();\n     }\n \n-    public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n-        requireNonNull(timeoutController, \"timeoutController\");\n-        requireNonNull(eventLoop, \"eventLoop\");\n-        checkState(this.timeoutController == null, \"timeoutController is set already.\");\n-        this.timeoutController = timeoutController;\n-        this.eventLoop = eventLoop;\n+    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n+        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n+            for (;;) {\n+                final Runnable pendingTask = this.pendingTimeoutTask;\n+                final Runnable newPendingTask = () -> {\n+                    pendingTask.run();\n+                    pendingTimeoutTask.run();\n+                };\n+                if (pendingTimeoutTaskUpdater.compareAndSet(this, pendingTask, newPendingTask)) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n \n-        final Consumer<TimeoutController> pendingTimeoutTask = this.pendingTimeoutTask;\n-        if (pendingTimeoutTask != null) {\n-            if (eventLoop.inEventLoop()) {\n-                pendingTimeoutTask.accept(timeoutController);\n-            } else {\n-                eventLoop.execute(() -> pendingTimeoutTask.accept(timeoutController));\n+    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         pendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            final long newPendingTimeoutNanos =\n+                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         newPendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void invokeTimeoutTask() {\n+        if (timeoutTask != null) {\n+            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.doComplete();\n+                }\n+            }\n+\n+            // Set TIMED_OUT flag first to prevent duplicate execution\n+            state = State.TIMED_OUT;\n+\n+            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n+            if (timeoutTask.canSchedule()) {\n+                timeoutTask.run();\n+            }\n+\n+            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                whenTimedOut.doComplete();\n             }\n         }\n     }\n \n+    public boolean isTimedOut() {\n+        return state == State.TIMED_OUT;\n+    }\n+\n     public long timeoutNanos() {\n-        return timeoutNanos;\n+        return initialized ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    private void addPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {\n-        if (this.pendingTimeoutTask == null) {\n-            this.pendingTimeoutTask = pendingTimeoutTask;\n-        } else {\n-            this.pendingTimeoutTask = this.pendingTimeoutTask.andThen(pendingTimeoutTask);\n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (whenTimingOut != null) {\n+            return whenTimingOut;\n+        }\n+        whenTimingOutUpdater.compareAndSet(this, null, new TimeoutFuture());\n+        return whenTimingOut;\n+    }\n+\n+    public CompletableFuture<Void> whenTimedOut() {\n+        if (whenTimedOut != null) {\n+            return whenTimedOut;\n+        }\n+        whenTimedOutUpdater.compareAndSet(this, null, new TimeoutFuture());\n+        return whenTimedOut;\n+    }\n+\n+    private void ensureInitialized() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+        if (state == State.INIT) {\n+            state = State.INACTIVE;\n+            firstExecutionTimeNanos = System.nanoTime();\n+        }\n+    }\n+\n+    public Long startTimeNanos() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed493ddd607793de60ccb6bcda70386b85c61079"}, "originalPosition": 471}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA5OTIyNA==", "bodyText": "This is init method. I think we don't have to call this.", "url": "https://github.com/line/armeria/pull/2939#discussion_r462099224", "createdAt": "2020-07-29T07:37:09Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -18,73 +18,192 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n-import static java.util.Objects.requireNonNull;\n \n-import java.util.function.Consumer;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n import javax.annotation.Nullable;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.math.LongMath;\n \n import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n \n-import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n \n public final class TimeoutScheduler {\n \n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimingOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimingOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimedOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimedOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, Runnable>\n+            pendingTimeoutTaskUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, Runnable.class, \"pendingTimeoutTask\");\n+\n+    private static final AtomicLongFieldUpdater<TimeoutScheduler> pendingTimeoutNanosUpdater =\n+            AtomicLongFieldUpdater.newUpdater(TimeoutScheduler.class, \"pendingTimeoutNanos\");\n+\n+    private static final TimeoutFuture COMPLETED_FUTURE;\n+\n+    static {\n+        COMPLETED_FUTURE = new TimeoutFuture();\n+        COMPLETED_FUTURE.doComplete();\n+    }\n+\n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        TIMED_OUT\n+    }\n+\n     private long timeoutNanos;\n+    private long firstExecutionTimeNanos;\n+\n+    private State state = State.INIT;\n+\n+    @Nullable\n+    private TimeoutTask timeoutTask;\n+    @Nullable\n+    private ScheduledFuture<?> timeoutFuture;\n+    @Nullable\n+    private EventExecutor eventLoop;\n+\n+    // Updated via whenTimingOutUpdater\n     @Nullable\n-    private Consumer<TimeoutController> pendingTimeoutTask;\n+    private volatile TimeoutFuture whenTimingOut;\n+    // Updated via whenTimedOutUpdater\n     @Nullable\n-    private EventLoop eventLoop;\n+    private volatile TimeoutFuture whenTimedOut;\n+    // Updated via pendingTimeoutTaskUpdater\n     @Nullable\n-    private TimeoutController timeoutController;\n+    private volatile Runnable pendingTimeoutTask;\n+    // Updated via pendingTimeoutNanosUpdater\n+    @SuppressWarnings(\"FieldMayBeFinal\")\n+    private volatile long pendingTimeoutNanos;\n+\n+    private volatile boolean initialized;\n \n     public TimeoutScheduler(long timeoutNanos) {\n         this.timeoutNanos = timeoutNanos;\n+        pendingTimeoutNanos = timeoutNanos;\n+    }\n+\n+    /**\n+     * Initializes this {@link TimeoutScheduler}.\n+     */\n+    public void init(EventExecutor eventLoop, TimeoutTask timeoutTask, long initialTimeoutNanos) {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> init(eventLoop, timeoutTask, initialTimeoutNanos));\n+            return;\n+        }\n+\n+        this.eventLoop = eventLoop;\n+        this.timeoutTask = timeoutTask;\n+        if (initialTimeoutNanos > 0) {\n+            timeoutNanos = initialTimeoutNanos;\n+        }\n+\n+        ensureInitialized();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwMTc3Mg==", "bodyText": "nit: clearTimeout0? we normally use unsafe for other purposes.", "url": "https://github.com/line/armeria/pull/2939#discussion_r462101772", "createdAt": "2020-07-29T07:41:47Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -18,73 +18,192 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n-import static java.util.Objects.requireNonNull;\n \n-import java.util.function.Consumer;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n import javax.annotation.Nullable;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.math.LongMath;\n \n import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n \n-import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n \n public final class TimeoutScheduler {\n \n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimingOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimingOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimedOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimedOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, Runnable>\n+            pendingTimeoutTaskUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, Runnable.class, \"pendingTimeoutTask\");\n+\n+    private static final AtomicLongFieldUpdater<TimeoutScheduler> pendingTimeoutNanosUpdater =\n+            AtomicLongFieldUpdater.newUpdater(TimeoutScheduler.class, \"pendingTimeoutNanos\");\n+\n+    private static final TimeoutFuture COMPLETED_FUTURE;\n+\n+    static {\n+        COMPLETED_FUTURE = new TimeoutFuture();\n+        COMPLETED_FUTURE.doComplete();\n+    }\n+\n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        TIMED_OUT\n+    }\n+\n     private long timeoutNanos;\n+    private long firstExecutionTimeNanos;\n+\n+    private State state = State.INIT;\n+\n+    @Nullable\n+    private TimeoutTask timeoutTask;\n+    @Nullable\n+    private ScheduledFuture<?> timeoutFuture;\n+    @Nullable\n+    private EventExecutor eventLoop;\n+\n+    // Updated via whenTimingOutUpdater\n     @Nullable\n-    private Consumer<TimeoutController> pendingTimeoutTask;\n+    private volatile TimeoutFuture whenTimingOut;\n+    // Updated via whenTimedOutUpdater\n     @Nullable\n-    private EventLoop eventLoop;\n+    private volatile TimeoutFuture whenTimedOut;\n+    // Updated via pendingTimeoutTaskUpdater\n     @Nullable\n-    private TimeoutController timeoutController;\n+    private volatile Runnable pendingTimeoutTask;\n+    // Updated via pendingTimeoutNanosUpdater\n+    @SuppressWarnings(\"FieldMayBeFinal\")\n+    private volatile long pendingTimeoutNanos;\n+\n+    private volatile boolean initialized;\n \n     public TimeoutScheduler(long timeoutNanos) {\n         this.timeoutNanos = timeoutNanos;\n+        pendingTimeoutNanos = timeoutNanos;\n+    }\n+\n+    /**\n+     * Initializes this {@link TimeoutScheduler}.\n+     */\n+    public void init(EventExecutor eventLoop, TimeoutTask timeoutTask, long initialTimeoutNanos) {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> init(eventLoop, timeoutTask, initialTimeoutNanos));\n+            return;\n+        }\n+\n+        this.eventLoop = eventLoop;\n+        this.timeoutTask = timeoutTask;\n+        if (initialTimeoutNanos > 0) {\n+            timeoutNanos = initialTimeoutNanos;\n+        }\n+\n+        ensureInitialized();\n+        if (timeoutNanos != 0) {\n+            state = State.SCHEDULED;\n+            timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutNanos, TimeUnit.NANOSECONDS);\n+        }\n+\n+        Runnable pendingTimeoutTask;\n+        for (;;) {\n+            pendingTimeoutTask = this.pendingTimeoutTask;\n+            if (pendingTimeoutTaskUpdater.compareAndSet(this, pendingTimeoutTask, null)) {\n+                break;\n+            }\n+        }\n+\n+        if (pendingTimeoutTask != null) {\n+            pendingTimeoutTask.run();\n+        }\n+        initialized = true;\n+        final Runnable newlyAdded = this.pendingTimeoutTask;\n+        if (newlyAdded != null) {\n+            newlyAdded.run();\n+        }\n     }\n \n     public void clearTimeout() {\n+       clearTimeout(true);\n+    }\n+\n+    public void clearTimeout(boolean resetTimeout) {\n         if (timeoutNanos == 0) {\n             return;\n         }\n \n-        final TimeoutController timeoutController = this.timeoutController;\n-        timeoutNanos = 0;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.cancelTimeout();\n+                unsafeClearTimeout(resetTimeout);\n             } else {\n-                eventLoop.execute(timeoutController::cancelTimeout);\n+                eventLoop.execute(() -> unsafeClearTimeout(resetTimeout));\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::cancelTimeout);\n+            setPendingTimeoutNanos(0);\n+            addPendingTimeoutTask(() -> unsafeClearTimeout(resetTimeout));\n+        }\n+    }\n+\n+    private boolean unsafeClearTimeout(boolean resetTimeout) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNjgzMQ==", "bodyText": "Question: Do we need to check if initialized is set in this loop and act differently?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462106831", "createdAt": "2020-07-29T07:51:07Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -97,93 +216,248 @@ private void extendTimeoutNanos(long adjustmentNanos) {\n             return;\n         }\n \n-        final long oldTimeoutNanos = timeoutNanos;\n-        timeoutNanos = LongMath.saturatedAdd(oldTimeoutNanos, adjustmentNanos);\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.extendTimeoutNanos(adjustmentNanos);\n+                unsafeExtendTimeoutNanos(adjustmentNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.extendTimeoutNanos(adjustmentNanos));\n+                eventLoop.execute(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n             }\n         } else {\n-            addPendingTimeoutTask(controller -> controller.extendTimeoutNanos(adjustmentNanos));\n+            addPendingTimeoutNanos(adjustmentNanos);\n+            addPendingTimeoutTask(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n         }\n     }\n \n-    private void setTimeoutAfterNanos(long timeoutNanos) {\n+    private boolean unsafeExtendTimeoutNanos(long adjustmentNanos) {\n+        ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        if (adjustmentNanos == 0) {\n+            return true;\n+        }\n+\n+        final long timeoutNanos = this.timeoutNanos;\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        this.timeoutNanos = LongMath.saturatedAdd(timeoutNanos, adjustmentNanos);\n+\n+        if (timeoutNanos <= 0) {\n+            invokeTimeoutTask();\n+            return true;\n+        }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, this.timeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n+    }\n+\n+    private void setTimeoutNanosFromNow(long timeoutNanos) {\n         checkArgument(timeoutNanos > 0, \"timeoutNanos: %s (expected: > 0)\", timeoutNanos);\n \n-        long passedTimeNanos = 0;\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n-            final Long startTimeNanos = timeoutController.startTimeNanos();\n-            if (startTimeNanos != null) {\n-                passedTimeNanos = System.nanoTime() - startTimeNanos;\n-            }\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.resetTimeoutNanos(timeoutNanos);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.resetTimeoutNanos(timeoutNanos));\n+                eventLoop.execute(() -> unsafeSetTimeoutNanosFromNow(timeoutNanos));\n             }\n         } else {\n             final long startTimeNanos = System.nanoTime();\n-            addPendingTimeoutTask(controller -> {\n+            setPendingTimeoutNanos(timeoutNanos);\n+            addPendingTimeoutTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n-                controller.resetTimeoutNanos(timeoutNanos0);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos0);\n             });\n         }\n+    }\n+\n+    private boolean unsafeSetTimeoutNanosFromNow(long newTimeoutNanos) {\n+        ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n+\n+        if (newTimeoutNanos <= 0) {\n+            return true;\n+        }\n \n-        this.timeoutNanos = LongMath.saturatedAdd(passedTimeNanos, timeoutNanos);\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n     public void timeoutNow() {\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.timeoutNow();\n+                unsafeTimeoutNow();\n             } else {\n-                eventLoop.execute(timeoutController::timeoutNow);\n+                eventLoop.execute(this::unsafeTimeoutNow);\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::timeoutNow);\n+            addPendingTimeoutTask(this::unsafeTimeoutNow);\n         }\n     }\n \n-    public boolean isTimedOut() {\n-        if (timeoutController == null) {\n-            return false;\n+    private void unsafeTimeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+\n+        if (!timeoutTask.canSchedule()) {\n+            return;\n+        }\n+\n+        switch (state) {\n+            case TIMED_OUT:\n+                return;\n+            case INIT:\n+            case INACTIVE:\n+                invokeTimeoutTask();\n+                return;\n+            case SCHEDULED:\n+                if (unsafeClearTimeout(false)) {\n+                    invokeTimeoutTask();\n+                }\n+                return;\n+            default:\n+                throw new Error(); // Should not reach here.\n         }\n-        return timeoutController.isTimedOut();\n     }\n \n-    public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n-        requireNonNull(timeoutController, \"timeoutController\");\n-        requireNonNull(eventLoop, \"eventLoop\");\n-        checkState(this.timeoutController == null, \"timeoutController is set already.\");\n-        this.timeoutController = timeoutController;\n-        this.eventLoop = eventLoop;\n+    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n+        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n+            for (;;) {\n+                final Runnable pendingTask = this.pendingTimeoutTask;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae"}, "originalPosition": 367}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3Mjg1NzA4", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-457285708", "createdAt": "2020-07-29T08:03:52Z", "commit": {"oid": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODowMzo1M1rOG4tNJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODowMzo1M1rOG4tNJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExNDA4NA==", "bodyText": "Could you explain why we don't need this condition please?", "url": "https://github.com/line/armeria/pull/2939#discussion_r462114084", "createdAt": "2020-07-29T08:03:53Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/server/HttpResponseSubscriber.java", "diffHunk": "@@ -414,15 +408,8 @@ public boolean canSchedule() {\n \n             @Override\n             public void run() {\n-                if (state != State.DONE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb7c611512e8b059fb1a78be97ab75780d1e1db2", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/cb7c611512e8b059fb1a78be97ab75780d1e1db2", "committedDate": "2020-07-29T13:13:35Z", "message": "Addres comments by @minwoox"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7bc65991ff6dcadf903650d85df0f6c30336c8c", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/d7bc65991ff6dcadf903650d85df0f6c30336c8c", "committedDate": "2020-07-30T02:32:24Z", "message": "Remove 'unsafe' and append '0'"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4Mjk5NTc1", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-458299575", "createdAt": "2020-07-30T11:03:40Z", "commit": {"oid": "d7bc65991ff6dcadf903650d85df0f6c30336c8c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d05053564087db2255ec6dc94d48f01f76e8ddeb", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/d05053564087db2255ec6dc94d48f01f76e8ddeb", "committedDate": "2020-07-31T03:35:19Z", "message": "Add more test for pendingTimeout"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4OTE1NzU5", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-458915759", "createdAt": "2020-07-31T04:57:17Z", "commit": {"oid": "d05053564087db2255ec6dc94d48f01f76e8ddeb"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNDo1NzoxN1rOG57_ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNDo1NzoxN1rOG57_ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDkyMw==", "bodyText": "how about breaking the loop if pendingTimeoutTask is null before doing CAS?", "url": "https://github.com/line/armeria/pull/2939#discussion_r463404923", "createdAt": "2020-07-31T04:57:17Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -17,173 +17,465 @@\n package com.linecorp.armeria.internal.common;\n \n import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkState;\n-import static java.util.Objects.requireNonNull;\n \n-import java.util.function.Consumer;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n import javax.annotation.Nullable;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.math.LongMath;\n \n import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n \n-import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n \n public final class TimeoutScheduler {\n \n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimingOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimingOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimedOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimedOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, Runnable>\n+            pendingTimeoutTaskUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, Runnable.class, \"pendingTimeoutTask\");\n+\n+    private static final AtomicLongFieldUpdater<TimeoutScheduler> pendingTimeoutNanosUpdater =\n+            AtomicLongFieldUpdater.newUpdater(TimeoutScheduler.class, \"pendingTimeoutNanos\");\n+\n+    private static final TimeoutFuture COMPLETED_FUTURE;\n+\n+    static {\n+        COMPLETED_FUTURE = new TimeoutFuture();\n+        COMPLETED_FUTURE.doComplete();\n+    }\n+\n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        TIMED_OUT\n+    }\n+\n     private long timeoutNanos;\n+    private long firstExecutionTimeNanos;\n+\n+    private State state = State.INIT;\n+\n+    @Nullable\n+    private TimeoutTask timeoutTask;\n     @Nullable\n-    private Consumer<TimeoutController> pendingTimeoutTask;\n+    private ScheduledFuture<?> timeoutFuture;\n     @Nullable\n-    private EventLoop eventLoop;\n+    private EventExecutor eventLoop;\n+\n+    // Updated via whenTimingOutUpdater\n+    @Nullable\n+    private volatile TimeoutFuture whenTimingOut;\n+    // Updated via whenTimedOutUpdater\n     @Nullable\n-    private TimeoutController timeoutController;\n+    private volatile TimeoutFuture whenTimedOut;\n+    // Updated via pendingTimeoutTaskUpdater\n+    @Nullable\n+    private volatile Runnable pendingTimeoutTask;\n+    // Updated via pendingTimeoutNanosUpdater\n+    @SuppressWarnings(\"FieldMayBeFinal\")\n+    private volatile long pendingTimeoutNanos;\n+\n+    private volatile boolean initialized;\n \n     public TimeoutScheduler(long timeoutNanos) {\n         this.timeoutNanos = timeoutNanos;\n+        pendingTimeoutNanos = timeoutNanos;\n+    }\n+\n+    /**\n+     * Initializes this {@link TimeoutScheduler}.\n+     */\n+    public void init(EventExecutor eventLoop, TimeoutTask timeoutTask, long initialTimeoutNanos) {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> init(eventLoop, timeoutTask, initialTimeoutNanos));\n+            return;\n+        }\n+\n+        this.eventLoop = eventLoop;\n+        this.timeoutTask = timeoutTask;\n+        if (initialTimeoutNanos > 0) {\n+            timeoutNanos = initialTimeoutNanos;\n+        }\n+\n+        firstExecutionTimeNanos = System.nanoTime();\n+\n+        if (timeoutNanos != 0) {\n+            state = State.SCHEDULED;\n+            timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutNanos, TimeUnit.NANOSECONDS);\n+        } else {\n+            state = State.INACTIVE;\n+        }\n+\n+        Runnable pendingTimeoutTask;\n+        for (;;) {\n+            pendingTimeoutTask = this.pendingTimeoutTask;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d05053564087db2255ec6dc94d48f01f76e8ddeb"}, "originalPosition": 117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0bcc1dc1aa4bf5e50eb3aae154c01f94a034706", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/d0bcc1dc1aa4bf5e50eb3aae154c01f94a034706", "committedDate": "2020-07-31T06:50:41Z", "message": "Address comments by @minwoox"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4OTU3Njg0", "url": "https://github.com/line/armeria/pull/2939#pullrequestreview-458957684", "createdAt": "2020-07-31T07:03:34Z", "commit": {"oid": "d0bcc1dc1aa4bf5e50eb3aae154c01f94a034706"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzowMzozNFrOG5-JjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNzowMzozNFrOG5-JjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0MDI2OA==", "bodyText": "isInitialized() ?", "url": "https://github.com/line/armeria/pull/2939#discussion_r463440268", "createdAt": "2020-07-31T07:03:34Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -410,7 +405,11 @@ public boolean isTimedOut() {\n     }\n \n     public long timeoutNanos() {\n-        return initialized ? timeoutNanos : pendingTimeoutNanos;\n+        return initialized() ? timeoutNanos : pendingTimeoutNanos;\n+    }\n+\n+    private boolean initialized() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bcc1dc1aa4bf5e50eb3aae154c01f94a034706"}, "originalPosition": 116}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3555fca59ba63c76c218e9ec14a9e6958d408ca1", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/3555fca59ba63c76c218e9ec14a9e6958d408ca1", "committedDate": "2020-07-31T07:06:00Z", "message": "Rename to isInitialized"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4961, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}