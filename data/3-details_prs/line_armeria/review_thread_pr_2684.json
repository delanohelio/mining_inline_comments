{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMDk0NTY5", "number": 2684, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzowNjoxMVrOD43zrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMToxNTo1NFrOD6eeFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTYxMTk5OnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzowNjoxMVrOGP0rpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODozOTozNFrOGQft1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0NDk2NQ==", "bodyText": "If a user does not specify a value,", "url": "https://github.com/line/armeria/pull/2684#discussion_r419244965", "createdAt": "2020-05-04T07:06:11Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Specifies an active local port of an Armeria server.\n+ */\n+@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+public @interface LocalArmeriaPort {\n+\n+    /**\n+     * Specifies the {@link SessionProtocol} to get the port from the {@link Server}.\n+     * If a user specify a default value, {@link Server#activeLocalPort()} is used.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDAzOQ==", "bodyText": "Fixed 568291b", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950039", "createdAt": "2020-05-05T08:39:34Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Specifies an active local port of an Armeria server.\n+ */\n+@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+public @interface LocalArmeriaPort {\n+\n+    /**\n+     * Specifies the {@link SessionProtocol} to get the port from the {@link Server}.\n+     * If a user specify a default value, {@link Server#activeLocalPort()} is used.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0NDk2NQ=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTYzMTEwOnYy", "diffSide": "RIGHT", "path": "gradle/scripts/lib/common-misc.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzoxNDoxMVrOGP03Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODozOTozOVrOGQfuDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0NzkxOQ==", "bodyText": "nit: hasGenerated", "url": "https://github.com/line/armeria/pull/2684#discussion_r419247919", "createdAt": "2020-05-04T07:14:11Z", "author": {"login": "minwoox"}, "path": "gradle/scripts/lib/common-misc.gradle", "diffHunk": "@@ -14,3 +15,14 @@ static boolean hasSourceDirectory(Project project, String name) {\n         dir -> new File(dir, name).isDirectory()\n     } != null\n }\n+\n+static boolean hasGenerateSourceDirectory(Project project, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDA5Mw==", "bodyText": "Fixed 568291b", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950093", "createdAt": "2020-05-05T08:39:39Z", "author": {"login": "heowc"}, "path": "gradle/scripts/lib/common-misc.gradle", "diffHunk": "@@ -14,3 +15,14 @@ static boolean hasSourceDirectory(Project project, String name) {\n         dir -> new File(dir, name).isDirectory()\n     } != null\n }\n+\n+static boolean hasGenerateSourceDirectory(Project project, String name) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0NzkxOQ=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTYzNTQwOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzoxNjowNFrOGP053Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODozOTo1M1rOGQfulw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0ODYwNQ==", "bodyText": "We don't need this because the class definition says so?", "url": "https://github.com/line/armeria/pull/2684#discussion_r419248605", "createdAt": "2020-05-04T07:16:04Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDIzMQ==", "bodyText": "Removed 568291b", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950231", "createdAt": "2020-05-05T08:39:53Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0ODYwNQ=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTYzOTE0OnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzoxNzozM1rOGP08MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOToxNzoyOVrOGRKi4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA==", "bodyText": "Could you leave a comment what -2 is for?", "url": "https://github.com/line/armeria/pull/2684#discussion_r419249200", "createdAt": "2020-05-04T07:17:33Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4NzY5MA==", "bodyText": "There is no special meaning for order. It just fits the same as AutowiredAnnotationBeanPostProcessor.\nIf I think we don't need an order, it doesn't seem like a way to specify it. What do you think?", "url": "https://github.com/line/armeria/pull/2684#discussion_r419887690", "createdAt": "2020-05-05T06:25:22Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjgxNA==", "bodyText": "Could you add an in-code comment that explains this? Not a Github comment", "url": "https://github.com/line/armeria/pull/2684#discussion_r420512814", "createdAt": "2020-05-06T02:25:23Z", "author": {"login": "trustin"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTQ0NA==", "bodyText": "What do you think about not implementing Ordered? When I looked at some BeanPostProcessor implementations, I saw no implementation.", "url": "https://github.com/line/armeria/pull/2684#discussion_r420549444", "createdAt": "2020-05-06T05:15:25Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MjU2Nw==", "bodyText": "What do you think about not implementing Ordered?\n\n+1. If we need to, I think we can implement it later.", "url": "https://github.com/line/armeria/pull/2684#discussion_r420552567", "createdAt": "2020-05-06T05:28:51Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY1MTc0NQ==", "bodyText": "Removed. be30ae3", "url": "https://github.com/line/armeria/pull/2684#discussion_r420651745", "createdAt": "2020-05-06T09:17:29Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTY0NjgzOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzoyMDoxN1rOGP1Ayw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODo0MDowMlrOGQfu6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1MDM3OQ==", "bodyText": "Let's use isNullOrEmpty from Guava.", "url": "https://github.com/line/armeria/pull/2684#discussion_r419250379", "createdAt": "2020-05-04T07:20:17Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDMxNA==", "bodyText": "Fixed 568291b", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950314", "createdAt": "2020-05-05T08:40:02Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1MDM3OQ=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTY2NzIwOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzoyNzo0MVrOGP1M-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODo0MDowN1rOGQfvGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1MzQ5Nw==", "bodyText": "This is a field so I think we need to use a singular sentence.\n\"LocalArmeriaPort annotation is not supported on the static field: \" + field.getName()", "url": "https://github.com/line/armeria/pull/2684#discussion_r419253497", "createdAt": "2020-05-04T07:27:41Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static fields\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDM2Mw==", "bodyText": "Fixed 568291b", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950363", "createdAt": "2020-05-05T08:40:07Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static fields\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1MzQ5Nw=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTY3MDAwOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzoyODo1MVrOGP1OvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzoyODo1MVrOGP1OvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1Mzk0OA==", "bodyText": "Seems like we don't use this for ElementType.PARAMETER?", "url": "https://github.com/line/armeria/pull/2684#discussion_r419253948", "createdAt": "2020-05-04T07:28:51Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Specifies an active local port of an Armeria server.\n+ */\n+@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTY4MDY1OnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessorConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzozMjoyN1rOGP1VHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODo0MDoxNFrOGQfvXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NTU4MQ==", "bodyText": "nit: a -> an", "url": "https://github.com/line/armeria/pull/2684#discussion_r419255581", "createdAt": "2020-05-04T07:32:27Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessorConfiguration.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Spring Boot {@link Configuration} that provides Armeria integration.\n+ */\n+@Configuration\n+@ConditionalOnBean(Server.class)\n+@ConditionalOnClass(ArmeriaBeanPostProcessor.class)\n+public class ArmeriaBeanPostProcessorConfiguration {\n+\n+    /**\n+     * Create a {@link ArmeriaBeanPostProcessor} bean.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDQyOQ==", "bodyText": "Fixed 568291b", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950429", "createdAt": "2020-05-05T08:40:14Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessorConfiguration.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Spring Boot {@link Configuration} that provides Armeria integration.\n+ */\n+@Configuration\n+@ConditionalOnBean(Server.class)\n+@ConditionalOnClass(ArmeriaBeanPostProcessor.class)\n+public class ArmeriaBeanPostProcessorConfiguration {\n+\n+    /**\n+     * Create a {@link ArmeriaBeanPostProcessor} bean.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NTU4MQ=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTY5MTIwOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/test/java/com/linecorp/armeria/spring/LocalArmeriaPortsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzozNTo1NVrOGP1bag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwODo1MDo1NFrOGP3q2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NzE5NA==", "bodyText": "Isn't it fail if it throws an exception?", "url": "https://github.com/line/armeria/pull/2684#discussion_r419257194", "createdAt": "2020-05-04T07:35:55Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/test/java/com/linecorp/armeria/spring/LocalArmeriaPortsTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ActiveProfiles;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.spring.LocalArmeriaPortTest.TestConfiguration;\n+\n+/**\n+ * Tests for {@link LocalArmeriaPorts}.\n+ */\n+@RunWith(SpringRunner.class)\n+@SpringBootTest(classes = TestConfiguration.class)\n+@ActiveProfiles({ \"local\", \"autoConfTest\" })\n+@DirtiesContext\n+public class LocalArmeriaPortsTest {\n+\n+    @SpringBootApplication\n+    @Import(ArmeriaOkServiceConfiguration.class)\n+    static class TestConfiguration {\n+    }\n+\n+    @LocalArmeriaPorts\n+    private List<Integer> ports;\n+\n+    @Inject\n+    private Server server;\n+\n+    private String newUrl(String scheme, Integer port) {\n+        return scheme + \"://127.0.0.1:\" + port;\n+    }\n+\n+    @Test\n+    public void testPortConfiguration() throws Exception {\n+        final Collection<ServerPort> serverPorts = server.activePorts().values();\n+        assertThat(serverPorts).size().isEqualTo(ports.size());\n+        serverPorts.stream()\n+                   .map(sp -> sp.localAddress().getPort())\n+                   .forEach(port -> assertThat(ports).contains(port));\n+    }\n+\n+    @Test\n+    public void testHttpServiceRegistrationBean() {\n+        ports.forEach(port -> {\n+            try {\n+                final WebClient client = WebClient.of(newUrl(\"h1c\", port));\n+\n+                final HttpResponse response = client.get(\"/ok\");\n+\n+                final AggregatedHttpResponse res = response.aggregate().get();\n+                assertThat(res.status()).isEqualTo(HttpStatus.OK);\n+                assertThat(res.contentUtf8()).isEqualTo(\"ok\");\n+            } catch (Exception e) {\n+                // Ignored", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MzkxMg==", "bodyText": "You don't need to catch an exception if iterate ports with:\nfor (port in ports) {\n    ...\n}", "url": "https://github.com/line/armeria/pull/2684#discussion_r419293912", "createdAt": "2020-05-04T08:50:54Z", "author": {"login": "ikhoon"}, "path": "spring/boot-autoconfigure/src/test/java/com/linecorp/armeria/spring/LocalArmeriaPortsTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ActiveProfiles;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.spring.LocalArmeriaPortTest.TestConfiguration;\n+\n+/**\n+ * Tests for {@link LocalArmeriaPorts}.\n+ */\n+@RunWith(SpringRunner.class)\n+@SpringBootTest(classes = TestConfiguration.class)\n+@ActiveProfiles({ \"local\", \"autoConfTest\" })\n+@DirtiesContext\n+public class LocalArmeriaPortsTest {\n+\n+    @SpringBootApplication\n+    @Import(ArmeriaOkServiceConfiguration.class)\n+    static class TestConfiguration {\n+    }\n+\n+    @LocalArmeriaPorts\n+    private List<Integer> ports;\n+\n+    @Inject\n+    private Server server;\n+\n+    private String newUrl(String scheme, Integer port) {\n+        return scheme + \"://127.0.0.1:\" + port;\n+    }\n+\n+    @Test\n+    public void testPortConfiguration() throws Exception {\n+        final Collection<ServerPort> serverPorts = server.activePorts().values();\n+        assertThat(serverPorts).size().isEqualTo(ports.size());\n+        serverPorts.stream()\n+                   .map(sp -> sp.localAddress().getPort())\n+                   .forEach(port -> assertThat(ports).contains(port));\n+    }\n+\n+    @Test\n+    public void testHttpServiceRegistrationBean() {\n+        ports.forEach(port -> {\n+            try {\n+                final WebClient client = WebClient.of(newUrl(\"h1c\", port));\n+\n+                final HttpResponse response = client.get(\"/ok\");\n+\n+                final AggregatedHttpResponse res = response.aggregate().get();\n+                assertThat(res.status()).isEqualTo(HttpStatus.OK);\n+                assertThat(res.contentUtf8()).isEqualTo(\"ok\");\n+            } catch (Exception e) {\n+                // Ignored", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NzE5NA=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTY5MzYyOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/test/java/com/linecorp/armeria/spring/LocalArmeriaPortTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzozNjo0NlrOGP1c7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODo0MjowMlrOGQfzaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NzU4Mg==", "bodyText": "Not sure if it's simple or not, but how about adding a test case where this annotation is used on method?", "url": "https://github.com/line/armeria/pull/2684#discussion_r419257582", "createdAt": "2020-05-04T07:36:46Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/test/java/com/linecorp/armeria/spring/LocalArmeriaPortTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ActiveProfiles;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.spring.LocalArmeriaPortTest.TestConfiguration;\n+\n+/**\n+ * Tests for {@link LocalArmeriaPort}.\n+ */\n+@RunWith(SpringRunner.class)\n+@SpringBootTest(classes = TestConfiguration.class)\n+@ActiveProfiles({ \"local\", \"autoConfTest\" })\n+@DirtiesContext\n+public class LocalArmeriaPortTest {\n+\n+    @SpringBootApplication\n+    @Import(ArmeriaOkServiceConfiguration.class)\n+    static class TestConfiguration {\n+    }\n+\n+    @Inject\n+    private Server server;\n+\n+    @LocalArmeriaPort", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MTQ2NA==", "bodyText": "Fixed 568291b.\nAnd I also wrote additional tests for https. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2684#discussion_r419951464", "createdAt": "2020-05-05T08:42:02Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/test/java/com/linecorp/armeria/spring/LocalArmeriaPortTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ActiveProfiles;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.spring.LocalArmeriaPortTest.TestConfiguration;\n+\n+/**\n+ * Tests for {@link LocalArmeriaPort}.\n+ */\n+@RunWith(SpringRunner.class)\n+@SpringBootTest(classes = TestConfiguration.class)\n+@ActiveProfiles({ \"local\", \"autoConfTest\" })\n+@DirtiesContext\n+public class LocalArmeriaPortTest {\n+\n+    @SpringBootApplication\n+    @Import(ArmeriaOkServiceConfiguration.class)\n+    static class TestConfiguration {\n+    }\n+\n+    @Inject\n+    private Server server;\n+\n+    @LocalArmeriaPort", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NzU4Mg=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTcxNDQxOnYy", "diffSide": "RIGHT", "path": "spring/boot1-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaSpringBoot1BeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzo0NDoxMlrOGP1pVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNjozNzozM1rOGQcNAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2MDc1OQ==", "bodyText": "How about adding a module for common so that we can put duplicate logic in it? @trustin, @ikhoon", "url": "https://github.com/line/armeria/pull/2684#discussion_r419260759", "createdAt": "2020-05-04T07:44:12Z", "author": {"login": "minwoox"}, "path": "spring/boot1-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaSpringBoot1BeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public class ArmeriaSpringBoot1BeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5MjQ4MA==", "bodyText": "I agree. I think that will reduce unnecessary work such as copying files. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2684#discussion_r419892480", "createdAt": "2020-05-05T06:37:33Z", "author": {"login": "heowc"}, "path": "spring/boot1-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaSpringBoot1BeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public class ArmeriaSpringBoot1BeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2MDc1OQ=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTkwNjA2OnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwODo0NDo0OFrOGP3dhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo0Njo0NVrOGQs90Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MDUwMA==", "bodyText": "The meaning of SessionProtocol.NONE and usage are different.\nSessionProtocol.NONE does not represent a session protocol, is only used to get any local port using Server.activeLocalPort().\nWhat happen when a server is built with SessionProtocol.NONE?\nServer.builder()\n      .port(8080, SessionProtocol.NONE)\n      ...\nI think this is useful for building test cases. If then, how about making SessionProtocol.HTTP default?", "url": "https://github.com/line/armeria/pull/2684#discussion_r419290500", "createdAt": "2020-05-04T08:44:48Z", "author": {"login": "ikhoon"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Specifies an active local port of an Armeria server.\n+ */\n+@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+public @interface LocalArmeriaPort {\n+\n+    /**\n+     * Specifies the {@link SessionProtocol} to get the port from the {@link Server}.\n+     * If a user specify a default value, {@link Server#activeLocalPort()} is used.\n+     */\n+    SessionProtocol value() default SessionProtocol.NONE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NjM2OQ==", "bodyText": "Good idea! \ud83d\udc4d", "url": "https://github.com/line/armeria/pull/2684#discussion_r419896369", "createdAt": "2020-05-05T06:47:49Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Specifies an active local port of an Armeria server.\n+ */\n+@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+public @interface LocalArmeriaPort {\n+\n+    /**\n+     * Specifies the {@link SessionProtocol} to get the port from the {@link Server}.\n+     * If a user specify a default value, {@link Server#activeLocalPort()} is used.\n+     */\n+    SessionProtocol value() default SessionProtocol.NONE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MDUwMA=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2NzEyMQ==", "bodyText": "Fixed 98f2e75", "url": "https://github.com/line/armeria/pull/2684#discussion_r420167121", "createdAt": "2020-05-05T14:46:45Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Specifies an active local port of an Armeria server.\n+ */\n+@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+public @interface LocalArmeriaPort {\n+\n+    /**\n+     * Specifies the {@link SessionProtocol} to get the port from the {@link Server}.\n+     * If a user specify a default value, {@link Server#activeLocalPort()} is used.\n+     */\n+    SessionProtocol value() default SessionProtocol.NONE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MDUwMA=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMDEzMTgyOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwOTo1MzowNFrOGP5n-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo0NjozOFrOGQs9fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNTk0Ng==", "bodyText": "Could we reuse this instance?", "url": "https://github.com/line/armeria/pull/2684#discussion_r419325946", "createdAt": "2020-05-04T09:53:04Z", "author": {"login": "ikhoon"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static fields\");\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotations are not supported on static fields\");\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static methods\");\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotations are not supported on static methods\");\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            final Server server = beanFactory.getBean(Server.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NTY0Mw==", "bodyText": "Let's find a way to reuse it. In addition, it would be good to add a value toMap.", "url": "https://github.com/line/armeria/pull/2684#discussion_r419895643", "createdAt": "2020-05-05T06:45:49Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static fields\");\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotations are not supported on static fields\");\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static methods\");\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotations are not supported on static methods\");\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            final Server server = beanFactory.getBean(Server.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNTk0Ng=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2NzAzOQ==", "bodyText": "Fixed 98f2e75", "url": "https://github.com/line/armeria/pull/2684#discussion_r420167039", "createdAt": "2020-05-05T14:46:38Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static fields\");\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotations are not supported on static fields\");\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static methods\");\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotations are not supported on static methods\");\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            final Server server = beanFactory.getBean(Server.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNTk0Ng=="}, "originalCommit": {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzc0Mjc4OnYy", "diffSide": "RIGHT", "path": "gradle/scripts/lib/java-rpc-proto.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjoyNjo0OFrOGRCFdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNToxNTo1OVrOGRETvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzE0Mg==", "bodyText": "Could you explain why you need this? This will not work if a user ran ./gradlew clean, which removes the gen-src directory.", "url": "https://github.com/line/armeria/pull/2684#discussion_r420513142", "createdAt": "2020-05-06T02:26:48Z", "author": {"login": "trustin"}, "path": "gradle/scripts/lib/java-rpc-proto.gradle", "diffHunk": "@@ -8,8 +8,8 @@ buildscript {\n }\n \n configure(projectsWithFlags('java')) {\n-    // Add protobuf/gRPC support if there is src/*/proto\n-    if (project.ext.hasSourceDirectory('proto')) {\n+    // Add protobuf/gRPC support if there is src/*/proto, gen-src/*/proto\n+    if (project.ext.hasSourceDirectory('proto') || project.ext.hasGenerated('proto')) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98f2e7593b361b722f82189791bfc63abb40a719"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0ODAyOA==", "bodyText": "Oops... Looking at the code, it is not necessary. I will remove it.", "url": "https://github.com/line/armeria/pull/2684#discussion_r420548028", "createdAt": "2020-05-06T05:09:27Z", "author": {"login": "heowc"}, "path": "gradle/scripts/lib/java-rpc-proto.gradle", "diffHunk": "@@ -8,8 +8,8 @@ buildscript {\n }\n \n configure(projectsWithFlags('java')) {\n-    // Add protobuf/gRPC support if there is src/*/proto\n-    if (project.ext.hasSourceDirectory('proto')) {\n+    // Add protobuf/gRPC support if there is src/*/proto, gen-src/*/proto\n+    if (project.ext.hasSourceDirectory('proto') || project.ext.hasGenerated('proto')) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzE0Mg=="}, "originalCommit": {"oid": "98f2e7593b361b722f82189791bfc63abb40a719"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTU2Ng==", "bodyText": "Fixed 44dfcbd", "url": "https://github.com/line/armeria/pull/2684#discussion_r420549566", "createdAt": "2020-05-06T05:15:59Z", "author": {"login": "heowc"}, "path": "gradle/scripts/lib/java-rpc-proto.gradle", "diffHunk": "@@ -8,8 +8,8 @@ buildscript {\n }\n \n configure(projectsWithFlags('java')) {\n-    // Add protobuf/gRPC support if there is src/*/proto\n-    if (project.ext.hasSourceDirectory('proto')) {\n+    // Add protobuf/gRPC support if there is src/*/proto, gen-src/*/proto\n+    if (project.ext.hasSourceDirectory('proto') || project.ext.hasGenerated('proto')) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzE0Mg=="}, "originalCommit": {"oid": "98f2e7593b361b722f82189791bfc63abb40a719"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzc0NTI2OnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjoyODozNFrOGRCG7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNToxNTo1MlrOGRETqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzUxOA==", "bodyText": "on the -> on a ?", "url": "https://github.com/line/armeria/pull/2684#discussion_r420513518", "createdAt": "2020-05-06T02:28:34Z", "author": {"login": "trustin"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98f2e7593b361b722f82189791bfc63abb40a719"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTU0NA==", "bodyText": "Fixed 44dfcbd", "url": "https://github.com/line/armeria/pull/2684#discussion_r420549544", "createdAt": "2020-05-06T05:15:52Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzUxOA=="}, "originalCommit": {"oid": "98f2e7593b361b722f82189791bfc63abb40a719"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzc0NzQxOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjoyOTo0M1rOGRCIEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNToxNTo0MVrOGREThA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzgxMA==", "bodyText": "on the static field -> on a static method", "url": "https://github.com/line/armeria/pull/2684#discussion_r420513810", "createdAt": "2020-05-06T02:29:43Z", "author": {"login": "trustin"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98f2e7593b361b722f82189791bfc63abb40a719"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0ODM5Nw==", "bodyText": "Oops... it's my mistake.", "url": "https://github.com/line/armeria/pull/2684#discussion_r420548397", "createdAt": "2020-05-06T05:11:00Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzgxMA=="}, "originalCommit": {"oid": "98f2e7593b361b722f82189791bfc63abb40a719"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTUwOA==", "bodyText": "Fixed 44dfcbd", "url": "https://github.com/line/armeria/pull/2684#discussion_r420549508", "createdAt": "2020-05-06T05:15:41Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzgxMA=="}, "originalCommit": {"oid": "98f2e7593b361b722f82189791bfc63abb40a719"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjM4OTM3OnYy", "diffSide": "RIGHT", "path": "spring/boot1-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaSpringBoot1BeanPostProcessorConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMDo1MzoyNVrOGSVQhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMTo0ODozNVrOGSWLTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg3NTg0NQ==", "bodyText": "nit: a -> an", "url": "https://github.com/line/armeria/pull/2684#discussion_r421875845", "createdAt": "2020-05-08T00:53:25Z", "author": {"login": "minwoox"}, "path": "spring/boot1-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaSpringBoot1BeanPostProcessorConfiguration.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.spring;\n+\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Spring Boot {@link Configuration} that provides Armeria integration.\n+ */\n+@Configuration\n+@ConditionalOnBean(Server.class)\n+public class ArmeriaSpringBoot1BeanPostProcessorConfiguration {\n+\n+    /**\n+     * Create a {@link ArmeriaSpringBoot1BeanPostProcessor} bean.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be30ae3ec38daac76252803045fc97fda2c4e4ed"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MDg5NA==", "bodyText": "Fixed 27bf859", "url": "https://github.com/line/armeria/pull/2684#discussion_r421890894", "createdAt": "2020-05-08T01:48:35Z", "author": {"login": "heowc"}, "path": "spring/boot1-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaSpringBoot1BeanPostProcessorConfiguration.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.spring;\n+\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Spring Boot {@link Configuration} that provides Armeria integration.\n+ */\n+@Configuration\n+@ConditionalOnBean(Server.class)\n+public class ArmeriaSpringBoot1BeanPostProcessorConfiguration {\n+\n+    /**\n+     * Create a {@link ArmeriaSpringBoot1BeanPostProcessor} bean.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg3NTg0NQ=="}, "originalCommit": {"oid": "be30ae3ec38daac76252803045fc97fda2c4e4ed"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjQzMTkwOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMToxNTo0OFrOGSVo7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMTo0ODo0MFrOGSWLXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4MjA5Mg==", "bodyText": "Could it be just portsCache.isEmpty?", "url": "https://github.com/line/armeria/pull/2684#discussion_r421882092", "createdAt": "2020-05-08T01:15:48Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    private void serServer(Server server) {\n+        this.server = requireNonNull(server, \"server\");\n+    }\n+\n+    @Nullable\n+    private Server getServer() {\n+        return server;\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            Integer port = portCache.get(protocol);\n+            if (port == null) {\n+                port = server.activeLocalPort(protocol);\n+                portCache.put(protocol, port);\n+            }\n+            this.port = port;\n+        }\n+\n+        /**\n+         * Resolve the object against the application context.\n+         */\n+        @Override\n+        protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n+            return port;\n+        }\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPorts}.\n+     */\n+    private final class LocalArmeriaPortsElement extends InjectionMetadata.InjectedElement {\n+\n+        private final List<Integer> ports;\n+\n+        private LocalArmeriaPortsElement(Member member, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            final Builder<Integer> ports = ImmutableList.builder();\n+            if (CollectionUtils.isEmpty(portsCache)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be30ae3ec38daac76252803045fc97fda2c4e4ed"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MDkwOQ==", "bodyText": "Fixed 27bf859", "url": "https://github.com/line/armeria/pull/2684#discussion_r421890909", "createdAt": "2020-05-08T01:48:40Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    private void serServer(Server server) {\n+        this.server = requireNonNull(server, \"server\");\n+    }\n+\n+    @Nullable\n+    private Server getServer() {\n+        return server;\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            Integer port = portCache.get(protocol);\n+            if (port == null) {\n+                port = server.activeLocalPort(protocol);\n+                portCache.put(protocol, port);\n+            }\n+            this.port = port;\n+        }\n+\n+        /**\n+         * Resolve the object against the application context.\n+         */\n+        @Override\n+        protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n+            return port;\n+        }\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPorts}.\n+     */\n+    private final class LocalArmeriaPortsElement extends InjectionMetadata.InjectedElement {\n+\n+        private final List<Integer> ports;\n+\n+        private LocalArmeriaPortsElement(Member member, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            final Builder<Integer> ports = ImmutableList.builder();\n+            if (CollectionUtils.isEmpty(portsCache)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4MjA5Mg=="}, "originalCommit": {"oid": "be30ae3ec38daac76252803045fc97fda2c4e4ed"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjQzMjIwOnYy", "diffSide": "RIGHT", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMToxNTo1NFrOGSVpFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMTo0ODo0M1rOGSWLag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4MjEzMg==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2684#discussion_r421882132", "createdAt": "2020-05-08T01:15:54Z", "author": {"login": "minwoox"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    private void serServer(Server server) {\n+        this.server = requireNonNull(server, \"server\");\n+    }\n+\n+    @Nullable\n+    private Server getServer() {\n+        return server;\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            Integer port = portCache.get(protocol);\n+            if (port == null) {\n+                port = server.activeLocalPort(protocol);\n+                portCache.put(protocol, port);\n+            }\n+            this.port = port;\n+        }\n+\n+        /**\n+         * Resolve the object against the application context.\n+         */\n+        @Override\n+        protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n+            return port;\n+        }\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPorts}.\n+     */\n+    private final class LocalArmeriaPortsElement extends InjectionMetadata.InjectedElement {\n+\n+        private final List<Integer> ports;\n+\n+        private LocalArmeriaPortsElement(Member member, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            final Builder<Integer> ports = ImmutableList.builder();\n+            if (CollectionUtils.isEmpty(portsCache)) {\n+                synchronized (portsCache) {\n+                    if (CollectionUtils.isEmpty(portsCache)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be30ae3ec38daac76252803045fc97fda2c4e4ed"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MDkyMg==", "bodyText": "Fixed 27bf859", "url": "https://github.com/line/armeria/pull/2684#discussion_r421890922", "createdAt": "2020-05-08T01:48:43Z", "author": {"login": "heowc"}, "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    private void serServer(Server server) {\n+        this.server = requireNonNull(server, \"server\");\n+    }\n+\n+    @Nullable\n+    private Server getServer() {\n+        return server;\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            Integer port = portCache.get(protocol);\n+            if (port == null) {\n+                port = server.activeLocalPort(protocol);\n+                portCache.put(protocol, port);\n+            }\n+            this.port = port;\n+        }\n+\n+        /**\n+         * Resolve the object against the application context.\n+         */\n+        @Override\n+        protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n+            return port;\n+        }\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPorts}.\n+     */\n+    private final class LocalArmeriaPortsElement extends InjectionMetadata.InjectedElement {\n+\n+        private final List<Integer> ports;\n+\n+        private LocalArmeriaPortsElement(Member member, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            final Builder<Integer> ports = ImmutableList.builder();\n+            if (CollectionUtils.isEmpty(portsCache)) {\n+                synchronized (portsCache) {\n+                    if (CollectionUtils.isEmpty(portsCache)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4MjEzMg=="}, "originalCommit": {"oid": "be30ae3ec38daac76252803045fc97fda2c4e4ed"}, "originalPosition": 211}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2541, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}