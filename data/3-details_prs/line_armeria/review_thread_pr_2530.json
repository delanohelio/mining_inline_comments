{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4OTM0NzU3", "number": 2530, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyNzo0NFrODiSyvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyNzo0NFrODiSyvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Mjg2MDc4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/internal/common/util/HttpTimestampSupplierTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyNzo0NFrOFtdcAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMTo0OToyOFrOFtd9xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjU0Ng==", "bodyText": "Why use spy instead of mock?", "url": "https://github.com/line/armeria/pull/2530#discussion_r383212546", "createdAt": "2020-02-24T11:27:44Z", "author": {"login": "anuraaga"}, "path": "core/src/test/java/com/linecorp/armeria/internal/common/util/HttpTimestampSupplierTest.java", "diffHunk": "@@ -17,43 +17,79 @@\n package com.linecorp.armeria.internal.common.util;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.awaitility.Awaitility.await;\n-import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.clearInvocations;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n-import java.time.Clock;\n-import java.time.Duration;\n import java.time.Instant;\n-import java.time.ZoneOffset;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.LongSupplier;\n+import java.util.function.Supplier;\n \n-import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.mockito.Mock;\n \n class HttpTimestampSupplierTest {\n \n     private static final Instant TIME0 = Instant.parse(\"2019-10-18T10:15:30.05Z\");\n     private static final Instant TIME1 = Instant.parse(\"2019-10-18T10:15:31.25Z\");\n \n-    @Mock private Clock clock;\n+    @Test\n+    void normal() {\n+        final AtomicReference<Instant> instantHolder = new AtomicReference<>(TIME0);\n+        final AtomicLong nanoTimeHolder = new AtomicLong(TimeUnit.MILLISECONDS.toNanos(-500));\n \n-    private HttpTimestampSupplier supplier;\n+        // Create delegating mock suppliers.\n+        // Note that we can't use method references or lambda expressions because they generate final classes.\n+        @SuppressWarnings({ \"Convert2Lambda\", \"Anonymous2MethodRef\" })\n+        final Supplier<Instant> instantSupplier = spy(new Supplier<Instant>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9db58fed45bb1df665257e78c7a1440b5d8f12a7"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMTE5MQ==", "bodyText": "No idea. Now using mock.", "url": "https://github.com/line/armeria/pull/2530#discussion_r383221191", "createdAt": "2020-02-24T11:49:28Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/internal/common/util/HttpTimestampSupplierTest.java", "diffHunk": "@@ -17,43 +17,79 @@\n package com.linecorp.armeria.internal.common.util;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.awaitility.Awaitility.await;\n-import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.clearInvocations;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n-import java.time.Clock;\n-import java.time.Duration;\n import java.time.Instant;\n-import java.time.ZoneOffset;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.LongSupplier;\n+import java.util.function.Supplier;\n \n-import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.mockito.Mock;\n \n class HttpTimestampSupplierTest {\n \n     private static final Instant TIME0 = Instant.parse(\"2019-10-18T10:15:30.05Z\");\n     private static final Instant TIME1 = Instant.parse(\"2019-10-18T10:15:31.25Z\");\n \n-    @Mock private Clock clock;\n+    @Test\n+    void normal() {\n+        final AtomicReference<Instant> instantHolder = new AtomicReference<>(TIME0);\n+        final AtomicLong nanoTimeHolder = new AtomicLong(TimeUnit.MILLISECONDS.toNanos(-500));\n \n-    private HttpTimestampSupplier supplier;\n+        // Create delegating mock suppliers.\n+        // Note that we can't use method references or lambda expressions because they generate final classes.\n+        @SuppressWarnings({ \"Convert2Lambda\", \"Anonymous2MethodRef\" })\n+        final Supplier<Instant> instantSupplier = spy(new Supplier<Instant>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjU0Ng=="}, "originalCommit": {"oid": "9db58fed45bb1df665257e78c7a1440b5d8f12a7"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2688, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}