{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MzE1NzMx", "number": 2374, "reviewThreads": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMTowNzozMVrODWafrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwODowNjoyN1rODgS_nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODI5MzU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMTowNzozMVrOFbKUzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMTowNzozMVrOFbKUzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyNTAzOA==", "bodyText": "this should be set per PoolKey", "url": "https://github.com/line/armeria/pull/2374#discussion_r364025038", "createdAt": "2020-01-08T01:07:31Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -71,6 +71,7 @@\n     // Fields for creating a new connection:\n     private final Bootstrap[] bootstraps;\n     private final int connectTimeoutMillis;\n+    private volatile int numPendingAcquisitions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37a56de52aedbde51625acdb1480dc6655694008"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODI5ODUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMToxMDo1MlrOFbKXwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMToxMDo1MlrOFbKXwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyNTc5NA==", "bodyText": "this can be optimized by checking existing connections", "url": "https://github.com/line/armeria/pull/2374#discussion_r364025794", "createdAt": "2020-01-08T01:10:52Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -266,14 +267,23 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             return false;\n         }\n \n+        numPendingAcquisitions++;\n+\n         timingsBuilder.pendingAcquisitionStart();\n         pendingAcquisition.handle((pch, cause) -> {\n             timingsBuilder.pendingAcquisitionEnd();\n \n+            numPendingAcquisitions--;\n+\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (numPendingAcquisitions < session.maxUnfinishedResponses() - 1) {\n+                        promise.complete(pch);\n+                    } else {\n+                        connect(actualProtocol, key, promise, timingsBuilder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37a56de52aedbde51625acdb1480dc6655694008"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODMwMjA1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMToxMzozNlrOFbKZ9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMToxMzozNlrOFbKZ9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyNjM1OA==", "bodyText": "should also compare with unfinishedResponses.\nalso, technically this may not be a correct check -- should also consider timing with\n\nadding response\ncheck for acquireNowExact", "url": "https://github.com/line/armeria/pull/2374#discussion_r364026358", "createdAt": "2020-01-08T01:13:36Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -266,14 +267,23 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             return false;\n         }\n \n+        numPendingAcquisitions++;\n+\n         timingsBuilder.pendingAcquisitionStart();\n         pendingAcquisition.handle((pch, cause) -> {\n             timingsBuilder.pendingAcquisitionEnd();\n \n+            numPendingAcquisitions--;\n+\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (numPendingAcquisitions < session.maxUnfinishedResponses() - 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37a56de52aedbde51625acdb1480dc6655694008"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTI5ODA5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODowNDoxOFrOFn_3Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODowNDoxOFrOFn_3Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4NTEzOA==", "bodyText": "I guess we can prevent calling pendingAcquisitionEnd() if acquireLater() will be called?", "url": "https://github.com/line/armeria/pull/2374#discussion_r377485138", "createdAt": "2020-02-11T08:04:18Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -107,8 +107,9 @@ public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n      * @throws IllegalStateException if {@link #pendingAcquisitionStart()} is not invoked before calling this.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionEnd() {\n-        checkState(pendingAcquisitionStartTimeMicros >= 0, \"pendingAcquisitionStart() is not called yet.\");\n-        checkState(!pendingAcquisitionEndSet, \"pendingAcquisitionEnd() is already called.\");\n+        // TODO: decide how to handle pendingAcquisitionEnd now that it might be called multiple times\n+        // checkState(pendingAcquisitionStartTimeMicros >= 0, \"pendingAcquisitionStart() is not called yet.\");\n+        // checkState(!pendingAcquisitionEndSet, \"pendingAcquisitionEnd() is already called.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e3b16d092668b39342414203663711903491133"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTMwOTE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODoxMDowNFrOFn_-FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODo1NDo0MFrOFqN44g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4Njg2OQ==", "bodyText": "Shouldn't we call acquireLater() after pendingAcquisition is cleared? acquireLater() (and inherently usePendingAcquisition()) would use the current pendingAcquisition again and again, making a busy loop.", "url": "https://github.com/line/armeria/pull/2374#discussion_r377486869", "createdAt": "2020-02-11T08:10:04Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +276,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());\n+                    // Need to subtract 1 since the current pending request may also be unfinished\n+                    if (session.unfinishedResponses() >= session.maxUnfinishedResponses() - 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder).thenAccept(promise::complete);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e3b16d092668b39342414203663711903491133"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3OTk1Mg==", "bodyText": "I see~ Of course I'll explore this idea, but just to share my original thought.\nI was thinking pendingAcquisition would always be cleared since notifyConnect clears it before completing the promise.", "url": "https://github.com/line/armeria/pull/2374#discussion_r377779952", "createdAt": "2020-02-11T17:18:55Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +276,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());\n+                    // Need to subtract 1 since the current pending request may also be unfinished\n+                    if (session.unfinishedResponses() >= session.maxUnfinishedResponses() - 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder).thenAccept(promise::complete);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4Njg2OQ=="}, "originalCommit": {"oid": "5e3b16d092668b39342414203663711903491133"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgxMjA2Ng==", "bodyText": "Ah, OK. pendingAcquisition is removed in notifyConnect() before pendingAcquisition is completed.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379812066", "createdAt": "2020-02-15T08:54:40Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +276,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());\n+                    // Need to subtract 1 since the current pending request may also be unfinished\n+                    if (session.unfinishedResponses() >= session.maxUnfinishedResponses() - 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder).thenAccept(promise::complete);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4Njg2OQ=="}, "originalCommit": {"oid": "5e3b16d092668b39342414203663711903491133"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjY3NDc5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxMToxOFrOFptVjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwNzowMToyNVrOFqLmTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI3ODczNA==", "bodyText": "also add checks for pendingAcquisitionMillis to ensure pendingAcquisition was really used", "url": "https://github.com/line/armeria/pull/2374#discussion_r379278734", "createdAt": "2020-02-14T07:11:18Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +170,143 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    public void succeedWhenExceedMaxStreams() throws Exception {\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        // running inside event loop ensures requests are queued before initial connect completes.\n+        for (int j = 0; j < MAX_CONCURRENT_STREAMS + 1; j++) {\n+            receivedResponses.add(client.get(PATH).aggregate());\n+        }\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(MAX_CONCURRENT_STREAMS + 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3879c7975a32d8f7f6aabacb862a099aeca97ee1"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc3NDU0MA==", "bodyText": "done -- not applying test for multipleEventLoops since this check depends on how event loops are acquired. (this would actually be do-able, but not sure if it's worth it)", "url": "https://github.com/line/armeria/pull/2374#discussion_r379774540", "createdAt": "2020-02-15T07:01:25Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +170,143 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    public void succeedWhenExceedMaxStreams() throws Exception {\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        // running inside event loop ensures requests are queued before initial connect completes.\n+        for (int j = 0; j < MAX_CONCURRENT_STREAMS + 1; j++) {\n+            receivedResponses.add(client.get(PATH).aggregate());\n+        }\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(MAX_CONCURRENT_STREAMS + 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI3ODczNA=="}, "originalCommit": {"oid": "3879c7975a32d8f7f6aabacb862a099aeca97ee1"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDI1MDI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODozMDo0MlrOFqNX_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxMjowNjoxNlrOFqO16Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwMzY0Nw==", "bodyText": "Better extracting them into a local variable if you intend to keep the logging above.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379803647", "createdAt": "2020-02-15T08:30:42Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());\n+                    // unfinishedResponses >= maxUnfinishedResponses - current connecting request\n+                    if (session.unfinishedResponses() >= session.maxUnfinishedResponses() - 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyNzY4OQ==", "bodyText": "added a local variable and removed the comment -- let me know if you prefer I leave the comment though \ud83d\ude47", "url": "https://github.com/line/armeria/pull/2374#discussion_r379827689", "createdAt": "2020-02-15T12:06:16Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());\n+                    // unfinishedResponses >= maxUnfinishedResponses - current connecting request\n+                    if (session.unfinishedResponses() >= session.maxUnfinishedResponses() - 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwMzY0Nw=="}, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDI1MTczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODozMToxMVrOFqNYow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODozMToxMVrOFqNYow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwMzgxMQ==", "bodyText": "Probably debug is better? Or do you intend to remove it before removing draft?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379803811", "createdAt": "2020-02-15T08:31:11Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDI1NzQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODozMjo0OFrOFqNbFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODozMjo0OFrOFqNbFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNDQzOQ==", "bodyText": "pendingAcquisitionEndNanos == 0 -> !pendingAcquisitionEndSet ?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379804439", "createdAt": "2020-02-15T08:32:48Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -95,8 +95,10 @@ public ClientConnectionTimingsBuilder socketConnectEnd() {\n      * in order to use one connection for HTTP/2.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n-        pendingAcquisitionStartTimeMicros = SystemInfo.currentTimeMicros();\n-        pendingAcquisitionStartNanos = System.nanoTime();\n+        if (pendingAcquisitionStartTimeMicros == 0 && pendingAcquisitionEndNanos == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDI2NTE3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODozNTozNFrOFqNesQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODozNTozNFrOFqNesQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNTM2MQ==", "bodyText": "j could be i?\nCould you add a comment about why you need to execute this via .execute()?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379805361", "createdAt": "2020-02-15T08:35:34Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDI4MTgyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODo0MTowNlrOFqNmXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo0NDo0M1rOFqPT3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNzMyNQ==", "bodyText": "Could you also check the cause of the cause as well? (with hasMessageContaining if possible.)\n// Not sure if this is the best example. Maybe you can just split the assertions.\nassertThatThrownBy(() -> ...)\n        .isInstanceOf(CompletionException.class)\n        .hasCauseInstanceOfSatisfying(UnprocessedRequestException.class, cause -> {\n            assertThat(cause).hasCauseInstanceofSatisfying(SomeException.class, causeOfCause -> {\n                ...\n            });\n        });", "url": "https://github.com/line/armeria/pull/2374#discussion_r379807325", "createdAt": "2020-02-15T08:41:06Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNTM1Nw==", "bodyText": "leaving for ref.  the stack trace is as follows (without a \"real\" message)\njava.util.concurrent.CompletionException: com.linecorp.armeria.client.UnprocessedRequestException: com.linecorp.armeria.common.ClosedSessionException\n\n\tat java.base/java.util.concurrent.CompletableFuture.reportJoin(CompletableFuture.java:412)\n\tat java.base/java.util.concurrent.CompletableFuture.join(CompletableFuture.java:2115)\n\tat com.linecorp.armeria.common.util.EventLoopCheckingFuture.join(EventLoopCheckingFuture.java:70)\n\tat com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.lambda$exceededMaxStreamsPropagatesFailureCorrectly$19(HttpClientMaxConcurrentStreamTest.java:309)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n\tat java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)\n\tat java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1654)\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497)\n\tat com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.exceededMaxStreamsPropagatesFailureCorrectly(HttpClientMaxConcurrentStreamTest.java:308)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:567)\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:686)\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:205)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:201)\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:137)\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1540)\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1540)\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248)\n\tat org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211)\n\tat org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226)\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199)\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132)\n\tat com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69)\n\tat com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\nCaused by: com.linecorp.armeria.client.UnprocessedRequestException: com.linecorp.armeria.common.ClosedSessionException\n\tat com.linecorp.armeria.client.HttpChannelPool.notifyConnect(HttpChannelPool.java:475)\n\tat com.linecorp.armeria.client.HttpChannelPool.lambda$connect$5(HttpChannelPool.java:348)\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\n\tat com.linecorp.armeria.client.HttpSessionHandler.channelInactive(HttpSessionHandler.java:335)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:239)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:386)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:351)\n\tat io.netty.handler.codec.http2.Http2ConnectionHandler.channelInactive(Http2ConnectionHandler.java:415)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:239)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:386)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:351)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:239)\n\tat io.netty.handler.logging.LoggingHandler.channelInactive(LoggingHandler.java:153)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:239)\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1405)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:901)\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:818)\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:164)\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:497)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.base/java.lang.Thread.run(Thread.java:835)\nCaused by: com.linecorp.armeria.common.ClosedSessionException\n\tat com.linecorp.armeria.common.ClosedSessionException.get(ClosedSessionException.java:33)\n\tat com.linecorp.armeria.client.HttpSessionHandler.channelInactive(HttpSessionHandler.java:329)\n\t... 31 more", "url": "https://github.com/line/armeria/pull/2374#discussion_r379835357", "createdAt": "2020-02-15T14:44:43Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNzMyNQ=="}, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDI4NzE1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODo0MjozOVrOFqNogA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODo0MjozOVrOFqNogA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNzg3Mg==", "bodyText": "mapToLong(...).max()", "url": "https://github.com/line/armeria/pull/2374#discussion_r379807872", "createdAt": "2020-02-15T08:42:39Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final int sleepMillis = 300;\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                Thread.sleep(sleepMillis);\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+\n+        // There should be at least one request with at least numConnections * pendingAcquisitionsDuration\n+        final Long maxPendingAcquisitionDurationNanos = connectionTimings.stream().map(\n+                ClientConnectionTimings::pendingAcquisitionDurationNanos).max(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDM3NDYxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwOToxMzowMVrOFqOQWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxMjoyNDoxN1rOFqO5Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgxODA3Mw==", "bodyText": "Note to self: check if this has a potential to be flaky depending on how requests are assigned to event loops", "url": "https://github.com/line/armeria/pull/2374#discussion_r379818073", "createdAt": "2020-02-15T09:13:01Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyODU2Mg==", "bodyText": "confirmed that HeapBasedEventLoopState guarantees this", "url": "https://github.com/line/armeria/pull/2374#discussion_r379828562", "createdAt": "2020-02-15T12:24:17Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgxODA3Mw=="}, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDQ3Mzk5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxMzoxMDoxNVrOFqPBRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDoxNzoxN1rOFqPO0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzMDU5OQ==", "bodyText": "Highly unlikely, but unfinishedResponses + 1 can overflow theoretically. How about this?\nif (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n\nor ..\nfinal int numRemainingStreams =\n        session.maxUnfinishedResponses() - session.unfinishedResponses();\nif (numRemainingStreams <= 1) {", "url": "https://github.com/line/armeria/pull/2374#discussion_r379830599", "createdAt": "2020-02-15T13:10:15Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,13 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    final int activeRequests = session.unfinishedResponses() + 1;\n+                    if (activeRequests >= session.maxUnfinishedResponses()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd25d2635f499c5e310e2b41ba34aa5feb00118"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNDA2Nw==", "bodyText": "good point (hadn't really thought about this -- will keep in mind for future PRs as well)  thanks \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2374#discussion_r379834067", "createdAt": "2020-02-15T14:17:17Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,13 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    final int activeRequests = session.unfinishedResponses() + 1;\n+                    if (activeRequests >= session.maxUnfinishedResponses()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzMDU5OQ=="}, "originalCommit": {"oid": "6cd25d2635f499c5e310e2b41ba34aa5feb00118"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxNjUwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1NzoyMFrOFqPWnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1NzoyMFrOFqPWnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjA2MA==", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836060", "createdAt": "2020-02-15T14:57:20Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxNjUzOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1NzozMFrOFqPWow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1NzozMFrOFqPWow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjA2Nw==", "bodyText": "Could use LinkedBlockingQueue or LinkedTransferQueue for thread safety, given that the list will be updated from a different thread. Could be removed as well.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836067", "createdAt": "2020-02-15T14:57:30Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final int sleepMillis = 300;\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                Thread.sleep(sleepMillis);\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxNjYxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1Nzo0OFrOFqPWrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1Nzo0OFrOFqPWrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjA3Nw==", "bodyText": "Could be removed.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836077", "createdAt": "2020-02-15T14:57:48Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 263}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxNzI3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1ODo1N1rOFqPW-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1ODo1N1rOFqPW-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjE1Mw==", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836153", "createdAt": "2020-02-15T14:58:57Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxNzQ5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1OTo1OFrOFqPXIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1OTo1OFrOFqPXIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjE5Mg==", "bodyText": "This seems unused.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836192", "createdAt": "2020-02-15T14:59:58Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxNzUxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowMDoxNFrOFqPXJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowMDoxNFrOFqPXJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjE5Nw==", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836197", "createdAt": "2020-02-15T15:00:14Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxNzcwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowMDo0MlrOFqPXOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowMDo0MlrOFqPXOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjIxOQ==", "bodyText": "Could be removed.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836219", "createdAt": "2020-02-15T15:00:42Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxNzg4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowMDo1NlrOFqPXUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowMDo1NlrOFqPXUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjI0Mw==", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836243", "createdAt": "2020-02-15T15:00:56Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxODYxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowMjoyOVrOFqPXsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowMjoyOVrOFqPXsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjMzNg==", "bodyText": "Could be deduplicated?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836336", "createdAt": "2020-02-15T15:02:29Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUxOTM0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowNDowOFrOFqPYBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowNDowOFrOFqPYBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjQyMw==", "bodyText": "initial connect -> an initial connection attempt ?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836423", "createdAt": "2020-02-15T15:04:08Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final int sleepMillis = 300;\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                Thread.sleep(sleepMillis);\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+\n+        // There should be at least one request with at least numConnections * pendingAcquisitionsDuration\n+        final Long maxPendingAcquisitionDurationNanos = connectionTimings.stream().mapToLong(\n+                ClientConnectionTimings::pendingAcquisitionDurationNanos).max().orElse(0L);\n+        assertThat(maxPendingAcquisitionDurationNanos)\n+                .isGreaterThan(TimeUnit.MILLISECONDS.toNanos(sleepMillis * numConnections));\n+    }\n+\n+    // running inside an event loop ensures requests are queued before initial connect completes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 326}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUyMDQxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowNjozMlrOFqPYjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowNjozMlrOFqPYjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjU1Ng==", "bodyText": "Could extract into a constant?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836556", "createdAt": "2020-02-15T15:06:32Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -62,6 +69,8 @@ protected void configure(ServerBuilder sb) throws Exception {\n                 return HttpResponse.from(f);\n             });\n             sb.http2MaxStreamsPerConnection(MAX_CONCURRENT_STREAMS);\n+            sb.maxNumConnections(6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDUyMDc3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowNzoxNFrOFqPYug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowNzoxNFrOFqPYug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjYwMg==", "bodyText": "Could be deduplicated as well?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836602", "createdAt": "2020-02-15T15:07:14Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDc0OTIxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwMDoyOTozNFrOFqRKUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwNjo0NjoyN1rOFqSAQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2NTY4Mg==", "bodyText": "flaky test stacktrace\nHttpClientMaxConcurrentStreamTest > exceededMaxStreamsPropagatesFailureCorrectly() FAILED\n    java.lang.IllegalStateException: java.util.concurrent.CompletionException: com.linecorp.armeria.client.UnprocessedRequestException: io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n        at com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.lambda$exceededMaxStreamsPropagatesFailureCorrectly$18(HttpClientMaxConcurrentStreamTest.java:305)\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n        at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\n        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)\n        at com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.exceededMaxStreamsPropagatesFailureCorrectly(HttpClientMaxConcurrentStreamTest.java:300)\n        Caused by:\n        java.util.concurrent.CompletionException: com.linecorp.armeria.client.UnprocessedRequestException: io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n            at java.util.concurrent.CompletableFuture.reportJoin(CompletableFuture.java:375)\n            at java.util.concurrent.CompletableFuture.join(CompletableFuture.java:1947)\n            at com.linecorp.armeria.common.util.EventLoopCheckingFuture.join(EventLoopCheckingFuture.java:70)\n            at org.assertj.core.api.ThrowableAssert.catchThrowable(ThrowableAssert.java:62)\n            at org.assertj.core.api.AssertionsForClassTypes.catchThrowable(AssertionsForClassTypes.java:750)\n            at org.assertj.core.api.Assertions.catchThrowable(Assertions.java:1179)\n            at com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.lambda$exceededMaxStreamsPropagatesFailureCorrectly$18(HttpClientMaxConcurrentStreamTest.java:301)\n            ... 10 more\n            Caused by:\n            com.linecorp.armeria.client.UnprocessedRequestException: io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n                at com.linecorp.armeria.client.HttpChannelPool.notifyConnect(HttpChannelPool.java:481)\n                at com.linecorp.armeria.client.HttpChannelPool.lambda$connect$5(HttpChannelPool.java:354)\n                at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\n                at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\n                at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\n                at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\n                at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\n                at io.netty.util.concurrent.DefaultPromise.setFailure(DefaultPromise.java:109)\n                at com.linecorp.armeria.client.HttpChannelPool.lambda$connect$6(HttpChannelPool.java:376)\n                at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\n                at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)\n                at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)\n                at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\n                at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\n                at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\n                at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.fulfillConnectPromise(AbstractEpollChannel.java:636)\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.finishConnect(AbstractEpollChannel.java:655)\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.epollOutReady(AbstractEpollChannel.java:529)\n                at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:465)\n                at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)\n                at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n                at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n                at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n                at java.lang.Thread.run(Thread.java:748)\n                Caused by:\n                io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n                    Caused by:\n                    java.net.ConnectException: finishConnect(..) failed: Connection reset by peer\n                        at io.netty.channel.unix.Errors.throwConnectException(Errors.java:124)\n                        at io.netty.channel.unix.Socket.finishConnect(Socket.java:243)\n                        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.doFinishConnect(AbstractEpollChannel.java:672)\n                        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.finishConnect(AbstractEpollChannel.java:649)\n                        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.epollOutReady(AbstractEpollChannel.java:529)\n                        at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:465)\n                        at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)\n                        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n                        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n                        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n                        at java.lang.Thread.run(Thread.java:748)", "url": "https://github.com/line/armeria/pull/2374#discussion_r379865682", "createdAt": "2020-02-16T00:29:34Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +217,184 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             if (!(throwable.getCause().getCause() instanceof ClosedSessionException)) {\n+                                 throw new IllegalStateException(throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3OTQ5MA==", "bodyText": "decided to also accept reset from server side as a valid exception for now...", "url": "https://github.com/line/armeria/pull/2374#discussion_r379879490", "createdAt": "2020-02-16T06:46:27Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +217,184 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             if (!(throwable.getCause().getCause() instanceof ClosedSessionException)) {\n+                                 throw new IllegalStateException(throwable);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2NTY4Mg=="}, "originalCommit": {"oid": "c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTg3OTE3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo0Njo1N1rOFqa1Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo0Njo1N1rOFqa1Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNDA3OA==", "bodyText": "MAX_NUM_CONNECTIONS", "url": "https://github.com/line/armeria/pull/2374#discussion_r380024078", "createdAt": "2020-02-17T07:46:57Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +218,185 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses\n+                .stream().filter(CompletableFuture::isCompletedExceptionally)\n+                .forEach(responseFuture -> {\n+                    final Throwable throwable = catchThrowable(responseFuture::join);\n+                    assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                         .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                    assertThat(throwable.getCause().getCause()).satisfiesAnyOf(\n+                            e -> assertThat(e).isInstanceOf(ClosedSessionException.class),\n+                            e -> assertThat(e).isInstanceOf(ConnectException.class)\n+                                                .hasMessageContaining(\"reset by peer\"));\n+                });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 6;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTg4MTg4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo0ODoxN1rOFqa2uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo0ODoxN1rOFqa2uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNDUwNw==", "bodyText": "Could you move these three methods to the bottom for readability?", "url": "https://github.com/line/armeria/pull/2374#discussion_r380024507", "createdAt": "2020-02-17T07:48:17Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -62,9 +71,59 @@ protected void configure(ServerBuilder sb) throws Exception {\n                 return HttpResponse.from(f);\n             });\n             sb.http2MaxStreamsPerConnection(MAX_CONCURRENT_STREAMS);\n+            sb.maxNumConnections(MAX_NUM_CONNECTIONS);\n+            sb.idleTimeoutMillis(3000);\n         }\n     };\n \n+    @RegisterExtension\n+    static final ServerExtension serverWithMaxConcurrentStreams_1 = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(PATH, (ctx, req) -> {\n+                final CompletableFuture<HttpResponse> f = new CompletableFuture<>();\n+                responses.add(f);\n+                return HttpResponse.from(f);\n+            });\n+            sb.http2MaxStreamsPerConnection(1);\n+            sb.maxNumConnections(MAX_NUM_CONNECTIONS);\n+            sb.idleTimeoutMillis(3000);\n+        }\n+    };\n+\n+    // running inside an event loop ensures requests are queued before an initial connect attempt completes.\n+    private static void runInsideEventLoop(EventLoopGroup eventLoopGroup, Runnable runnable) {\n+        eventLoopGroup.execute(runnable);\n+    }\n+\n+    private static DecoratingHttpClientFunction connectionTimingsAccumulatingDecorator(\n+            Queue<ClientConnectionTimings> connectionTimings) {\n+        return (delegate, ctx, req) -> {\n+            ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+               .thenAccept(requestLog -> {\n+                   connectionTimings.add(requestLog.connectionTimings());\n+               });\n+            return delegate.execute(ctx, req);\n+        };\n+    }\n+\n+    private static ConnectionPoolListener newConnectionPoolListener(\n+            Runnable openRunnable, Runnable closeRunnable) {\n+        return new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                openRunnable.run();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closeRunnable.run();\n+            }\n+        };\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTg5MjE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo1Mjo1N1rOFqa8rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwODoyNDozOFrOFqbpTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ==", "bodyText": "Don't we need to limit pending acquisition time? I think we have no chance to trigger timeout for long waiting requests. \ud83e\uddd0 Any thoughts? /cc @trustin", "url": "https://github.com/line/armeria/pull/2374#discussion_r380026029", "createdAt": "2020-02-17T07:52:57Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMDgzNw==", "bodyText": "Agreed. Probably worth a separate pull request?", "url": "https://github.com/line/armeria/pull/2374#discussion_r380030837", "createdAt": "2020-02-17T08:06:57Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMTI5MQ==", "bodyText": "Oh, that is better. \ud83d\udc4d", "url": "https://github.com/line/armeria/pull/2374#discussion_r380031291", "createdAt": "2020-02-17T08:08:22Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMjEzOA==", "bodyText": "You mean on the off-chance an unknowing user uses MAX_CONCURRENT_STREAMS = 1 and burst requests 10000 connections at ocne right?\nLet me create a separate issue for this as this had me a little worried as well", "url": "https://github.com/line/armeria/pull/2374#discussion_r380032138", "createdAt": "2020-02-17T08:10:49Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMjc0Ng==", "bodyText": "You can set a special timeout for pending acquisition time, or could set a call timeout like OkHttp? https://square.github.io/okhttp/4.x/okhttp/okhttp3/-call/timeout/", "url": "https://github.com/line/armeria/pull/2374#discussion_r380032746", "createdAt": "2020-02-17T08:12:27Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzNDg0NA==", "bodyText": "Maybe just reuse ChannelOption.CONNECT_TIMEOUT and later introduce a new option if there's demand?", "url": "https://github.com/line/armeria/pull/2374#discussion_r380034844", "createdAt": "2020-02-17T08:18:03Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzNjcxOQ==", "bodyText": "sounds good to me as I don't think most users will know what pendingAcquisitionTimeoutMillis is \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2374#discussion_r380036719", "createdAt": "2020-02-17T08:22:54Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzNzQ1Mg==", "bodyText": "Agreed! I saw only ClientOption.*TIMEOUT_MILLIS. ChannelOption.CONNECT_TIMEOUT makes sense.", "url": "https://github.com/line/armeria/pull/2374#discussion_r380037452", "createdAt": "2020-02-17T08:24:38Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTg5ODM2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo1NTo0NFrOFqbAXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo1NTo0NFrOFqbAXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjk3NA==", "bodyText": "nit: serverWithMaxConcurrentStreams1? Prefer camel case for variables. \ud83d\ude00", "url": "https://github.com/line/armeria/pull/2374#discussion_r380026974", "createdAt": "2020-02-17T07:55:44Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -62,9 +71,59 @@ protected void configure(ServerBuilder sb) throws Exception {\n                 return HttpResponse.from(f);\n             });\n             sb.http2MaxStreamsPerConnection(MAX_CONCURRENT_STREAMS);\n+            sb.maxNumConnections(MAX_NUM_CONNECTIONS);\n+            sb.idleTimeoutMillis(3000);\n         }\n     };\n \n+    @RegisterExtension\n+    static final ServerExtension serverWithMaxConcurrentStreams_1 = new ServerExtension() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTkxNTczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwODowMzoyNlrOFqbKtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwODoxNzowM1rOFqbdpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyOTYyMw==", "bodyText": "Could remove !pendingAcquisitionEndSet?", "url": "https://github.com/line/armeria/pull/2374#discussion_r380029623", "createdAt": "2020-02-17T08:03:26Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -95,8 +95,10 @@ public ClientConnectionTimingsBuilder socketConnectEnd() {\n      * in order to use one connection for HTTP/2.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n-        pendingAcquisitionStartTimeMicros = SystemInfo.currentTimeMicros();\n-        pendingAcquisitionStartNanos = System.nanoTime();\n+        if (pendingAcquisitionStartTimeMicros == 0 && !pendingAcquisitionEndSet) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMjUwMQ==", "bodyText": "I think we can't because pendingAcquisitionStart* will be overwritten", "url": "https://github.com/line/armeria/pull/2374#discussion_r380032501", "createdAt": "2020-02-17T08:11:50Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -95,8 +95,10 @@ public ClientConnectionTimingsBuilder socketConnectEnd() {\n      * in order to use one connection for HTTP/2.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n-        pendingAcquisitionStartTimeMicros = SystemInfo.currentTimeMicros();\n-        pendingAcquisitionStartNanos = System.nanoTime();\n+        if (pendingAcquisitionStartTimeMicros == 0 && !pendingAcquisitionEndSet) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyOTYyMw=="}, "originalCommit": {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzNDQ2OA==", "bodyText": "Ah, please ignore this preview. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2374#discussion_r380034468", "createdAt": "2020-02-17T08:17:03Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -95,8 +95,10 @@ public ClientConnectionTimingsBuilder socketConnectEnd() {\n      * in order to use one connection for HTTP/2.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n-        pendingAcquisitionStartTimeMicros = SystemInfo.currentTimeMicros();\n-        pendingAcquisitionStartNanos = System.nanoTime();\n+        if (pendingAcquisitionStartTimeMicros == 0 && !pendingAcquisitionEndSet) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyOTYyMw=="}, "originalCommit": {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTkyMjIxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwODowNjoyN1rOFqbOuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwODowNjoyN1rOFqbOuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMDY1MQ==", "bodyText": "Remove public for methods and class?", "url": "https://github.com/line/armeria/pull/2374#discussion_r380030651", "createdAt": "2020-02-17T08:06:27Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -92,16 +118,16 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n     @Nullable\n     private volatile ConnectionPoolListener connectionPoolListener;\n \n-    @Before\n+    @BeforeEach\n     public void setUp() {\n         clientFactory = ClientFactory.builder()\n                                      .workerGroup(EventLoopGroups.newEventLoopGroup(1), true)\n                                      .connectionPoolListener(connectionPoolListenerWrapper)\n                                      .build();\n     }\n \n-    @After\n-    public void tearDown() {\n+    @AfterEach\n+    public void tearDown() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d"}, "originalPosition": 100}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2869, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}