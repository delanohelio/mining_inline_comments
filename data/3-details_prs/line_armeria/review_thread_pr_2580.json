{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3NjcxNzAw", "number": 2580, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozNjozNFrODnxKcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozNjozNFrODnxKcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDI2NTQ3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozNjozNVrOF19EGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDoyMToxOVrOF1-brA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTMyMA==", "bodyText": "Is there any chance that the previousCause is not suppressible?", "url": "https://github.com/line/armeria/pull/2580#discussion_r392119320", "createdAt": "2020-03-13T09:36:35Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java", "diffHunk": "@@ -322,34 +324,53 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n             channelPool.connect(channel.remoteAddress(), H1C, sessionPromise);\n         } else {\n             // Fail all pending responses.\n-            final Throwable throwable;\n-            if (ctx.channel().hasAttr(PENDING_EXCEPTION)) {\n-                throwable = ctx.channel().attr(PENDING_EXCEPTION).get();\n+            final HttpResponseDecoder responseDecoder = this.responseDecoder;\n+            final Throwable pendingException;\n+            if (responseDecoder != null && responseDecoder.hasUnfinishedResponses()) {\n+                pendingException = getPendingException(ctx);\n+                responseDecoder.failUnfinishedResponses(pendingException);\n             } else {\n-                throwable = ClosedSessionException.get();\n+                pendingException = null;\n             }\n-            failUnfinishedResponses(throwable);\n+\n             // Cancel the timeout and reject the sessionPromise just in case the connection has been closed\n             // even before the session protocol negotiation is done.\n             sessionTimeoutFuture.cancel(false);\n-            sessionPromise.tryFailure(throwable);\n+            if (!sessionPromise.isDone()) {\n+                sessionPromise.tryFailure(pendingException != null ? pendingException\n+                                                                   : getPendingException(ctx));\n+            }\n         }\n     }\n \n     @Override\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        setPendingException(ctx, new ClosedSessionException(cause));\n         Exceptions.logIfUnexpected(logger, channel, protocol(), cause);\n-        if (channel.isActive()) {\n+        if (!(cause instanceof IOException)) {\n             ctx.close();\n+        } else {\n+            // Netty will close the connection automatically on an IOException.\n         }\n     }\n \n-    private void failUnfinishedResponses(Throwable e) {\n-        final HttpResponseDecoder responseDecoder = this.responseDecoder;\n-        if (responseDecoder == null) {\n-            return;\n+    private static Throwable getPendingException(ChannelHandlerContext ctx) {\n+        if (ctx.channel().hasAttr(PENDING_EXCEPTION)) {\n+            return ctx.channel().attr(PENDING_EXCEPTION).get();\n         }\n \n-        responseDecoder.failUnfinishedResponses(e);\n+        return ClosedSessionException.get();\n+    }\n+\n+    static void setPendingException(ChannelHandlerContext ctx, Throwable cause) {\n+        final Attribute<Throwable> attr = ctx.channel().attr(PENDING_EXCEPTION);\n+        final Throwable previousCause = attr.get();\n+        if (previousCause == null) {\n+            attr.set(cause);\n+        } else if (previousCause != cause) {\n+            previousCause.addSuppressed(cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b40ef7e9c724f687cd25b9195d645627911233f"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEzNTYwOA==", "bodyText": "It's possible but we need to preserve the type of the original exception, such as UnprocessedRequestException.", "url": "https://github.com/line/armeria/pull/2580#discussion_r392135608", "createdAt": "2020-03-13T10:08:45Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java", "diffHunk": "@@ -322,34 +324,53 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n             channelPool.connect(channel.remoteAddress(), H1C, sessionPromise);\n         } else {\n             // Fail all pending responses.\n-            final Throwable throwable;\n-            if (ctx.channel().hasAttr(PENDING_EXCEPTION)) {\n-                throwable = ctx.channel().attr(PENDING_EXCEPTION).get();\n+            final HttpResponseDecoder responseDecoder = this.responseDecoder;\n+            final Throwable pendingException;\n+            if (responseDecoder != null && responseDecoder.hasUnfinishedResponses()) {\n+                pendingException = getPendingException(ctx);\n+                responseDecoder.failUnfinishedResponses(pendingException);\n             } else {\n-                throwable = ClosedSessionException.get();\n+                pendingException = null;\n             }\n-            failUnfinishedResponses(throwable);\n+\n             // Cancel the timeout and reject the sessionPromise just in case the connection has been closed\n             // even before the session protocol negotiation is done.\n             sessionTimeoutFuture.cancel(false);\n-            sessionPromise.tryFailure(throwable);\n+            if (!sessionPromise.isDone()) {\n+                sessionPromise.tryFailure(pendingException != null ? pendingException\n+                                                                   : getPendingException(ctx));\n+            }\n         }\n     }\n \n     @Override\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        setPendingException(ctx, new ClosedSessionException(cause));\n         Exceptions.logIfUnexpected(logger, channel, protocol(), cause);\n-        if (channel.isActive()) {\n+        if (!(cause instanceof IOException)) {\n             ctx.close();\n+        } else {\n+            // Netty will close the connection automatically on an IOException.\n         }\n     }\n \n-    private void failUnfinishedResponses(Throwable e) {\n-        final HttpResponseDecoder responseDecoder = this.responseDecoder;\n-        if (responseDecoder == null) {\n-            return;\n+    private static Throwable getPendingException(ChannelHandlerContext ctx) {\n+        if (ctx.channel().hasAttr(PENDING_EXCEPTION)) {\n+            return ctx.channel().attr(PENDING_EXCEPTION).get();\n         }\n \n-        responseDecoder.failUnfinishedResponses(e);\n+        return ClosedSessionException.get();\n+    }\n+\n+    static void setPendingException(ChannelHandlerContext ctx, Throwable cause) {\n+        final Attribute<Throwable> attr = ctx.channel().attr(PENDING_EXCEPTION);\n+        final Throwable previousCause = attr.get();\n+        if (previousCause == null) {\n+            attr.set(cause);\n+        } else if (previousCause != cause) {\n+            previousCause.addSuppressed(cause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTMyMA=="}, "originalCommit": {"oid": "9b40ef7e9c724f687cd25b9195d645627911233f"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEzODg4OQ==", "bodyText": "Yes couldn't think of that. \ud83d\ude05", "url": "https://github.com/line/armeria/pull/2580#discussion_r392138889", "createdAt": "2020-03-13T10:15:33Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java", "diffHunk": "@@ -322,34 +324,53 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n             channelPool.connect(channel.remoteAddress(), H1C, sessionPromise);\n         } else {\n             // Fail all pending responses.\n-            final Throwable throwable;\n-            if (ctx.channel().hasAttr(PENDING_EXCEPTION)) {\n-                throwable = ctx.channel().attr(PENDING_EXCEPTION).get();\n+            final HttpResponseDecoder responseDecoder = this.responseDecoder;\n+            final Throwable pendingException;\n+            if (responseDecoder != null && responseDecoder.hasUnfinishedResponses()) {\n+                pendingException = getPendingException(ctx);\n+                responseDecoder.failUnfinishedResponses(pendingException);\n             } else {\n-                throwable = ClosedSessionException.get();\n+                pendingException = null;\n             }\n-            failUnfinishedResponses(throwable);\n+\n             // Cancel the timeout and reject the sessionPromise just in case the connection has been closed\n             // even before the session protocol negotiation is done.\n             sessionTimeoutFuture.cancel(false);\n-            sessionPromise.tryFailure(throwable);\n+            if (!sessionPromise.isDone()) {\n+                sessionPromise.tryFailure(pendingException != null ? pendingException\n+                                                                   : getPendingException(ctx));\n+            }\n         }\n     }\n \n     @Override\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        setPendingException(ctx, new ClosedSessionException(cause));\n         Exceptions.logIfUnexpected(logger, channel, protocol(), cause);\n-        if (channel.isActive()) {\n+        if (!(cause instanceof IOException)) {\n             ctx.close();\n+        } else {\n+            // Netty will close the connection automatically on an IOException.\n         }\n     }\n \n-    private void failUnfinishedResponses(Throwable e) {\n-        final HttpResponseDecoder responseDecoder = this.responseDecoder;\n-        if (responseDecoder == null) {\n-            return;\n+    private static Throwable getPendingException(ChannelHandlerContext ctx) {\n+        if (ctx.channel().hasAttr(PENDING_EXCEPTION)) {\n+            return ctx.channel().attr(PENDING_EXCEPTION).get();\n         }\n \n-        responseDecoder.failUnfinishedResponses(e);\n+        return ClosedSessionException.get();\n+    }\n+\n+    static void setPendingException(ChannelHandlerContext ctx, Throwable cause) {\n+        final Attribute<Throwable> attr = ctx.channel().attr(PENDING_EXCEPTION);\n+        final Throwable previousCause = attr.get();\n+        if (previousCause == null) {\n+            attr.set(cause);\n+        } else if (previousCause != cause) {\n+            previousCause.addSuppressed(cause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTMyMA=="}, "originalCommit": {"oid": "9b40ef7e9c724f687cd25b9195d645627911233f"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0MTc0MA==", "bodyText": "Now just logging, instead of suppressing.", "url": "https://github.com/line/armeria/pull/2580#discussion_r392141740", "createdAt": "2020-03-13T10:21:19Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java", "diffHunk": "@@ -322,34 +324,53 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n             channelPool.connect(channel.remoteAddress(), H1C, sessionPromise);\n         } else {\n             // Fail all pending responses.\n-            final Throwable throwable;\n-            if (ctx.channel().hasAttr(PENDING_EXCEPTION)) {\n-                throwable = ctx.channel().attr(PENDING_EXCEPTION).get();\n+            final HttpResponseDecoder responseDecoder = this.responseDecoder;\n+            final Throwable pendingException;\n+            if (responseDecoder != null && responseDecoder.hasUnfinishedResponses()) {\n+                pendingException = getPendingException(ctx);\n+                responseDecoder.failUnfinishedResponses(pendingException);\n             } else {\n-                throwable = ClosedSessionException.get();\n+                pendingException = null;\n             }\n-            failUnfinishedResponses(throwable);\n+\n             // Cancel the timeout and reject the sessionPromise just in case the connection has been closed\n             // even before the session protocol negotiation is done.\n             sessionTimeoutFuture.cancel(false);\n-            sessionPromise.tryFailure(throwable);\n+            if (!sessionPromise.isDone()) {\n+                sessionPromise.tryFailure(pendingException != null ? pendingException\n+                                                                   : getPendingException(ctx));\n+            }\n         }\n     }\n \n     @Override\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        setPendingException(ctx, new ClosedSessionException(cause));\n         Exceptions.logIfUnexpected(logger, channel, protocol(), cause);\n-        if (channel.isActive()) {\n+        if (!(cause instanceof IOException)) {\n             ctx.close();\n+        } else {\n+            // Netty will close the connection automatically on an IOException.\n         }\n     }\n \n-    private void failUnfinishedResponses(Throwable e) {\n-        final HttpResponseDecoder responseDecoder = this.responseDecoder;\n-        if (responseDecoder == null) {\n-            return;\n+    private static Throwable getPendingException(ChannelHandlerContext ctx) {\n+        if (ctx.channel().hasAttr(PENDING_EXCEPTION)) {\n+            return ctx.channel().attr(PENDING_EXCEPTION).get();\n         }\n \n-        responseDecoder.failUnfinishedResponses(e);\n+        return ClosedSessionException.get();\n+    }\n+\n+    static void setPendingException(ChannelHandlerContext ctx, Throwable cause) {\n+        final Attribute<Throwable> attr = ctx.channel().attr(PENDING_EXCEPTION);\n+        final Throwable previousCause = attr.get();\n+        if (previousCause == null) {\n+            attr.set(cause);\n+        } else if (previousCause != cause) {\n+            previousCause.addSuppressed(cause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTMyMA=="}, "originalCommit": {"oid": "9b40ef7e9c724f687cd25b9195d645627911233f"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2768, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}