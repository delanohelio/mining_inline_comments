{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMjUzNDkw", "number": 3080, "title": "Provide request context cancellation", "bodyText": "Motivation:\n\nProvide a general way to cancel a client's response or service's request. Previously, we can do this with RequestContext.timeoutNow(), which always stops the request with a TimeoutException. Now we can use a more general RequestContext.cancel() or cancel(Throwable).\n\nModifications:\n\nIn RequestContext, add cancel(Throwable). Make timeoutNow() and cancel() shortcuts for cancel(Throwable) with the appropriate exceptions.\nAdd cancellationCause() which returns the final cause if cancellation happens and isCancelled() to check if the context has been cancelled.\nIn ClientRequestContext, add whenResponseCancelling() and whenResponseCancelled(), which return futures that are completed with the cancellation cause if cancellation happens. In effect deprecate whenResponseTimingOut() and whenResponseTimedOut().\nSame for ServiceRequestContext with whenRequestCancelling() and whenRequestCancelled().\nAdd CancellationException and subclasses to provide comprehensive cancellation causes.\nInternally, rename and modify TimeoutScheduler for this task.\n\nResult:\n\nCloses #3046.\nYou can cancel the response of a client's request or the request received by a service with any Throwable.\nDeprecate whenResponseTimingOut, whenResponseTimedOut, whenRequestTimingOut, whenRequestTimedOut.", "createdAt": "2020-09-23T00:00:31Z", "url": "https://github.com/line/armeria/pull/3080", "merged": true, "mergeCommit": {"oid": "97e23218b95f6e047d29ac75cf6ab53ede1ea4a5"}, "closed": true, "closedAt": "2020-10-16T07:45:48Z", "author": {"login": "tumile"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLg411gH2gAyNDkxMjUzNDkwOjFiOTc3MjU5OGY4NGU1OGVkMmY2ZjhmMTY0NWZiZmRlOWRlNjcxMjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdTBMllgFqTUwOTk4OTA2NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1b9772598f84e58ed2f6f8f1645fbfde9de67127", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/1b9772598f84e58ed2f6f8f1645fbfde9de67127", "committedDate": "2020-09-22T23:49:27Z", "message": "Add request cancel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/3eae085f97feebfe56dd5fc3bd2889eb513be4ba", "committedDate": "2020-09-23T04:00:37Z", "message": "Add tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MTk2NTI0", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-495196524", "createdAt": "2020-09-24T03:37:00Z", "commit": {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMzozNzowMFrOHXIf8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMzo0MjoxOFrOHXIk8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxODU0Ng==", "bodyText": "We should do delegate.close(cause); before ctx.request().abort(cause);", "url": "https://github.com/line/armeria/pull/3080#discussion_r494018546", "createdAt": "2020-09-24T03:37:00Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -391,12 +392,15 @@ public boolean canSchedule() {\n \n                 @Override\n                 public void run() {\n-                    final ResponseTimeoutException cause = ResponseTimeoutException.get();\n-                    delegate.close(cause);\n+                    RuntimeException cause = ResponseTimeoutException.get();\n                     if (ctx != null) {\n+                        if (ctx.isCancelled()) {\n+                            cause = new CancellationException();\n+                        }\n                         ctx.request().abort(cause);\n                         ctx.logBuilder().endResponse(cause);\n                     }\n+                    delegate.close(cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxOTgyNQ==", "bodyText": "It seems like canceling the response timeout to me. Should we rename the TimeoutScheduler? \ud83e\udd14\n/cc @ikhoon", "url": "https://github.com/line/armeria/pull/3080#discussion_r494019825", "createdAt": "2020-09-24T03:42:18Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -586,6 +586,16 @@ public boolean isTimedOut() {\n         return responseTimeoutScheduler.isTimedOut();\n     }\n \n+    @Override\n+    public void cancel() {\n+        responseTimeoutScheduler.cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MjM2OTA5", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-495236909", "createdAt": "2020-09-24T05:49:42Z", "commit": {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNTo0OTo0MlrOHXKoQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNjowNDo0NlrOHXK7dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1MzQ0MA==", "bodyText": "Don't we need to introduce RequestCancellationException and make it singletone?", "url": "https://github.com/line/armeria/pull/3080#discussion_r494053440", "createdAt": "2020-09-24T05:49:42Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -391,12 +392,15 @@ public boolean canSchedule() {\n \n                 @Override\n                 public void run() {\n-                    final ResponseTimeoutException cause = ResponseTimeoutException.get();\n-                    delegate.close(cause);\n+                    RuntimeException cause = ResponseTimeoutException.get();\n                     if (ctx != null) {\n+                        if (ctx.isCancelled()) {\n+                            cause = new CancellationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1NDQ2OQ==", "bodyText": "Is it better to move these methods down to ClientRequestContext? \ud83e\udd14", "url": "https://github.com/line/armeria/pull/3080#discussion_r494054469", "createdAt": "2020-09-24T05:52:58Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -377,6 +378,16 @@ default boolean hasOwnAttr(AttributeKey<?> key) {\n      */\n     boolean isTimedOut();\n \n+    /**\n+     * Cancels the request. Similar to {@link #timeoutNow()}, but throws a {@link CancellationException}.\n+     */\n+    void cancel();\n+\n+    /**\n+     * Returns whether this {@link RequestContext} has been cancelled.\n+     */\n+    boolean isCancelled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1NzgzNQ==", "bodyText": "Agreed. How about making timeoutNow() take an Exception that could be used when TimeoutTask is invoked?\n// in TimeoutScheduler\nvoid timeoutNow(Throwable cause) {\n   ...\n}\n@Nullable\nThrowable timeoutCause() { ... }\n\n// in HttpResponseDecoder\nThrowable cause = timeoutScheduler.timeoutCause();\nif (cause == null) {\n    cause = ResponseTimeoutException.get();\n} \n...", "url": "https://github.com/line/armeria/pull/3080#discussion_r494057835", "createdAt": "2020-09-24T06:03:23Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -586,6 +586,16 @@ public boolean isTimedOut() {\n         return responseTimeoutScheduler.isTimedOut();\n     }\n \n+    @Override\n+    public void cancel() {\n+        responseTimeoutScheduler.cancel();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxOTgyNQ=="}, "originalCommit": {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1ODM1OA==", "bodyText": "Don't we need to complete whenTimingOut and whenTimedOut even if it is cancelled? Unless the futures never complete forever.", "url": "https://github.com/line/armeria/pull/3080#discussion_r494058358", "createdAt": "2020-09-24T06:04:46Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -416,13 +435,21 @@ private void invokeTimeoutTask() {\n             if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n                 whenTimedOut.doComplete();\n             }\n+        } else {\n+            // Set CANCELLED flag first to prevent duplicate execution\n+            state = State.CANCELLED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7395d5aa168a1fa9bc47d7f4f4e22af29a784a53", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/7395d5aa168a1fa9bc47d7f4f4e22af29a784a53", "committedDate": "2020-09-26T00:48:36Z", "message": "Move cancel to ClientRequestContext"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e18b5d9b04530c19473215aa3d4918f35a9c207", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/9e18b5d9b04530c19473215aa3d4918f35a9c207", "committedDate": "2020-09-26T21:26:39Z", "message": "Add RequestCancellationException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50558a44188096ff36b0e0c130217bd6f50c7d9c", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/50558a44188096ff36b0e0c130217bd6f50c7d9c", "committedDate": "2020-09-26T21:46:50Z", "message": "Fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cb2a997a8e916e4ef7febd444d8afc016f934fd", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/0cb2a997a8e916e4ef7febd444d8afc016f934fd", "committedDate": "2020-10-01T22:17:46Z", "message": "Merge branch 'master' of github.com:line/armeria into request-cancel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10713ff0a82020c156e6947f34d5e2394b951201", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/10713ff0a82020c156e6947f34d5e2394b951201", "committedDate": "2020-10-03T19:57:55Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "committedDate": "2020-10-03T20:31:46Z", "message": "Fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNzM3NTQ3", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-501737547", "createdAt": "2020-10-05T05:53:53Z", "commit": {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNTo1Mzo1M1rOHcOaKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjoxNjoxOVrOHcOySA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1ODI1MA==", "bodyText": "This is not thread safe and could override the original cause if a request was cancelled already.\nQuestion: Do we need to save cancellationCause in this class?", "url": "https://github.com/line/armeria/pull/3080#discussion_r499358250", "createdAt": "2020-10-05T05:53:53Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -572,28 +576,50 @@ public RequestLogBuilder logBuilder() {\n         return log;\n     }\n \n-    TimeoutScheduler responseTimeoutScheduler() {\n-        return responseTimeoutScheduler;\n+    TimeoutScheduler responseCancellationScheduler() {\n+        return responseCancellationScheduler;\n+    }\n+\n+    @Override\n+    public void cancel(Throwable cause) {\n+        cancellationCause = cause;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1ODg0Nw==", "bodyText": "nit: Could you break this line between setTimeoutNanos( and requireNonNull(...) for readability.", "url": "https://github.com/line/armeria/pull/3080#discussion_r499358847", "createdAt": "2020-10-05T05:56:09Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -498,24 +501,25 @@ public void setWriteTimeout(Duration writeTimeout) {\n \n     @Override\n     public long responseTimeoutMillis() {\n-        return TimeUnit.NANOSECONDS.toMillis(responseTimeoutScheduler.timeoutNanos());\n+        return TimeUnit.NANOSECONDS.toMillis(responseCancellationScheduler.timeoutNanos());\n     }\n \n     @Override\n     public void clearResponseTimeout() {\n-        responseTimeoutScheduler.clearTimeout();\n+        responseCancellationScheduler.clearTimeout();\n     }\n \n     @Override\n     public void setResponseTimeoutMillis(TimeoutMode mode, long responseTimeoutMillis) {\n-        responseTimeoutScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n-                                                 TimeUnit.MILLISECONDS.toNanos(responseTimeoutMillis));\n+        responseCancellationScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n+                                                      TimeUnit.MILLISECONDS.toNanos(responseTimeoutMillis));\n     }\n \n     @Override\n     public void setResponseTimeout(TimeoutMode mode, Duration responseTimeout) {\n-        responseTimeoutScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n-                                                 requireNonNull(responseTimeout, \"responseTimeout\").toNanos());\n+        responseCancellationScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1OTMzMQ==", "bodyText": "This is not a singleton if Flags.verboseExceptionSampler().isSampled(...) returns true.", "url": "https://github.com/line/armeria/pull/3080#discussion_r499359331", "createdAt": "2020-10-05T05:57:58Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/RequestCancellationException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+/**\n+ * A {@link RuntimeException} raised when a request is cancelled by the user.\n+ */\n+public final class RequestCancellationException extends RuntimeException {\n+\n+    private static final long serialVersionUID = -8891853443874862294L;\n+\n+    private static final RequestCancellationException INSTANCE = new RequestCancellationException();\n+\n+    /**\n+     * Returns a singleton {@link RequestCancellationException}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MjE4MQ==", "bodyText": "\ud83d\ude47\u200d\u2642\ufe0f", "url": "https://github.com/line/armeria/pull/3080#discussion_r499362181", "createdAt": "2020-10-05T06:08:14Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/internal/common/TimeoutSchedulerTest.java", "diffHunk": "@@ -97,58 +98,56 @@ void resetTimeout() {\n     }\n \n     @Test\n-    void resetTimeout_zero() {\n+    void setTimeoutFromNowZero() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MjgzNg==", "bodyText": "Could use WebClient.of(server.httpUri())", "url": "https://github.com/line/armeria/pull/3080#discussion_r499362836", "createdAt": "2020-10-05T06:10:44Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientResponseTimeoutTest.java", "diffHunk": "@@ -117,6 +119,54 @@ void whenTimedOut() {\n         });\n     }\n \n+    @Test\n+    void timeoutWithContext() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2Mjk3Ng==", "bodyText": "Could use WebClient.of(server.httpUri())", "url": "https://github.com/line/armeria/pull/3080#discussion_r499362976", "createdAt": "2020-10-05T06:11:13Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientResponseTimeoutTest.java", "diffHunk": "@@ -117,6 +119,54 @@ void whenTimedOut() {\n         });\n     }\n \n+    @Test\n+    void timeoutWithContext() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .build();\n+        try (ClientRequestContextCaptor ctxCaptor = Clients.newContextCaptor()) {\n+            final CompletableFuture<AggregatedHttpResponse> response = client.get(\"/no-timeout\").aggregate();\n+            final ClientRequestContext cctx = ctxCaptor.get();\n+            cctx.timeoutNow();\n+            assertThat(cctx.isTimedOut()).isFalse();\n+            assertThatThrownBy(response::join)\n+                    .isInstanceOf(CompletionException.class)\n+                    .hasCauseInstanceOf(ResponseTimeoutException.class);\n+            assertThat(cctx.isTimedOut()).isTrue();\n+        }\n+    }\n+\n+    @Test\n+    void cancel() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .decorator((delegate, ctx, req) -> {\n+                    ctx.cancel();\n+                    return delegate.execute(ctx, req);\n+                })\n+                .build();\n+        assertThatThrownBy(() -> client.get(\"/no-timeout\").aggregate().join())\n+                .isInstanceOf(CompletionException.class)\n+                .hasCauseInstanceOf(RequestCancellationException.class);\n+    }\n+\n+    @Test\n+    void cancelWithContext() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2NDQyNA==", "bodyText": "This might be flaky. According to the CPU scheduling, isTimedOut() could be returned true.\nHow about checking the condition before calling timeoutNow().", "url": "https://github.com/line/armeria/pull/3080#discussion_r499364424", "createdAt": "2020-10-05T06:16:19Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientResponseTimeoutTest.java", "diffHunk": "@@ -117,6 +119,54 @@ void whenTimedOut() {\n         });\n     }\n \n+    @Test\n+    void timeoutWithContext() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .build();\n+        try (ClientRequestContextCaptor ctxCaptor = Clients.newContextCaptor()) {\n+            final CompletableFuture<AggregatedHttpResponse> response = client.get(\"/no-timeout\").aggregate();\n+            final ClientRequestContext cctx = ctxCaptor.get();\n+            cctx.timeoutNow();\n+            assertThat(cctx.isTimedOut()).isFalse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4da1d9f44a60362e5cbd824ff4d62813491bdbcc", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/4da1d9f44a60362e5cbd824ff4d62813491bdbcc", "committedDate": "2020-10-06T17:27:58Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fde278c3f0d34ca35da652a1c3499ab85503fa9", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/5fde278c3f0d34ca35da652a1c3499ab85503fa9", "committedDate": "2020-10-07T01:32:45Z", "message": "Retest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTk5NzMz", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-503599733", "createdAt": "2020-10-07T07:36:10Z", "commit": {"oid": "5fde278c3f0d34ca35da652a1c3499ab85503fa9"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzozNjoxMFrOHdmT_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzo0MToxM1rOHdmflQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw==", "bodyText": "Should we make TimeoutException extend this class?", "url": "https://github.com/line/armeria/pull/3080#discussion_r500798463", "createdAt": "2020-10-07T07:36:10Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/RequestCancellationException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+/**\n+ * A {@link RuntimeException} raised when a request is cancelled by the user.\n+ */\n+public final class RequestCancellationException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fde278c3f0d34ca35da652a1c3499ab85503fa9"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgwMTQyOQ==", "bodyText": "How about overriding this method in ClientRequestContext and ServiceRequestContext to provide better Javadoc there? e.g.\n/**\n * Shortcut for {@code cancel(RequestTimeoutException.get()}.\n */\n@Override\nvoid timeoutNow();", "url": "https://github.com/line/armeria/pull/3080#discussion_r500801429", "createdAt": "2020-10-07T07:41:13Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -365,15 +365,35 @@ default boolean hasOwnAttr(AttributeKey<?> key) {\n     MeterRegistry meterRegistry();\n \n     /**\n-     * Triggers the current timeout immediately if a timeout was scheduled before.\n-     * Otherwise, the current {@link Request} will be timed-out immediately after a timeout scheduler is\n-     * initialized.\n+     * Cancels the current {@link Request} with a {@link Throwable}.\n+     */\n+    void cancel(Throwable cause);\n+\n+    /**\n+     * Shortcut for {@code cancel(RequestCancellationException.get())}.\n+     */\n+    void cancel();\n+\n+    /**\n+     * Shortcut for {@code cancel(RequestTimeoutException.get())} or\n+     * {@code cancel(ResponseTimeoutException.get())}.\n      */\n     void timeoutNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fde278c3f0d34ca35da652a1c3499ab85503fa9"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "426a237b5b2c2732de1d8d93fb24117777d13d68", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/426a237b5b2c2732de1d8d93fb24117777d13d68", "committedDate": "2020-10-07T15:19:05Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3df3aec6623d57b34e6753ef47961f846de09c2", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/d3df3aec6623d57b34e6753ef47961f846de09c2", "committedDate": "2020-10-12T19:29:23Z", "message": "Rename and add cancel handlers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b80af345b80c5ea08326291e83705d6ce0b5145", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/4b80af345b80c5ea08326291e83705d6ce0b5145", "committedDate": "2020-10-12T19:44:13Z", "message": "Add todo for trustin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/dcaf9196b733058e33959941fecfdd51d6ad54d8", "committedDate": "2020-10-13T01:28:36Z", "message": "Cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MDIyMzc0", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-507022374", "createdAt": "2020-10-13T02:12:39Z", "commit": {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwMjoxMjozOVrOHgS9Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwMzozNDowM1rOHgUMHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyNzA5MQ==", "bodyText": "Could use a default method?", "url": "https://github.com/line/armeria/pull/3080#discussion_r503627091", "createdAt": "2020-10-13T02:12:39Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContext.java", "diffHunk": "@@ -441,6 +441,11 @@ default void setResponseTimeout(Duration responseTimeout) {\n      */\n     CompletableFuture<Void> whenResponseTimedOut();\n \n+    /**\n+     * Times out the request. Shortcut for {@code cancel(ResponseTimeoutException.get())}.\n+     */\n+    void timeoutNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyNzg2OQ==", "bodyText": "Make it default?", "url": "https://github.com/line/armeria/pull/3080#discussion_r503627869", "createdAt": "2020-10-13T02:15:40Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -365,15 +365,34 @@ default boolean hasOwnAttr(AttributeKey<?> key) {\n     MeterRegistry meterRegistry();\n \n     /**\n-     * Triggers the current timeout immediately if a timeout was scheduled before.\n-     * Otherwise, the current {@link Request} will be timed-out immediately after a timeout scheduler is\n-     * initialized.\n+     * Cancels the request with a {@link Throwable}.\n+     */\n+    void cancel(Throwable cause);\n+\n+    /**\n+     * Cancels the request. Shortcut for {@code cancel(RequestCancellationException.get())}.\n+     */\n+    void cancel();\n+\n+    /**\n+     * Times out the request.\n      */\n     void timeoutNow();\n \n     /**\n-     * Returns whether this {@link RequestContext} has been timed-out (e.g., when the\n-     * corresponding request passes a deadline).\n+     * Returns the cause of cancellation, {@code null} if the request has not been cancelled.\n+     */\n+    @Nullable\n+    Throwable cancellationCause();\n+\n+    /**\n+     * Returns whether this {@link RequestContext} has been cancelled.\n+     */\n+    boolean isCancelled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyNzg4NA==", "bodyText": "Ditto.", "url": "https://github.com/line/armeria/pull/3080#discussion_r503627884", "createdAt": "2020-10-13T02:15:43Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -365,15 +365,34 @@ default boolean hasOwnAttr(AttributeKey<?> key) {\n     MeterRegistry meterRegistry();\n \n     /**\n-     * Triggers the current timeout immediately if a timeout was scheduled before.\n-     * Otherwise, the current {@link Request} will be timed-out immediately after a timeout scheduler is\n-     * initialized.\n+     * Cancels the request with a {@link Throwable}.\n+     */\n+    void cancel(Throwable cause);\n+\n+    /**\n+     * Cancels the request. Shortcut for {@code cancel(RequestCancellationException.get())}.\n+     */\n+    void cancel();\n+\n+    /**\n+     * Times out the request.\n      */\n     void timeoutNow();\n \n     /**\n-     * Returns whether this {@link RequestContext} has been timed-out (e.g., when the\n-     * corresponding request passes a deadline).\n+     * Returns the cause of cancellation, {@code null} if the request has not been cancelled.\n+     */\n+    @Nullable\n+    Throwable cancellationCause();\n+\n+    /**\n+     * Returns whether this {@link RequestContext} has been cancelled.\n+     */\n+    boolean isCancelled();\n+\n+    /**\n+     * Returns whether this {@link RequestContext} has been timed-out, that is the cancellation cause is an\n+     * instance of {@link TimeoutException}.\n      */\n     boolean isTimedOut();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYzMjA3NQ==", "bodyText": "Ditto.", "url": "https://github.com/line/armeria/pull/3080#discussion_r503632075", "createdAt": "2020-10-13T02:32:51Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContext.java", "diffHunk": "@@ -429,6 +429,11 @@ default void setRequestTimeout(Duration requestTimeout) {\n      */\n     CompletableFuture<Void> whenRequestTimedOut();\n \n+    /**\n+     * Times out the request. Shortcut for {@code cancel(RequestTimeoutException.get())}.\n+     */\n+    void timeoutNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYzMzQwNA==", "bodyText": "Question: Don't we need to introduce ResponseCancellantionExeption for consistency?", "url": "https://github.com/line/armeria/pull/3080#discussion_r503633404", "createdAt": "2020-10-13T02:38:08Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/RequestCancellationException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+/**\n+ * A {@link RuntimeException} raised when a request is cancelled by the user.\n+ */\n+public final class RequestCancellationException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw=="}, "originalCommit": {"oid": "5fde278c3f0d34ca35da652a1c3499ab85503fa9"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0NzI2MA==", "bodyText": "Don't we need to deprecate this?\nIf then, we also need to migrate the code where whenResponseTimingOut() is used.", "url": "https://github.com/line/armeria/pull/3080#discussion_r503647260", "createdAt": "2020-10-13T03:34:03Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -572,28 +573,49 @@ public RequestLogBuilder logBuilder() {\n         return log;\n     }\n \n-    TimeoutScheduler responseTimeoutScheduler() {\n-        return responseTimeoutScheduler;\n+    CancellationScheduler responseCancellationScheduler() {\n+        return responseCancellationScheduler;\n+    }\n+\n+    @Override\n+    public void cancel(Throwable cause) {\n+        responseCancellationScheduler.finishNow(cause);\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        cancel(RequestCancellationException.get());\n     }\n \n     @Override\n     public void timeoutNow() {\n-        responseTimeoutScheduler.timeoutNow();\n+        cancel(ResponseTimeoutException.get());\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Throwable cancellationCause() {\n+        return responseCancellationScheduler.cause();\n+    }\n+\n+    @Override\n+    public boolean isCancelled() {\n+        return cancellationCause() != null;\n     }\n \n     @Override\n     public boolean isTimedOut() {\n-        return responseTimeoutScheduler.isTimedOut();\n+        return cancellationCause() instanceof TimeoutException;\n     }\n \n     @Override\n     public CompletableFuture<Void> whenResponseTimingOut() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8"}, "originalPosition": 171}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac49515657c5f822928a28c0cfabec24b413d864", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/ac49515657c5f822928a28c0cfabec24b413d864", "committedDate": "2020-10-13T04:26:54Z", "message": "Use default methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89b3cb8e82d1a26af0c3fbc9759e933a87d7b12e", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/89b3cb8e82d1a26af0c3fbc9759e933a87d7b12e", "committedDate": "2020-10-13T05:32:34Z", "message": "Deprecate whenTiming/TimedOut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e0536fac5dd1d4bdf859344435fe4e18bebeb64", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/6e0536fac5dd1d4bdf859344435fe4e18bebeb64", "committedDate": "2020-10-13T06:31:13Z", "message": "Retest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MTQ2NDIw", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-507146420", "createdAt": "2020-10-13T07:34:54Z", "commit": {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNzozNDo1NFrOHgZNUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNzozNDo1NFrOHgZNUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTQ4OQ==", "bodyText": "Thanks for the clean-up \ud83d\ude47", "url": "https://github.com/line/armeria/pull/3080#discussion_r503729489", "createdAt": "2020-10-13T07:34:54Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/internal/common/CancellationSchedulerTest.java", "diffHunk": "@@ -362,21 +413,24 @@ void evaluatePendingTimeout() {\n     @Test\n     void initializeOnlyOnce() {\n         final AtomicBoolean completed = new AtomicBoolean();\n-        final CancellationScheduler timeoutScheduler = new CancellationScheduler(0);\n+        final CancellationScheduler scheduler = new CancellationScheduler(0);\n         eventExecutor.execute(() -> {\n-            timeoutScheduler.init(eventExecutor, noopTask, MILLISECONDS.toNanos(100), timeoutCause);\n-            assertThat(timeoutScheduler.timeoutNanos()).isEqualTo(MILLISECONDS.toNanos(100));\n+            scheduler.init(eventExecutor, noopTask, MILLISECONDS.toNanos(100), cancellationCause);\n+            assertThat(scheduler.timeoutNanos()).isEqualTo(MILLISECONDS.toNanos(100));\n \n-            timeoutScheduler.init(eventExecutor, noopTask, MILLISECONDS.toNanos(1000), timeoutCause);\n-            assertThat(timeoutScheduler.timeoutNanos()).isEqualTo(MILLISECONDS.toNanos(100));\n+            scheduler.init(eventExecutor, noopTask, MILLISECONDS.toNanos(1000), cancellationCause);\n+            assertThat(scheduler.timeoutNanos()).isEqualTo(MILLISECONDS.toNanos(100));\n             completed.set(true);\n         });\n \n         await().untilTrue(completed);\n     }\n \n     static void assertTimeoutWithTolerance(long actualNanos, long expectedNanos) {\n-        assertThat(actualNanos)\n-                .isCloseTo(expectedNanos, Offset.offset(MILLISECONDS.toNanos(200)));\n+        assertTimeoutWithTolerance(actualNanos, expectedNanos, MILLISECONDS.toNanos(200));\n+    }\n+\n+    static void assertTimeoutWithTolerance(long actualNanos, long expectedNanos, long toleranceNanos) {\n+        assertThat(actualNanos).isCloseTo(expectedNanos, Offset.offset(toleranceNanos));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8"}, "originalPosition": 534}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MTUwNzU2", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-507150756", "createdAt": "2020-10-13T07:40:34Z", "commit": {"oid": "6e0536fac5dd1d4bdf859344435fe4e18bebeb64"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNzo1NDozMFrOHgZ8Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNzo1NjoxM1rOHgaAXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0MTQ0Nw==", "bodyText": "IIRC we never cancel the future returned by whenTimed/TimingOut(), i.e. any callbacks added by a user will be invoked only when the request has timed out.", "url": "https://github.com/line/armeria/pull/3080#discussion_r503741447", "createdAt": "2020-10-13T07:54:30Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/CancellationScheduler.java", "diffHunk": "@@ -291,213 +261,252 @@ private void setTimeoutNanosFromNow(long timeoutNanos) {\n         } else {\n             final long startTimeNanos = System.nanoTime();\n             setPendingTimeoutNanos(timeoutNanos);\n-            addPendingTimeoutTask(() -> {\n+            addPendingTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n                 setTimeoutNanosFromNow0(timeoutNanos0);\n             });\n         }\n     }\n \n-    private boolean setTimeoutNanosFromNow0(long newTimeoutNanos) {\n-        assert eventLoop.inEventLoop();\n-\n-        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n-            return false;\n+    private void setTimeoutNanosFromNow0(long newTimeoutNanos) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null && initialCause != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n+            return;\n         }\n-\n         // Cancel the previously scheduled timeout, if exists.\n         clearTimeout0(true);\n-\n-        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        final long passedTimeNanos = System.nanoTime() - startTimeNanos;\n         timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n-\n         if (newTimeoutNanos <= 0) {\n-            return true;\n+            return;\n         }\n-\n         state = State.SCHEDULED;\n-        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n-        return true;\n+        scheduledFuture = eventLoop.schedule(() -> invokeTask(initialCause), newTimeoutNanos, NANOSECONDS);\n+    }\n+\n+    public void finishNow() {\n+        assert initialCause != null;\n+        finishNow(initialCause);\n     }\n \n-    public void timeoutNow() {\n+    public void finishNow(Throwable cause) {\n         if (isInitialized()) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutNow0();\n+                finishNow0(cause);\n             } else {\n-                eventLoop.execute(this::timeoutNow0);\n+                eventLoop.execute(() -> finishNow0(cause));\n             }\n         } else {\n-            addPendingTimeoutTask(this::timeoutNow0);\n+            addPendingTask(() -> finishNow0(cause));\n         }\n     }\n \n-    private void timeoutNow0() {\n-        assert eventLoop.inEventLoop();\n-\n-        if (!timeoutTask.canSchedule()) {\n+    private void finishNow0(Throwable cause) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n             return;\n         }\n-\n-        switch (state) {\n-            case TIMED_OUT:\n-                return;\n-            case INIT:\n-            case INACTIVE:\n-                invokeTimeoutTask();\n-                return;\n-            case SCHEDULED:\n-                if (clearTimeout0(false)) {\n-                    invokeTimeoutTask();\n-                }\n-                return;\n-            default:\n-                throw new Error(); // Should not reach here.\n-        }\n-    }\n-\n-    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n-        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n-            for (;;) {\n-                final Runnable oldPendingTimeoutTask = this.pendingTimeoutTask;\n-                if (oldPendingTimeoutTask == initializedPendingTimeoutTask) {\n-                    eventLoop.execute(pendingTimeoutTask);\n-                    break;\n-                }\n-\n-                final Runnable newPendingTimeoutTask = () -> {\n-                    oldPendingTimeoutTask.run();\n-                    pendingTimeoutTask.run();\n-                };\n-\n-                if (pendingTimeoutTaskUpdater.compareAndSet(this, oldPendingTimeoutTask,\n-                                                            newPendingTimeoutTask)) {\n-                    break;\n-                }\n+        if (state == State.SCHEDULED) {\n+            if (clearTimeout0(false)) {\n+                invokeTask(cause);\n             }\n+        } else {\n+            invokeTask(cause);\n         }\n     }\n \n-    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         pendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    public boolean isFinished() {\n+        return state == State.FINISHED;\n     }\n \n-    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            final long newPendingTimeoutNanos =\n-                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         newPendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    @Nullable\n+    public Throwable cause() {\n+        return cause;\n     }\n \n-    private void invokeTimeoutTask() {\n-        if (timeoutTask != null) {\n-            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                if (timeoutTask.canSchedule()) {\n-                    whenTimingOut.doComplete();\n-                }\n-            }\n-\n-            // Set TIMED_OUT flag first to prevent duplicate execution\n-            state = State.TIMED_OUT;\n-\n-            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n-            if (timeoutTask.canSchedule()) {\n-                timeoutTask.run();\n-            }\n-\n-            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                whenTimedOut.doComplete();\n-            }\n-        }\n+    public long timeoutNanos() {\n+        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    public boolean isTimedOut() {\n-        return state == State.TIMED_OUT;\n+    public long startTimeNanos() {\n+        return startTimeNanos;\n     }\n \n-    public long timeoutNanos() {\n-        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n+    public CompletableFuture<Throwable> whenCancelling() {\n+        final CancellationFuture whenCancelling = this.whenCancelling;\n+        if (whenCancelling != null) {\n+            return whenCancelling;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancellingUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelling;\n+        }\n     }\n \n-    private boolean isInitialized() {\n-        return pendingTimeoutTask == initializedPendingTimeoutTask;\n+    public CompletableFuture<Throwable> whenCancelled() {\n+        final CancellationFuture whenCancelled = this.whenCancelled;\n+        if (whenCancelled != null) {\n+            return whenCancelled;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancelledUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelled;\n+        }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimingOut() {\n         final TimeoutFuture whenTimingOut = this.whenTimingOut;\n         if (whenTimingOut != null) {\n             return whenTimingOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimingOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelling().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();\n+                }\n+            });\n             return timeoutFuture;\n         } else {\n             return this.whenTimingOut;\n         }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimedOut() {\n         final TimeoutFuture whenTimedOut = this.whenTimedOut;\n         if (whenTimedOut != null) {\n             return whenTimedOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimedOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelled().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0536fac5dd1d4bdf859344435fe4e18bebeb64"}, "originalPosition": 562}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0MTUyNQ==", "bodyText": "IIRC we never cancel the future returned by whenTimed/TimingOut(), i.e. any callbacks added by a user will be invoked only when the request has timed out.", "url": "https://github.com/line/armeria/pull/3080#discussion_r503741525", "createdAt": "2020-10-13T07:54:37Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/CancellationScheduler.java", "diffHunk": "@@ -291,213 +261,252 @@ private void setTimeoutNanosFromNow(long timeoutNanos) {\n         } else {\n             final long startTimeNanos = System.nanoTime();\n             setPendingTimeoutNanos(timeoutNanos);\n-            addPendingTimeoutTask(() -> {\n+            addPendingTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n                 setTimeoutNanosFromNow0(timeoutNanos0);\n             });\n         }\n     }\n \n-    private boolean setTimeoutNanosFromNow0(long newTimeoutNanos) {\n-        assert eventLoop.inEventLoop();\n-\n-        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n-            return false;\n+    private void setTimeoutNanosFromNow0(long newTimeoutNanos) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null && initialCause != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n+            return;\n         }\n-\n         // Cancel the previously scheduled timeout, if exists.\n         clearTimeout0(true);\n-\n-        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        final long passedTimeNanos = System.nanoTime() - startTimeNanos;\n         timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n-\n         if (newTimeoutNanos <= 0) {\n-            return true;\n+            return;\n         }\n-\n         state = State.SCHEDULED;\n-        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n-        return true;\n+        scheduledFuture = eventLoop.schedule(() -> invokeTask(initialCause), newTimeoutNanos, NANOSECONDS);\n+    }\n+\n+    public void finishNow() {\n+        assert initialCause != null;\n+        finishNow(initialCause);\n     }\n \n-    public void timeoutNow() {\n+    public void finishNow(Throwable cause) {\n         if (isInitialized()) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutNow0();\n+                finishNow0(cause);\n             } else {\n-                eventLoop.execute(this::timeoutNow0);\n+                eventLoop.execute(() -> finishNow0(cause));\n             }\n         } else {\n-            addPendingTimeoutTask(this::timeoutNow0);\n+            addPendingTask(() -> finishNow0(cause));\n         }\n     }\n \n-    private void timeoutNow0() {\n-        assert eventLoop.inEventLoop();\n-\n-        if (!timeoutTask.canSchedule()) {\n+    private void finishNow0(Throwable cause) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n             return;\n         }\n-\n-        switch (state) {\n-            case TIMED_OUT:\n-                return;\n-            case INIT:\n-            case INACTIVE:\n-                invokeTimeoutTask();\n-                return;\n-            case SCHEDULED:\n-                if (clearTimeout0(false)) {\n-                    invokeTimeoutTask();\n-                }\n-                return;\n-            default:\n-                throw new Error(); // Should not reach here.\n-        }\n-    }\n-\n-    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n-        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n-            for (;;) {\n-                final Runnable oldPendingTimeoutTask = this.pendingTimeoutTask;\n-                if (oldPendingTimeoutTask == initializedPendingTimeoutTask) {\n-                    eventLoop.execute(pendingTimeoutTask);\n-                    break;\n-                }\n-\n-                final Runnable newPendingTimeoutTask = () -> {\n-                    oldPendingTimeoutTask.run();\n-                    pendingTimeoutTask.run();\n-                };\n-\n-                if (pendingTimeoutTaskUpdater.compareAndSet(this, oldPendingTimeoutTask,\n-                                                            newPendingTimeoutTask)) {\n-                    break;\n-                }\n+        if (state == State.SCHEDULED) {\n+            if (clearTimeout0(false)) {\n+                invokeTask(cause);\n             }\n+        } else {\n+            invokeTask(cause);\n         }\n     }\n \n-    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         pendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    public boolean isFinished() {\n+        return state == State.FINISHED;\n     }\n \n-    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            final long newPendingTimeoutNanos =\n-                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         newPendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    @Nullable\n+    public Throwable cause() {\n+        return cause;\n     }\n \n-    private void invokeTimeoutTask() {\n-        if (timeoutTask != null) {\n-            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                if (timeoutTask.canSchedule()) {\n-                    whenTimingOut.doComplete();\n-                }\n-            }\n-\n-            // Set TIMED_OUT flag first to prevent duplicate execution\n-            state = State.TIMED_OUT;\n-\n-            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n-            if (timeoutTask.canSchedule()) {\n-                timeoutTask.run();\n-            }\n-\n-            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                whenTimedOut.doComplete();\n-            }\n-        }\n+    public long timeoutNanos() {\n+        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    public boolean isTimedOut() {\n-        return state == State.TIMED_OUT;\n+    public long startTimeNanos() {\n+        return startTimeNanos;\n     }\n \n-    public long timeoutNanos() {\n-        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n+    public CompletableFuture<Throwable> whenCancelling() {\n+        final CancellationFuture whenCancelling = this.whenCancelling;\n+        if (whenCancelling != null) {\n+            return whenCancelling;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancellingUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelling;\n+        }\n     }\n \n-    private boolean isInitialized() {\n-        return pendingTimeoutTask == initializedPendingTimeoutTask;\n+    public CompletableFuture<Throwable> whenCancelled() {\n+        final CancellationFuture whenCancelled = this.whenCancelled;\n+        if (whenCancelled != null) {\n+            return whenCancelled;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancelledUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelled;\n+        }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimingOut() {\n         final TimeoutFuture whenTimingOut = this.whenTimingOut;\n         if (whenTimingOut != null) {\n             return whenTimingOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimingOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelling().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0536fac5dd1d4bdf859344435fe4e18bebeb64"}, "originalPosition": 540}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0MjU1OQ==", "bodyText": "Can we extend UnmodifiableFuture<Throwable> here?", "url": "https://github.com/line/armeria/pull/3080#discussion_r503742559", "createdAt": "2020-10-13T07:56:13Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/CancellationScheduler.java", "diffHunk": "@@ -291,213 +261,252 @@ private void setTimeoutNanosFromNow(long timeoutNanos) {\n         } else {\n             final long startTimeNanos = System.nanoTime();\n             setPendingTimeoutNanos(timeoutNanos);\n-            addPendingTimeoutTask(() -> {\n+            addPendingTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n                 setTimeoutNanosFromNow0(timeoutNanos0);\n             });\n         }\n     }\n \n-    private boolean setTimeoutNanosFromNow0(long newTimeoutNanos) {\n-        assert eventLoop.inEventLoop();\n-\n-        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n-            return false;\n+    private void setTimeoutNanosFromNow0(long newTimeoutNanos) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null && initialCause != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n+            return;\n         }\n-\n         // Cancel the previously scheduled timeout, if exists.\n         clearTimeout0(true);\n-\n-        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        final long passedTimeNanos = System.nanoTime() - startTimeNanos;\n         timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n-\n         if (newTimeoutNanos <= 0) {\n-            return true;\n+            return;\n         }\n-\n         state = State.SCHEDULED;\n-        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n-        return true;\n+        scheduledFuture = eventLoop.schedule(() -> invokeTask(initialCause), newTimeoutNanos, NANOSECONDS);\n+    }\n+\n+    public void finishNow() {\n+        assert initialCause != null;\n+        finishNow(initialCause);\n     }\n \n-    public void timeoutNow() {\n+    public void finishNow(Throwable cause) {\n         if (isInitialized()) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutNow0();\n+                finishNow0(cause);\n             } else {\n-                eventLoop.execute(this::timeoutNow0);\n+                eventLoop.execute(() -> finishNow0(cause));\n             }\n         } else {\n-            addPendingTimeoutTask(this::timeoutNow0);\n+            addPendingTask(() -> finishNow0(cause));\n         }\n     }\n \n-    private void timeoutNow0() {\n-        assert eventLoop.inEventLoop();\n-\n-        if (!timeoutTask.canSchedule()) {\n+    private void finishNow0(Throwable cause) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n             return;\n         }\n-\n-        switch (state) {\n-            case TIMED_OUT:\n-                return;\n-            case INIT:\n-            case INACTIVE:\n-                invokeTimeoutTask();\n-                return;\n-            case SCHEDULED:\n-                if (clearTimeout0(false)) {\n-                    invokeTimeoutTask();\n-                }\n-                return;\n-            default:\n-                throw new Error(); // Should not reach here.\n-        }\n-    }\n-\n-    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n-        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n-            for (;;) {\n-                final Runnable oldPendingTimeoutTask = this.pendingTimeoutTask;\n-                if (oldPendingTimeoutTask == initializedPendingTimeoutTask) {\n-                    eventLoop.execute(pendingTimeoutTask);\n-                    break;\n-                }\n-\n-                final Runnable newPendingTimeoutTask = () -> {\n-                    oldPendingTimeoutTask.run();\n-                    pendingTimeoutTask.run();\n-                };\n-\n-                if (pendingTimeoutTaskUpdater.compareAndSet(this, oldPendingTimeoutTask,\n-                                                            newPendingTimeoutTask)) {\n-                    break;\n-                }\n+        if (state == State.SCHEDULED) {\n+            if (clearTimeout0(false)) {\n+                invokeTask(cause);\n             }\n+        } else {\n+            invokeTask(cause);\n         }\n     }\n \n-    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         pendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    public boolean isFinished() {\n+        return state == State.FINISHED;\n     }\n \n-    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            final long newPendingTimeoutNanos =\n-                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         newPendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    @Nullable\n+    public Throwable cause() {\n+        return cause;\n     }\n \n-    private void invokeTimeoutTask() {\n-        if (timeoutTask != null) {\n-            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                if (timeoutTask.canSchedule()) {\n-                    whenTimingOut.doComplete();\n-                }\n-            }\n-\n-            // Set TIMED_OUT flag first to prevent duplicate execution\n-            state = State.TIMED_OUT;\n-\n-            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n-            if (timeoutTask.canSchedule()) {\n-                timeoutTask.run();\n-            }\n-\n-            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                whenTimedOut.doComplete();\n-            }\n-        }\n+    public long timeoutNanos() {\n+        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    public boolean isTimedOut() {\n-        return state == State.TIMED_OUT;\n+    public long startTimeNanos() {\n+        return startTimeNanos;\n     }\n \n-    public long timeoutNanos() {\n-        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n+    public CompletableFuture<Throwable> whenCancelling() {\n+        final CancellationFuture whenCancelling = this.whenCancelling;\n+        if (whenCancelling != null) {\n+            return whenCancelling;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancellingUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelling;\n+        }\n     }\n \n-    private boolean isInitialized() {\n-        return pendingTimeoutTask == initializedPendingTimeoutTask;\n+    public CompletableFuture<Throwable> whenCancelled() {\n+        final CancellationFuture whenCancelled = this.whenCancelled;\n+        if (whenCancelled != null) {\n+            return whenCancelled;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancelledUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelled;\n+        }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimingOut() {\n         final TimeoutFuture whenTimingOut = this.whenTimingOut;\n         if (whenTimingOut != null) {\n             return whenTimingOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimingOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelling().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();\n+                }\n+            });\n             return timeoutFuture;\n         } else {\n             return this.whenTimingOut;\n         }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimedOut() {\n         final TimeoutFuture whenTimedOut = this.whenTimedOut;\n         if (whenTimedOut != null) {\n             return whenTimedOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimedOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelled().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();\n+                }\n+            });\n             return timeoutFuture;\n         } else {\n             return this.whenTimedOut;\n         }\n     }\n \n-    @Nullable\n-    public Long startTimeNanos() {\n-        return state != State.INIT ? firstExecutionTimeNanos : null;\n+    private boolean isInitialized() {\n+        return pendingTask == noopPendingTask && eventLoop != null;\n+    }\n+\n+    private void addPendingTask(Runnable pendingTask) {\n+        if (!pendingTaskUpdater.compareAndSet(this, null, pendingTask)) {\n+            for (;;) {\n+                final Runnable oldPendingTask = this.pendingTask;\n+                assert oldPendingTask != null;\n+                if (oldPendingTask == noopPendingTask) {\n+                    assert eventLoop != null;\n+                    eventLoop.execute(pendingTask);\n+                    break;\n+                }\n+                final Runnable newPendingTask = () -> {\n+                    oldPendingTask.run();\n+                    pendingTask.run();\n+                };\n+                if (pendingTaskUpdater.compareAndSet(this, oldPendingTask, newPendingTask)) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos, pendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            final long newPendingTimeoutNanos = LongMath.saturatedAdd(oldPendingTimeoutNanos,\n+                                                                      pendingTimeoutNanos);\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         newPendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void invokeTask(Throwable cause) {\n+        if (task == null) {\n+            return;\n+        }\n+        if (task.canSchedule()) {\n+            whenCancelling().complete(cause);\n+        }\n+        // Set state first to prevent duplicate execution\n+        state = State.FINISHED;\n+        // The returned value of `canSchedule()` could've been changed by the callbacks of `whenCancelling`\n+        if (task.canSchedule()) {\n+            task.run(cause);\n+        }\n+        this.cause = cause;\n+        whenCancelled().complete(cause);\n     }\n \n     @Nullable\n     @VisibleForTesting\n-    ScheduledFuture<?> timeoutFuture() {\n-        return timeoutFuture;\n+    ScheduledFuture<?> scheduledFuture() {\n+        return scheduledFuture;\n     }\n \n     @VisibleForTesting\n     State state() {\n         return state;\n     }\n \n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        FINISHED\n+    }\n+\n     /**\n-     * A timeout task that is invoked when the deadline exceeded.\n+     * A cancellation task invoked by the scheduler when its timeout exceeds or invoke by the user.\n      */\n-    public interface TimeoutTask extends Runnable {\n+    public interface CancellationTask {\n         /**\n-         * Returns {@code true} if the timeout task can be scheduled.\n+         * Returns {@code true} if the cancellation task can be scheduled.\n          */\n         boolean canSchedule();\n \n         /**\n-         * Invoked when the deadline exceeded.\n+         * Invoked by the scheduler with the cause of cancellation.\n          */\n-        @Override\n-        void run();\n+        void run(Throwable cause);\n+    }\n+\n+    private static class CancellationFuture extends CompletableFuture<Throwable> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0536fac5dd1d4bdf859344435fe4e18bebeb64"}, "originalPosition": 678}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MTc3MDk2", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-507177096", "createdAt": "2020-10-13T08:12:38Z", "commit": {"oid": "ac49515657c5f822928a28c0cfabec24b413d864"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwODoxMjozOFrOHgaprA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwODoxMzoyN1rOHgarpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1MzEzMg==", "bodyText": "We still need these methods because the delegate's methods might have different behavior than the default methods.", "url": "https://github.com/line/armeria/pull/3080#discussion_r503753132", "createdAt": "2020-10-13T08:12:38Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextWrapper.java", "diffHunk": "@@ -140,32 +140,12 @@ public void cancel(Throwable cause) {\n         delegate().cancel(cause);\n     }\n \n-    @Override\n-    public void cancel() {\n-        delegate().cancel();\n-    }\n-\n-    @Override\n-    public void timeoutNow() {\n-        delegate().timeoutNow();\n-    }\n-\n     @Nullable\n     @Override\n     public Throwable cancellationCause() {\n         return delegate().cancellationCause();\n     }\n \n-    @Override\n-    public boolean isCancelled() {\n-        return delegate().isCancelled();\n-    }\n-\n-    @Override\n-    public boolean isTimedOut() {\n-        return delegate().isTimedOut();\n-    }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac49515657c5f822928a28c0cfabec24b413d864"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1MzYzOQ==", "bodyText": "Ditto", "url": "https://github.com/line/armeria/pull/3080#discussion_r503753639", "createdAt": "2020-10-13T08:13:27Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContextWrapper.java", "diffHunk": "@@ -148,32 +148,12 @@ public void cancel(Throwable cause) {\n         delegate().cancel(cause);\n     }\n \n-    @Override\n-    public void cancel() {\n-        delegate().cancel();\n-    }\n-\n-    @Override\n-    public void timeoutNow() {\n-        delegate().timeoutNow();\n-    }\n-\n     @Nullable\n     @Override\n     public Throwable cancellationCause() {\n         return delegate().cancellationCause();\n     }\n \n-    @Override\n-    public boolean isCancelled() {\n-        return delegate().isCancelled();\n-    }\n-\n-    @Override\n-    public boolean isTimedOut() {\n-        return delegate().isTimedOut();\n-    }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac49515657c5f822928a28c0cfabec24b413d864"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46b7f31a91537de8f0a65fb8ff82e3998253c118", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/46b7f31a91537de8f0a65fb8ff82e3998253c118", "committedDate": "2020-10-13T19:55:21Z", "message": "Address reviews"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MDQ0Njgw", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-508044680", "createdAt": "2020-10-14T06:56:03Z", "commit": {"oid": "46b7f31a91537de8f0a65fb8ff82e3998253c118"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MjUyNDc2", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-508252476", "createdAt": "2020-10-14T11:34:11Z", "commit": {"oid": "46b7f31a91537de8f0a65fb8ff82e3998253c118"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMTozNDoxMVrOHhOplQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMTo0MjozNFrOHhO6mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYwNTA3Nw==", "bodyText": "Add requireNonNull(cause, \"cause\")?", "url": "https://github.com/line/armeria/pull/3080#discussion_r504605077", "createdAt": "2020-10-14T11:34:11Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -283,48 +283,62 @@ public SSLSession sslSession() {\n \n     @Override\n     public long requestTimeoutMillis() {\n-        return TimeUnit.NANOSECONDS.toMillis(requestTimeoutScheduler.timeoutNanos());\n+        return TimeUnit.NANOSECONDS.toMillis(requestCancellationScheduler.timeoutNanos());\n     }\n \n     @Override\n     public void clearRequestTimeout() {\n-        requestTimeoutScheduler.clearTimeout();\n+        requestCancellationScheduler.clearTimeout();\n     }\n \n     @Override\n     public void setRequestTimeoutMillis(TimeoutMode mode, long requestTimeoutMillis) {\n-        requestTimeoutScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n-                                                TimeUnit.MILLISECONDS.toNanos(requestTimeoutMillis));\n+        requestCancellationScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n+                                                     TimeUnit.MILLISECONDS.toNanos(requestTimeoutMillis));\n     }\n \n     @Override\n     public void setRequestTimeout(TimeoutMode mode, Duration requestTimeout) {\n-        requestTimeoutScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n-                                                requireNonNull(requestTimeout, \"requestTimeout\").toNanos());\n+        requestCancellationScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n+                                                     requireNonNull(requestTimeout, \"requestTimeout\")\n+                                                             .toNanos());\n     }\n \n-    TimeoutScheduler requestTimeoutScheduler() {\n-        return requestTimeoutScheduler;\n+    CancellationScheduler requestCancellationScheduler() {\n+        return requestCancellationScheduler;\n     }\n \n     @Override\n-    public void timeoutNow() {\n-        requestTimeoutScheduler.timeoutNow();\n+    public void cancel(Throwable cause) {\n+        requestCancellationScheduler.finishNow(cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46b7f31a91537de8f0a65fb8ff82e3998253c118"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYwOTQzMg==", "bodyText": "This should be called only when a timeout has exceeded.", "url": "https://github.com/line/armeria/pull/3080#discussion_r504609432", "createdAt": "2020-10-14T11:42:34Z", "author": {"login": "ikhoon"}, "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaClientCall.java", "diffHunk": "@@ -194,7 +194,7 @@ public void start(Listener<O> responseListener, Metadata metadata) {\n                 close(status, new Metadata());\n             } else {\n                 ctx.setResponseTimeout(TimeoutMode.SET_FROM_NOW, Duration.ofNanos(remainingNanos));\n-                ctx.whenResponseTimingOut().thenRun(() -> {\n+                ctx.whenResponseCancelling().thenRun(() -> {\n                     final Status status = Status.DEADLINE_EXCEEDED\n                             .augmentDescription(\"deadline exceeded after \" + remainingNanos + \"ns.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46b7f31a91537de8f0a65fb8ff82e3998253c118"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb8eda469635527a579107ced391d769fb7f2bab", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/eb8eda469635527a579107ced391d769fb7f2bab", "committedDate": "2020-10-14T18:33:47Z", "message": "CancellationException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52335981dba959f9dac1ec0e6a80a83973e316db", "author": {"user": {"login": "tumile", "name": "Tuan Le"}}, "url": "https://github.com/line/armeria/commit/52335981dba959f9dac1ec0e6a80a83973e316db", "committedDate": "2020-10-14T18:54:35Z", "message": "checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4ODg4MjM4", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-508888238", "createdAt": "2020-10-15T02:09:57Z", "commit": {"oid": "52335981dba959f9dac1ec0e6a80a83973e316db"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMTkxNDIy", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-510191422", "createdAt": "2020-10-16T06:40:19Z", "commit": {"oid": "52335981dba959f9dac1ec0e6a80a83973e316db"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5OTg5MDY1", "url": "https://github.com/line/armeria/pull/3080#pullrequestreview-509989065", "createdAt": "2020-10-16T03:37:00Z", "commit": {"oid": "52335981dba959f9dac1ec0e6a80a83973e316db"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwMzozNzowMFrOHilf3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwMzozNzowMFrOHilf3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyNzk5OQ==", "bodyText": "Thanks!", "url": "https://github.com/line/armeria/pull/3080#discussion_r506027999", "createdAt": "2020-10-16T03:37:00Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -375,28 +376,28 @@ private void cancelTimeoutOrLog(@Nullable Throwable cause,\n \n         void initTimeout() {\n             if (ctx instanceof DefaultClientRequestContext) {\n-                final TimeoutScheduler responseTimeoutScheduler =\n-                        ((DefaultClientRequestContext) ctx).responseTimeoutScheduler();\n-                responseTimeoutScheduler.init(ctx.eventLoop(), newTimeoutTask(),\n-                                      TimeUnit.MILLISECONDS.toNanos(responseTimeoutMillis));\n+                final CancellationScheduler responseCancellationScheduler =\n+                        ((DefaultClientRequestContext) ctx).responseCancellationScheduler();\n+                responseCancellationScheduler.init(ctx.eventLoop(), newCancellationTask(),\n+                                                   TimeUnit.MILLISECONDS.toNanos(responseTimeoutMillis),\n+                                                   ResponseTimeoutException.get());\n             }\n         }\n \n-        private TimeoutTask newTimeoutTask() {\n-            return new TimeoutTask() {\n+        private CancellationTask newCancellationTask() {\n+            return new CancellationTask() {\n                 @Override\n                 public boolean canSchedule() {\n                     return delegate.isOpen() && state != State.DONE;\n                 }\n \n                 @Override\n-                public void run() {\n-                    final ResponseTimeoutException cause = ResponseTimeoutException.get();\n+                public void run(Throwable cause) {\n+                    assert ctx != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52335981dba959f9dac1ec0e6a80a83973e316db"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4689, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}