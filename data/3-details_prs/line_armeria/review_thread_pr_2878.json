{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0ODEwMTcz", "number": 2878, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNDoyNjo0OVrOELta-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNDoyNjo0OVrOELta-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzEzOTc2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/server/ProxyServerAuthorityHeaderTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNDoyNjo0OVrOGtZpBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDoxMDowMVrOGtudug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI1OTIwNQ==", "bodyText": "It seems like HAproxy does not translate the Host header to :authority header when it's acting as a proxy between H1 and H2. (However, we do.)\nhaproxy/haproxy#716 (comment)\nRelate spec: https://tools.ietf.org/html/rfc7540#section-8.1.2.3\n(I'm not 100% sure which behavior is the correct one. \ud83e\udd14 )", "url": "https://github.com/line/armeria/pull/2878#discussion_r450259205", "createdAt": "2020-07-06T14:26:49Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/server/ProxyServerAuthorityHeaderTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+class ProxyServerAuthorityHeaderTest {\n+\n+    private static final AtomicReference<RequestHeaders> backendHeaders = new AtomicReference<>();\n+\n+    private static final AtomicReference<RequestHeaders> proxyHeaders = new AtomicReference<>();\n+\n+    @RegisterExtension\n+    static final ServerExtension backend = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(\"/toHttp1\", (ctx, req) -> {\n+                backendHeaders.set(req.headers());\n+                return HttpResponse.of(200);\n+            });\n+            sb.service(\"/toHttp2\", (ctx, req) -> {\n+                backendHeaders.set(req.headers());\n+                return HttpResponse.of(200);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static final ServerExtension proxy = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(\"/toHttp1\", (ctx, req) -> {\n+                proxyHeaders.set(req.headers());\n+                final WebClient client = WebClient.of(backend.uri(SessionProtocol.H1C));\n+                return client.execute(req);\n+            });\n+            sb.service(\"/toHttp2\", (ctx, req) -> {\n+                proxyHeaders.set(req.headers());\n+                final WebClient client = WebClient.of(backend.uri(SessionProtocol.H2C));\n+                return client.execute(req);\n+            });\n+        }\n+    };\n+\n+    @BeforeEach\n+    void setUp() {\n+        backendHeaders.set(null);\n+        proxyHeaders.set(null);\n+    }\n+\n+    @Test\n+    void http1ToHttp1() {\n+        final WebClient client = WebClient.of(proxy.uri(SessionProtocol.H1C));\n+        client.get(\"/toHttp1\").aggregate().join();\n+        final RequestHeaders proxyRequestHeaders = proxyHeaders.get();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.HOST)).isNotNull();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNull();\n+\n+        final RequestHeaders backendRequestHeaders = backendHeaders.get();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.HOST)).isNotNull();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNull();\n+    }\n+\n+    @Test\n+    void http2ToHttp2() {\n+        final WebClient client = WebClient.of(proxy.uri(SessionProtocol.H2C));\n+        client.get(\"/toHttp2\").aggregate().join();\n+        final RequestHeaders proxyRequestHeaders = proxyHeaders.get();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.HOST)).isNull();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNotNull();\n+\n+        final RequestHeaders backendRequestHeaders = backendHeaders.get();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.HOST)).isNull();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNotNull();\n+    }\n+\n+    @Test\n+    void http1ToHttp2() {\n+        final WebClient client = WebClient.of(proxy.uri(SessionProtocol.H1C));\n+        client.get(\"/toHttp2\").aggregate().join();\n+        final RequestHeaders proxyRequestHeaders = proxyHeaders.get();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.HOST)).isNotNull();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNull();\n+\n+        final RequestHeaders backendRequestHeaders = backendHeaders.get();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.HOST)).isNull();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNotNull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2294f0d7c57e82266b45887abd7864fe11b6ad32"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU3MDkxMg==", "bodyText": "+1 for HAProxy behavior so that we allow a user to build a proxy server that does not touch the original request.", "url": "https://github.com/line/armeria/pull/2878#discussion_r450570912", "createdAt": "2020-07-07T02:03:47Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/server/ProxyServerAuthorityHeaderTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+class ProxyServerAuthorityHeaderTest {\n+\n+    private static final AtomicReference<RequestHeaders> backendHeaders = new AtomicReference<>();\n+\n+    private static final AtomicReference<RequestHeaders> proxyHeaders = new AtomicReference<>();\n+\n+    @RegisterExtension\n+    static final ServerExtension backend = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(\"/toHttp1\", (ctx, req) -> {\n+                backendHeaders.set(req.headers());\n+                return HttpResponse.of(200);\n+            });\n+            sb.service(\"/toHttp2\", (ctx, req) -> {\n+                backendHeaders.set(req.headers());\n+                return HttpResponse.of(200);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static final ServerExtension proxy = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(\"/toHttp1\", (ctx, req) -> {\n+                proxyHeaders.set(req.headers());\n+                final WebClient client = WebClient.of(backend.uri(SessionProtocol.H1C));\n+                return client.execute(req);\n+            });\n+            sb.service(\"/toHttp2\", (ctx, req) -> {\n+                proxyHeaders.set(req.headers());\n+                final WebClient client = WebClient.of(backend.uri(SessionProtocol.H2C));\n+                return client.execute(req);\n+            });\n+        }\n+    };\n+\n+    @BeforeEach\n+    void setUp() {\n+        backendHeaders.set(null);\n+        proxyHeaders.set(null);\n+    }\n+\n+    @Test\n+    void http1ToHttp1() {\n+        final WebClient client = WebClient.of(proxy.uri(SessionProtocol.H1C));\n+        client.get(\"/toHttp1\").aggregate().join();\n+        final RequestHeaders proxyRequestHeaders = proxyHeaders.get();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.HOST)).isNotNull();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNull();\n+\n+        final RequestHeaders backendRequestHeaders = backendHeaders.get();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.HOST)).isNotNull();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNull();\n+    }\n+\n+    @Test\n+    void http2ToHttp2() {\n+        final WebClient client = WebClient.of(proxy.uri(SessionProtocol.H2C));\n+        client.get(\"/toHttp2\").aggregate().join();\n+        final RequestHeaders proxyRequestHeaders = proxyHeaders.get();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.HOST)).isNull();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNotNull();\n+\n+        final RequestHeaders backendRequestHeaders = backendHeaders.get();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.HOST)).isNull();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNotNull();\n+    }\n+\n+    @Test\n+    void http1ToHttp2() {\n+        final WebClient client = WebClient.of(proxy.uri(SessionProtocol.H1C));\n+        client.get(\"/toHttp2\").aggregate().join();\n+        final RequestHeaders proxyRequestHeaders = proxyHeaders.get();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.HOST)).isNotNull();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNull();\n+\n+        final RequestHeaders backendRequestHeaders = backendHeaders.get();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.HOST)).isNull();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNotNull();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI1OTIwNQ=="}, "originalCommit": {"oid": "2294f0d7c57e82266b45887abd7864fe11b6ad32"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwMDM3OA==", "bodyText": "Fixed. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2878#discussion_r450600378", "createdAt": "2020-07-07T04:10:01Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/server/ProxyServerAuthorityHeaderTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+class ProxyServerAuthorityHeaderTest {\n+\n+    private static final AtomicReference<RequestHeaders> backendHeaders = new AtomicReference<>();\n+\n+    private static final AtomicReference<RequestHeaders> proxyHeaders = new AtomicReference<>();\n+\n+    @RegisterExtension\n+    static final ServerExtension backend = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(\"/toHttp1\", (ctx, req) -> {\n+                backendHeaders.set(req.headers());\n+                return HttpResponse.of(200);\n+            });\n+            sb.service(\"/toHttp2\", (ctx, req) -> {\n+                backendHeaders.set(req.headers());\n+                return HttpResponse.of(200);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static final ServerExtension proxy = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(\"/toHttp1\", (ctx, req) -> {\n+                proxyHeaders.set(req.headers());\n+                final WebClient client = WebClient.of(backend.uri(SessionProtocol.H1C));\n+                return client.execute(req);\n+            });\n+            sb.service(\"/toHttp2\", (ctx, req) -> {\n+                proxyHeaders.set(req.headers());\n+                final WebClient client = WebClient.of(backend.uri(SessionProtocol.H2C));\n+                return client.execute(req);\n+            });\n+        }\n+    };\n+\n+    @BeforeEach\n+    void setUp() {\n+        backendHeaders.set(null);\n+        proxyHeaders.set(null);\n+    }\n+\n+    @Test\n+    void http1ToHttp1() {\n+        final WebClient client = WebClient.of(proxy.uri(SessionProtocol.H1C));\n+        client.get(\"/toHttp1\").aggregate().join();\n+        final RequestHeaders proxyRequestHeaders = proxyHeaders.get();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.HOST)).isNotNull();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNull();\n+\n+        final RequestHeaders backendRequestHeaders = backendHeaders.get();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.HOST)).isNotNull();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNull();\n+    }\n+\n+    @Test\n+    void http2ToHttp2() {\n+        final WebClient client = WebClient.of(proxy.uri(SessionProtocol.H2C));\n+        client.get(\"/toHttp2\").aggregate().join();\n+        final RequestHeaders proxyRequestHeaders = proxyHeaders.get();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.HOST)).isNull();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNotNull();\n+\n+        final RequestHeaders backendRequestHeaders = backendHeaders.get();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.HOST)).isNull();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNotNull();\n+    }\n+\n+    @Test\n+    void http1ToHttp2() {\n+        final WebClient client = WebClient.of(proxy.uri(SessionProtocol.H1C));\n+        client.get(\"/toHttp2\").aggregate().join();\n+        final RequestHeaders proxyRequestHeaders = proxyHeaders.get();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.HOST)).isNotNull();\n+        assertThat(proxyRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNull();\n+\n+        final RequestHeaders backendRequestHeaders = backendHeaders.get();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.HOST)).isNull();\n+        assertThat(backendRequestHeaders.get(HttpHeaderNames.AUTHORITY)).isNotNull();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI1OTIwNQ=="}, "originalCommit": {"oid": "2294f0d7c57e82266b45887abd7864fe11b6ad32"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2489, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}