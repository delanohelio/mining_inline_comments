{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMzcxMDcw", "number": 2391, "title": "Clean up TimeoutController implementation", "bodyText": "Motivation:\nWhen a past time is passed to ctx.set{Response,Request}TimeoutAt()\nit throws IllegalArgumentException.\nI think it would be more natural to trigger timeout immediately.\nAnd clean up TimeoutController implementation.\nModifications:\n\nAdd timeoutNow() to TimeoutController for invoking timeout directly.\nAdd isTimedOut() for checking whether the timeout has been timed out or not.\nAdd State to DefaultTimeoutController for expressing the current timeout status.\nRename initTimeout to scheduleTimeout.\nChange void xxxTimeout(...) to boolean xxxTimeout(...).\nAllow to execute the pending task when the TimeoutController is set to the {Client,Service}RequestContext.\nInvoke timeoutNow() when the given time is before now in ctx.set{Response,Request}TimeoutAt().\nRemove order of precedence for xxxTimeout.\n\nCan call resetTimeout or exendTimeout before calling scheduleTimeout.\n\n\n\nResult:\n\nA user can trigger timeout immediately by setting past time.\nMore clarified implementations.", "createdAt": "2020-01-10T10:03:17Z", "url": "https://github.com/line/armeria/pull/2391", "merged": true, "mergeCommit": {"oid": "efef68f01c7136b99299fffa4b4792a0d59cef13"}, "closed": true, "closedAt": "2020-01-21T09:44:16Z", "author": {"login": "ikhoon"}, "timelineItems": {"totalCount": 41, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb47nfIgH2gAyMzYxMzcxMDcwOjhlYTlhZjU2NDZiODlhYmI5ZTI5ZjQ4MzhmM2RjYmU4OTdiN2Y3MTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8bk0JAFqTM0NTY2NTE4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8ea9af5646b89abb9e29f4838f3dcbe897b7f710", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/8ea9af5646b89abb9e29f4838f3dcbe897b7f710", "committedDate": "2020-01-10T10:02:13Z", "message": "Trigger request or response timeout when past time is set to\n\nMotivation:\nWhen a past time is passed to `ctx.set{Response,Request}TimeoutAt()`\nit throws `IllegalArgumentException`.\nI think it would be more natural to trigger timeout immediately.\n\nModifications:\n* Add `timeoutNow()` to `TimeoutController` for invoking timeout\n  directly\n* Invoke `timeoutNow()` when the given time is before now\n\nResult:\nA user can trigger timeout immediately by setting past time"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMDYzNjgy", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-341063682", "createdAt": "2020-01-10T10:06:18Z", "commit": {"oid": "8ea9af5646b89abb9e29f4838f3dcbe897b7f710"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDowNjoxOFrOFcPiZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDowNjoxOFrOFcPiZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE1OTAxNQ==", "bodyText": "Does it need a guard here? \ud83e\udd14\nif (cancelTimeout()) {\n    timeoutTask.run();\n}", "url": "https://github.com/line/armeria/pull/2391#discussion_r365159015", "createdAt": "2020-01-10T10:06:18Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -149,6 +149,13 @@ public void resetTimeout(long newTimeoutMillis) {\n         }\n     }\n \n+    @Override\n+    public void timeoutNow() {\n+        ensureInitialized();\n+        cancelTimeout();\n+        timeoutTask.run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ea9af5646b89abb9e29f4838f3dcbe897b7f710"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e6cf6119c5747753b34742bdd48a9b2d3cbf13f", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/7e6cf6119c5747753b34742bdd48a9b2d3cbf13f", "committedDate": "2020-01-10T10:11:03Z", "message": "Change Instant.now() to System.currentTimeMillis()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMDcwMDI2", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-341070026", "createdAt": "2020-01-10T10:18:17Z", "commit": {"oid": "7e6cf6119c5747753b34742bdd48a9b2d3cbf13f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDoxODoxN1rOFcP2sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDoxODoxN1rOFcP2sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NDIwOA==", "bodyText": "How about: the request will be timed out immediately", "url": "https://github.com/line/armeria/pull/2391#discussion_r365164208", "createdAt": "2020-01-10T10:18:17Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContext.java", "diffHunk": "@@ -497,6 +498,7 @@ default MediaType negotiatedProduceType() {\n     /**\n      * Schedules the request timeout that is triggered at the specified time represented\n      * as the number since the epoch ({@code 1970-01-01T00:00:00Z}).\n+     * Note that the request timeout is triggered immediately if the specified time is before now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6cf6119c5747753b34742bdd48a9b2d3cbf13f"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "934d89f41debea4892773cee4c212a2330dcaa52", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/934d89f41debea4892773cee4c212a2330dcaa52", "committedDate": "2020-01-10T10:32:03Z", "message": "Address comments by @trustin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMTM3OTY5", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-341137969", "createdAt": "2020-01-10T12:41:21Z", "commit": {"oid": "934d89f41debea4892773cee4c212a2330dcaa52"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMjUyODA4", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-342252808", "createdAt": "2020-01-14T01:59:27Z", "commit": {"oid": "8a490d47b12478bfe08b6ed054df61d45f759611"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMTo1OToyN1rOFdKOig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMTo1OToyN1rOFdKOig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEyMDU4Ng==", "bodyText": "Don't we need to add pendingTimeoutTask here?", "url": "https://github.com/line/armeria/pull/2391#discussion_r366120586", "createdAt": "2020-01-14T01:59:27Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -456,12 +456,20 @@ public void setRequestTimeoutAfter(Duration requestTimeout) {\n     public void setRequestTimeoutAtMillis(long requestTimeoutAtMillis) {\n         checkArgument(requestTimeoutAtMillis >= 0,\n                       \"requestTimeoutAtMillis: \" + requestTimeoutAtMillis + \" (expected: >= 0)\");\n-        final long nowMillis = Instant.now().toEpochMilli();\n-        final long requestTimeoutAfter = requestTimeoutAtMillis - nowMillis;\n-        checkArgument(requestTimeoutAfter > 0,\n-                      \"requestTimeoutAtMillis: %s (expected: > 'now=%s')\", requestTimeoutAtMillis, nowMillis);\n-\n-        setRequestTimeoutAfterMillis(requestTimeoutAfter);\n+        final long requestTimeoutAfter = requestTimeoutAtMillis - System.currentTimeMillis();\n+\n+        if (requestTimeoutAfter <= 0) {\n+            final TimeoutController requestTimeoutController = this.requestTimeoutController;\n+            if (requestTimeoutController != null) {\n+                if (eventLoop().inEventLoop()) {\n+                    requestTimeoutController.timeoutNow();\n+                } else {\n+                    eventLoop().execute(requestTimeoutController::timeoutNow);\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a490d47b12478bfe08b6ed054df61d45f759611"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMjUzMzY0", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-342253364", "createdAt": "2020-01-14T02:01:36Z", "commit": {"oid": "8a490d47b12478bfe08b6ed054df61d45f759611"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMjowMTozNlrOFdKQYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMjowMTozNlrOFdKQYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEyMTA1Ng==", "bodyText": "Initializes -> Sets?\nDo you have a reason that you changed the name? I think I'd like initTimeout. \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2391#discussion_r366121056", "createdAt": "2020-01-14T02:01:36Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -26,7 +26,7 @@\n     /**\n      * Initializes the timeout scheduler with the specified {@code timeoutMillis}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a490d47b12478bfe08b6ed054df61d45f759611"}, "originalPosition": 2}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32f45dd6b3587f1087c090dcd1280ba8a55bc424", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/32f45dd6b3587f1087c090dcd1280ba8a55bc424", "committedDate": "2020-01-14T03:49:53Z", "message": "Address comments by @minwoox\n\n- Update Javadoc\n- Capture timeout changes when the responseTimeoutController is not set yet\n- Run the pending task when responseTimeoutController is set to the context\n- Rename `initTimeout` to `scheduleTimeout`\n- Lax DefaultTimeoutController API validation\n  - Can call `resetTimeout` or `exendTimeout` before `scheduleTimeout` is called."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8a490d47b12478bfe08b6ed054df61d45f759611", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/8a490d47b12478bfe08b6ed054df61d45f759611", "committedDate": "2020-01-13T16:13:57Z", "message": "Address comments by @minwoox\n\n- Capture timeout changes when the responseTimeoutController is not set yet\n- Run the pending task when responseTimeoutController is set to the context"}, "afterCommit": {"oid": "32f45dd6b3587f1087c090dcd1280ba8a55bc424", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/32f45dd6b3587f1087c090dcd1280ba8a55bc424", "committedDate": "2020-01-14T03:49:53Z", "message": "Address comments by @minwoox\n\n- Update Javadoc\n- Capture timeout changes when the responseTimeoutController is not set yet\n- Run the pending task when responseTimeoutController is set to the context\n- Rename `initTimeout` to `scheduleTimeout`\n- Lax DefaultTimeoutController API validation\n  - Can call `resetTimeout` or `exendTimeout` before `scheduleTimeout` is called."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cad8d180a7b43633de11510a5472fa858688633", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/6cad8d180a7b43633de11510a5472fa858688633", "committedDate": "2020-01-14T04:01:06Z", "message": "Merge branch 'master' into past-timeout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e971d6cd23da99c59409f5d1279327288a05f88a", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/e971d6cd23da99c59409f5d1279327288a05f88a", "committedDate": "2020-01-14T05:40:49Z", "message": "Add server-side pendingTimeoutTask"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c997709866ea6b28d1c1a0769654d5c96b6978e", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/1c997709866ea6b28d1c1a0769654d5c96b6978e", "committedDate": "2020-01-14T06:26:48Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ba0e6fd3b015ed5f35dbb0ad6fca792a4f7bdbe", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/8ba0e6fd3b015ed5f35dbb0ad6fca792a4f7bdbe", "committedDate": "2020-01-14T08:02:11Z", "message": "Update scheduleTimeout() - work only if no timeout was scheduled"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMzY4Mjk2", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-342368296", "createdAt": "2020-01-14T08:51:39Z", "commit": {"oid": "8ba0e6fd3b015ed5f35dbb0ad6fca792a4f7bdbe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwODo1MTo0MFrOFdP4Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwODo1MTo0MFrOFdP4Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxMzE1MQ==", "bodyText": "It seems like there's not much chance that a new TimeoutTask it set.\nHow about removing the setter and setting it in the constructor?\n// In HttpResponseDecoder\nHttpResponseWrapper(...) {\n    super(eventLoop, newTimeoutTask(delegate, ctx));\n    this.delegate = delegate;\n    this.ctx = ctx;\n    this.maxContentLength = maxContentLength;\n    this.responseTimeoutMillis = responseTimeoutMillis;\n}\n\n// In HttpResponseSubscriber\nHttpResponseSubscriber(ChannelHandlerContext ctx, HttpObjectEncoder responseEncoder,\n                       DefaultServiceRequestContext reqCtx, DecodedHttpRequest req,\n                       boolean enableServerHeader, boolean enableDateHeader) {\n    super(ctx.channel().eventLoop(), newTimeoutTask(reqCtx));\n    this.ctx = ctx;\n    this.responseEncoder = responseEncoder;\n    this.req = req;\n    this.reqCtx = reqCtx;\n    this.enableServerHeader = enableServerHeader;\n    this.enableDateHeader = enableDateHeader;\n}", "url": "https://github.com/line/armeria/pull/2391#discussion_r366213151", "createdAt": "2020-01-14T08:51:40Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -78,74 +79,98 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        // Do nothing if the timeout was scheduled already\n+        if (timeoutFuture != null) {\n+            return false;\n+        }\n+\n+        cancelTimeout();\n+        if (!timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+        timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba0e6fd3b015ed5f35dbb0ad6fca792a4f7bdbe"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTc0MDQ4", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-342974048", "createdAt": "2020-01-15T03:40:21Z", "commit": {"oid": "8ba0e6fd3b015ed5f35dbb0ad6fca792a4f7bdbe"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d540cdacc10670806c4464bfe9ecc37c31545668", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/d540cdacc10670806c4464bfe9ecc37c31545668", "committedDate": "2020-01-15T05:22:25Z", "message": "Add 'TODO' for future work"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDA5NTE4", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-343009518", "createdAt": "2020-01-15T06:30:39Z", "commit": {"oid": "d540cdacc10670806c4464bfe9ecc37c31545668"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNjozMDozOVrOFduYjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNjozMjoyMFrOFduaKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcxMjk3Mg==", "bodyText": "Question, does it makes sense to make this method return a boolean value?", "url": "https://github.com/line/armeria/pull/2391#discussion_r366712972", "createdAt": "2020-01-15T06:30:39Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,27 +24,38 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     * @return {@code true} if the timeout is scheduled.\n      */\n-    void initTimeout(long timeoutMillis);\n+    boolean scheduleTimeout(long timeoutMillis);\n \n     /**\n      * Extends the current timeout by the specified {@code adjustmentMillis}.\n+     * This method does nothing if no timeout was scheduled previously.\n      * Note that a negative {@code adjustmentMillis} reduces the current timeout.\n      *\n      * @param adjustmentMillis the adjustment of time amount value in milliseconds.\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n      */\n-    void extendTimeout(long adjustmentMillis);\n+    boolean extendTimeout(long adjustmentMillis);\n \n     /**\n      * Sets the amount of time that is after the specified {@code newTimeoutMillis} from now.\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n      */\n-    void resetTimeout(long newTimeoutMillis);\n+    boolean resetTimeout(long newTimeoutMillis);\n+\n+    /**\n+     * Trigger the current timeout immediately.\n+     */\n+    void timeoutNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d540cdacc10670806c4464bfe9ecc37c31545668"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcxMzA5Nw==", "bodyText": "Could you also document when false is returned, e.g. {@code false} if the timeout could not be scheduled because .... or .... (Please fix all methods.)", "url": "https://github.com/line/armeria/pull/2391#discussion_r366713097", "createdAt": "2020-01-15T06:31:10Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,27 +24,38 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     * @return {@code true} if the timeout is scheduled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d540cdacc10670806c4464bfe9ecc37c31545668"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcxMzM4NQ==", "bodyText": "Could return whether the timeout task was run or not?", "url": "https://github.com/line/armeria/pull/2391#discussion_r366713385", "createdAt": "2020-01-15T06:32:20Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -78,74 +79,98 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        // Do nothing if the timeout was scheduled already\n+        if (timeoutFuture != null) {\n+            return false;\n+        }\n+\n+        cancelTimeout();\n+        if (!timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+        timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n-        if (adjustmentMillis == 0) {\n-            return;\n+        if (adjustmentMillis == 0 || timeoutFuture == null) {\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n+        if (!timeoutTask.canSchedule()) {\n+            return false;\n+        }\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+        if (newTimeoutMillis > 0) {\n+            timeoutFuture = eventLoop.schedule(\n+                    timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        } else {\n+            // We went past the dead line set by the new timeout already.\n+            timeoutTask.run();\n         }\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        if (!timeoutTask.canSchedule()) {\n+            return false;\n+        }\n \n-            // Cancel the previously scheduled timeout, if exists.\n-            cancelTimeout();\n-            timeoutMillis = newTimeoutMillis;\n-            timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis,\n-                                               TimeUnit.MILLISECONDS);\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n+    }\n+\n+    @Override\n+    public void timeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"setTimeoutTask(timeoutTask) is not called yet.\");\n+        if (cancelTimeout()) {\n+            timeoutTask.run();\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d540cdacc10670806c4464bfe9ecc37c31545668"}, "originalPosition": 159}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "368a9383d810f5e8f630b3bcff9bc6e40581711f", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/368a9383d810f5e8f630b3bcff9bc6e40581711f", "committedDate": "2020-01-15T07:51:21Z", "message": "Address comments by @trustin / Update Javdoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14e7d1a5b0d0aa01e145a7b7baae31fb8553b4cd", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/14e7d1a5b0d0aa01e145a7b7baae31fb8553b4cd", "committedDate": "2020-01-15T08:12:10Z", "message": "Update Javadoc @param"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjQ4MzMz", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-343648333", "createdAt": "2020-01-16T02:56:02Z", "commit": {"oid": "368a9383d810f5e8f630b3bcff9bc6e40581711f"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjo1NjowM1rOFeMrNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjo1ODo0NFrOFeMtYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTI3MQ==", "bodyText": "What are the 'some constraints'?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209271", "createdAt": "2020-01-16T02:56:03Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -37,6 +39,8 @@\n      *\n      * @param adjustmentMillis the adjustment of time amount value in milliseconds.\n      * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if the current timeout could not be extended\n+     *         because of some constraints in the class that implements this interface.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "368a9383d810f5e8f630b3bcff9bc6e40581711f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTM3OQ==", "bodyText": ".. if the timeout has been scheduled already?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209379", "createdAt": "2020-01-16T02:56:37Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -27,6 +27,8 @@\n      * Schedules a new timeout with the specified {@code timeoutMillis}.\n      * If a timeout is scheduled already, this method will not start a new timeout.\n      * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout could not be scheduled because the timeout is currently being\n+     *         scheduled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "368a9383d810f5e8f630b3bcff9bc6e40581711f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTQ3Nw==", "bodyText": "What are the 'some constraints'?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209477", "createdAt": "2020-01-16T02:57:08Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -45,17 +49,24 @@\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n      * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the current timeout could not be reset\n+     *         because of some constraints in the class that implements this interface.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "368a9383d810f5e8f630b3bcff9bc6e40581711f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTYxOA==", "bodyText": ".. if the timeout has been triggered already?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209618", "createdAt": "2020-01-16T02:57:48Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -45,17 +49,24 @@\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n      * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the current timeout could not be reset\n+     *         because of some constraints in the class that implements this interface.\n      */\n     boolean resetTimeout(long newTimeoutMillis);\n \n     /**\n      * Trigger the current timeout immediately.\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if the current timeout could not be triggered now because\n+     *         the timeout schedule has already completed normally.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "368a9383d810f5e8f630b3bcff9bc6e40581711f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTgyNw==", "bodyText": ".. if the timeout has been triggered already?\nWhat happens if no timeout was scheduled previously? What happens if a user calls this method and then scheduled a new timeout?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209827", "createdAt": "2020-01-16T02:58:44Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -45,17 +49,24 @@\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n      * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the current timeout could not be reset\n+     *         because of some constraints in the class that implements this interface.\n      */\n     boolean resetTimeout(long newTimeoutMillis);\n \n     /**\n      * Trigger the current timeout immediately.\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if the current timeout could not be triggered now because\n+     *         the timeout schedule has already completed normally.\n      */\n-    void timeoutNow();\n+    boolean timeoutNow();\n \n     /**\n      * Cancels the current timeout scheduled.\n-     * @return {@code true} if the current timeout is canceled.\n+     * @return {@code true} if the current timeout is canceled or no timeout is being scheduled.\n+     *         {@code false} if the current timeout could not be cancelled typically because\n+     *         the timeout schedule has already completed normally.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "368a9383d810f5e8f630b3bcff9bc6e40581711f"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0c03af8b844183dcc70d665a7d03feb4ad77533", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/b0c03af8b844183dcc70d665a7d03feb4ad77533", "committedDate": "2020-01-16T07:39:58Z", "message": "Address comments by @trustin\n\n- Add State to DefalutTimeoutController\n- Update Javadoc\n- Add test case for checking State transition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a29181bcf77cf9840fbc4b92884545a31b214817", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/a29181bcf77cf9840fbc4b92884545a31b214817", "committedDate": "2020-01-16T07:46:24Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "committedDate": "2020-01-16T07:49:48Z", "message": "Fix test name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a463b933ca2d03f626e7c5f44109cf58196dc1d", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/4a463b933ca2d03f626e7c5f44109cf58196dc1d", "committedDate": "2020-01-16T08:27:53Z", "message": "Fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzM0NzY5", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-343734769", "createdAt": "2020-01-16T08:17:27Z", "commit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwODoxNzoyOFrOFeRE0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwODoyNzowOFrOFeRT0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MTM2MA==", "bodyText": "has been scheduled or triggered already", "url": "https://github.com/line/armeria/pull/2391#discussion_r367281360", "createdAt": "2020-01-16T08:17:28Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,27 +24,47 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     *\n+     * @param timeoutMillis a positive time amount value in milliseconds.\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled or the timeout has been triggered already.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MTk0Nw==", "bodyText": "Perhaps we can remove this, because it's already in the super class Javadoc?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367281947", "createdAt": "2020-01-16T08:18:59Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MjM0Nw==", "bodyText": "Ditto - already in the super class Javadoc", "url": "https://github.com/line/armeria/pull/2391#discussion_r367282347", "createdAt": "2020-01-16T08:20:04Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4Mjc3MA==", "bodyText": "Ditto", "url": "https://github.com/line/armeria/pull/2391#discussion_r367282770", "createdAt": "2020-01-16T08:21:15Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;\n+            return false;\n         }\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4Mjk2MA==", "bodyText": "Global comment - state != ... or state == ... for readability", "url": "https://github.com/line/armeria/pull/2391#discussion_r367282960", "createdAt": "2020-01-16T08:21:49Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;\n+            return false;\n         }\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n+    }\n \n-            // Cancel the previously scheduled timeout, if exists.\n-            cancelTimeout();\n-            timeoutMillis = newTimeoutMillis;\n-            timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis,\n-                                               TimeUnit.MILLISECONDS);\n+    /**\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n+    @Override\n+    public boolean timeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"setTimeoutTask(timeoutTask) is not called yet.\");\n+\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MzI1NA==", "bodyText": "Could set in finally block, just in case run() throws an exception", "url": "https://github.com/line/armeria/pull/2391#discussion_r367283254", "createdAt": "2020-01-16T08:22:42Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;\n+            return false;\n         }\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n+    }\n \n-            // Cancel the previously scheduled timeout, if exists.\n-            cancelTimeout();\n-            timeoutMillis = newTimeoutMillis;\n-            timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis,\n-                                               TimeUnit.MILLISECONDS);\n+    /**\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n+    @Override\n+    public boolean timeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"setTimeoutTask(timeoutTask) is not called yet.\");\n+\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n+\n+        if (cancelTimeout()) {\n+            invokeTimeoutTask();\n+            return true;\n+        }\n+\n+        return false;\n     }\n \n     @Override\n     public boolean cancelTimeout() {\n-        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;\n-        if (timeoutFuture == null) {\n+        if (State.TIMED_OUT == state) {\n+            return false;\n+        }\n+        if (State.DISABLED == state) {\n             return true;\n         }\n \n+        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;\n+        assert timeoutFuture != null;\n+\n         this.timeoutFuture = null;\n-        return timeoutFuture.cancel(false);\n+        final boolean canceled = timeoutFuture.cancel(false);\n+        state = State.DISABLED;\n+        return canceled;\n     }\n \n     private void ensureInitialized() {\n         checkState(timeoutTask != null,\n                    \"setTimeoutTask(timeoutTask) is not called yet.\");\n-        checkState(firstStartTimeNanos > 0,\n-                   \"initTimeout(timeoutMillis) is not called yet.\");\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = lastExecutionTimeNanos = System.nanoTime();\n+        }\n+    }\n+\n+    @Nullable\n+    private void invokeTimeoutTask() {\n+        if (timeoutTask != null) {\n+            timeoutTask.run();\n+            state = State.TIMED_OUT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MzU2NA==", "bodyText": "This is redundant because invokeTimeoutTask updates state.", "url": "https://github.com/line/armeria/pull/2391#discussion_r367283564", "createdAt": "2020-01-16T08:23:30Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4Mzg2Ng==", "bodyText": "nit: Could use switch-case?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367283866", "createdAt": "2020-01-16T08:24:15Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;\n+            return false;\n         }\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n+    }\n \n-            // Cancel the previously scheduled timeout, if exists.\n-            cancelTimeout();\n-            timeoutMillis = newTimeoutMillis;\n-            timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis,\n-                                               TimeUnit.MILLISECONDS);\n+    /**\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n+    @Override\n+    public boolean timeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"setTimeoutTask(timeoutTask) is not called yet.\");\n+\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n+\n+        if (cancelTimeout()) {\n+            invokeTimeoutTask();\n+            return true;\n+        }\n+\n+        return false;\n     }\n \n     @Override\n     public boolean cancelTimeout() {\n-        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;\n-        if (timeoutFuture == null) {\n+        if (State.TIMED_OUT == state) {\n+            return false;\n+        }\n+        if (State.DISABLED == state) {\n             return true;\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4NTIwMQ==", "bodyText": "0 has a meaning in nano time. Need to introduce a boolean?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367285201", "createdAt": "2020-01-16T08:27:08Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -35,16 +36,23 @@\n  */\n public class DefaultTimeoutController implements TimeoutController {\n \n+    enum State {\n+        DISABLED,\n+        SCHEDULED,\n+        TIMED_OUT,\n+    }\n+\n     @Nullable\n     private TimeoutTask timeoutTask;\n     private final EventLoop eventLoop;\n \n     private long timeoutMillis;\n-    private long firstStartTimeNanos;\n-    private long lastStartTimeNanos;\n+    private long firstExecutionTimeNanos;\n+    private long lastExecutionTimeNanos;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "750caad3a01f8b55ce87fd09cdceb848de9979b6", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/750caad3a01f8b55ce87fd09cdceb848de9979b6", "committedDate": "2020-01-16T09:12:15Z", "message": "Address comments by @trustin\n\n- Update Javadoc in TimeoutController\n- Add finnaly in invokeTimeoutTask\n- Flip if condition\n- Add a flag to indicate the timeout task is scheduled at least once"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "742f7b4247d841c48bc8c8a84a75e229f65dbc73", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/742f7b4247d841c48bc8c8a84a75e229f65dbc73", "committedDate": "2020-01-16T09:58:37Z", "message": "Make `startTimeNanos` return null when no timeout was scheduled before"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67eef3419ec1a728df4a977f431309833b41bff2", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/67eef3419ec1a728df4a977f431309833b41bff2", "committedDate": "2020-01-17T09:21:02Z", "message": "Revamp cancelTimeout return value\n\n- Add getters for TimeoutController state\n- Fix broken test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NDUyNTM3", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-344452537", "createdAt": "2020-01-17T09:26:43Z", "commit": {"oid": "67eef3419ec1a728df4a977f431309833b41bff2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOToyNjo0NFrOFezIDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOToyNzo0OVrOFezJzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzOTI0Nw==", "bodyText": "The cancelTimeout returns true if the timeout is being scheduled now.", "url": "https://github.com/line/armeria/pull/2391#discussion_r367839247", "createdAt": "2020-01-17T09:26:44Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/server/HttpResponseSubscriber.java", "diffHunk": "@@ -258,11 +261,13 @@ public void onError(Throwable cause) {\n \n     @Override\n     public void onComplete() {\n-        if (!cancelTimeout() && reqCtx.requestTimeoutHandler() == null) {\n+        if (isTimedOut() && reqCtx.requestTimeoutHandler() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67eef3419ec1a728df4a977f431309833b41bff2"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzOTY5NA==", "bodyText": "I changed due to the changed cancelTimeout return value.", "url": "https://github.com/line/armeria/pull/2391#discussion_r367839694", "createdAt": "2020-01-17T09:27:49Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -294,14 +294,19 @@ private void cancelAction(@Nullable Throwable cause) {\n         }\n \n         private void cancelTimeoutOrLog(@Nullable Throwable cause,\n-                                        Consumer<Throwable> actionOnTimeoutCancelled) {\n+                                        Consumer<Throwable> actionOnNotTimedOut) {\n \n-            if (cancelTimeout()) {\n+            if (!isTimedOut()) {\n+                cancelTimeout();\n                 // There's no timeout or the response has not been timed out.\n-                actionOnTimeoutCancelled.accept(cause);\n+                actionOnNotTimedOut.accept(cause);\n                 return;\n             }\n \n+            if (delegate.isOpen()) {\n+                closeAction(cause);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67eef3419ec1a728df4a977f431309833b41bff2"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NDU1MDc2", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-344455076", "createdAt": "2020-01-17T09:30:59Z", "commit": {"oid": "750caad3a01f8b55ce87fd09cdceb848de9979b6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOTozMTowMFrOFezPtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOTozNzo1OFrOFezcLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0MTIwNA==", "bodyText": "How about scheduledAtLeastOnce?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367841204", "createdAt": "2020-01-17T09:31:00Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -93,14 +94,15 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n     public boolean scheduleTimeout(long timeoutMillis) {\n         checkArgument(timeoutMillis > 0,\n                       \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n-        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n             return false;\n         }\n \n         cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n         final long nanoTime = System.nanoTime();\n-        if (firstExecutionTimeNanos == 0) {\n+        if (!isExecutedAtLeastOnce) {\n+            isExecutedAtLeastOnce = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "750caad3a01f8b55ce87fd09cdceb848de9979b6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0MzMxNQ==", "bodyText": "case SCHEDULED:\n    ...\n\ndefault:\n    throw new Error();", "url": "https://github.com/line/armeria/pull/2391#discussion_r367843315", "createdAt": "2020-01-17T09:35:33Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -196,36 +190,60 @@ public boolean timeoutNow() {\n         checkState(timeoutTask != null,\n                    \"setTimeoutTask(timeoutTask) is not called yet.\");\n \n-        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+        if (!timeoutTask.canSchedule()) {\n             return false;\n         }\n \n-        if (cancelTimeout()) {\n-            invokeTimeoutTask();\n-            return true;\n+        switch (state) {\n+            case TIMED_OUT:\n+                return false;\n+            case DISABLED:\n+                invokeTimeoutTask();\n+                return true;\n+            default: // state == State.SCHEDULED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67eef3419ec1a728df4a977f431309833b41bff2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NDM5OA==", "bodyText": "It seems like this method is not used anywhere? Maybe OK to remove?", "url": "https://github.com/line/armeria/pull/2391#discussion_r367844398", "createdAt": "2020-01-17T09:37:58Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -69,11 +69,32 @@\n     /**\n      * Cancels the current timeout scheduled. You can schedule a new timeout with\n      * {@link #scheduleTimeout(long)} if the current timeout is canceled successfully.\n-     * @return {@code true} if the current timeout is canceled or no timeout was scheduled previously.\n-     *         {@code false} if the timeout has been triggered already.\n+     * @return {@code true} if the current timeout is canceled.\n+     *         {@code false} if the timeout has been triggered already or no timeout was scheduled previously.\n      */\n     boolean cancelTimeout();\n \n+    /**\n+     * Returns whether the timeout is scheduled or not.\n+     *\n+     * @return {@code true} the timeout is scheduled now.\n+     *         {@code false} if the timeout has been triggered already or no timeout was scheduled previously.\n+     */\n+    boolean isScheduled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67eef3419ec1a728df4a977f431309833b41bff2"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NDYwMzg0", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-344460384", "createdAt": "2020-01-17T09:40:27Z", "commit": {"oid": "67eef3419ec1a728df4a977f431309833b41bff2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOTo0MDoyN1rOFezgJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOTo0NTowMVrOFezojg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NTQxMw==", "bodyText": "Is there a chance a user calls timeout methods multiple times? Probably better chaining with andThen()", "url": "https://github.com/line/armeria/pull/2391#discussion_r367845413", "createdAt": "2020-01-17T09:40:27Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -95,6 +95,8 @@\n     private Runnable responseTimeoutHandler;\n     @Nullable\n     private TimeoutController responseTimeoutController;\n+    @Nullable\n+    private Consumer<TimeoutController> pendingTimeoutTask;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67eef3419ec1a728df4a977f431309833b41bff2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NzU2Ng==", "bodyText": "Seems like this is only used for testing.\nI'm not sure, but if (startTimeNanos() is null if and only if state is DISABLED), then we could:\n\nRemove isDisabled() and use startTimeNanos() == null in the tests\nReplace isExecutedAtLeastOnce with state != DISABLED\n\nWe could set firstExecutionTime when the current state is DISABLED.", "url": "https://github.com/line/armeria/pull/2391#discussion_r367847566", "createdAt": "2020-01-17T09:45:01Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,32 +26,79 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     *\n+     * @param timeoutMillis a positive time amount value in milliseconds.\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void initTimeout(long timeoutMillis);\n+    boolean scheduleTimeout(long timeoutMillis);\n \n     /**\n      * Extends the current timeout by the specified {@code adjustmentMillis}.\n      * Note that a negative {@code adjustmentMillis} reduces the current timeout.\n      *\n      * @param adjustmentMillis the adjustment of time amount value in milliseconds.\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void extendTimeout(long adjustmentMillis);\n+    boolean extendTimeout(long adjustmentMillis);\n \n     /**\n      * Sets the amount of time that is after the specified {@code newTimeoutMillis} from now.\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void resetTimeout(long newTimeoutMillis);\n+    boolean resetTimeout(long newTimeoutMillis);\n \n     /**\n-     * Cancels the current timeout scheduled.\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n+     */\n+    boolean timeoutNow();\n+\n+    /**\n+     * Cancels the current timeout scheduled. You can schedule a new timeout with\n+     * {@link #scheduleTimeout(long)} if the current timeout is canceled successfully.\n+     * @return {@code true} if the current timeout is canceled.\n+     *         {@code false} if the timeout has been triggered already or no timeout was scheduled previously.\n      */\n     boolean cancelTimeout();\n \n     /**\n-     * Returns the start time of the initial timeout in nanoseconds.\n+     * Returns whether the timeout is scheduled or not.\n+     *\n+     * @return {@code true} the timeout is scheduled now.\n+     *         {@code false} if the timeout has been triggered already or no timeout was scheduled previously.\n+     */\n+    boolean isScheduled();\n+\n+    /**\n+     * Returns whether the timeout has been triggered or not.\n+     *\n+     * @return {@code true} if the timeout has been triggered already.\n+     *         {@code false} if the timeout is scheduled now or no timeout was scheduled previously.\n+     */\n+    boolean isTimedOut();\n+\n+    /**\n+     * Returns {@code true} if no timeout was scheduled previously.\n+     */\n+    boolean isDisabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67eef3419ec1a728df4a977f431309833b41bff2"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/58c45948770817092b945acef0cb4f0ed5310f0e", "committedDate": "2020-01-19T14:41:29Z", "message": "Add  State.INIT to DefaultTimeoutController"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTA2ODMz", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-345106833", "createdAt": "2020-01-20T06:57:35Z", "commit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwNjo1NzozNVrOFfU3BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwNzowNzoyMFrOFfU_tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MTk0MQ==", "bodyText": "set -> add?", "url": "https://github.com/line/armeria/pull/2391#discussion_r368391941", "createdAt": "2020-01-20T06:57:35Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -593,6 +593,14 @@ public void setResponseTimeoutController(TimeoutController responseTimeoutContro\n         }\n     }\n \n+    private void setPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MjIwMg==", "bodyText": "set -> add", "url": "https://github.com/line/armeria/pull/2391#discussion_r368392202", "createdAt": "2020-01-20T06:58:39Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -669,6 +669,14 @@ public void setRequestTimeoutController(TimeoutController requestTimeoutControll\n         }\n     }\n \n+    private void setPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MjU2Mg==", "bodyText": "assertThat(prevState).isNotIn(State.INIT, State.DISABLED)", "url": "https://github.com/line/armeria/pull/2391#discussion_r368392562", "createdAt": "2020-01-20T07:00:13Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/internal/DefaultTimeoutControllerTest.java", "diffHunk": "@@ -281,12 +282,12 @@ public boolean scheduleTimeout(long timeoutMillis) {\n             final boolean result = delegate.scheduleTimeout(timeoutMillis);\n             if (result) {\n                 // Previous: DISABLED\n-                assertThat(prevState).isEqualTo(State.DISABLED);\n+                assertThat(prevState == State.INIT || prevState == DISABLED).isTrue();\n                 // Transition to: SCHEDULE\n                 assertThat(delegate.state()).isEqualTo(State.SCHEDULED);\n             } else {\n                 // Previous: !DISABLED\n-                assertThat(prevState).isNotEqualTo(State.DISABLED);\n+                assertThat(prevState == State.INIT || prevState == DISABLED).isFalse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MjU3OA==", "bodyText": "assertThat(prevState).isIn(State.INIT, State.DISABLED)", "url": "https://github.com/line/armeria/pull/2391#discussion_r368392578", "createdAt": "2020-01-20T07:00:20Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/internal/DefaultTimeoutControllerTest.java", "diffHunk": "@@ -281,12 +282,12 @@ public boolean scheduleTimeout(long timeoutMillis) {\n             final boolean result = delegate.scheduleTimeout(timeoutMillis);\n             if (result) {\n                 // Previous: DISABLED\n-                assertThat(prevState).isEqualTo(State.DISABLED);\n+                assertThat(prevState == State.INIT || prevState == DISABLED).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MjY3MA==", "bodyText": "Static-import all or none", "url": "https://github.com/line/armeria/pull/2391#discussion_r368392670", "createdAt": "2020-01-20T07:00:45Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/internal/DefaultTimeoutControllerTest.java", "diffHunk": "@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.linecorp.armeria.internal.DefaultTimeoutController.State.DISABLED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MzU2Nw==", "bodyText": "Use %s. + will be done even if IllegalArgumentException is not raised.", "url": "https://github.com/line/armeria/pull/2391#discussion_r368393567", "createdAt": "2020-01-20T07:04:42Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5Mzc1Nw==", "bodyText": "How about: {@link TimeoutTask#canScheduled()} returned {@code false}. to make it more direct and clear?", "url": "https://github.com/line/armeria/pull/2391#discussion_r368393757", "createdAt": "2020-01-20T07:05:40Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        ensureInitialized();\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n-        }\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5Mzg5Mw==", "bodyText": "Ditto", "url": "https://github.com/line/armeria/pull/2391#discussion_r368393893", "createdAt": "2020-01-20T07:06:19Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        ensureInitialized();\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n-        }\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            return false;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MzkzOA==", "bodyText": "Ditto", "url": "https://github.com/line/armeria/pull/2391#discussion_r368393938", "createdAt": "2020-01-20T07:06:30Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        ensureInitialized();\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n-        }\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            return false;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n+    }\n+\n+    /**\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5NDE2NQ==", "bodyText": "%s please", "url": "https://github.com/line/armeria/pull/2391#discussion_r368394165", "createdAt": "2020-01-20T07:07:20Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -427,12 +446,22 @@ public void setRequestTimeoutAfter(Duration requestTimeout) {\n     public void setRequestTimeoutAtMillis(long requestTimeoutAtMillis) {\n         checkArgument(requestTimeoutAtMillis >= 0,\n                       \"requestTimeoutAtMillis: \" + requestTimeoutAtMillis + \" (expected: >= 0)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ac1a22f54ca6fd40d4a8c77c79a72494b10db38", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/9ac1a22f54ca6fd40d4a8c77c79a72494b10db38", "committedDate": "2020-01-20T08:08:40Z", "message": "Address comments by @trustin\n\n- Rename setPendingTimeoutTask to addPendingTimeoutTask\n- Replace string concat with `+` to `%s` in checkArgument and\n  checkState.\n- Update Javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1Mjc4MzA4", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-345278308", "createdAt": "2020-01-20T12:35:03Z", "commit": {"oid": "9ac1a22f54ca6fd40d4a8c77c79a72494b10db38"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjUzODE2", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-345253816", "createdAt": "2020-01-20T11:46:30Z", "commit": {"oid": "9ac1a22f54ca6fd40d4a8c77c79a72494b10db38"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTo0NjozMFrOFfb1Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMTo1NDowNFrOFfcAtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUwNjE1MA==", "bodyText": "nit: cancelled", "url": "https://github.com/line/armeria/pull/2391#discussion_r368506150", "createdAt": "2020-01-20T11:46:30Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,32 +26,71 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     *\n+     * @param timeoutMillis a positive time amount value in milliseconds.\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void initTimeout(long timeoutMillis);\n+    boolean scheduleTimeout(long timeoutMillis);\n \n     /**\n      * Extends the current timeout by the specified {@code adjustmentMillis}.\n      * Note that a negative {@code adjustmentMillis} reduces the current timeout.\n      *\n      * @param adjustmentMillis the adjustment of time amount value in milliseconds.\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void extendTimeout(long adjustmentMillis);\n+    boolean extendTimeout(long adjustmentMillis);\n \n     /**\n      * Sets the amount of time that is after the specified {@code newTimeoutMillis} from now.\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void resetTimeout(long newTimeoutMillis);\n+    boolean resetTimeout(long newTimeoutMillis);\n \n     /**\n-     * Cancels the current timeout scheduled.\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n+     */\n+    boolean timeoutNow();\n+\n+    /**\n+     * Cancels the current timeout scheduled. You can schedule a new timeout with\n+     * {@link #scheduleTimeout(long)} if the current timeout is canceled successfully.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ac1a22f54ca6fd40d4a8c77c79a72494b10db38"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUwOTExMA==", "bodyText": "Because adjustmentMillis can be a negative number, shouldn't this be true?", "url": "https://github.com/line/armeria/pull/2391#discussion_r368509110", "createdAt": "2020-01-20T11:54:04Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask#canSchedule()} returned {@code false}.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: %s (expected: > 0)\", timeoutMillis);\n+        ensureInitialized();\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n-        }\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask#canSchedule()} returned {@code false}.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ac1a22f54ca6fd40d4a8c77c79a72494b10db38"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdb8886b1932cb6832b122fd93e6ee6c29115c51", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/bdb8886b1932cb6832b122fd93e6ee6c29115c51", "committedDate": "2020-01-21T02:39:44Z", "message": "Address comments by @minwoox\n\n- Remove `isDisabled` in TimeoutController\n- Rename `DISABLED` to `INACTIVE`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8ec1fb8856050550269950be7b7321d8a296c91", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/e8ec1fb8856050550269950be7b7321d8a296c91", "committedDate": "2020-01-21T04:00:56Z", "message": "Address comments by @minwoox\n\n- Change 'canceled' to 'cancelled'\n- extendTimeout returns 'true' when timeout is triggered"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "473493448faa016f23100c778bc29fa452b82080", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/473493448faa016f23100c778bc29fa452b82080", "committedDate": "2020-01-21T04:00:43Z", "message": "Address comments by @minwoox\n\n- Change 'canceled' to 'cancelled'\n- extendTimeout returns 'false' when timeout is triggered"}, "afterCommit": {"oid": "e8ec1fb8856050550269950be7b7321d8a296c91", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/e8ec1fb8856050550269950be7b7321d8a296c91", "committedDate": "2020-01-21T04:00:56Z", "message": "Address comments by @minwoox\n\n- Change 'canceled' to 'cancelled'\n- extendTimeout returns 'true' when timeout is triggered"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjY1MTg5", "url": "https://github.com/line/armeria/pull/2391#pullrequestreview-345665189", "createdAt": "2020-01-21T06:58:02Z", "commit": {"oid": "e8ec1fb8856050550269950be7b7321d8a296c91"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 846, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}