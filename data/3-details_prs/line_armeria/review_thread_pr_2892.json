{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NDgwMDkw", "number": 2892, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjowMjowOFrOENsY8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjozMzozNFrOEPX64Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzk0MjI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/ByteArrayHttpData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjowMjowOFrOGwceGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjowMjowOFrOGwceGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1MTI5MQ==", "bodyText": "nit: 2020 \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2892#discussion_r453451291", "createdAt": "2020-07-13T06:02:08Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteArrayHttpData.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2016 LINE Corporation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzk2MDkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufAccessMode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjoxMjowNFrOGwco9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjoxMjowNFrOGwco9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NDA3MQ==", "bodyText": "Better to use HttpData?", "url": "https://github.com/line/armeria/pull/2892#discussion_r453454071", "createdAt": "2020-07-13T06:12:04Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufAccessMode.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+/**\n+ * Specifies the way a {@link ByteBuf} is retrieved from an {@link HttpData}.\n+ */\n+@UnstableApi\n+public enum ByteBufAccessMode {\n+    /**\n+     * Gets the duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when you access\n+     * the {@link ByteBuf} within the life cycle of the {@link HttpData}:\n+     * <pre>{@code\n+     * try (HttpContent content = ...) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjI1MTI5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufHttpData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNToxMDo1MVrOGxEXoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNToxMDo1MVrOGxEXoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDEwNDk5Mg==", "bodyText": "nit: rnn?", "url": "https://github.com/line/armeria/pull/2892#discussion_r454104992", "createdAt": "2020-07-14T05:10:51Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufHttpData.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import it.unimi.dsi.fastutil.io.FastByteArrayInputStream;\n+\n+/**\n+ * A {@link ByteBuf}-based {@link HttpData}.\n+ */\n+final class ByteBufHttpData implements HttpData {\n+\n+    private static final int FLAG_POOLED = 1;\n+    private static final int FLAG_END_OF_STREAM = 2;\n+    private static final int FLAG_CLOSED = 4;\n+\n+    private final ByteBuf buf;\n+    @Nullable\n+    private byte[] array;\n+    private int flags;\n+\n+    ByteBufHttpData(ByteBuf buf, boolean pooled) {\n+        this(buf, pooled ? FLAG_POOLED : 0, null);\n+    }\n+\n+    private ByteBufHttpData(ByteBuf buf, int flags, @Nullable byte[] array) {\n+        this.buf = buf;\n+        this.array = array;\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        if (array != null) {\n+            return array;\n+        }\n+\n+        final int length = buf.readableBytes();\n+        if (isPooled()) {\n+            buf.touch();\n+        } else if (buf.hasArray() && buf.arrayOffset() == 0 && buf.readerIndex() == 0) {\n+            final byte[] bufArray = buf.array();\n+            if (bufArray.length == length) {\n+                return array = bufArray;\n+            }\n+        }\n+\n+        return array = ByteBufUtil.getBytes(buf, buf.readerIndex(), length);\n+    }\n+\n+    @Override\n+    public int length() {\n+        return buf.readableBytes();\n+    }\n+\n+    @Override\n+    public String toString(Charset charset) {\n+        requireNonNull(charset, \"charset\");\n+        if (array != null) {\n+            return new String(array, charset);\n+        } else {\n+            return buf.toString(charset);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final MoreObjects.ToStringHelper helper =\n+                MoreObjects.toStringHelper(this)\n+                           .omitNullValues()\n+                           .addValue(buf.readableBytes() + \"B\");\n+\n+        if (isEndOfStream()) {\n+            helper.addValue(\"endOfStream\");\n+        }\n+        if (isPooled()) {\n+            helper.addValue(\"pooled\");\n+        }\n+        if ((flags & FLAG_CLOSED) != 0) {\n+            helper.addValue(\"closed\");\n+        }\n+\n+        return helper.add(\"byteBuf\", buf)\n+                     .toString();\n+    }\n+\n+    @Override\n+    public InputStream toInputStream() {\n+        if (array != null) {\n+            return new FastByteArrayInputStream(array);\n+        } else {\n+            return new ByteBufInputStream(buf.duplicate(), false);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isEndOfStream() {\n+        return (flags & FLAG_END_OF_STREAM) != 0;\n+    }\n+\n+    @Override\n+    public ByteBufHttpData withEndOfStream(boolean endOfStream) {\n+        if (isEndOfStream() == endOfStream) {\n+            return this;\n+        }\n+\n+        int newFlags = flags & ~FLAG_END_OF_STREAM;\n+        if (endOfStream) {\n+            newFlags |= FLAG_END_OF_STREAM;\n+        }\n+\n+        return new ByteBufHttpData(buf, newFlags, array);\n+    }\n+\n+    @Override\n+    public boolean isPooled() {\n+        return (flags & FLAG_POOLED) != 0;\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(ByteBufAccessMode mode) {\n+        switch (mode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjI2OTk2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/ByteArrayHttpData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNToyMDoxNVrOGxEiVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNToyMDoxNVrOGxEiVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDEwNzczMg==", "bodyText": "nit: rnn for mode?", "url": "https://github.com/line/armeria/pull/2892#discussion_r454107732", "createdAt": "2020-07-14T05:20:15Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteArrayHttpData.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.internal.EmptyArrays;\n+import it.unimi.dsi.fastutil.io.FastByteArrayInputStream;\n+\n+/**\n+ * A {@code byte[]}-based {@link HttpData}.\n+ */\n+final class ByteArrayHttpData implements HttpData {\n+\n+    static final ByteArrayHttpData EMPTY = new ByteArrayHttpData(EmptyArrays.EMPTY_BYTES, false);\n+    static final ByteArrayHttpData EMPTY_EOS = new ByteArrayHttpData(EmptyArrays.EMPTY_BYTES, true);\n+\n+    private final byte[] array;\n+    private final boolean endOfStream;\n+\n+    ByteArrayHttpData(byte[] array) {\n+        this(array, false);\n+    }\n+\n+    private ByteArrayHttpData(byte[] array, boolean endOfStream) {\n+        this.array = array;\n+        this.endOfStream = endOfStream;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        return array;\n+    }\n+\n+    @Override\n+    public int length() {\n+        return array.length;\n+    }\n+\n+    @Override\n+    public String toString(Charset charset) {\n+        requireNonNull(charset, \"charset\");\n+        return new String(array, charset);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final MoreObjects.ToStringHelper helper =\n+                MoreObjects.toStringHelper(this)\n+                           .omitNullValues()\n+                           .addValue(length() + \"B\");\n+\n+        if (isEndOfStream()) {\n+            helper.addValue(\"endOfStream\");\n+        }\n+        return helper.add(\"array\", array)\n+                     .toString();\n+    }\n+\n+    @Override\n+    public InputStream toInputStream() {\n+        return new FastByteArrayInputStream(array);\n+    }\n+\n+    @Override\n+    public boolean isEndOfStream() {\n+        return endOfStream;\n+    }\n+\n+    @Override\n+    public ByteArrayHttpData withEndOfStream(boolean endOfStream) {\n+        if (isEmpty()) {\n+            return endOfStream ? EMPTY_EOS : EMPTY;\n+        }\n+\n+        if (isEndOfStream() == endOfStream) {\n+            return this;\n+        }\n+        return new ByteArrayHttpData(array, endOfStream);\n+    }\n+\n+    @Override\n+    public boolean isPooled() {\n+        return false;\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(ByteBufAccessMode mode) {\n+        if (isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjI3MDMyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/ByteArrayHttpData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNToyMDoyNlrOGxEiig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNToyMDoyNlrOGxEiig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDEwNzc4Ng==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2892#discussion_r454107786", "createdAt": "2020-07-14T05:20:26Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteArrayHttpData.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.internal.EmptyArrays;\n+import it.unimi.dsi.fastutil.io.FastByteArrayInputStream;\n+\n+/**\n+ * A {@code byte[]}-based {@link HttpData}.\n+ */\n+final class ByteArrayHttpData implements HttpData {\n+\n+    static final ByteArrayHttpData EMPTY = new ByteArrayHttpData(EmptyArrays.EMPTY_BYTES, false);\n+    static final ByteArrayHttpData EMPTY_EOS = new ByteArrayHttpData(EmptyArrays.EMPTY_BYTES, true);\n+\n+    private final byte[] array;\n+    private final boolean endOfStream;\n+\n+    ByteArrayHttpData(byte[] array) {\n+        this(array, false);\n+    }\n+\n+    private ByteArrayHttpData(byte[] array, boolean endOfStream) {\n+        this.array = array;\n+        this.endOfStream = endOfStream;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        return array;\n+    }\n+\n+    @Override\n+    public int length() {\n+        return array.length;\n+    }\n+\n+    @Override\n+    public String toString(Charset charset) {\n+        requireNonNull(charset, \"charset\");\n+        return new String(array, charset);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final MoreObjects.ToStringHelper helper =\n+                MoreObjects.toStringHelper(this)\n+                           .omitNullValues()\n+                           .addValue(length() + \"B\");\n+\n+        if (isEndOfStream()) {\n+            helper.addValue(\"endOfStream\");\n+        }\n+        return helper.add(\"array\", array)\n+                     .toString();\n+    }\n+\n+    @Override\n+    public InputStream toInputStream() {\n+        return new FastByteArrayInputStream(array);\n+    }\n+\n+    @Override\n+    public boolean isEndOfStream() {\n+        return endOfStream;\n+    }\n+\n+    @Override\n+    public ByteArrayHttpData withEndOfStream(boolean endOfStream) {\n+        if (isEmpty()) {\n+            return endOfStream ? EMPTY_EOS : EMPTY;\n+        }\n+\n+        if (isEndOfStream() == endOfStream) {\n+            return this;\n+        }\n+        return new ByteArrayHttpData(array, endOfStream);\n+    }\n+\n+    @Override\n+    public boolean isPooled() {\n+        return false;\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(ByteBufAccessMode mode) {\n+        if (isEmpty()) {\n+            return Unpooled.EMPTY_BUFFER;\n+        }\n+\n+        if (mode != ByteBufAccessMode.DIRECT) {\n+            return Unpooled.wrappedBuffer(array);\n+        } else {\n+            final ByteBuf copy = newDirectByteBuf();\n+            copy.writeBytes(array);\n+            return copy;\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(int offset, int length, ByteBufAccessMode mode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjI3MTIwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufHttpData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNToyMDo0NlrOGxEjAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNToyMDo0NlrOGxEjAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDEwNzkwNA==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2892#discussion_r454107904", "createdAt": "2020-07-14T05:20:46Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufHttpData.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import it.unimi.dsi.fastutil.io.FastByteArrayInputStream;\n+\n+/**\n+ * A {@link ByteBuf}-based {@link HttpData}.\n+ */\n+final class ByteBufHttpData implements HttpData {\n+\n+    private static final int FLAG_POOLED = 1;\n+    private static final int FLAG_END_OF_STREAM = 2;\n+    private static final int FLAG_CLOSED = 4;\n+\n+    private final ByteBuf buf;\n+    @Nullable\n+    private byte[] array;\n+    private int flags;\n+\n+    ByteBufHttpData(ByteBuf buf, boolean pooled) {\n+        this(buf, pooled ? FLAG_POOLED : 0, null);\n+    }\n+\n+    private ByteBufHttpData(ByteBuf buf, int flags, @Nullable byte[] array) {\n+        this.buf = buf;\n+        this.array = array;\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        if (array != null) {\n+            return array;\n+        }\n+\n+        final int length = buf.readableBytes();\n+        if (isPooled()) {\n+            buf.touch();\n+        } else if (buf.hasArray() && buf.arrayOffset() == 0 && buf.readerIndex() == 0) {\n+            final byte[] bufArray = buf.array();\n+            if (bufArray.length == length) {\n+                return array = bufArray;\n+            }\n+        }\n+\n+        return array = ByteBufUtil.getBytes(buf, buf.readerIndex(), length);\n+    }\n+\n+    @Override\n+    public int length() {\n+        return buf.readableBytes();\n+    }\n+\n+    @Override\n+    public String toString(Charset charset) {\n+        requireNonNull(charset, \"charset\");\n+        if (array != null) {\n+            return new String(array, charset);\n+        } else {\n+            return buf.toString(charset);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final MoreObjects.ToStringHelper helper =\n+                MoreObjects.toStringHelper(this)\n+                           .omitNullValues()\n+                           .addValue(buf.readableBytes() + \"B\");\n+\n+        if (isEndOfStream()) {\n+            helper.addValue(\"endOfStream\");\n+        }\n+        if (isPooled()) {\n+            helper.addValue(\"pooled\");\n+        }\n+        if ((flags & FLAG_CLOSED) != 0) {\n+            helper.addValue(\"closed\");\n+        }\n+\n+        return helper.add(\"byteBuf\", buf)\n+                     .toString();\n+    }\n+\n+    @Override\n+    public InputStream toInputStream() {\n+        if (array != null) {\n+            return new FastByteArrayInputStream(array);\n+        } else {\n+            return new ByteBufInputStream(buf.duplicate(), false);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isEndOfStream() {\n+        return (flags & FLAG_END_OF_STREAM) != 0;\n+    }\n+\n+    @Override\n+    public ByteBufHttpData withEndOfStream(boolean endOfStream) {\n+        if (isEndOfStream() == endOfStream) {\n+            return this;\n+        }\n+\n+        int newFlags = flags & ~FLAG_END_OF_STREAM;\n+        if (endOfStream) {\n+            newFlags |= FLAG_END_OF_STREAM;\n+        }\n+\n+        return new ByteBufHttpData(buf, newFlags, array);\n+    }\n+\n+    @Override\n+    public boolean isPooled() {\n+        return (flags & FLAG_POOLED) != 0;\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(ByteBufAccessMode mode) {\n+        switch (mode) {\n+            case DUPLICATE:\n+                return buf.duplicate();\n+            case RETAINED_DUPLICATE:\n+                return buf.retainedDuplicate();\n+            case DIRECT:\n+                if (buf.isDirect()) {\n+                    return buf.retainedDuplicate();\n+                }\n+\n+                final ByteBuf copy = newDirectByteBuf();\n+                copy.writeBytes(buf, buf.readerIndex(), buf.readableBytes());\n+                return copy;\n+        }\n+\n+        throw new Error(); // Never reaches here.\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(int offset, int length, ByteBufAccessMode mode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjMxNzA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/unsafe/PooledObjects.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNTo0MzoxMlrOGxE99g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNTo0MzoxMlrOGxE99g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDExNDgwNg==", "bodyText": "Could just otherwise it's no-op. ?", "url": "https://github.com/line/armeria/pull/2892#discussion_r454114806", "createdAt": "2020-07-14T05:43:12Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/unsafe/PooledObjects.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.unsafe;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnstableApi;\n+import com.linecorp.armeria.server.file.HttpFile;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+\n+/**\n+ * Utility class that provides ways to create a pooled {@link HttpData} and manage its life cycle.\n+ *\n+ * <p><b>Warning</b>: Using a pooled {@link HttpData} is very advanced and can open up much more complicated\n+ * management of a reference counted {@link ByteBuf}. You should only ever do this if you are very comfortable\n+ * with Netty. It is recommended to also read through\n+ * <a href=\"https://netty.io/wiki/reference-counted-objects.html\">Reference counted objects</a>\n+ * for more information on pooled objects.</p>\n+ *\n+ * <h3>What is a pooled {@link HttpData}?</h3>\n+ *\n+ * <p>A pooled {@link HttpData} is a special variant of {@link HttpData} whose {@link HttpData#isPooled()}\n+ * returns {@code true}. It's usually created via {@link HttpData#wrap(ByteBuf)} by wrapping an existing\n+ * {@link ByteBuf}. It can appear when you consume data using the operations such as:\n+ * <ul>\n+ *   <li>{@link StreamMessage#subscribe(Subscriber, SubscriptionOption...)} with\n+ *       {@link SubscriptionOption#WITH_POOLED_OBJECTS}</li>\n+ *   <li>{@link HttpRequest#aggregateWithPooledObjects(ByteBufAllocator)}</li>\n+ *   <li>{@link HttpResponse#aggregateWithPooledObjects(ByteBufAllocator)}</li>\n+ *   <li>{@link HttpFile#aggregateWithPooledObjects(Executor, ByteBufAllocator)}</li>\n+ * </ul></p>\n+ *\n+ * <p>To put it another way, you'll <b>never</b> see a pooled {@link HttpData} if you did not use such\n+ * operations. You can ignore the rest of this section if that's the case.</p>\n+ *\n+ * <p>Any time you receive a pooled {@link HttpData}, it will have an underlying {@link ByteBuf} that must be\n+ * released - failure to release the {@link ByteBuf} will result in a memory leak and poor performance.\n+ * You must make sure to do this by calling {@link HttpData#close()}, usually in a try-with-resources structure\n+ * to avoid side effects, e.g.\n+ * <pre>{@code\n+ * HttpResponse res = client.get(\"/\");\n+ * res.aggregateWithPooledObjects(ctx.alloc(), ctx.executor())\n+ *    .thenApply(aggResp -> {\n+ *        // try-with-resources here ensures the content is released\n+ *        // if it is a pooled HttpData, or otherwise is a no-op if it is not.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjMyNjg5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/server/healthcheck/HealthCheckServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNTo0NzoyOVrOGxFDow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNToyNTozN1rOGyalaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDExNjI1OQ==", "bodyText": "\ud83d\ude04", "url": "https://github.com/line/armeria/pull/2892#discussion_r454116259", "createdAt": "2020-07-14T05:47:29Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/server/healthcheck/HealthCheckServiceTest.java", "diffHunk": "@@ -382,6 +382,7 @@ void custom() {\n                                    \"armeria-lphc\", \"60, 5\"),\n                 HttpData.ofUtf8(\"ok\")));\n \n+        System.err.println(\"--------------------------\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUxNzU0NQ==", "bodyText": "\ud83d\ude05", "url": "https://github.com/line/armeria/pull/2892#discussion_r455517545", "createdAt": "2020-07-16T05:25:37Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/server/healthcheck/HealthCheckServiceTest.java", "diffHunk": "@@ -382,6 +382,7 @@ void custom() {\n                                    \"armeria-lphc\", \"60, 5\"),\n                 HttpData.ofUtf8(\"ok\")));\n \n+        System.err.println(\"--------------------------\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDExNjI1OQ=="}, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjk2MTk4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/ByteArrayHttpData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOToxMDowNlrOGxLGvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOToxMDowNlrOGxLGvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxNTM1Nw==", "bodyText": "I think this should come first for readability given the method's primary goal is changing the value of endofstream", "url": "https://github.com/line/armeria/pull/2892#discussion_r454215357", "createdAt": "2020-07-14T09:10:06Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteArrayHttpData.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.internal.EmptyArrays;\n+import it.unimi.dsi.fastutil.io.FastByteArrayInputStream;\n+\n+/**\n+ * A {@code byte[]}-based {@link HttpData}.\n+ */\n+final class ByteArrayHttpData implements HttpData {\n+\n+    static final ByteArrayHttpData EMPTY = new ByteArrayHttpData(EmptyArrays.EMPTY_BYTES, false);\n+    static final ByteArrayHttpData EMPTY_EOS = new ByteArrayHttpData(EmptyArrays.EMPTY_BYTES, true);\n+\n+    private final byte[] array;\n+    private final boolean endOfStream;\n+\n+    ByteArrayHttpData(byte[] array) {\n+        this(array, false);\n+    }\n+\n+    private ByteArrayHttpData(byte[] array, boolean endOfStream) {\n+        this.array = array;\n+        this.endOfStream = endOfStream;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        return array;\n+    }\n+\n+    @Override\n+    public int length() {\n+        return array.length;\n+    }\n+\n+    @Override\n+    public String toString(Charset charset) {\n+        requireNonNull(charset, \"charset\");\n+        return new String(array, charset);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final MoreObjects.ToStringHelper helper =\n+                MoreObjects.toStringHelper(this)\n+                           .omitNullValues()\n+                           .addValue(length() + \"B\");\n+\n+        if (isEndOfStream()) {\n+            helper.addValue(\"endOfStream\");\n+        }\n+        return helper.add(\"array\", array)\n+                     .toString();\n+    }\n+\n+    @Override\n+    public InputStream toInputStream() {\n+        return new FastByteArrayInputStream(array);\n+    }\n+\n+    @Override\n+    public boolean isEndOfStream() {\n+        return endOfStream;\n+    }\n+\n+    @Override\n+    public ByteArrayHttpData withEndOfStream(boolean endOfStream) {\n+        if (isEmpty()) {\n+            return endOfStream ? EMPTY_EOS : EMPTY;\n+        }\n+\n+        if (isEndOfStream() == endOfStream) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjk4Mzg4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufAccessMode.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOToxNTo1NlrOGxLULg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjo0NjoxNFrOGzDgUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxODc5OA==", "bodyText": "DIRECT_RETAINED_DUPLICATE?", "url": "https://github.com/line/armeria/pull/2892#discussion_r454218798", "createdAt": "2020-07-14T09:15:56Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufAccessMode.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+/**\n+ * Specifies the way a {@link ByteBuf} is retrieved from an {@link HttpData}.\n+ */\n+@UnstableApi\n+public enum ByteBufAccessMode {\n+    /**\n+     * Gets the duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when you access\n+     * the {@link ByteBuf} within the life cycle of the {@link HttpData}:\n+     * <pre>{@code\n+     * try (HttpContent content = ...) {\n+     *     ByteBuf buf = content.byteBuf(ByteBufAccessMode.DUPLICATE);\n+     *     // Read something from 'buf' here.\n+     * }\n+     * }</pre>\n+     *\n+     * @see ByteBuf#duplicate()\n+     * @see ByteBuf#slice()\n+     */\n+    DUPLICATE,\n+    /**\n+     * Gets the retained duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when\n+     * you access the {@link ByteBuf} beyond the life cycle of the {@link HttpData}, such as creating\n+     * another {@link HttpData} that shares the {@link ByteBuf}'s memory region:\n+     * <pre>{@code\n+     * HttpData data1 = HttpData.wrap(byteBuf);\n+     * HttpData data2 = HttpData.wrap(data1.byteBuf(ByteBufAccessMode.RETAINED_DUPLICATE));\n+     * }</pre>\n+     *\n+     * @see ByteBuf#retainedDuplicate()\n+     * @see ByteBuf#retainedSlice()\n+     */\n+    RETAINED_DUPLICATE,\n+    /**\n+     * Converts the underlying {@link ByteBuf} into a direct {@link ByteBuf} if necessary. If the underlying\n+     * {@link ByteBuf} is already direct, it behaves same with {@link #RETAINED_DUPLICATE}. Otherwise, a new\n+     * direct {@link ByteBuf} is allocated and the content of the underlying {@link ByteBuf} is copied into it.\n+     * This access mode is useful when you perform direct I/O or send data to a Netty {@link Channel}.\n+     */\n+    DIRECT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUxNTc4Mw==", "bodyText": "It makes or does not make a copy depending on situation,  so 'retained' or 'duplicate' is not always correct. DIRECT_COPY_OR_RETAINED_DUPLICATE is too long obviously. Any better suggestions?", "url": "https://github.com/line/armeria/pull/2892#discussion_r455515783", "createdAt": "2020-07-16T05:19:07Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufAccessMode.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+/**\n+ * Specifies the way a {@link ByteBuf} is retrieved from an {@link HttpData}.\n+ */\n+@UnstableApi\n+public enum ByteBufAccessMode {\n+    /**\n+     * Gets the duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when you access\n+     * the {@link ByteBuf} within the life cycle of the {@link HttpData}:\n+     * <pre>{@code\n+     * try (HttpContent content = ...) {\n+     *     ByteBuf buf = content.byteBuf(ByteBufAccessMode.DUPLICATE);\n+     *     // Read something from 'buf' here.\n+     * }\n+     * }</pre>\n+     *\n+     * @see ByteBuf#duplicate()\n+     * @see ByteBuf#slice()\n+     */\n+    DUPLICATE,\n+    /**\n+     * Gets the retained duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when\n+     * you access the {@link ByteBuf} beyond the life cycle of the {@link HttpData}, such as creating\n+     * another {@link HttpData} that shares the {@link ByteBuf}'s memory region:\n+     * <pre>{@code\n+     * HttpData data1 = HttpData.wrap(byteBuf);\n+     * HttpData data2 = HttpData.wrap(data1.byteBuf(ByteBufAccessMode.RETAINED_DUPLICATE));\n+     * }</pre>\n+     *\n+     * @see ByteBuf#retainedDuplicate()\n+     * @see ByteBuf#retainedSlice()\n+     */\n+    RETAINED_DUPLICATE,\n+    /**\n+     * Converts the underlying {@link ByteBuf} into a direct {@link ByteBuf} if necessary. If the underlying\n+     * {@link ByteBuf} is already direct, it behaves same with {@link #RETAINED_DUPLICATE}. Otherwise, a new\n+     * direct {@link ByteBuf} is allocated and the content of the underlying {@link ByteBuf} is copied into it.\n+     * This access mode is useful when you perform direct I/O or send data to a Netty {@link Channel}.\n+     */\n+    DIRECT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxODc5OA=="}, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUxOTA4OA==", "bodyText": "I think semantically it's the same as RETAINED_DUPLICATE, returning a new reference but guarantees that it's direct, so seems clear. The copy is sort of an implementation detail that is fine with javadoc.\nOtherwise direct seems like a totally different concept from the others and looks weird in this enum.", "url": "https://github.com/line/armeria/pull/2892#discussion_r455519088", "createdAt": "2020-07-16T05:30:56Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufAccessMode.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+/**\n+ * Specifies the way a {@link ByteBuf} is retrieved from an {@link HttpData}.\n+ */\n+@UnstableApi\n+public enum ByteBufAccessMode {\n+    /**\n+     * Gets the duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when you access\n+     * the {@link ByteBuf} within the life cycle of the {@link HttpData}:\n+     * <pre>{@code\n+     * try (HttpContent content = ...) {\n+     *     ByteBuf buf = content.byteBuf(ByteBufAccessMode.DUPLICATE);\n+     *     // Read something from 'buf' here.\n+     * }\n+     * }</pre>\n+     *\n+     * @see ByteBuf#duplicate()\n+     * @see ByteBuf#slice()\n+     */\n+    DUPLICATE,\n+    /**\n+     * Gets the retained duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when\n+     * you access the {@link ByteBuf} beyond the life cycle of the {@link HttpData}, such as creating\n+     * another {@link HttpData} that shares the {@link ByteBuf}'s memory region:\n+     * <pre>{@code\n+     * HttpData data1 = HttpData.wrap(byteBuf);\n+     * HttpData data2 = HttpData.wrap(data1.byteBuf(ByteBufAccessMode.RETAINED_DUPLICATE));\n+     * }</pre>\n+     *\n+     * @see ByteBuf#retainedDuplicate()\n+     * @see ByteBuf#retainedSlice()\n+     */\n+    RETAINED_DUPLICATE,\n+    /**\n+     * Converts the underlying {@link ByteBuf} into a direct {@link ByteBuf} if necessary. If the underlying\n+     * {@link ByteBuf} is already direct, it behaves same with {@link #RETAINED_DUPLICATE}. Otherwise, a new\n+     * direct {@link ByteBuf} is allocated and the content of the underlying {@link ByteBuf} is copied into it.\n+     * This access mode is useful when you perform direct I/O or send data to a Netty {@link Channel}.\n+     */\n+    DIRECT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxODc5OA=="}, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4NTY2MA==", "bodyText": "'duplicate' and 'retained duplicate' in Netty are well-known terms that signify they will never make a copy, so I still think it's confusing to use here. \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2892#discussion_r456185660", "createdAt": "2020-07-17T02:37:10Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufAccessMode.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+/**\n+ * Specifies the way a {@link ByteBuf} is retrieved from an {@link HttpData}.\n+ */\n+@UnstableApi\n+public enum ByteBufAccessMode {\n+    /**\n+     * Gets the duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when you access\n+     * the {@link ByteBuf} within the life cycle of the {@link HttpData}:\n+     * <pre>{@code\n+     * try (HttpContent content = ...) {\n+     *     ByteBuf buf = content.byteBuf(ByteBufAccessMode.DUPLICATE);\n+     *     // Read something from 'buf' here.\n+     * }\n+     * }</pre>\n+     *\n+     * @see ByteBuf#duplicate()\n+     * @see ByteBuf#slice()\n+     */\n+    DUPLICATE,\n+    /**\n+     * Gets the retained duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when\n+     * you access the {@link ByteBuf} beyond the life cycle of the {@link HttpData}, such as creating\n+     * another {@link HttpData} that shares the {@link ByteBuf}'s memory region:\n+     * <pre>{@code\n+     * HttpData data1 = HttpData.wrap(byteBuf);\n+     * HttpData data2 = HttpData.wrap(data1.byteBuf(ByteBufAccessMode.RETAINED_DUPLICATE));\n+     * }</pre>\n+     *\n+     * @see ByteBuf#retainedDuplicate()\n+     * @see ByteBuf#retainedSlice()\n+     */\n+    RETAINED_DUPLICATE,\n+    /**\n+     * Converts the underlying {@link ByteBuf} into a direct {@link ByteBuf} if necessary. If the underlying\n+     * {@link ByteBuf} is already direct, it behaves same with {@link #RETAINED_DUPLICATE}. Otherwise, a new\n+     * direct {@link ByteBuf} is allocated and the content of the underlying {@link ByteBuf} is copied into it.\n+     * This access mode is useful when you perform direct I/O or send data to a Netty {@link Channel}.\n+     */\n+    DIRECT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxODc5OA=="}, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4NjgxMA==", "bodyText": "How about FOR_IO?", "url": "https://github.com/line/armeria/pull/2892#discussion_r456186810", "createdAt": "2020-07-17T02:41:33Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufAccessMode.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+/**\n+ * Specifies the way a {@link ByteBuf} is retrieved from an {@link HttpData}.\n+ */\n+@UnstableApi\n+public enum ByteBufAccessMode {\n+    /**\n+     * Gets the duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when you access\n+     * the {@link ByteBuf} within the life cycle of the {@link HttpData}:\n+     * <pre>{@code\n+     * try (HttpContent content = ...) {\n+     *     ByteBuf buf = content.byteBuf(ByteBufAccessMode.DUPLICATE);\n+     *     // Read something from 'buf' here.\n+     * }\n+     * }</pre>\n+     *\n+     * @see ByteBuf#duplicate()\n+     * @see ByteBuf#slice()\n+     */\n+    DUPLICATE,\n+    /**\n+     * Gets the retained duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when\n+     * you access the {@link ByteBuf} beyond the life cycle of the {@link HttpData}, such as creating\n+     * another {@link HttpData} that shares the {@link ByteBuf}'s memory region:\n+     * <pre>{@code\n+     * HttpData data1 = HttpData.wrap(byteBuf);\n+     * HttpData data2 = HttpData.wrap(data1.byteBuf(ByteBufAccessMode.RETAINED_DUPLICATE));\n+     * }</pre>\n+     *\n+     * @see ByteBuf#retainedDuplicate()\n+     * @see ByteBuf#retainedSlice()\n+     */\n+    RETAINED_DUPLICATE,\n+    /**\n+     * Converts the underlying {@link ByteBuf} into a direct {@link ByteBuf} if necessary. If the underlying\n+     * {@link ByteBuf} is already direct, it behaves same with {@link #RETAINED_DUPLICATE}. Otherwise, a new\n+     * direct {@link ByteBuf} is allocated and the content of the underlying {@link ByteBuf} is copied into it.\n+     * This access mode is useful when you perform direct I/O or send data to a Netty {@link Channel}.\n+     */\n+    DIRECT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxODc5OA=="}, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4Nzk4Nw==", "bodyText": "FOR_IO seems a bit better yeah", "url": "https://github.com/line/armeria/pull/2892#discussion_r456187987", "createdAt": "2020-07-17T02:46:14Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufAccessMode.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+/**\n+ * Specifies the way a {@link ByteBuf} is retrieved from an {@link HttpData}.\n+ */\n+@UnstableApi\n+public enum ByteBufAccessMode {\n+    /**\n+     * Gets the duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when you access\n+     * the {@link ByteBuf} within the life cycle of the {@link HttpData}:\n+     * <pre>{@code\n+     * try (HttpContent content = ...) {\n+     *     ByteBuf buf = content.byteBuf(ByteBufAccessMode.DUPLICATE);\n+     *     // Read something from 'buf' here.\n+     * }\n+     * }</pre>\n+     *\n+     * @see ByteBuf#duplicate()\n+     * @see ByteBuf#slice()\n+     */\n+    DUPLICATE,\n+    /**\n+     * Gets the retained duplicate (or slice) of the underlying {@link ByteBuf}. This mode is useful when\n+     * you access the {@link ByteBuf} beyond the life cycle of the {@link HttpData}, such as creating\n+     * another {@link HttpData} that shares the {@link ByteBuf}'s memory region:\n+     * <pre>{@code\n+     * HttpData data1 = HttpData.wrap(byteBuf);\n+     * HttpData data2 = HttpData.wrap(data1.byteBuf(ByteBufAccessMode.RETAINED_DUPLICATE));\n+     * }</pre>\n+     *\n+     * @see ByteBuf#retainedDuplicate()\n+     * @see ByteBuf#retainedSlice()\n+     */\n+    RETAINED_DUPLICATE,\n+    /**\n+     * Converts the underlying {@link ByteBuf} into a direct {@link ByteBuf} if necessary. If the underlying\n+     * {@link ByteBuf} is already direct, it behaves same with {@link #RETAINED_DUPLICATE}. Otherwise, a new\n+     * direct {@link ByteBuf} is allocated and the content of the underlying {@link ByteBuf} is copied into it.\n+     * This access mode is useful when you perform direct I/O or send data to a Netty {@link Channel}.\n+     */\n+    DIRECT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxODc5OA=="}, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzA4MDczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOTo0MjozOVrOGxMQMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNToyMDo0MVrOGyagIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzNDE2MQ==", "bodyText": "Maybe:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            data.close();\n          \n          \n            \n                            buf.close();", "url": "https://github.com/line/armeria/pull/2892#discussion_r454234161", "createdAt": "2020-07-14T09:42:39Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java", "diffHunk": "@@ -162,7 +161,7 @@ private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStrea\n             return future;\n         } finally {\n             if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n+                data.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUxNjE5NA==", "bodyText": "Nice catch. \ud83d\udc4d", "url": "https://github.com/line/armeria/pull/2892#discussion_r455516194", "createdAt": "2020-07-16T05:20:41Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java", "diffHunk": "@@ -162,7 +161,7 @@ private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStrea\n             return future;\n         } finally {\n             if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n+                data.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzNDE2MQ=="}, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzEwNTE0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufHttpData.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOTo0OToyM1rOGxMfGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNToyNzoxMFrOGyanLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzNzk3Nw==", "bodyText": "Could remove | FLAG_CLOSED?", "url": "https://github.com/line/armeria/pull/2892#discussion_r454237977", "createdAt": "2020-07-14T09:49:23Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufHttpData.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import it.unimi.dsi.fastutil.io.FastByteArrayInputStream;\n+\n+/**\n+ * A {@link ByteBuf}-based {@link HttpData}.\n+ */\n+final class ByteBufHttpData implements HttpData {\n+\n+    private static final int FLAG_POOLED = 1;\n+    private static final int FLAG_END_OF_STREAM = 2;\n+    private static final int FLAG_CLOSED = 4;\n+\n+    private final ByteBuf buf;\n+    @Nullable\n+    private byte[] array;\n+    private int flags;\n+\n+    ByteBufHttpData(ByteBuf buf, boolean pooled) {\n+        this(buf, pooled ? FLAG_POOLED : 0, null);\n+    }\n+\n+    private ByteBufHttpData(ByteBuf buf, int flags, @Nullable byte[] array) {\n+        this.buf = buf;\n+        this.array = array;\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        if (array != null) {\n+            return array;\n+        }\n+\n+        final int length = buf.readableBytes();\n+        if (isPooled()) {\n+            buf.touch();\n+        } else if (buf.hasArray() && buf.arrayOffset() == 0 && buf.readerIndex() == 0) {\n+            final byte[] bufArray = buf.array();\n+            if (bufArray.length == length) {\n+                return array = bufArray;\n+            }\n+        }\n+\n+        return array = ByteBufUtil.getBytes(buf, buf.readerIndex(), length);\n+    }\n+\n+    @Override\n+    public int length() {\n+        return buf.readableBytes();\n+    }\n+\n+    @Override\n+    public String toString(Charset charset) {\n+        requireNonNull(charset, \"charset\");\n+        if (array != null) {\n+            return new String(array, charset);\n+        } else {\n+            return buf.toString(charset);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final MoreObjects.ToStringHelper helper =\n+                MoreObjects.toStringHelper(this)\n+                           .omitNullValues()\n+                           .addValue(buf.readableBytes() + \"B\");\n+\n+        if (isEndOfStream()) {\n+            helper.addValue(\"endOfStream\");\n+        }\n+        if (isPooled()) {\n+            helper.addValue(\"pooled\");\n+        }\n+        if ((flags & FLAG_CLOSED) != 0) {\n+            helper.addValue(\"closed\");\n+        }\n+\n+        return helper.add(\"byteBuf\", buf)\n+                     .toString();\n+    }\n+\n+    @Override\n+    public InputStream toInputStream() {\n+        if (array != null) {\n+            return new FastByteArrayInputStream(array);\n+        } else {\n+            return new ByteBufInputStream(buf.duplicate(), false);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isEndOfStream() {\n+        return (flags & FLAG_END_OF_STREAM) != 0;\n+    }\n+\n+    @Override\n+    public ByteBufHttpData withEndOfStream(boolean endOfStream) {\n+        if (isEndOfStream() == endOfStream) {\n+            return this;\n+        }\n+\n+        int newFlags = flags & ~FLAG_END_OF_STREAM;\n+        if (endOfStream) {\n+            newFlags |= FLAG_END_OF_STREAM;\n+        }\n+\n+        return new ByteBufHttpData(buf, newFlags, array);\n+    }\n+\n+    @Override\n+    public boolean isPooled() {\n+        return (flags & FLAG_POOLED) != 0;\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(ByteBufAccessMode mode) {\n+        switch (mode) {\n+            case DUPLICATE:\n+                return buf.duplicate();\n+            case RETAINED_DUPLICATE:\n+                return buf.retainedDuplicate();\n+            case DIRECT:\n+                if (buf.isDirect()) {\n+                    return buf.retainedDuplicate();\n+                }\n+\n+                final ByteBuf copy = newDirectByteBuf();\n+                copy.writeBytes(buf, buf.readerIndex(), buf.readableBytes());\n+                return copy;\n+        }\n+\n+        throw new Error(); // Never reaches here.\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(int offset, int length, ByteBufAccessMode mode) {\n+        final int startIndex = buf.readerIndex() + offset;\n+        switch (mode) {\n+            case DUPLICATE:\n+                return buf.slice(startIndex, length);\n+            case RETAINED_DUPLICATE:\n+                return buf.retainedSlice(startIndex, length);\n+            case DIRECT:\n+                if (buf.isDirect()) {\n+                    return buf.retainedSlice(startIndex, length);\n+                }\n+\n+                final ByteBuf copy = newDirectByteBuf(length);\n+                copy.writeBytes(buf, startIndex, length);\n+                return copy;\n+        }\n+\n+        throw new Error(); // Never reaches here.\n+    }\n+\n+    private ByteBuf newDirectByteBuf() {\n+        return newDirectByteBuf(buf.readableBytes());\n+    }\n+\n+    private static ByteBuf newDirectByteBuf(int length) {\n+        return PooledByteBufAllocator.DEFAULT.directBuffer(length);\n+    }\n+\n+    @Override\n+    public void close() {\n+        // This is not thread safe, but an attempt to close one instance from multiple threads would fail\n+        // with an IllegalReferenceCountException anyway.\n+        if ((flags & (FLAG_POOLED | FLAG_CLOSED)) == FLAG_POOLED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUxMzAwNg==", "bodyText": "No, we can't, because otherwise .release() can be called twice.", "url": "https://github.com/line/armeria/pull/2892#discussion_r455513006", "createdAt": "2020-07-16T05:08:59Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufHttpData.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import it.unimi.dsi.fastutil.io.FastByteArrayInputStream;\n+\n+/**\n+ * A {@link ByteBuf}-based {@link HttpData}.\n+ */\n+final class ByteBufHttpData implements HttpData {\n+\n+    private static final int FLAG_POOLED = 1;\n+    private static final int FLAG_END_OF_STREAM = 2;\n+    private static final int FLAG_CLOSED = 4;\n+\n+    private final ByteBuf buf;\n+    @Nullable\n+    private byte[] array;\n+    private int flags;\n+\n+    ByteBufHttpData(ByteBuf buf, boolean pooled) {\n+        this(buf, pooled ? FLAG_POOLED : 0, null);\n+    }\n+\n+    private ByteBufHttpData(ByteBuf buf, int flags, @Nullable byte[] array) {\n+        this.buf = buf;\n+        this.array = array;\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        if (array != null) {\n+            return array;\n+        }\n+\n+        final int length = buf.readableBytes();\n+        if (isPooled()) {\n+            buf.touch();\n+        } else if (buf.hasArray() && buf.arrayOffset() == 0 && buf.readerIndex() == 0) {\n+            final byte[] bufArray = buf.array();\n+            if (bufArray.length == length) {\n+                return array = bufArray;\n+            }\n+        }\n+\n+        return array = ByteBufUtil.getBytes(buf, buf.readerIndex(), length);\n+    }\n+\n+    @Override\n+    public int length() {\n+        return buf.readableBytes();\n+    }\n+\n+    @Override\n+    public String toString(Charset charset) {\n+        requireNonNull(charset, \"charset\");\n+        if (array != null) {\n+            return new String(array, charset);\n+        } else {\n+            return buf.toString(charset);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final MoreObjects.ToStringHelper helper =\n+                MoreObjects.toStringHelper(this)\n+                           .omitNullValues()\n+                           .addValue(buf.readableBytes() + \"B\");\n+\n+        if (isEndOfStream()) {\n+            helper.addValue(\"endOfStream\");\n+        }\n+        if (isPooled()) {\n+            helper.addValue(\"pooled\");\n+        }\n+        if ((flags & FLAG_CLOSED) != 0) {\n+            helper.addValue(\"closed\");\n+        }\n+\n+        return helper.add(\"byteBuf\", buf)\n+                     .toString();\n+    }\n+\n+    @Override\n+    public InputStream toInputStream() {\n+        if (array != null) {\n+            return new FastByteArrayInputStream(array);\n+        } else {\n+            return new ByteBufInputStream(buf.duplicate(), false);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isEndOfStream() {\n+        return (flags & FLAG_END_OF_STREAM) != 0;\n+    }\n+\n+    @Override\n+    public ByteBufHttpData withEndOfStream(boolean endOfStream) {\n+        if (isEndOfStream() == endOfStream) {\n+            return this;\n+        }\n+\n+        int newFlags = flags & ~FLAG_END_OF_STREAM;\n+        if (endOfStream) {\n+            newFlags |= FLAG_END_OF_STREAM;\n+        }\n+\n+        return new ByteBufHttpData(buf, newFlags, array);\n+    }\n+\n+    @Override\n+    public boolean isPooled() {\n+        return (flags & FLAG_POOLED) != 0;\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(ByteBufAccessMode mode) {\n+        switch (mode) {\n+            case DUPLICATE:\n+                return buf.duplicate();\n+            case RETAINED_DUPLICATE:\n+                return buf.retainedDuplicate();\n+            case DIRECT:\n+                if (buf.isDirect()) {\n+                    return buf.retainedDuplicate();\n+                }\n+\n+                final ByteBuf copy = newDirectByteBuf();\n+                copy.writeBytes(buf, buf.readerIndex(), buf.readableBytes());\n+                return copy;\n+        }\n+\n+        throw new Error(); // Never reaches here.\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(int offset, int length, ByteBufAccessMode mode) {\n+        final int startIndex = buf.readerIndex() + offset;\n+        switch (mode) {\n+            case DUPLICATE:\n+                return buf.slice(startIndex, length);\n+            case RETAINED_DUPLICATE:\n+                return buf.retainedSlice(startIndex, length);\n+            case DIRECT:\n+                if (buf.isDirect()) {\n+                    return buf.retainedSlice(startIndex, length);\n+                }\n+\n+                final ByteBuf copy = newDirectByteBuf(length);\n+                copy.writeBytes(buf, startIndex, length);\n+                return copy;\n+        }\n+\n+        throw new Error(); // Never reaches here.\n+    }\n+\n+    private ByteBuf newDirectByteBuf() {\n+        return newDirectByteBuf(buf.readableBytes());\n+    }\n+\n+    private static ByteBuf newDirectByteBuf(int length) {\n+        return PooledByteBufAllocator.DEFAULT.directBuffer(length);\n+    }\n+\n+    @Override\n+    public void close() {\n+        // This is not thread safe, but an attempt to close one instance from multiple threads would fail\n+        // with an IllegalReferenceCountException anyway.\n+        if ((flags & (FLAG_POOLED | FLAG_CLOSED)) == FLAG_POOLED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzNzk3Nw=="}, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUxNzk5Nw==", "bodyText": "I understand. \ud83d\ude00", "url": "https://github.com/line/armeria/pull/2892#discussion_r455517997", "createdAt": "2020-07-16T05:27:10Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/ByteBufHttpData.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import it.unimi.dsi.fastutil.io.FastByteArrayInputStream;\n+\n+/**\n+ * A {@link ByteBuf}-based {@link HttpData}.\n+ */\n+final class ByteBufHttpData implements HttpData {\n+\n+    private static final int FLAG_POOLED = 1;\n+    private static final int FLAG_END_OF_STREAM = 2;\n+    private static final int FLAG_CLOSED = 4;\n+\n+    private final ByteBuf buf;\n+    @Nullable\n+    private byte[] array;\n+    private int flags;\n+\n+    ByteBufHttpData(ByteBuf buf, boolean pooled) {\n+        this(buf, pooled ? FLAG_POOLED : 0, null);\n+    }\n+\n+    private ByteBufHttpData(ByteBuf buf, int flags, @Nullable byte[] array) {\n+        this.buf = buf;\n+        this.array = array;\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        if (array != null) {\n+            return array;\n+        }\n+\n+        final int length = buf.readableBytes();\n+        if (isPooled()) {\n+            buf.touch();\n+        } else if (buf.hasArray() && buf.arrayOffset() == 0 && buf.readerIndex() == 0) {\n+            final byte[] bufArray = buf.array();\n+            if (bufArray.length == length) {\n+                return array = bufArray;\n+            }\n+        }\n+\n+        return array = ByteBufUtil.getBytes(buf, buf.readerIndex(), length);\n+    }\n+\n+    @Override\n+    public int length() {\n+        return buf.readableBytes();\n+    }\n+\n+    @Override\n+    public String toString(Charset charset) {\n+        requireNonNull(charset, \"charset\");\n+        if (array != null) {\n+            return new String(array, charset);\n+        } else {\n+            return buf.toString(charset);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final MoreObjects.ToStringHelper helper =\n+                MoreObjects.toStringHelper(this)\n+                           .omitNullValues()\n+                           .addValue(buf.readableBytes() + \"B\");\n+\n+        if (isEndOfStream()) {\n+            helper.addValue(\"endOfStream\");\n+        }\n+        if (isPooled()) {\n+            helper.addValue(\"pooled\");\n+        }\n+        if ((flags & FLAG_CLOSED) != 0) {\n+            helper.addValue(\"closed\");\n+        }\n+\n+        return helper.add(\"byteBuf\", buf)\n+                     .toString();\n+    }\n+\n+    @Override\n+    public InputStream toInputStream() {\n+        if (array != null) {\n+            return new FastByteArrayInputStream(array);\n+        } else {\n+            return new ByteBufInputStream(buf.duplicate(), false);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isEndOfStream() {\n+        return (flags & FLAG_END_OF_STREAM) != 0;\n+    }\n+\n+    @Override\n+    public ByteBufHttpData withEndOfStream(boolean endOfStream) {\n+        if (isEndOfStream() == endOfStream) {\n+            return this;\n+        }\n+\n+        int newFlags = flags & ~FLAG_END_OF_STREAM;\n+        if (endOfStream) {\n+            newFlags |= FLAG_END_OF_STREAM;\n+        }\n+\n+        return new ByteBufHttpData(buf, newFlags, array);\n+    }\n+\n+    @Override\n+    public boolean isPooled() {\n+        return (flags & FLAG_POOLED) != 0;\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(ByteBufAccessMode mode) {\n+        switch (mode) {\n+            case DUPLICATE:\n+                return buf.duplicate();\n+            case RETAINED_DUPLICATE:\n+                return buf.retainedDuplicate();\n+            case DIRECT:\n+                if (buf.isDirect()) {\n+                    return buf.retainedDuplicate();\n+                }\n+\n+                final ByteBuf copy = newDirectByteBuf();\n+                copy.writeBytes(buf, buf.readerIndex(), buf.readableBytes());\n+                return copy;\n+        }\n+\n+        throw new Error(); // Never reaches here.\n+    }\n+\n+    @Override\n+    public ByteBuf byteBuf(int offset, int length, ByteBufAccessMode mode) {\n+        final int startIndex = buf.readerIndex() + offset;\n+        switch (mode) {\n+            case DUPLICATE:\n+                return buf.slice(startIndex, length);\n+            case RETAINED_DUPLICATE:\n+                return buf.retainedSlice(startIndex, length);\n+            case DIRECT:\n+                if (buf.isDirect()) {\n+                    return buf.retainedSlice(startIndex, length);\n+                }\n+\n+                final ByteBuf copy = newDirectByteBuf(length);\n+                copy.writeBytes(buf, startIndex, length);\n+                return copy;\n+        }\n+\n+        throw new Error(); // Never reaches here.\n+    }\n+\n+    private ByteBuf newDirectByteBuf() {\n+        return newDirectByteBuf(buf.readableBytes());\n+    }\n+\n+    private static ByteBuf newDirectByteBuf(int length) {\n+        return PooledByteBufAllocator.DEFAULT.directBuffer(length);\n+    }\n+\n+    @Override\n+    public void close() {\n+        // This is not thread safe, but an attempt to close one instance from multiple threads would fail\n+        // with an IllegalReferenceCountException anyway.\n+        if ((flags & (FLAG_POOLED | FLAG_CLOSED)) == FLAG_POOLED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzNzk3Nw=="}, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzIyODI3OnYy", "diffSide": "LEFT", "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDoyNDo1M1rOGxNpZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDoyNDo1M1rOGxNpZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1Njk5Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/line/armeria/pull/2892#discussion_r454256996", "createdAt": "2020-07-14T10:24:53Z", "author": {"login": "ikhoon"}, "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "diffHunk": "@@ -77,41 +75,31 @@\n     @Nullable\n     public static HttpHeaders parseTrailers(HttpData response) {\n         requireNonNull(response, \"response\");\n-        final ByteBuf buf;\n-        if (response instanceof PooledHttpData) {\n-            buf = ((PooledHttpData) response).content();\n-        } else {\n-            buf = Unpooled.wrappedBuffer(response.array());\n-        }\n-        final int readerIndex = buf.readerIndex();\n+        final ByteBuf buf = response.byteBuf();\n \n-        try {\n-            HttpHeaders trailers = null;\n-            while (buf.isReadable(HEADER_LENGTH)) {\n-                final short type = buf.readUnsignedByte();\n-                if ((type & RESERVED_MASK) != 0) {\n-                    // Malformed header\n-                    break;\n-                }\n+        HttpHeaders trailers = null;\n+        while (buf.isReadable(HEADER_LENGTH)) {\n+            final short type = buf.readUnsignedByte();\n+            if ((type & RESERVED_MASK) != 0) {\n+                // Malformed header\n+                break;\n+            }\n \n-                final int length = buf.readInt();\n-                // 8th (MSB) bit of the 1st gRPC frame byte is:\n-                // - '1' for trailers\n-                // - '0' for data\n-                //\n-                // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#protocol-differences-vs-grpc-over-http2\n-                if (type >> 7 == 1) {\n-                    trailers = InternalGrpcWebUtil.parseGrpcWebTrailers(buf);\n-                    break;\n-                } else {\n-                    // Skip a gRPC content\n-                    buf.skipBytes(length);\n-                }\n+            final int length = buf.readInt();\n+            // 8th (MSB) bit of the 1st gRPC frame byte is:\n+            // - '1' for trailers\n+            // - '0' for data\n+            //\n+            // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#protocol-differences-vs-grpc-over-http2\n+            if (type >> 7 == 1) {\n+                trailers = InternalGrpcWebUtil.parseGrpcWebTrailers(buf);\n+                break;\n+            } else {\n+                // Skip a gRPC content\n+                buf.skipBytes(length);\n             }\n-            return trailers;\n-        } finally {\n-            buf.readerIndex(readerIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8abc447e9c0744abdc1c1dfc226faff88a9f163a"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTU2MDAxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/unsafe/PooledObjects.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjozMzozNFrOGzDTvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjozMzozNFrOGzDTvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4NDc2NQ==", "bodyText": "nit: ByteBuf#touch(Object)", "url": "https://github.com/line/armeria/pull/2892#discussion_r456184765", "createdAt": "2020-07-17T02:33:34Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/unsafe/PooledObjects.java", "diffHunk": "@@ -100,10 +102,18 @@ public static void close(Object obj) {\n      * Does nothing if it's not a pooled {@link HttpData}.\n      */\n     public static void touch(Object obj) {\n+        touch(obj, obj);\n+    }\n+\n+    /**\n+     * Calls {@link ByteBuf#touch()} of the specified {@link HttpData}'s underlying {@link ByteBuf}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec59a3a7c7cf305e6f5be254e74911e6599ebec7"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2088, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}