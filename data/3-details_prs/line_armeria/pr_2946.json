{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4ODcxNDA3", "number": 2946, "title": "Fix a bug where grpc-web-text add line-feed when base64 encoding", "bodyText": "Motivation:\nThe spec says that\nImplementations MUST NOT add line feeds to base-encoded data unless\nthe specification referring to this document explicitly directs base\nencoders to add line feeds after a specific number of characters.\n\nSo we should not add line-feed when base64 encoding.\nMotivations:\n\nDo not add line-feed when base64 encoding.\nAddress comments from @anuraaga in #2938.\n\nResult:\n\ngrpc-web-text does not contain line-feed characters.", "createdAt": "2020-07-30T04:48:45Z", "url": "https://github.com/line/armeria/pull/2946", "merged": true, "mergeCommit": {"oid": "90b172bf8f835b45046faeb8042563a64c0fc9f2"}, "closed": true, "closedAt": "2020-07-31T06:09:11Z", "author": {"login": "minwoox"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc54K5UgH2gAyNDU4ODcxNDA3OmQ0ZWYwY2JjZWRmM2VhZTM0NmEwZTQyMzJhZmNmMzVhNmU2NGZmMzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc6N8oigFqTQ1ODkzNjU5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d4ef0cbcedf3eae346a0e4232afcf35a6e64ff30", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/d4ef0cbcedf3eae346a0e4232afcf35a6e64ff30", "committedDate": "2020-07-30T04:46:21Z", "message": "Follow up for #2938\nAddress the comments from @anuraaga"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcac56aab26df36dbe011968c69ac9ada58a66e1", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/fcac56aab26df36dbe011968c69ac9ada58a66e1", "committedDate": "2020-07-30T05:09:25Z", "message": "Do not add line-feed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4064648bbc58d26eeef4d3daed7a288260dd05c6", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/4064648bbc58d26eeef4d3daed7a288260dd05c6", "committedDate": "2020-07-30T06:06:04Z", "message": "Update test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5", "committedDate": "2020-07-30T06:07:24Z", "message": "Update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MTY1NzQ1", "url": "https://github.com/line/armeria/pull/2946#pullrequestreview-458165745", "createdAt": "2020-07-30T07:53:23Z", "commit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MTg4OTQ4", "url": "https://github.com/line/armeria/pull/2946#pullrequestreview-458188948", "createdAt": "2020-07-30T08:25:33Z", "commit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNTozM1rOG5ZHxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyODowMlrOG5ZNng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzYwNg==", "bodyText": "Could be decodedByte < EQUALS_SIGN_ENC ?", "url": "https://github.com/line/armeria/pull/2946#discussion_r462833606", "createdAt": "2020-07-30T08:25:33Z", "author": {"login": "trustin"}, "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/Base64Decoder.java", "diffHunk": "@@ -125,17 +123,11 @@ private int decodedBufferSize(int len) {\n     @Override\n     public boolean process(byte value) throws Exception {\n         final byte decodedByte = DECODABET[value & 0xFF];\n-        if (decodedByte < WHITE_SPACE_ENC) {\n+        if (decodedByte <= WHITE_SPACE_ENC) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzg1Ng==", "bodyText": "Could use @CsvSource instead?", "url": "https://github.com/line/armeria/pull/2946#discussion_r462833856", "createdAt": "2020-07-30T08:26:02Z", "author": {"login": "trustin"}, "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "diffHunk": "@@ -19,63 +19,65 @@\n \n import java.nio.charset.Charset;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n-import java.util.Random;\n+import java.util.stream.Stream;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.base64.Base64;\n \n class Base64DecoderTest {\n \n-    private static final ByteBuf[] EMPTY_BYTE_BUF = new ByteBuf[0];\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decode(String expected, String encoded) {\n+        final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(encoded.getBytes()));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        decoded.release();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeConcatenatedBufs(String expected, String encoded) {\n+        final ByteBuf buf1 = Unpooled.wrappedBuffer(encoded.getBytes());\n+        final ByteBuf buf2 = buf1.retainedDuplicate();\n \n-    @Test\n-    void decodeConcatenatedBufsWithPadding() {\n-        final String str = \"abcd\"; // YWJjZA==\n-        final ByteBuf buf = Unpooled.wrappedBuffer(str.getBytes());\n-        final ByteBuf encoded1 = Base64.encode(buf);\n-        buf.readerIndex(0);\n-        final ByteBuf encoded2 = Base64.encode(buf);\n-        final ByteBuf concatenated = Unpooled.wrappedBuffer(encoded1, encoded2); // YWJjZA==YWJjZA==\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decoded = base64Decoder.decode(concatenated);\n-        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(\"abcdabcd\");\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(buf1, buf2));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected + expected);\n         decoded.release();\n     }\n \n-    @Test\n-    void decodeMultipleEncodedBytes() {\n-        final String str = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz1234567890\";\n-        final byte[] bytes = str.getBytes();\n-        final List<ByteBuf> fragments = fragmentRandomly(bytes);\n-        final int half = fragments.size() / 2;\n-        final ByteBuf first =\n-                Unpooled.wrappedBuffer(fragments.subList(0, half).toArray(EMPTY_BYTE_BUF));\n-        final ByteBuf second =\n-                Unpooled.wrappedBuffer(fragments.subList(half, fragments.size()).toArray(EMPTY_BYTE_BUF));\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeEachByteSeparately(String expected, String encoded) {\n+        final ByteBuf buf = Unpooled.wrappedBuffer(encoded.getBytes());\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decodedFirst = base64Decoder.decode(first);\n-        final ByteBuf decodedSecond = base64Decoder.decode(second);\n-        assertThat(Unpooled.wrappedBuffer(decodedFirst, decodedSecond).toString(Charset.defaultCharset()))\n-                .isEqualTo(str);\n-        decodedFirst.release();\n-        decodedSecond.release();\n+        final int readableBytes = buf.readableBytes();\n+        final List<ByteBuf> bufs = new ArrayList<>();\n+        for (int i = 0; i < readableBytes; i++) {\n+            bufs.add(base64Decoder.decode(buf.retainedSlice(i, 1)));\n+        }\n+        buf.release();\n+        final ByteBuf wrappedBuffer = Unpooled.wrappedBuffer(bufs.toArray(new ByteBuf[0]));\n+        assertThat(wrappedBuffer.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        wrappedBuffer.release();\n     }\n \n-    private static List<ByteBuf> fragmentRandomly(byte[] bytes) {\n-        final List<ByteBuf> fragments = new ArrayList<>();\n-        for (int i = 0; i < bytes.length;) {\n-            final int to = Math.min(bytes.length,\n-                                    new Random().nextInt(5) + 1 + i); // One byte is selected at least.\n-            final ByteBuf encoded = Base64.encode(Unpooled.wrappedBuffer(Arrays.copyOfRange(bytes, i, to)));\n-            fragments.add(encoded);\n-            i = to;\n+    private static final class EncodedStringProvider implements ArgumentsProvider {\n+\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext context) throws Exception {\n+            return Stream.of(Arguments.of(\"abcde\", \"YWJjZGU=\"),\n+                             Arguments.of(\"123456789\", \"MTIzNDU2Nzg5\"),\n+                             Arguments.of(\"~!@#$%^&*()-_\", \"fiFAIyQlXiYqKCktXw==\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNTEwMg==", "bodyText": "Could be simplified into:\nwhile (buf.isReadable()) {\n    bufs.add(base64Decoder.decode(buf.readRetainedSlice(1)));\n}", "url": "https://github.com/line/armeria/pull/2946#discussion_r462835102", "createdAt": "2020-07-30T08:28:02Z", "author": {"login": "trustin"}, "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "diffHunk": "@@ -19,63 +19,65 @@\n \n import java.nio.charset.Charset;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n-import java.util.Random;\n+import java.util.stream.Stream;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.base64.Base64;\n \n class Base64DecoderTest {\n \n-    private static final ByteBuf[] EMPTY_BYTE_BUF = new ByteBuf[0];\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decode(String expected, String encoded) {\n+        final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(encoded.getBytes()));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        decoded.release();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeConcatenatedBufs(String expected, String encoded) {\n+        final ByteBuf buf1 = Unpooled.wrappedBuffer(encoded.getBytes());\n+        final ByteBuf buf2 = buf1.retainedDuplicate();\n \n-    @Test\n-    void decodeConcatenatedBufsWithPadding() {\n-        final String str = \"abcd\"; // YWJjZA==\n-        final ByteBuf buf = Unpooled.wrappedBuffer(str.getBytes());\n-        final ByteBuf encoded1 = Base64.encode(buf);\n-        buf.readerIndex(0);\n-        final ByteBuf encoded2 = Base64.encode(buf);\n-        final ByteBuf concatenated = Unpooled.wrappedBuffer(encoded1, encoded2); // YWJjZA==YWJjZA==\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decoded = base64Decoder.decode(concatenated);\n-        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(\"abcdabcd\");\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(buf1, buf2));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected + expected);\n         decoded.release();\n     }\n \n-    @Test\n-    void decodeMultipleEncodedBytes() {\n-        final String str = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz1234567890\";\n-        final byte[] bytes = str.getBytes();\n-        final List<ByteBuf> fragments = fragmentRandomly(bytes);\n-        final int half = fragments.size() / 2;\n-        final ByteBuf first =\n-                Unpooled.wrappedBuffer(fragments.subList(0, half).toArray(EMPTY_BYTE_BUF));\n-        final ByteBuf second =\n-                Unpooled.wrappedBuffer(fragments.subList(half, fragments.size()).toArray(EMPTY_BYTE_BUF));\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeEachByteSeparately(String expected, String encoded) {\n+        final ByteBuf buf = Unpooled.wrappedBuffer(encoded.getBytes());\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decodedFirst = base64Decoder.decode(first);\n-        final ByteBuf decodedSecond = base64Decoder.decode(second);\n-        assertThat(Unpooled.wrappedBuffer(decodedFirst, decodedSecond).toString(Charset.defaultCharset()))\n-                .isEqualTo(str);\n-        decodedFirst.release();\n-        decodedSecond.release();\n+        final int readableBytes = buf.readableBytes();\n+        final List<ByteBuf> bufs = new ArrayList<>();\n+        for (int i = 0; i < readableBytes; i++) {\n+            bufs.add(base64Decoder.decode(buf.retainedSlice(i, 1)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d6dc1b9af3aa5177fbfa170a173ba2b981dd3db", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/8d6dc1b9af3aa5177fbfa170a173ba2b981dd3db", "committedDate": "2020-07-30T11:11:26Z", "message": "Address comments by @trustin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MzE3NzEz", "url": "https://github.com/line/armeria/pull/2946#pullrequestreview-458317713", "createdAt": "2020-07-30T11:35:12Z", "commit": {"oid": "8d6dc1b9af3aa5177fbfa170a173ba2b981dd3db"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b91280aabf814287ffc8cf26020b41d2e0a8f7f3", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/b91280aabf814287ffc8cf26020b41d2e0a8f7f3", "committedDate": "2020-07-30T11:37:25Z", "message": "Address the comment by @trustin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MzQzOTI4", "url": "https://github.com/line/armeria/pull/2946#pullrequestreview-458343928", "createdAt": "2020-07-30T12:17:34Z", "commit": {"oid": "b91280aabf814287ffc8cf26020b41d2e0a8f7f3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79f03795ff247fd720a31ef4243c60c088d11729", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/79f03795ff247fd720a31ef4243c60c088d11729", "committedDate": "2020-07-31T03:14:46Z", "message": "Add more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4OTM2NTkw", "url": "https://github.com/line/armeria/pull/2946#pullrequestreview-458936590", "createdAt": "2020-07-31T06:08:41Z", "commit": {"oid": "79f03795ff247fd720a31ef4243c60c088d11729"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4972, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}