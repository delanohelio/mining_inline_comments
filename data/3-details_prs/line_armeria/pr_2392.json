{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMzczMTc2", "number": 2392, "title": "Send periodic `102 Processing` headers for long-polling health\u2026", "bodyText": "Motivation:\nWith long-polling health check, it is currently not possible to\ndistinguish unresponsive servers who just accepts sockets doing nothing.\nHealthCheckService must send some informational headers periodically,\nsuch as 102 Processing.\nModifications:\n\nChange the format of the armeria-lphc header value to contain two\nvalues:\n\nmaxLongPollingTimeoutSeconds\npingIntervalSeconds\n\n\nChange the behavior of HealthCheckService to send 102 Processing\ninformational headers every pingIntervalSeconds.\n\nUpdated HealthCheckServiceBuilder.longPolling()\n\n\nChange the behavior of HealthCheckedEndpointGroup to mark an\nEndpoint as unhealthy when not receiving a ping for last\npingIntervalSeconds * 2 seconds.\nMiscellaneous:\n\nRemoved Http from the test classes that test HealthCheckEndpointGroup\n\n\n\nResult:\n\nFixes #2386\nHealthCheckedEndpointGroup now marks an unresponsive endpoints as\nsoon as possible when long-polling is enabled.\nThe old Armeria clients will automatically fall back to traditional\nperiodic health check, because it does not understand the new header\nformat.", "createdAt": "2020-01-10T10:06:20Z", "url": "https://github.com/line/armeria/pull/2392", "merged": true, "mergeCommit": {"oid": "75108265eda02f18871dd8b721400084422d3a13"}, "closed": true, "closedAt": "2020-01-14T03:25:45Z", "author": {"login": "trustin"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb47qKCAH2gAyMzYxMzczMTc2OjdiYmU4NDIyMjE2M2E4OTM2ZjMxODY5ZGMwNmNiN2I2Y2JkZTk5NGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6NrWRgFqTM0MjI4ODM3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7bbe84222163a8936f31869dc06cb7b6cbde994e", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/7bbe84222163a8936f31869dc06cb7b6cbde994e", "committedDate": "2020-01-10T10:05:08Z", "message": "Send periodic `102 Processing` headers for long-polling health checks\n\nMotivation:\n\nWith long-polling health check, it is currently not possible to\ndistinguish unresponsive servers who just accepts sockets doing nothing.\n`HealthCheckService` must send some informational headers periodically,\nsuch as `102 Processing`.\n\nModifications:\n\n- Change the format of the `armeria-lphc` header value to contain two\n  values:\n  - `maxLongPollingTimeoutSeconds`\n  - `pingIntervalSeconds`\n- Change the behavior of `HealthCheckService` to send `102 Processing`\n  informational headers every `pingIntervalSeconds`.\n  - Updated `HealthCheckServiceBuilder.longPolling()`\n- Change the behavior of `HealthCheckedEndpointGroup` to mark an\n  `Endpoint` as unhealthy when not receiving a ping for last\n  `pingIntervalSeconds * 2` seconds.\n- Miscellaneous:\n  - Removed `Http` from the test classes that test `HealthCheckEndpointGroup`\n\nResult:\n\n- Fixes #2386\n- `HealthCheckedEndpointGroup` now marks an unresponsive endpoints as\n  soon as possible when long-polling is enabled.\n- The old Armeria clients will automatically fall back to traditional\n  periodic health check, because it does not understand the new header\n  format."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b52f6fb51a238a1d17da4d8caeb825c222bfb3c", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/2b52f6fb51a238a1d17da4d8caeb825c222bfb3c", "committedDate": "2020-01-10T10:09:32Z", "message": "Remove unused fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e512d5eeea3fc18b46a4e87bd602a03b586c32f7", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/e512d5eeea3fc18b46a4e87bd602a03b586c32f7", "committedDate": "2020-01-10T10:11:52Z", "message": "Fix test failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/db00fffa64e6008decb710fdf51a885b082e7513", "committedDate": "2020-01-10T10:20:33Z", "message": "More fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNzI3OTQ0", "url": "https://github.com/line/armeria/pull/2392#pullrequestreview-341727944", "createdAt": "2020-01-13T09:51:34Z", "commit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwOTo1MTozNVrOFcxgDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwOTo1MTozNVrOFcxgDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxNTQ3MA==", "bodyText": "shouldn't we do this on ctx.executor() not the eventLoop used on the first health check request?\nForget about it. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2392#discussion_r365715470", "createdAt": "2020-01-13T09:51:35Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;\n+            long pingIntervalSeconds = 0;\n+            try {\n+                maxLongPollingSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(0, commaPos).trim()));\n+                pingIntervalSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(commaPos + 1).trim()));\n+            } catch (NumberFormatException e) {\n+                // Ignore malformed settings.\n+            }\n+\n+            HttpHealthChecker.this.maxLongPollingSeconds = maxLongPollingSeconds;\n+            if (maxLongPollingSeconds > 0 && pingIntervalSeconds < maxLongPollingSeconds) {\n+                HttpHealthChecker.this.pingIntervalSeconds = pingIntervalSeconds;\n+            } else {\n+                HttpHealthChecker.this.pingIntervalSeconds = 0;\n+            }\n+        }\n+\n+        // TODO(trustin): Remove once https://github.com/line/armeria/issues/1063 is fixed.\n+        private void maybeSchedulePingCheck() {\n+            lastPingTimeNanos = System.nanoTime();\n+\n+            if (pingCheckFuture != null) {\n+                return;\n+            }\n+\n+            final long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\n+            final long pingTimeoutNanos = LongMath.saturatedMultiply(\n+                    TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);\n+            if (pingIntervalSeconds <= 0) {\n+                return;\n+            }\n+\n+            pingCheckFuture = reqCtx.eventLoop().scheduleWithFixedDelay(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 230}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNjY2NDc5", "url": "https://github.com/line/armeria/pull/2392#pullrequestreview-341666479", "createdAt": "2020-01-13T07:27:40Z", "commit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNzoyNzo0MVrOFcuqMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNzoyNzo0MVrOFcuqMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2ODkxNQ==", "bodyText": "nit: Could return early? You think it is trivial, feel free to ignore this.\ud83d\ude00\nfinal long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\nif (pingIntervalSeconds <= 0) {\n    return;\n}\nfinal long pingTimeoutNanos = LongMath.saturatedMultiply(\n        TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);", "url": "https://github.com/line/armeria/pull/2392#discussion_r365668915", "createdAt": "2020-01-13T07:27:41Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;\n+            long pingIntervalSeconds = 0;\n+            try {\n+                maxLongPollingSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(0, commaPos).trim()));\n+                pingIntervalSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(commaPos + 1).trim()));\n+            } catch (NumberFormatException e) {\n+                // Ignore malformed settings.\n+            }\n+\n+            HttpHealthChecker.this.maxLongPollingSeconds = maxLongPollingSeconds;\n+            if (maxLongPollingSeconds > 0 && pingIntervalSeconds < maxLongPollingSeconds) {\n+                HttpHealthChecker.this.pingIntervalSeconds = pingIntervalSeconds;\n+            } else {\n+                HttpHealthChecker.this.pingIntervalSeconds = 0;\n+            }\n+        }\n+\n+        // TODO(trustin): Remove once https://github.com/line/armeria/issues/1063 is fixed.\n+        private void maybeSchedulePingCheck() {\n+            lastPingTimeNanos = System.nanoTime();\n+\n+            if (pingCheckFuture != null) {\n+                return;\n+            }\n+\n+            final long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\n+            final long pingTimeoutNanos = LongMath.saturatedMultiply(\n+                    TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);\n+            if (pingIntervalSeconds <= 0) {\n+                return;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 228}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNzY0OTAy", "url": "https://github.com/line/armeria/pull/2392#pullrequestreview-341764902", "createdAt": "2020-01-13T10:57:31Z", "commit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMDo1NzozMVrOFczQyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMToxNzozMFrOFczugA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDMzMA==", "bodyText": "I notice this is copied but wondered, why we don't set closed in this branch?", "url": "https://github.com/line/armeria/pull/2392#discussion_r365744330", "createdAt": "2020-01-13T10:57:31Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0OTAzMw==", "bodyText": "Don't think these need to be long, especially the ping interval", "url": "https://github.com/line/armeria/pull/2392#discussion_r365749033", "createdAt": "2020-01-13T11:09:45Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1MTkzNg==", "bodyText": "Should extend itself be a no-op if the timeout is 0?", "url": "https://github.com/line/armeria/pull/2392#discussion_r365751936", "createdAt": "2020-01-13T11:17:30Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46299fd0238d40a7e5cf755cc2d00f440a0aa43f", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/46299fd0238d40a7e5cf755cc2d00f440a0aa43f", "committedDate": "2020-01-14T03:11:57Z", "message": "Address the comments from @ikhoon and @anuraaga"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMjg4Mzc3", "url": "https://github.com/line/armeria/pull/2392#pullrequestreview-342288377", "createdAt": "2020-01-14T04:40:41Z", "commit": {"oid": "46299fd0238d40a7e5cf755cc2d00f440a0aa43f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwOTozODoyN1rOFdRMfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwOTozODoyN1rOFdRMfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIzNDc0OA==", "bodyText": "Just noticed this is probably for #1913.\nDo you think we can special case 4XX with something like \"Received 4XX health check response. This generally indicates a misconfiguration of the client. Did you happen to forget to configure the endpoint group option with those of the client?\"", "url": "https://github.com/line/armeria/pull/2392#discussion_r366234748", "createdAt": "2020-01-14T09:38:27Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,189 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse == null) {\n+            // Called even before the first request is sent.\n+            closed = true;\n+            return CompletableFuture.completedFuture(null);\n+        }\n+\n+        if (!closed) {\n+            closed = true;\n+            lastResponse.abort();\n+        }\n+\n+        return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46299fd0238d40a7e5cf755cc2d00f440a0aa43f"}, "originalPosition": 170}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 851, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}