{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMjY1MjUw", "number": 2383, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMzo0ODo0MVrODWbowg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNDowMzoyMFrODWbvLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODQ4MDY2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/ClientThreadLocalState.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMzo0ODo0MVrOFbMFNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNTozNTo0OVrOFbNEuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1MzgxMw==", "bodyText": "How about not adding after close()?", "url": "https://github.com/line/armeria/pull/2383#discussion_r364053813", "createdAt": "2020-01-08T03:48:41Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientThreadLocalState.java", "diffHunk": "@@ -129,6 +129,13 @@ private static void reportThreadSafetyViolation() {\n             this.oldCaptor = oldCaptor;\n         }\n \n+        void add(ClientRequestContext ctx) {\n+            captured.add(ctx);\n+            if (oldCaptor != null) {\n+                oldCaptor.add(ctx);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2NzkzOA==", "bodyText": "Oops. \ud83d\ude05 I thought it's null after it's closed.", "url": "https://github.com/line/armeria/pull/2383#discussion_r364067938", "createdAt": "2020-01-08T05:22:31Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientThreadLocalState.java", "diffHunk": "@@ -129,6 +129,13 @@ private static void reportThreadSafetyViolation() {\n             this.oldCaptor = oldCaptor;\n         }\n \n+        void add(ClientRequestContext ctx) {\n+            captured.add(ctx);\n+            if (oldCaptor != null) {\n+                oldCaptor.add(ctx);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1MzgxMw=="}, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MDA3NQ==", "bodyText": "Changed. But I couldn't make a test case because oldCaptor.add() is never called...", "url": "https://github.com/line/armeria/pull/2383#discussion_r364070075", "createdAt": "2020-01-08T05:35:49Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientThreadLocalState.java", "diffHunk": "@@ -129,6 +129,13 @@ private static void reportThreadSafetyViolation() {\n             this.oldCaptor = oldCaptor;\n         }\n \n+        void add(ClientRequestContext ctx) {\n+            captured.add(ctx);\n+            if (oldCaptor != null) {\n+                oldCaptor.add(ctx);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1MzgxMw=="}, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODQ5NzA4OnYy", "diffSide": "RIGHT", "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNDowMzoyMFrOFbMOsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNTo0NDo0MlrOFbNK4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ==", "bodyText": "I think we can directly mount the context here and below instead of using makeContextAware.", "url": "https://github.com/line/armeria/pull/2383#discussion_r364056241", "createdAt": "2020-01-08T04:03:20Z", "author": {"login": "anuraaga"}, "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "diffHunk": "@@ -119,31 +124,51 @@ private Object invokeClientMethod(Method method, @Nullable Object[] args) throws\n             }\n         }\n \n-        try {\n-            final RpcResponse reply;\n-            if (fragment != null) {\n-                reply = delegate().executeMultiplexed(\n-                        path, params.clientType(), fragment, method.getName(), args);\n-            } else {\n-                reply = delegate().execute(path, params.clientType(), method.getName(), args);\n-            }\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            try {\n+                final RpcResponse reply;\n+                if (fragment != null) {\n+                    reply = delegate().executeMultiplexed(\n+                            path, params.clientType(), fragment, method.getName(), args);\n+                } else {\n+                    reply = delegate().execute(path, params.clientType(), method.getName(), args);\n+                }\n \n-            if (callback != null) {\n-                AsyncMethodCallbacks.transfer(reply, callback);\n-                return null;\n-            } else {\n-                try {\n-                    return reply.get();\n-                } catch (ExecutionException e) {\n-                    throw Exceptions.peel(e);\n+                final ClientRequestContext ctx = captor.get();\n+                if (callback != null) {\n+                    reply.handle(ctx.makeContextAware((res, cause) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2NzU1NA==", "bodyText": "https://github.com/line/armeria/pull/2383/files#diff-6ab8399d40ca91dd25785dc822606306R167\nThis line should be called by the same executor so I chose this way which is let the thread, which completes the reply, do the jobs in callback.\nBut I'm not so strong this and I can put the job in the executor.", "url": "https://github.com/line/armeria/pull/2383#discussion_r364067554", "createdAt": "2020-01-08T05:20:19Z", "author": {"login": "minwoox"}, "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "diffHunk": "@@ -119,31 +124,51 @@ private Object invokeClientMethod(Method method, @Nullable Object[] args) throws\n             }\n         }\n \n-        try {\n-            final RpcResponse reply;\n-            if (fragment != null) {\n-                reply = delegate().executeMultiplexed(\n-                        path, params.clientType(), fragment, method.getName(), args);\n-            } else {\n-                reply = delegate().execute(path, params.clientType(), method.getName(), args);\n-            }\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            try {\n+                final RpcResponse reply;\n+                if (fragment != null) {\n+                    reply = delegate().executeMultiplexed(\n+                            path, params.clientType(), fragment, method.getName(), args);\n+                } else {\n+                    reply = delegate().execute(path, params.clientType(), method.getName(), args);\n+                }\n \n-            if (callback != null) {\n-                AsyncMethodCallbacks.transfer(reply, callback);\n-                return null;\n-            } else {\n-                try {\n-                    return reply.get();\n-                } catch (ExecutionException e) {\n-                    throw Exceptions.peel(e);\n+                final ClientRequestContext ctx = captor.get();\n+                if (callback != null) {\n+                    reply.handle(ctx.makeContextAware((res, cause) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2OTY3NQ==", "bodyText": "I'm not sure I understand, probably since I wasn't clear either - I didn't mean use the executor, but just something like this to directly mount the context without creating a wrapped callable\nreply.handle((res, cause) -> {\n  try (SafeCloseable unused = ctx.push()) {\n    if (cause != null) {\n                     invokeOnError(callback, cause);\n                } else {\n                    callback.onComplete(res);\n                            }\n                        } catch (Exception e) {\n                            CompletionActions.log(e);\n                        }\n                        return null;\n                    }));", "url": "https://github.com/line/armeria/pull/2383#discussion_r364069675", "createdAt": "2020-01-08T05:33:18Z", "author": {"login": "anuraaga"}, "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "diffHunk": "@@ -119,31 +124,51 @@ private Object invokeClientMethod(Method method, @Nullable Object[] args) throws\n             }\n         }\n \n-        try {\n-            final RpcResponse reply;\n-            if (fragment != null) {\n-                reply = delegate().executeMultiplexed(\n-                        path, params.clientType(), fragment, method.getName(), args);\n-            } else {\n-                reply = delegate().execute(path, params.clientType(), method.getName(), args);\n-            }\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            try {\n+                final RpcResponse reply;\n+                if (fragment != null) {\n+                    reply = delegate().executeMultiplexed(\n+                            path, params.clientType(), fragment, method.getName(), args);\n+                } else {\n+                    reply = delegate().execute(path, params.clientType(), method.getName(), args);\n+                }\n \n-            if (callback != null) {\n-                AsyncMethodCallbacks.transfer(reply, callback);\n-                return null;\n-            } else {\n-                try {\n-                    return reply.get();\n-                } catch (ExecutionException e) {\n-                    throw Exceptions.peel(e);\n+                final ClientRequestContext ctx = captor.get();\n+                if (callback != null) {\n+                    reply.handle(ctx.makeContextAware((res, cause) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2OTg4MQ==", "bodyText": "Well actually, I can't get an executor in that case. Is it okay to execute the callback(invokeOnError(callback, cause);) with the different thread in this case?", "url": "https://github.com/line/armeria/pull/2383#discussion_r364069881", "createdAt": "2020-01-08T05:34:37Z", "author": {"login": "minwoox"}, "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "diffHunk": "@@ -119,31 +124,51 @@ private Object invokeClientMethod(Method method, @Nullable Object[] args) throws\n             }\n         }\n \n-        try {\n-            final RpcResponse reply;\n-            if (fragment != null) {\n-                reply = delegate().executeMultiplexed(\n-                        path, params.clientType(), fragment, method.getName(), args);\n-            } else {\n-                reply = delegate().execute(path, params.clientType(), method.getName(), args);\n-            }\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            try {\n+                final RpcResponse reply;\n+                if (fragment != null) {\n+                    reply = delegate().executeMultiplexed(\n+                            path, params.clientType(), fragment, method.getName(), args);\n+                } else {\n+                    reply = delegate().execute(path, params.clientType(), method.getName(), args);\n+                }\n \n-            if (callback != null) {\n-                AsyncMethodCallbacks.transfer(reply, callback);\n-                return null;\n-            } else {\n-                try {\n-                    return reply.get();\n-                } catch (ExecutionException e) {\n-                    throw Exceptions.peel(e);\n+                final ClientRequestContext ctx = captor.get();\n+                if (callback != null) {\n+                    reply.handle(ctx.makeContextAware((res, cause) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MDExMg==", "bodyText": "By the way, as far as the thread, from what I understand, the thread running the handle callback will be the thread in delegate().execute( and isn't related to this code directly. Though I guess this code, delegate().execute will in practice be the same thread, which happens to be ctx.contextAwareExecutor too. JFYI, I don't think it affects how we mount the context here.", "url": "https://github.com/line/armeria/pull/2383#discussion_r364070112", "createdAt": "2020-01-08T05:35:57Z", "author": {"login": "anuraaga"}, "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "diffHunk": "@@ -119,31 +124,51 @@ private Object invokeClientMethod(Method method, @Nullable Object[] args) throws\n             }\n         }\n \n-        try {\n-            final RpcResponse reply;\n-            if (fragment != null) {\n-                reply = delegate().executeMultiplexed(\n-                        path, params.clientType(), fragment, method.getName(), args);\n-            } else {\n-                reply = delegate().execute(path, params.clientType(), method.getName(), args);\n-            }\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            try {\n+                final RpcResponse reply;\n+                if (fragment != null) {\n+                    reply = delegate().executeMultiplexed(\n+                            path, params.clientType(), fragment, method.getName(), args);\n+                } else {\n+                    reply = delegate().execute(path, params.clientType(), method.getName(), args);\n+                }\n \n-            if (callback != null) {\n-                AsyncMethodCallbacks.transfer(reply, callback);\n-                return null;\n-            } else {\n-                try {\n-                    return reply.get();\n-                } catch (ExecutionException e) {\n-                    throw Exceptions.peel(e);\n+                final ClientRequestContext ctx = captor.get();\n+                if (callback != null) {\n+                    reply.handle(ctx.makeContextAware((res, cause) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MDc4Ng==", "bodyText": "Well, it could be the thread which calls reply.handle() (i,e, reply is completed when attaching callback. \ud83d\ude2d  This is why previous PR was not working )", "url": "https://github.com/line/armeria/pull/2383#discussion_r364070786", "createdAt": "2020-01-08T05:39:53Z", "author": {"login": "minwoox"}, "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "diffHunk": "@@ -119,31 +124,51 @@ private Object invokeClientMethod(Method method, @Nullable Object[] args) throws\n             }\n         }\n \n-        try {\n-            final RpcResponse reply;\n-            if (fragment != null) {\n-                reply = delegate().executeMultiplexed(\n-                        path, params.clientType(), fragment, method.getName(), args);\n-            } else {\n-                reply = delegate().execute(path, params.clientType(), method.getName(), args);\n-            }\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            try {\n+                final RpcResponse reply;\n+                if (fragment != null) {\n+                    reply = delegate().executeMultiplexed(\n+                            path, params.clientType(), fragment, method.getName(), args);\n+                } else {\n+                    reply = delegate().execute(path, params.clientType(), method.getName(), args);\n+                }\n \n-            if (callback != null) {\n-                AsyncMethodCallbacks.transfer(reply, callback);\n-                return null;\n-            } else {\n-                try {\n-                    return reply.get();\n-                } catch (ExecutionException e) {\n-                    throw Exceptions.peel(e);\n+                final ClientRequestContext ctx = captor.get();\n+                if (callback != null) {\n+                    reply.handle(ctx.makeContextAware((res, cause) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MDkyOA==", "bodyText": "I'm not sure I understand, probably since I wasn't clear either - I didn't mean use the executor, but just something like this to directly mount the context without creating a wrapped callable\n\nYeah, I can do that and I misunderstood it. \ud83d\ude05", "url": "https://github.com/line/armeria/pull/2383#discussion_r364070928", "createdAt": "2020-01-08T05:40:39Z", "author": {"login": "minwoox"}, "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "diffHunk": "@@ -119,31 +124,51 @@ private Object invokeClientMethod(Method method, @Nullable Object[] args) throws\n             }\n         }\n \n-        try {\n-            final RpcResponse reply;\n-            if (fragment != null) {\n-                reply = delegate().executeMultiplexed(\n-                        path, params.clientType(), fragment, method.getName(), args);\n-            } else {\n-                reply = delegate().execute(path, params.clientType(), method.getName(), args);\n-            }\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            try {\n+                final RpcResponse reply;\n+                if (fragment != null) {\n+                    reply = delegate().executeMultiplexed(\n+                            path, params.clientType(), fragment, method.getName(), args);\n+                } else {\n+                    reply = delegate().execute(path, params.clientType(), method.getName(), args);\n+                }\n \n-            if (callback != null) {\n-                AsyncMethodCallbacks.transfer(reply, callback);\n-                return null;\n-            } else {\n-                try {\n-                    return reply.get();\n-                } catch (ExecutionException e) {\n-                    throw Exceptions.peel(e);\n+                final ClientRequestContext ctx = captor.get();\n+                if (callback != null) {\n+                    reply.handle(ctx.makeContextAware((res, cause) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MTY0OA==", "bodyText": "Aha - thanks I understand the threading issue now. I never realized the non-async callback methods had such a dangerous caveat to them though I guess there isn't any way to implement them consistently", "url": "https://github.com/line/armeria/pull/2383#discussion_r364071648", "createdAt": "2020-01-08T05:44:42Z", "author": {"login": "anuraaga"}, "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "diffHunk": "@@ -119,31 +124,51 @@ private Object invokeClientMethod(Method method, @Nullable Object[] args) throws\n             }\n         }\n \n-        try {\n-            final RpcResponse reply;\n-            if (fragment != null) {\n-                reply = delegate().executeMultiplexed(\n-                        path, params.clientType(), fragment, method.getName(), args);\n-            } else {\n-                reply = delegate().execute(path, params.clientType(), method.getName(), args);\n-            }\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            try {\n+                final RpcResponse reply;\n+                if (fragment != null) {\n+                    reply = delegate().executeMultiplexed(\n+                            path, params.clientType(), fragment, method.getName(), args);\n+                } else {\n+                    reply = delegate().execute(path, params.clientType(), method.getName(), args);\n+                }\n \n-            if (callback != null) {\n-                AsyncMethodCallbacks.transfer(reply, callback);\n-                return null;\n-            } else {\n-                try {\n-                    return reply.get();\n-                } catch (ExecutionException e) {\n-                    throw Exceptions.peel(e);\n+                final ClientRequestContext ctx = captor.get();\n+                if (callback != null) {\n+                    reply.handle(ctx.makeContextAware((res, cause) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, "originalCommit": {"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2888, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}