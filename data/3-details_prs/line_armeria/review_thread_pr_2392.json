{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMzczMTc2", "number": 2392, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNzoyNzo0MVrODXb2pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwOTozODoyN1rODXyKCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTAwMTk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNzoyNzo0MVrOFcuqMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMzoxMTo0OFrOFdLGtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2ODkxNQ==", "bodyText": "nit: Could return early? You think it is trivial, feel free to ignore this.\ud83d\ude00\nfinal long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\nif (pingIntervalSeconds <= 0) {\n    return;\n}\nfinal long pingTimeoutNanos = LongMath.saturatedMultiply(\n        TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);", "url": "https://github.com/line/armeria/pull/2392#discussion_r365668915", "createdAt": "2020-01-13T07:27:41Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;\n+            long pingIntervalSeconds = 0;\n+            try {\n+                maxLongPollingSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(0, commaPos).trim()));\n+                pingIntervalSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(commaPos + 1).trim()));\n+            } catch (NumberFormatException e) {\n+                // Ignore malformed settings.\n+            }\n+\n+            HttpHealthChecker.this.maxLongPollingSeconds = maxLongPollingSeconds;\n+            if (maxLongPollingSeconds > 0 && pingIntervalSeconds < maxLongPollingSeconds) {\n+                HttpHealthChecker.this.pingIntervalSeconds = pingIntervalSeconds;\n+            } else {\n+                HttpHealthChecker.this.pingIntervalSeconds = 0;\n+            }\n+        }\n+\n+        // TODO(trustin): Remove once https://github.com/line/armeria/issues/1063 is fixed.\n+        private void maybeSchedulePingCheck() {\n+            lastPingTimeNanos = System.nanoTime();\n+\n+            if (pingCheckFuture != null) {\n+                return;\n+            }\n+\n+            final long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\n+            final long pingTimeoutNanos = LongMath.saturatedMultiply(\n+                    TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);\n+            if (pingIntervalSeconds <= 0) {\n+                return;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzNDk2NQ==", "bodyText": "Indeed.", "url": "https://github.com/line/armeria/pull/2392#discussion_r366134965", "createdAt": "2020-01-14T03:11:48Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;\n+            long pingIntervalSeconds = 0;\n+            try {\n+                maxLongPollingSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(0, commaPos).trim()));\n+                pingIntervalSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(commaPos + 1).trim()));\n+            } catch (NumberFormatException e) {\n+                // Ignore malformed settings.\n+            }\n+\n+            HttpHealthChecker.this.maxLongPollingSeconds = maxLongPollingSeconds;\n+            if (maxLongPollingSeconds > 0 && pingIntervalSeconds < maxLongPollingSeconds) {\n+                HttpHealthChecker.this.pingIntervalSeconds = pingIntervalSeconds;\n+            } else {\n+                HttpHealthChecker.this.pingIntervalSeconds = 0;\n+            }\n+        }\n+\n+        // TODO(trustin): Remove once https://github.com/line/armeria/issues/1063 is fixed.\n+        private void maybeSchedulePingCheck() {\n+            lastPingTimeNanos = System.nanoTime();\n+\n+            if (pingCheckFuture != null) {\n+                return;\n+            }\n+\n+            final long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\n+            final long pingTimeoutNanos = LongMath.saturatedMultiply(\n+                    TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);\n+            if (pingIntervalSeconds <= 0) {\n+                return;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2ODkxNQ=="}, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTMxMTg2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwOTo1MTozNVrOFcxgDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwOTo1MTozNVrOFcxgDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxNTQ3MA==", "bodyText": "shouldn't we do this on ctx.executor() not the eventLoop used on the first health check request?\nForget about it. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2392#discussion_r365715470", "createdAt": "2020-01-13T09:51:35Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;\n+            long pingIntervalSeconds = 0;\n+            try {\n+                maxLongPollingSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(0, commaPos).trim()));\n+                pingIntervalSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(commaPos + 1).trim()));\n+            } catch (NumberFormatException e) {\n+                // Ignore malformed settings.\n+            }\n+\n+            HttpHealthChecker.this.maxLongPollingSeconds = maxLongPollingSeconds;\n+            if (maxLongPollingSeconds > 0 && pingIntervalSeconds < maxLongPollingSeconds) {\n+                HttpHealthChecker.this.pingIntervalSeconds = pingIntervalSeconds;\n+            } else {\n+                HttpHealthChecker.this.pingIntervalSeconds = 0;\n+            }\n+        }\n+\n+        // TODO(trustin): Remove once https://github.com/line/armeria/issues/1063 is fixed.\n+        private void maybeSchedulePingCheck() {\n+            lastPingTimeNanos = System.nanoTime();\n+\n+            if (pingCheckFuture != null) {\n+                return;\n+            }\n+\n+            final long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\n+            final long pingTimeoutNanos = LongMath.saturatedMultiply(\n+                    TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);\n+            if (pingIntervalSeconds <= 0) {\n+                return;\n+            }\n+\n+            pingCheckFuture = reqCtx.eventLoop().scheduleWithFixedDelay(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTUwMjgzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMDo1NzozMVrOFczQyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMzoxMTowNlrOFdLGLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDMzMA==", "bodyText": "I notice this is copied but wondered, why we don't set closed in this branch?", "url": "https://github.com/line/armeria/pull/2392#discussion_r365744330", "createdAt": "2020-01-13T10:57:31Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzNDgyOA==", "bodyText": "Because it's a bug? \ud83d\ude06", "url": "https://github.com/line/armeria/pull/2392#discussion_r366134828", "createdAt": "2020-01-14T03:11:06Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDMzMA=="}, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTUzMzE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMTowOTo0NVrOFczjKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMzoxMTozNlrOFdLGkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0OTAzMw==", "bodyText": "Don't think these need to be long, especially the ping interval", "url": "https://github.com/line/armeria/pull/2392#discussion_r365749033", "createdAt": "2020-01-13T11:09:45Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzNDkyOQ==", "bodyText": "All changed to int", "url": "https://github.com/line/armeria/pull/2392#discussion_r366134929", "createdAt": "2020-01-14T03:11:36Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0OTAzMw=="}, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTU1MTg5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMToxNzozMFrOFczugA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMzoxMToyMFrOFdLGYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1MTkzNg==", "bodyText": "Should extend itself be a no-op if the timeout is 0?", "url": "https://github.com/line/armeria/pull/2392#discussion_r365751936", "createdAt": "2020-01-13T11:17:30Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzNDg4Mg==", "bodyText": "Good point. No need for if.", "url": "https://github.com/line/armeria/pull/2392#discussion_r366134882", "createdAt": "2020-01-14T03:11:20Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1MTkzNg=="}, "originalCommit": {"oid": "db00fffa64e6008decb710fdf51a885b082e7513"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MjY1NjExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwOTozODoyN1rOFdRMfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwOTozODoyN1rOFdRMfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIzNDc0OA==", "bodyText": "Just noticed this is probably for #1913.\nDo you think we can special case 4XX with something like \"Received 4XX health check response. This generally indicates a misconfiguration of the client. Did you happen to forget to configure the endpoint group option with those of the client?\"", "url": "https://github.com/line/armeria/pull/2392#discussion_r366234748", "createdAt": "2020-01-14T09:38:27Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,189 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse == null) {\n+            // Called even before the first request is sent.\n+            closed = true;\n+            return CompletableFuture.completedFuture(null);\n+        }\n+\n+        if (!closed) {\n+            closed = true;\n+            lastResponse.abort();\n+        }\n+\n+        return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46299fd0238d40a7e5cf755cc2d00f440a0aa43f"}, "originalPosition": 170}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2895, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}