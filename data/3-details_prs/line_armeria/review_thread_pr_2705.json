{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2ODM0MTQ4", "number": 2705, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTozMjozOFrOD8SshA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowNzo1OVrOD8UKvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTQ3NDYwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTozMjozOFrOGVJD9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTozMjozOFrOGVJD9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMTc0OA==", "bodyText": "This needs to be cleaned up.", "url": "https://github.com/line/armeria/pull/2705#discussion_r424821748", "createdAt": "2020-05-14T01:32:38Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3c909a76830b14eb0fd56a818ec084bf622b9e8"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTQ3NTE2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTozMjo1MlrOGVJEOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDoxMjoyOVrOGVLbTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMTgxNw==", "bodyText": "Ditto - needs cleanup", "url": "https://github.com/line/armeria/pull/2705#discussion_r424821817", "createdAt": "2020-05-14T01:32:52Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (HttpMethod.valueOf(\"PRI\").equals(request.method())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(\n+                        HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER, headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address())).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3c909a76830b14eb0fd56a818ec084bf622b9e8"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTAzMg==", "bodyText": "Could use try-with-resources?", "url": "https://github.com/line/armeria/pull/2705#discussion_r424859032", "createdAt": "2020-05-14T04:06:34Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (HttpMethod.valueOf(\"PRI\").equals(request.method())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(\n+                        HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER, headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address())).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMTgxNw=="}, "originalCommit": {"oid": "b3c909a76830b14eb0fd56a818ec084bf622b9e8"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDQ5NA==", "bodyText": "Never mind. All other test methods seem not to use it anyway.", "url": "https://github.com/line/armeria/pull/2705#discussion_r424860494", "createdAt": "2020-05-14T04:12:29Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (HttpMethod.valueOf(\"PRI\").equals(request.method())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(\n+                        HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER, headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address())).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMTgxNw=="}, "originalCommit": {"oid": "b3c909a76830b14eb0fd56a818ec084bf622b9e8"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTQ3NzMxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTozNDozM1rOGVJFng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMjo1OTo0MlrOGVKZSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMjE3NA==", "bodyText": "Could we also check if the client retried a CONNECT request, instead of GET? For example, you could send a response content that contains the request method instead of success above.", "url": "https://github.com/line/armeria/pull/2705#discussion_r424822174", "createdAt": "2020-05-14T01:34:33Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3c909a76830b14eb0fd56a818ec084bf622b9e8"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzODUwOA==", "bodyText": "I've changed the test so that it returns the requested method which is GET.\nThis check should ensure CONNECT requests were not made directly to the backend server.\nI'm still brainstorming ways where we can ensure CONNECT was retried as you said.", "url": "https://github.com/line/armeria/pull/2705#discussion_r424838508", "createdAt": "2020-05-14T02:39:08Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMjE3NA=="}, "originalCommit": {"oid": "b3c909a76830b14eb0fd56a818ec084bf622b9e8"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MzU5NA==", "bodyText": "Decided to go with the \"easy route\" and just add a counter for the number of successful proxy requests.", "url": "https://github.com/line/armeria/pull/2705#discussion_r424843594", "createdAt": "2020-05-14T02:59:42Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMjE3NA=="}, "originalCommit": {"oid": "b3c909a76830b14eb0fd56a818ec084bf622b9e8"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTQ3ODE5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTozNDo1NlrOGVJGHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMTozNDo1NlrOGVJGHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMjMwMg==", "bodyText": "Ditto - needs to ensure CONNECT request was sent", "url": "https://github.com/line/armeria/pull/2705#discussion_r424822302", "createdAt": "2020-05-14T01:34:56Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (HttpMethod.valueOf(\"PRI\").equals(request.method())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(\n+                        HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER, headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address())).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3c909a76830b14eb0fd56a818ec084bf622b9e8"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTcxMDQwOnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/NettyServerExtension.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowNDoyM1rOGVLT6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowOToxM1rOGVLYRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1ODYwMg==", "bodyText": "This needs Javadoc.", "url": "https://github.com/line/armeria/pull/2705#discussion_r424858602", "createdAt": "2020-05-14T04:04:23Z", "author": {"login": "trustin"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/NettyServerExtension.java", "diffHunk": "@@ -50,6 +51,10 @@ public final InetSocketAddress address() {\n         return (InetSocketAddress) channel.localAddress();\n     }\n \n+    public final Endpoint endpoint() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be10aed4312a2ccdae272a0b3434d773c607340e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTcxNg==", "bodyText": "Never mind - it's an internal class.", "url": "https://github.com/line/armeria/pull/2705#discussion_r424859716", "createdAt": "2020-05-14T04:09:13Z", "author": {"login": "trustin"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/NettyServerExtension.java", "diffHunk": "@@ -50,6 +51,10 @@ public final InetSocketAddress address() {\n         return (InetSocketAddress) channel.localAddress();\n     }\n \n+    public final Endpoint endpoint() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1ODYwMg=="}, "originalCommit": {"oid": "be10aed4312a2ccdae272a0b3434d773c607340e"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTcxMzkwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowNzowM1rOGVLV7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowNzowM1rOGVLV7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTExOQ==", "bodyText": "isEqualTo() ?", "url": "https://github.com/line/armeria/pull/2705#discussion_r424859119", "createdAt": "2020-05-14T04:07:03Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -216,6 +248,81 @@ void testHttpProxyBasicCase() throws Exception {\n         final AggregatedHttpResponse response = responseFuture.join();\n         assertThat(response.status()).isEqualByComparingTo(OK);\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+        assertThat(numSuccessfulProxyRequests).isEqualTo(1);\n+        clientFactory.close();\n+    }\n+\n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(request.method().name(), US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(GET.name());\n+        assertThat(numSuccessfulProxyRequests).isEqualTo(2);\n+        clientFactory.close();\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (HttpMethod.valueOf(\"PRI\").equals(request.method())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(\n+                        HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER, headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(request.method().name(), US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address())).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be10aed4312a2ccdae272a0b3434d773c607340e"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTcxNTgyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowNzo1OVrOGVLW_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowNzo1OVrOGVLW_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTM5MA==", "bodyText": "isEqualTo() will do.", "url": "https://github.com/line/armeria/pull/2705#discussion_r424859390", "createdAt": "2020-05-14T04:07:59Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -216,6 +248,81 @@ void testHttpProxyBasicCase() throws Exception {\n         final AggregatedHttpResponse response = responseFuture.join();\n         assertThat(response.status()).isEqualByComparingTo(OK);\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+        assertThat(numSuccessfulProxyRequests).isEqualTo(1);\n+        clientFactory.close();\n+    }\n+\n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(request.method().name(), US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be10aed4312a2ccdae272a0b3434d773c607340e"}, "originalPosition": 146}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2598, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}