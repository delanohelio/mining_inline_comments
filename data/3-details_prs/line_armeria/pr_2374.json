{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MzE1NzMx", "number": 2374, "title": "Fix `MAX_CONCURRENT_STREAMS` violation on client side", "bodyText": "Fixes (#2256 )\nMotivation\nCurrently an exception is thrown when a burst of requests are made for HTTP/2 clients\n(More specifically, when MAX_CONCURRENT_STREAMS is violated for pendingAcquisitions)\nThis PR attempts to modify so that no exceptions are thrown\nModifications\n\nReschedule pending requests when exceeding MAX_CONCURRENT_STREAMS\nModify the definition of pendingAcquisitionDuration to be total duration of pendingAcquisition (no matter how many connections are attempted)\n\npendingAcquisitionStart is set only once\npendingAcquisitionEnd can be set more than once", "createdAt": "2020-01-05T16:24:08Z", "url": "https://github.com/line/armeria/pull/2374", "merged": true, "mergeCommit": {"oid": "6ed874dd9dbffa9988b2476bc5fec8c1cb359b18"}, "closed": true, "closedAt": "2020-02-17T09:38:02Z", "author": {"login": "jrhee17"}, "timelineItems": {"totalCount": 62, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4K3O2AFqTMzOTU5OTc0OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcFI7eBAFqTM1OTU1MTQwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5NTk5NzQ5", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-339599749", "createdAt": "2020-01-08T01:07:31Z", "commit": {"oid": "37a56de52aedbde51625acdb1480dc6655694008"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMTowNzozMVrOFbKUzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMToxMzozNlrOFbKZ9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyNTAzOA==", "bodyText": "this should be set per PoolKey", "url": "https://github.com/line/armeria/pull/2374#discussion_r364025038", "createdAt": "2020-01-08T01:07:31Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -71,6 +71,7 @@\n     // Fields for creating a new connection:\n     private final Bootstrap[] bootstraps;\n     private final int connectTimeoutMillis;\n+    private volatile int numPendingAcquisitions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37a56de52aedbde51625acdb1480dc6655694008"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyNTc5NA==", "bodyText": "this can be optimized by checking existing connections", "url": "https://github.com/line/armeria/pull/2374#discussion_r364025794", "createdAt": "2020-01-08T01:10:52Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -266,14 +267,23 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             return false;\n         }\n \n+        numPendingAcquisitions++;\n+\n         timingsBuilder.pendingAcquisitionStart();\n         pendingAcquisition.handle((pch, cause) -> {\n             timingsBuilder.pendingAcquisitionEnd();\n \n+            numPendingAcquisitions--;\n+\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (numPendingAcquisitions < session.maxUnfinishedResponses() - 1) {\n+                        promise.complete(pch);\n+                    } else {\n+                        connect(actualProtocol, key, promise, timingsBuilder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37a56de52aedbde51625acdb1480dc6655694008"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyNjM1OA==", "bodyText": "should also compare with unfinishedResponses.\nalso, technically this may not be a correct check -- should also consider timing with\n\nadding response\ncheck for acquireNowExact", "url": "https://github.com/line/armeria/pull/2374#discussion_r364026358", "createdAt": "2020-01-08T01:13:36Z", "author": {"login": "jrhee17"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -266,14 +267,23 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             return false;\n         }\n \n+        numPendingAcquisitions++;\n+\n         timingsBuilder.pendingAcquisitionStart();\n         pendingAcquisition.handle((pch, cause) -> {\n             timingsBuilder.pendingAcquisitionEnd();\n \n+            numPendingAcquisitions--;\n+\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (numPendingAcquisitions < session.maxUnfinishedResponses() - 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37a56de52aedbde51625acdb1480dc6655694008"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7b04f05e0c1bf29d2fcef00450b208066230e87f", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/7b04f05e0c1bf29d2fcef00450b208066230e87f", "committedDate": "2020-01-09T15:49:19Z", "message": "fix checkstyle long line"}, "afterCommit": {"oid": "32ca3cdf8f89bc10cb2750ec143aabfe7c1cbe66", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/32ca3cdf8f89bc10cb2750ec143aabfe7c1cbe66", "committedDate": "2020-01-10T15:11:18Z", "message": "fix checkstyle: long line, newline"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32ca3cdf8f89bc10cb2750ec143aabfe7c1cbe66", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/32ca3cdf8f89bc10cb2750ec143aabfe7c1cbe66", "committedDate": "2020-01-10T15:11:18Z", "message": "fix checkstyle: long line, newline"}, "afterCommit": {"oid": "c63179d086dd121dbd655b99a162116a2fe3fbec", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/c63179d086dd121dbd655b99a162116a2fe3fbec", "committedDate": "2020-02-03T15:09:51Z", "message": "very basic fix -- simply create new connection if violated\n\n- this fix assumes pending acquisition isn't done\n- this fix can unnecessarily create many connections"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d648ab4a565ce324cfcbdf9b6d2e05032898780c", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/d648ab4a565ce324cfcbdf9b6d2e05032898780c", "committedDate": "2020-02-10T13:56:36Z", "message": "open minimal number of connections using recursion"}, "afterCommit": {"oid": "3dd48cc208b12782823d997a3edaa0606f526d08", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/3dd48cc208b12782823d997a3edaa0606f526d08", "committedDate": "2020-02-10T14:01:59Z", "message": "open minimal number of connections using recursion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef41055a9fb2580ad0ecad51040045e3a6c9dac6", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/ef41055a9fb2580ad0ecad51040045e3a6c9dac6", "committedDate": "2020-02-10T14:03:38Z", "message": "add initial failing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b8679b72b0e233cf195433a72a023a3d60f93de", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/6b8679b72b0e233cf195433a72a023a3d60f93de", "committedDate": "2020-02-10T14:03:38Z", "message": "very basic fix -- simply create new connection if violated\n\n- this fix assumes pending acquisition isn't done\n- this fix can unnecessarily create many connections"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40ed8328f394a4732ad4358881e25683a25d74db", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/40ed8328f394a4732ad4358881e25683a25d74db", "committedDate": "2020-02-10T14:03:38Z", "message": "fix test to succeed when max stream exceeded"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43b1a5f86447f5b8b4ea22003f3f9571d1995be6", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/43b1a5f86447f5b8b4ea22003f3f9571d1995be6", "committedDate": "2020-02-10T14:03:38Z", "message": "add failing test which opens too many connections"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20f04ecf7fae6604ae3e38b2af8605acdb15431b", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/20f04ecf7fae6604ae3e38b2af8605acdb15431b", "committedDate": "2020-02-10T14:03:38Z", "message": "fix checkStyleMain newline before brace"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3dd48cc208b12782823d997a3edaa0606f526d08", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/3dd48cc208b12782823d997a3edaa0606f526d08", "committedDate": "2020-02-10T14:01:59Z", "message": "open minimal number of connections using recursion"}, "afterCommit": {"oid": "63cd41b9eedcb9e03e265b6f29f6a445740a734a", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/63cd41b9eedcb9e03e265b6f29f6a445740a734a", "committedDate": "2020-02-10T14:03:38Z", "message": "open minimal number of connections using recursion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e3b16d092668b39342414203663711903491133", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/5e3b16d092668b39342414203663711903491133", "committedDate": "2020-02-10T14:47:17Z", "message": "open minimal number of connections using recursion"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63cd41b9eedcb9e03e265b6f29f6a445740a734a", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/63cd41b9eedcb9e03e265b6f29f6a445740a734a", "committedDate": "2020-02-10T14:03:38Z", "message": "open minimal number of connections using recursion"}, "afterCommit": {"oid": "5e3b16d092668b39342414203663711903491133", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/5e3b16d092668b39342414203663711903491133", "committedDate": "2020-02-10T14:47:17Z", "message": "open minimal number of connections using recursion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDY0Nzk1", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-356464795", "createdAt": "2020-02-11T08:04:18Z", "commit": {"oid": "5e3b16d092668b39342414203663711903491133"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODowNDoxOFrOFn_3Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODowNDoxOFrOFn_3Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4NTEzOA==", "bodyText": "I guess we can prevent calling pendingAcquisitionEnd() if acquireLater() will be called?", "url": "https://github.com/line/armeria/pull/2374#discussion_r377485138", "createdAt": "2020-02-11T08:04:18Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -107,8 +107,9 @@ public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n      * @throws IllegalStateException if {@link #pendingAcquisitionStart()} is not invoked before calling this.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionEnd() {\n-        checkState(pendingAcquisitionStartTimeMicros >= 0, \"pendingAcquisitionStart() is not called yet.\");\n-        checkState(!pendingAcquisitionEndSet, \"pendingAcquisitionEnd() is already called.\");\n+        // TODO: decide how to handle pendingAcquisitionEnd now that it might be called multiple times\n+        // checkState(pendingAcquisitionStartTimeMicros >= 0, \"pendingAcquisitionStart() is not called yet.\");\n+        // checkState(!pendingAcquisitionEndSet, \"pendingAcquisitionEnd() is already called.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e3b16d092668b39342414203663711903491133"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDY2OTkz", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-356466993", "createdAt": "2020-02-11T08:10:04Z", "commit": {"oid": "5e3b16d092668b39342414203663711903491133"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODoxMDowNFrOFn_-FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODoxMDowNFrOFn_-FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4Njg2OQ==", "bodyText": "Shouldn't we call acquireLater() after pendingAcquisition is cleared? acquireLater() (and inherently usePendingAcquisition()) would use the current pendingAcquisition again and again, making a busy loop.", "url": "https://github.com/line/armeria/pull/2374#discussion_r377486869", "createdAt": "2020-02-11T08:10:04Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +276,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());\n+                    // Need to subtract 1 since the current pending request may also be unfinished\n+                    if (session.unfinishedResponses() >= session.maxUnfinishedResponses() - 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder).thenAccept(promise::complete);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e3b16d092668b39342414203663711903491133"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c2cb9206668a765c1958eff522381126518aebb", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/2c2cb9206668a765c1958eff522381126518aebb", "committedDate": "2020-02-11T17:20:57Z", "message": "add failing test for proper exception handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e0810efa870a1720c4632ced06d2b1c6689a785", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/3e0810efa870a1720c4632ced06d2b1c6689a785", "committedDate": "2020-02-12T16:00:39Z", "message": "improve unit test for connection failure to include use pending case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "164cb7b154c92ceb71b6c1b9c9f9c3b701c5c0c0", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/164cb7b154c92ceb71b6c1b9c9f9c3b701c5c0c0", "committedDate": "2020-02-13T15:06:36Z", "message": "remove potential flakiness for failure test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d9e74f9451ca326e05310ee11946908c2870c19", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/6d9e74f9451ca326e05310ee11946908c2870c19", "committedDate": "2020-02-13T15:19:28Z", "message": "re-use future when acquiring new connection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3879c7975a32d8f7f6aabacb862a099aeca97ee1", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/3879c7975a32d8f7f6aabacb862a099aeca97ee1", "committedDate": "2020-02-13T15:37:43Z", "message": "add test for multiple event loops and clean tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NzQ2OTg0", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-358746984", "createdAt": "2020-02-14T07:11:18Z", "commit": {"oid": "3879c7975a32d8f7f6aabacb862a099aeca97ee1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxMToxOFrOFptVjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxMToxOFrOFptVjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI3ODczNA==", "bodyText": "also add checks for pendingAcquisitionMillis to ensure pendingAcquisition was really used", "url": "https://github.com/line/armeria/pull/2374#discussion_r379278734", "createdAt": "2020-02-14T07:11:18Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +170,143 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    public void succeedWhenExceedMaxStreams() throws Exception {\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        // running inside event loop ensures requests are queued before initial connect completes.\n+        for (int j = 0; j < MAX_CONCURRENT_STREAMS + 1; j++) {\n+            receivedResponses.add(client.get(PATH).aggregate());\n+        }\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(MAX_CONCURRENT_STREAMS + 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3879c7975a32d8f7f6aabacb862a099aeca97ee1"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0be6a39788d12129e2f951685a046137b24d4e5", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/d0be6a39788d12129e2f951685a046137b24d4e5", "committedDate": "2020-02-15T06:59:29Z", "message": "improve flakiness, stricter check for pendingAcquisition called"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e90705184b616f1bfeac3f8aebd2570446064a7", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/6e90705184b616f1bfeac3f8aebd2570446064a7", "committedDate": "2020-02-15T07:21:41Z", "message": "add failing test for correct pendingAcquisitionTime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8373a97d306c9206d63bdf08b2215a5c004d6442", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/8373a97d306c9206d63bdf08b2215a5c004d6442", "committedDate": "2020-02-15T07:24:39Z", "message": "somewhat dirty fix for correct pendingAcquisition duration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/91bb3846b60bc5301b19619ce9488307898bd40b", "committedDate": "2020-02-15T08:22:46Z", "message": "migrate to junit 5"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c1927e73137ac9786b0a833f55fa1b8e24c484f", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/5c1927e73137ac9786b0a833f55fa1b8e24c484f", "committedDate": "2020-02-15T08:20:27Z", "message": "migrate to junit 5"}, "afterCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/91bb3846b60bc5301b19619ce9488307898bd40b", "committedDate": "2020-02-15T08:22:46Z", "message": "migrate to junit 5"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzM0NDUz", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359334453", "createdAt": "2020-02-15T08:30:42Z", "commit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODozMDo0MlrOFqNX_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwODo0MjozOVrOFqNogA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwMzY0Nw==", "bodyText": "Better extracting them into a local variable if you intend to keep the logging above.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379803647", "createdAt": "2020-02-15T08:30:42Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());\n+                    // unfinishedResponses >= maxUnfinishedResponses - current connecting request\n+                    if (session.unfinishedResponses() >= session.maxUnfinishedResponses() - 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwMzgxMQ==", "bodyText": "Probably debug is better? Or do you intend to remove it before removing draft?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379803811", "createdAt": "2020-02-15T08:31:11Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNDQzOQ==", "bodyText": "pendingAcquisitionEndNanos == 0 -> !pendingAcquisitionEndSet ?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379804439", "createdAt": "2020-02-15T08:32:48Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -95,8 +95,10 @@ public ClientConnectionTimingsBuilder socketConnectEnd() {\n      * in order to use one connection for HTTP/2.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n-        pendingAcquisitionStartTimeMicros = SystemInfo.currentTimeMicros();\n-        pendingAcquisitionStartNanos = System.nanoTime();\n+        if (pendingAcquisitionStartTimeMicros == 0 && pendingAcquisitionEndNanos == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNTM2MQ==", "bodyText": "j could be i?\nCould you add a comment about why you need to execute this via .execute()?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379805361", "createdAt": "2020-02-15T08:35:34Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNzMyNQ==", "bodyText": "Could you also check the cause of the cause as well? (with hasMessageContaining if possible.)\n// Not sure if this is the best example. Maybe you can just split the assertions.\nassertThatThrownBy(() -> ...)\n        .isInstanceOf(CompletionException.class)\n        .hasCauseInstanceOfSatisfying(UnprocessedRequestException.class, cause -> {\n            assertThat(cause).hasCauseInstanceofSatisfying(SomeException.class, causeOfCause -> {\n                ...\n            });\n        });", "url": "https://github.com/line/armeria/pull/2374#discussion_r379807325", "createdAt": "2020-02-15T08:41:06Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNzg3Mg==", "bodyText": "mapToLong(...).max()", "url": "https://github.com/line/armeria/pull/2374#discussion_r379807872", "createdAt": "2020-02-15T08:42:39Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final int sleepMillis = 300;\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                Thread.sleep(sleepMillis);\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+\n+        // There should be at least one request with at least numConnections * pendingAcquisitionsDuration\n+        final Long maxPendingAcquisitionDurationNanos = connectionTimings.stream().map(\n+                ClientConnectionTimings::pendingAcquisitionDurationNanos).max(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 317}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b8536044a4b56ea2b3be8b236ba12ae95387cdb", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/0b8536044a4b56ea2b3be8b236ba12ae95387cdb", "committedDate": "2020-02-15T08:56:47Z", "message": "(POC) explore idea of maxRetryCount - reverted immediately"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7c6ada1e43e49c55556bd5d6f849602a18c7eec", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/f7c6ada1e43e49c55556bd5d6f849602a18c7eec", "committedDate": "2020-02-15T08:57:12Z", "message": "Revert \"(POC) explore idea of maxRetryCount - reverted immediately\"\n\nThis reverts commit 0b8536044a4b56ea2b3be8b236ba12ae95387cdb."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "248c2b15dc2c7e084e368309a58ba471d617f746", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/248c2b15dc2c7e084e368309a58ba471d617f746", "committedDate": "2020-02-15T09:10:27Z", "message": "add comments, clean up tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzM1OTY4", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359335968", "createdAt": "2020-02-15T09:13:01Z", "commit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwOToxMzowMVrOFqOQWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwOToxMzowMVrOFqOQWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgxODA3Mw==", "bodyText": "Note to self: check if this has a potential to be flaky depending on how requests are assigned to event loops", "url": "https://github.com/line/armeria/pull/2374#discussion_r379818073", "createdAt": "2020-02-15T09:13:01Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b"}, "originalPosition": 235}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9257be77ef57b6a4c9f7d49efd67f479b573a296", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/9257be77ef57b6a4c9f7d49efd67f479b573a296", "committedDate": "2020-02-15T11:53:27Z", "message": "remove unnecessary import for comparator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cd25d2635f499c5e310e2b41ba34aa5feb00118", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/6cd25d2635f499c5e310e2b41ba34aa5feb00118", "committedDate": "2020-02-15T12:25:53Z", "message": "remove debug log for number of connections"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c49b1c3e74bee0aff9fa172a559106489daf77cf", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/c49b1c3e74bee0aff9fa172a559106489daf77cf", "committedDate": "2020-02-15T12:05:05Z", "message": "remove debug log for number of connections"}, "afterCommit": {"oid": "6cd25d2635f499c5e310e2b41ba34aa5feb00118", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/6cd25d2635f499c5e310e2b41ba34aa5feb00118", "committedDate": "2020-02-15T12:25:53Z", "message": "remove debug log for number of connections"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzQ0Nzgw", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359344780", "createdAt": "2020-02-15T13:10:14Z", "commit": {"oid": "6cd25d2635f499c5e310e2b41ba34aa5feb00118"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxMzoxMDoxNVrOFqPBRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxMzoxMDoxNVrOFqPBRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzMDU5OQ==", "bodyText": "Highly unlikely, but unfinishedResponses + 1 can overflow theoretically. How about this?\nif (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n\nor ..\nfinal int numRemainingStreams =\n        session.maxUnfinishedResponses() - session.unfinishedResponses();\nif (numRemainingStreams <= 1) {", "url": "https://github.com/line/armeria/pull/2374#discussion_r379830599", "createdAt": "2020-02-15T13:10:15Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,13 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    final int activeRequests = session.unfinishedResponses() + 1;\n+                    if (activeRequests >= session.maxUnfinishedResponses()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd25d2635f499c5e310e2b41ba34aa5feb00118"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da804cd08f47b4e247db5b04df61444040d44dfe", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/da804cd08f47b4e247db5b04df61444040d44dfe", "committedDate": "2020-02-15T14:14:48Z", "message": "ensure overflow doesn't occur"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f272afcd4c6de9e5adab1dfa11a1bbb2b6aa2fa6", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/f272afcd4c6de9e5adab1dfa11a1bbb2b6aa2fa6", "committedDate": "2020-02-15T14:31:35Z", "message": "also check root cause for failed connections"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/91c73c4981906eb3fdce803c9184c3cf0751f58c", "committedDate": "2020-02-15T14:41:39Z", "message": "also check cause of cause for failed connections"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzQ5Mjk4", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359349298", "createdAt": "2020-02-15T14:57:20Z", "commit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNDo1NzoyMFrOFqPWnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxNTowNzoxNFrOFqPYug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjA2MA==", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836060", "createdAt": "2020-02-15T14:57:20Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjA2Nw==", "bodyText": "Could use LinkedBlockingQueue or LinkedTransferQueue for thread safety, given that the list will be updated from a different thread. Could be removed as well.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836067", "createdAt": "2020-02-15T14:57:30Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final int sleepMillis = 300;\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                Thread.sleep(sleepMillis);\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjA3Nw==", "bodyText": "Could be removed.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836077", "createdAt": "2020-02-15T14:57:48Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjE1Mw==", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836153", "createdAt": "2020-02-15T14:58:57Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjE5Mg==", "bodyText": "This seems unused.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836192", "createdAt": "2020-02-15T14:59:58Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjE5Nw==", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836197", "createdAt": "2020-02-15T15:00:14Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjIxOQ==", "bodyText": "Could be removed.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836219", "createdAt": "2020-02-15T15:00:42Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjI0Mw==", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836243", "createdAt": "2020-02-15T15:00:56Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjMzNg==", "bodyText": "Could be deduplicated?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836336", "createdAt": "2020-02-15T15:02:29Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjQyMw==", "bodyText": "initial connect -> an initial connection attempt ?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836423", "createdAt": "2020-02-15T15:04:08Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final int sleepMillis = 300;\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                Thread.sleep(sleepMillis);\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+\n+        // There should be at least one request with at least numConnections * pendingAcquisitionsDuration\n+        final Long maxPendingAcquisitionDurationNanos = connectionTimings.stream().mapToLong(\n+                ClientConnectionTimings::pendingAcquisitionDurationNanos).max().orElse(0L);\n+        assertThat(maxPendingAcquisitionDurationNanos)\n+                .isGreaterThan(TimeUnit.MILLISECONDS.toNanos(sleepMillis * numConnections));\n+    }\n+\n+    // running inside an event loop ensures requests are queued before initial connect completes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjU1Ng==", "bodyText": "Could extract into a constant?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836556", "createdAt": "2020-02-15T15:06:32Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -62,6 +69,8 @@ protected void configure(ServerBuilder sb) throws Exception {\n                 return HttpResponse.from(f);\n             });\n             sb.http2MaxStreamsPerConnection(MAX_CONCURRENT_STREAMS);\n+            sb.maxNumConnections(6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjYwMg==", "bodyText": "Could be deduplicated as well?", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836602", "createdAt": "2020-02-15T15:07:14Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c"}, "originalPosition": 206}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "151d8e80f882661dff019a2fdc79d0de6d0481b9", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/151d8e80f882661dff019a2fdc79d0de6d0481b9", "committedDate": "2020-02-15T16:16:59Z", "message": "dedup/improve tests, add test case for maxConcStreams 1"}, "afterCommit": {"oid": "0573d8d496f9d26a8604ba30aeb1bed6aad0224e", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/0573d8d496f9d26a8604ba30aeb1bed6aad0224e", "committedDate": "2020-02-15T16:41:48Z", "message": "dedup/improve tests, add test case for maxConcStreams 1"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0573d8d496f9d26a8604ba30aeb1bed6aad0224e", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/0573d8d496f9d26a8604ba30aeb1bed6aad0224e", "committedDate": "2020-02-15T16:41:48Z", "message": "dedup/improve tests, add test case for maxConcStreams 1"}, "afterCommit": {"oid": "9539c9d1301e40bb5a02e4369f5cfe960f5b9584", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/9539c9d1301e40bb5a02e4369f5cfe960f5b9584", "committedDate": "2020-02-15T16:44:36Z", "message": "dedup/improve tests, add test case for maxConcStreams 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd15431b6576e3eb3ec7b199b632f8551d623712", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/fd15431b6576e3eb3ec7b199b632f8551d623712", "committedDate": "2020-02-15T16:46:06Z", "message": "dedup/improve tests, add test case for maxConcStreams 1"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9539c9d1301e40bb5a02e4369f5cfe960f5b9584", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/9539c9d1301e40bb5a02e4369f5cfe960f5b9584", "committedDate": "2020-02-15T16:44:36Z", "message": "dedup/improve tests, add test case for maxConcStreams 1"}, "afterCommit": {"oid": "fd15431b6576e3eb3ec7b199b632f8551d623712", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/fd15431b6576e3eb3ec7b199b632f8551d623712", "committedDate": "2020-02-15T16:46:06Z", "message": "dedup/improve tests, add test case for maxConcStreams 1"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6054a9fffaacb88fd37ef91318c8102be2f3a99b", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/6054a9fffaacb88fd37ef91318c8102be2f3a99b", "committedDate": "2020-02-15T17:49:22Z", "message": "REVERT THIS -- assert test cause outside of lambda for easy debugging"}, "afterCommit": {"oid": "c3e59b45928ffa5190ad94b0ada7531e879dc348", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/c3e59b45928ffa5190ad94b0ada7531e879dc348", "committedDate": "2020-02-15T18:06:28Z", "message": "assert test cause outside of lambda\n\nin case of flaky tests, we can have a better stacktrace"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3e59b45928ffa5190ad94b0ada7531e879dc348", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/c3e59b45928ffa5190ad94b0ada7531e879dc348", "committedDate": "2020-02-15T18:06:28Z", "message": "assert test cause outside of lambda\n\nin case of flaky tests, we can have a better stacktrace"}, "afterCommit": {"oid": "198c60a860ffcdf3e6ff3729c617fbdd12925659", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/198c60a860ffcdf3e6ff3729c617fbdd12925659", "committedDate": "2020-02-15T18:21:55Z", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "198c60a860ffcdf3e6ff3729c617fbdd12925659", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/198c60a860ffcdf3e6ff3729c617fbdd12925659", "committedDate": "2020-02-15T18:21:55Z", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace"}, "afterCommit": {"oid": "71f18f0ed308828ae758d5a4cb8c187cd918450b", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/71f18f0ed308828ae758d5a4cb8c187cd918450b", "committedDate": "2020-02-15T18:38:17Z", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b", "committedDate": "2020-02-16T00:15:55Z", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71f18f0ed308828ae758d5a4cb8c187cd918450b", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/71f18f0ed308828ae758d5a4cb8c187cd918450b", "committedDate": "2020-02-15T18:38:17Z", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace"}, "afterCommit": {"oid": "c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b", "committedDate": "2020-02-16T00:15:55Z", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzczMzQz", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359373343", "createdAt": "2020-02-16T00:29:33Z", "commit": {"oid": "c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwMDoyOTozNFrOFqRKUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwMDoyOTozNFrOFqRKUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2NTY4Mg==", "bodyText": "flaky test stacktrace\nHttpClientMaxConcurrentStreamTest > exceededMaxStreamsPropagatesFailureCorrectly() FAILED\n    java.lang.IllegalStateException: java.util.concurrent.CompletionException: com.linecorp.armeria.client.UnprocessedRequestException: io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n        at com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.lambda$exceededMaxStreamsPropagatesFailureCorrectly$18(HttpClientMaxConcurrentStreamTest.java:305)\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n        at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\n        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)\n        at com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.exceededMaxStreamsPropagatesFailureCorrectly(HttpClientMaxConcurrentStreamTest.java:300)\n        Caused by:\n        java.util.concurrent.CompletionException: com.linecorp.armeria.client.UnprocessedRequestException: io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n            at java.util.concurrent.CompletableFuture.reportJoin(CompletableFuture.java:375)\n            at java.util.concurrent.CompletableFuture.join(CompletableFuture.java:1947)\n            at com.linecorp.armeria.common.util.EventLoopCheckingFuture.join(EventLoopCheckingFuture.java:70)\n            at org.assertj.core.api.ThrowableAssert.catchThrowable(ThrowableAssert.java:62)\n            at org.assertj.core.api.AssertionsForClassTypes.catchThrowable(AssertionsForClassTypes.java:750)\n            at org.assertj.core.api.Assertions.catchThrowable(Assertions.java:1179)\n            at com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.lambda$exceededMaxStreamsPropagatesFailureCorrectly$18(HttpClientMaxConcurrentStreamTest.java:301)\n            ... 10 more\n            Caused by:\n            com.linecorp.armeria.client.UnprocessedRequestException: io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n                at com.linecorp.armeria.client.HttpChannelPool.notifyConnect(HttpChannelPool.java:481)\n                at com.linecorp.armeria.client.HttpChannelPool.lambda$connect$5(HttpChannelPool.java:354)\n                at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\n                at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\n                at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\n                at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\n                at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\n                at io.netty.util.concurrent.DefaultPromise.setFailure(DefaultPromise.java:109)\n                at com.linecorp.armeria.client.HttpChannelPool.lambda$connect$6(HttpChannelPool.java:376)\n                at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\n                at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)\n                at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)\n                at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\n                at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\n                at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\n                at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.fulfillConnectPromise(AbstractEpollChannel.java:636)\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.finishConnect(AbstractEpollChannel.java:655)\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.epollOutReady(AbstractEpollChannel.java:529)\n                at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:465)\n                at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)\n                at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n                at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n                at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n                at java.lang.Thread.run(Thread.java:748)\n                Caused by:\n                io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n                    Caused by:\n                    java.net.ConnectException: finishConnect(..) failed: Connection reset by peer\n                        at io.netty.channel.unix.Errors.throwConnectException(Errors.java:124)\n                        at io.netty.channel.unix.Socket.finishConnect(Socket.java:243)\n                        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.doFinishConnect(AbstractEpollChannel.java:672)\n                        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.finishConnect(AbstractEpollChannel.java:649)\n                        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.epollOutReady(AbstractEpollChannel.java:529)\n                        at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:465)\n                        at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)\n                        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n                        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n                        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n                        at java.lang.Thread.run(Thread.java:748)", "url": "https://github.com/line/armeria/pull/2374#discussion_r379865682", "createdAt": "2020-02-16T00:29:34Z", "author": {"login": "jrhee17"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +217,184 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             if (!(throwable.getCause().getCause() instanceof ClosedSessionException)) {\n+                                 throw new IllegalStateException(throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b"}, "originalPosition": 262}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "251e1325a9795e6c274356862186caab552f8577", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/251e1325a9795e6c274356862186caab552f8577", "committedDate": "2020-02-16T06:22:57Z", "message": "handle test flakiness due to connection reset"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92f9aabc05656544b97fafcc65ed9012d0d9673c", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/92f9aabc05656544b97fafcc65ed9012d0d9673c", "committedDate": "2020-02-16T06:03:18Z", "message": "handle test flakiness due to connection reset"}, "afterCommit": {"oid": "251e1325a9795e6c274356862186caab552f8577", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/251e1325a9795e6c274356862186caab552f8577", "committedDate": "2020-02-16T06:22:57Z", "message": "handle test flakiness due to connection reset"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e11ee18d52c59a58239a1192051172771149df9", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/8e11ee18d52c59a58239a1192051172771149df9", "committedDate": "2020-02-16T06:32:18Z", "message": "POC for checking maxConcurrentStreams 0 case -- revert immediately"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/085c83b554c2fc197fc316b6baa7ddb5b2b1643d", "committedDate": "2020-02-16T06:32:37Z", "message": "Revert \"POC for checking maxConcurrentStreams 0 case -- revert immediately\"\n\nThis reverts commit 8e11ee18d52c59a58239a1192051172771149df9."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NTM2OTY4", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359536968", "createdAt": "2020-02-17T07:46:57Z", "commit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo0Njo1N1rOFqa1Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo0Njo1N1rOFqa1Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNDA3OA==", "bodyText": "MAX_NUM_CONNECTIONS", "url": "https://github.com/line/armeria/pull/2374#discussion_r380024078", "createdAt": "2020-02-17T07:46:57Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +218,185 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses\n+                .stream().filter(CompletableFuture::isCompletedExceptionally)\n+                .forEach(responseFuture -> {\n+                    final Throwable throwable = catchThrowable(responseFuture::join);\n+                    assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                         .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                    assertThat(throwable.getCause().getCause()).satisfiesAnyOf(\n+                            e -> assertThat(e).isInstanceOf(ClosedSessionException.class),\n+                            e -> assertThat(e).isInstanceOf(ConnectException.class)\n+                                                .hasMessageContaining(\"reset by peer\"));\n+                });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 6;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 283}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NTM3NTE3", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359537517", "createdAt": "2020-02-17T07:48:17Z", "commit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo0ODoxN1rOFqa2uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo0ODoxN1rOFqa2uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNDUwNw==", "bodyText": "Could you move these three methods to the bottom for readability?", "url": "https://github.com/line/armeria/pull/2374#discussion_r380024507", "createdAt": "2020-02-17T07:48:17Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -62,9 +71,59 @@ protected void configure(ServerBuilder sb) throws Exception {\n                 return HttpResponse.from(f);\n             });\n             sb.http2MaxStreamsPerConnection(MAX_CONCURRENT_STREAMS);\n+            sb.maxNumConnections(MAX_NUM_CONNECTIONS);\n+            sb.idleTimeoutMillis(3000);\n         }\n     };\n \n+    @RegisterExtension\n+    static final ServerExtension serverWithMaxConcurrentStreams_1 = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(PATH, (ctx, req) -> {\n+                final CompletableFuture<HttpResponse> f = new CompletableFuture<>();\n+                responses.add(f);\n+                return HttpResponse.from(f);\n+            });\n+            sb.http2MaxStreamsPerConnection(1);\n+            sb.maxNumConnections(MAX_NUM_CONNECTIONS);\n+            sb.idleTimeoutMillis(3000);\n+        }\n+    };\n+\n+    // running inside an event loop ensures requests are queued before an initial connect attempt completes.\n+    private static void runInsideEventLoop(EventLoopGroup eventLoopGroup, Runnable runnable) {\n+        eventLoopGroup.execute(runnable);\n+    }\n+\n+    private static DecoratingHttpClientFunction connectionTimingsAccumulatingDecorator(\n+            Queue<ClientConnectionTimings> connectionTimings) {\n+        return (delegate, ctx, req) -> {\n+            ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+               .thenAccept(requestLog -> {\n+                   connectionTimings.add(requestLog.connectionTimings());\n+               });\n+            return delegate.execute(ctx, req);\n+        };\n+    }\n+\n+    private static ConnectionPoolListener newConnectionPoolListener(\n+            Runnable openRunnable, Runnable closeRunnable) {\n+        return new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                openRunnable.run();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closeRunnable.run();\n+            }\n+        };\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 115}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d6ade4be729a73e5c41fb35b1e1a315b559442d", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/6d6ade4be729a73e5c41fb35b1e1a315b559442d", "committedDate": "2020-02-17T07:55:23Z", "message": "oops -- delete random file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/22db592195fb4407f7d70e25f8cd9a756dfb063d", "committedDate": "2020-02-17T07:56:59Z", "message": "reuse static variable, move static methods to bottom for readability"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NTM5NDQ5", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359539449", "createdAt": "2020-02-17T07:52:57Z", "commit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo1Mjo1N1rOFqa8rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNzo1NTo0NFrOFqbAXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ==", "bodyText": "Don't we need to limit pending acquisition time? I think we have no chance to trigger timeout for long waiting requests. \ud83e\uddd0 Any thoughts? /cc @trustin", "url": "https://github.com/line/armeria/pull/2374#discussion_r380026029", "createdAt": "2020-02-17T07:52:57Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjk3NA==", "bodyText": "nit: serverWithMaxConcurrentStreams1? Prefer camel case for variables. \ud83d\ude00", "url": "https://github.com/line/armeria/pull/2374#discussion_r380026974", "createdAt": "2020-02-17T07:55:44Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -62,9 +71,59 @@ protected void configure(ServerBuilder sb) throws Exception {\n                 return HttpResponse.from(f);\n             });\n             sb.http2MaxStreamsPerConnection(MAX_CONCURRENT_STREAMS);\n+            sb.maxNumConnections(MAX_NUM_CONNECTIONS);\n+            sb.idleTimeoutMillis(3000);\n         }\n     };\n \n+    @RegisterExtension\n+    static final ServerExtension serverWithMaxConcurrentStreams_1 = new ServerExtension() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NTQ1NjEy", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359545612", "createdAt": "2020-02-17T08:07:20Z", "commit": {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a2f6c8c630c8562ddabd818695894949f83ab8b", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/9a2f6c8c630c8562ddabd818695894949f83ab8b", "committedDate": "2020-02-17T08:07:27Z", "message": "prefer MAX_NUM_CONNECTIONS over primitive value"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NTQzODg4", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359543888", "createdAt": "2020-02-17T08:03:25Z", "commit": {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwODowMzoyNlrOFqbKtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwODowODoyMlrOFqbROw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyOTYyMw==", "bodyText": "Could remove !pendingAcquisitionEndSet?", "url": "https://github.com/line/armeria/pull/2374#discussion_r380029623", "createdAt": "2020-02-17T08:03:26Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -95,8 +95,10 @@ public ClientConnectionTimingsBuilder socketConnectEnd() {\n      * in order to use one connection for HTTP/2.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n-        pendingAcquisitionStartTimeMicros = SystemInfo.currentTimeMicros();\n-        pendingAcquisitionStartNanos = System.nanoTime();\n+        if (pendingAcquisitionStartTimeMicros == 0 && !pendingAcquisitionEndSet) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMDY1MQ==", "bodyText": "Remove public for methods and class?", "url": "https://github.com/line/armeria/pull/2374#discussion_r380030651", "createdAt": "2020-02-17T08:06:27Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -92,16 +118,16 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n     @Nullable\n     private volatile ConnectionPoolListener connectionPoolListener;\n \n-    @Before\n+    @BeforeEach\n     public void setUp() {\n         clientFactory = ClientFactory.builder()\n                                      .workerGroup(EventLoopGroups.newEventLoopGroup(1), true)\n                                      .connectionPoolListener(connectionPoolListenerWrapper)\n                                      .build();\n     }\n \n-    @After\n-    public void tearDown() {\n+    @AfterEach\n+    public void tearDown() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMTI5MQ==", "bodyText": "Oh, that is better. \ud83d\udc4d", "url": "https://github.com/line/armeria/pull/2374#discussion_r380031291", "createdAt": "2020-02-17T08:08:22Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, "originalCommit": {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80122206665ec6c5ea82e25151e8de991df52088", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/80122206665ec6c5ea82e25151e8de991df52088", "committedDate": "2020-02-17T08:18:09Z", "message": "remove before/after each public modifiers from test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NTUxNDAy", "url": "https://github.com/line/armeria/pull/2374#pullrequestreview-359551402", "createdAt": "2020-02-17T08:19:54Z", "commit": {"oid": "80122206665ec6c5ea82e25151e8de991df52088"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 816, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}