{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMDg1NDIw", "number": 3005, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzoyMzo1OFrOEZ-eUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMjoxMTo0OFrOEaRbyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NjczNDI0OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/reactor/src/main/java/example/armeria/contextpropagation/reactor/MainService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzoyMzo1OFrOHDHNFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMToxMjozNVrOHDkK4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAyNTgxMg==", "bodyText": "context executor -> context-aware event loop? (probably need to update other examples.)", "url": "https://github.com/line/armeria/pull/3005#discussion_r473025812", "createdAt": "2020-08-19T13:23:58Z", "author": {"login": "trustin"}, "path": "examples/context-propagation/reactor/src/main/java/example/armeria/contextpropagation/reactor/MainService.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package example.armeria.contextpropagation.reactor;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+public class MainService implements HttpService {\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Scheduler contextAwareScheduler = Schedulers.fromExecutor(ctx.eventLoop());\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final Flux<Long> fetchNumsFromFakeDb =\n+                Mono.fromCallable(\n+                        () -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all\n+                            // logic such as tracing.\n+                            assert ServiceRequestContext.current() == ctx;\n+                            assert !ctx.eventLoop().inEventLoop();\n+\n+                            try {\n+                                // Simulate a blocking API call.\n+                                Thread.sleep(50);\n+                            } catch (Exception ignored) {\n+                                // Do nothing.\n+                            }\n+                            return Arrays.asList(23L, -23L);\n+                        })\n+                    // Always run blocking logic on the blocking task executor. By using\n+                    // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted\n+                    // inside the logic (e.g., your DB call will be traced!).\n+                    .subscribeOn(Schedulers.fromExecutor(ctx.blockingTaskExecutor()))\n+                    .flatMapIterable(l -> l);\n+\n+        final Flux<Long> extractNumsFromRequest =\n+                Mono.fromCompletionStage(req.aggregate())\n+                    // Unless you know what you're doing, always use subscribeOn with the context\n+                    // executor to have the context mounted and stay on a single thread to reduce", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a15ba7e79b9bdcbb8f5667041cb7b05c0063f9"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwMDM4NA==", "bodyText": "Thanks! I used context-aware scheduler and executor depending on the types. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/3005#discussion_r473500384", "createdAt": "2020-08-20T01:12:35Z", "author": {"login": "minwoox"}, "path": "examples/context-propagation/reactor/src/main/java/example/armeria/contextpropagation/reactor/MainService.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package example.armeria.contextpropagation.reactor;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+public class MainService implements HttpService {\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Scheduler contextAwareScheduler = Schedulers.fromExecutor(ctx.eventLoop());\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final Flux<Long> fetchNumsFromFakeDb =\n+                Mono.fromCallable(\n+                        () -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all\n+                            // logic such as tracing.\n+                            assert ServiceRequestContext.current() == ctx;\n+                            assert !ctx.eventLoop().inEventLoop();\n+\n+                            try {\n+                                // Simulate a blocking API call.\n+                                Thread.sleep(50);\n+                            } catch (Exception ignored) {\n+                                // Do nothing.\n+                            }\n+                            return Arrays.asList(23L, -23L);\n+                        })\n+                    // Always run blocking logic on the blocking task executor. By using\n+                    // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted\n+                    // inside the logic (e.g., your DB call will be traced!).\n+                    .subscribeOn(Schedulers.fromExecutor(ctx.blockingTaskExecutor()))\n+                    .flatMapIterable(l -> l);\n+\n+        final Flux<Long> extractNumsFromRequest =\n+                Mono.fromCompletionStage(req.aggregate())\n+                    // Unless you know what you're doing, always use subscribeOn with the context\n+                    // executor to have the context mounted and stay on a single thread to reduce", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAyNTgxMg=="}, "originalCommit": {"oid": "e2a15ba7e79b9bdcbb8f5667041cb7b05c0063f9"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTg0MDcyOnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/reactor/src/main/java/example/armeria/contextpropagation/reactor/MainService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMjoxMTo0OFrOHDmgNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMzowMToxNlrOHDnw5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUzODYxMg==", "bodyText": "nit: Could be ignored :-)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .flatMapIterable(l -> l);\n          \n          \n            \n                                .flatMapIterable(Function.identity());", "url": "https://github.com/line/armeria/pull/3005#discussion_r473538612", "createdAt": "2020-08-20T02:11:48Z", "author": {"login": "ikhoon"}, "path": "examples/context-propagation/reactor/src/main/java/example/armeria/contextpropagation/reactor/MainService.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package example.armeria.contextpropagation.reactor;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+public class MainService implements HttpService {\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Scheduler contextAwareScheduler = Schedulers.fromExecutor(ctx.eventLoop());\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final Flux<Long> fetchNumsFromFakeDb =\n+                Mono.fromCallable(\n+                        () -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all\n+                            // logic such as tracing.\n+                            assert ServiceRequestContext.current() == ctx;\n+                            assert !ctx.eventLoop().inEventLoop();\n+\n+                            try {\n+                                // Simulate a blocking API call.\n+                                Thread.sleep(50);\n+                            } catch (Exception ignored) {\n+                                // Do nothing.\n+                            }\n+                            return Arrays.asList(23L, -23L);\n+                        })\n+                    // Always run blocking logic on the blocking task executor. By using\n+                    // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted\n+                    // inside the logic (e.g., your DB call will be traced!).\n+                    .subscribeOn(Schedulers.fromExecutor(ctx.blockingTaskExecutor()))\n+                    .flatMapIterable(l -> l);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aee3dfa2807d14468f87dc490d1237285d45f6d7"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU1OTI2OA==", "bodyText": "Thanks fixed. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/3005#discussion_r473559268", "createdAt": "2020-08-20T03:01:16Z", "author": {"login": "minwoox"}, "path": "examples/context-propagation/reactor/src/main/java/example/armeria/contextpropagation/reactor/MainService.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package example.armeria.contextpropagation.reactor;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+public class MainService implements HttpService {\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Scheduler contextAwareScheduler = Schedulers.fromExecutor(ctx.eventLoop());\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final Flux<Long> fetchNumsFromFakeDb =\n+                Mono.fromCallable(\n+                        () -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all\n+                            // logic such as tracing.\n+                            assert ServiceRequestContext.current() == ctx;\n+                            assert !ctx.eventLoop().inEventLoop();\n+\n+                            try {\n+                                // Simulate a blocking API call.\n+                                Thread.sleep(50);\n+                            } catch (Exception ignored) {\n+                                // Do nothing.\n+                            }\n+                            return Arrays.asList(23L, -23L);\n+                        })\n+                    // Always run blocking logic on the blocking task executor. By using\n+                    // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted\n+                    // inside the logic (e.g., your DB call will be traced!).\n+                    .subscribeOn(Schedulers.fromExecutor(ctx.blockingTaskExecutor()))\n+                    .flatMapIterable(l -> l);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUzODYxMg=="}, "originalCommit": {"oid": "aee3dfa2807d14468f87dc490d1237285d45f6d7"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2258, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}