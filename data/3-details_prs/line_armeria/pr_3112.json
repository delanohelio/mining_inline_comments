{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNzcyNjY0", "number": 3112, "title": "Support prefix option for Logback integration", "bodyText": "Motivations:\n#3086\nCurrently, to add a prefix, users have to write many and redundant key patterns like this.\n<exports>\n  armeria.remote.host=remote.host,\n  armeria.remote.ip=remote.ip,\n  armeria.remote.port=remote.port,\n  armeria.req.content_length=req.content_length,\n  armeria.req.direction=req.direction,\n  armeria.req.service_name=req.service_name,\n  armeria.req.name=req.name,\n  armeria.req.path=req.path,\n  ...\n</exports>\nModifications:\n\nAdd ExportGroup and ExportGroupBuilder\n\nLogback configuration can be seen as a set of ExportGroup\n\n\nMove the logic for setExport(s) to ExportGroupBuilder\n\nResults:\nYou can specify a prefix for MDC keys using the <prefix> element.\n<!-- If not wrapped with exportGroup, all directives go to the 'default export group'. -->\n<prefix>...</prefix> <!-- This sets the prefix for all exports in the default export group. -->\n<export>...</export>\n<exports>...</exports>\n\n<!-- exportGroup creates a new export group. -->\n<exportGroup>\n  <prefix>...</prefix> <!-- This sets the prefix for the exports in its group only. -->\n  <export>...</export>\n  <exports>...</exports>\n</exportGroup>", "createdAt": "2020-10-15T03:16:51Z", "url": "https://github.com/line/armeria/pull/3112", "merged": true, "mergeCommit": {"oid": "2de52fef73e9755d347887bbabea0c04fddf4408"}, "closed": true, "closedAt": "2020-11-01T06:30:26Z", "author": {"login": "okue"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTBbT-AFqTUxMDIyMjEwMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdX0F8dgH2gAyNTAzNzcyNjY0OmY3NGFlMTUyNWY4ZTA1OTFlMThmYzg5YjYwZDhkNGI5YjNkYTdlNjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMjIyMTAw", "url": "https://github.com/line/armeria/pull/3112#pullrequestreview-510222100", "createdAt": "2020-10-16T07:36:01Z", "commit": {"oid": "33afe47fa7486ce6bd683a24861655b81935f4a0"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzozNjowMVrOHirkGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzo0MDo1M1rOHirvEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyNzM4Ng==", "bodyText": "How about just prefix? IIUC, the following example:\n              RequestContextExporter\n                      .builder()\n                      .setDefaultExportPrefix(\"foo\")\n                      .addExportGroup(\n                              ExportGroup\n                                      .builder()\n                                      .keyPattern(\"client.*\")\n                                      .build()\n                      )\n.. does not make client.* have foo prefix, so it'll be confusing to say foo is the default prefix.\nset could be omitted.", "url": "https://github.com/line/armeria/pull/3112#discussion_r506127386", "createdAt": "2020-10-16T07:36:01Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -134,16 +122,17 @@ public RequestContextExporterBuilder responseHeader(CharSequence headerName) {\n     public RequestContextExporterBuilder responseHeader(CharSequence headerName, String alias) {\n         requireNonNull(headerName, \"headerName\");\n         requireNonNull(alias, \"alias\");\n-        return addResponseHeader(toHeaderName(headerName), alias);\n-    }\n-\n-    private RequestContextExporterBuilder addResponseHeader(AsciiString headerKey, String alias) {\n-        resHeaders.add(new ExportEntry<>(headerKey, alias));\n+        defaultExportGroupBuilder.responseHeader(headerName, alias);\n         return this;\n     }\n \n-    private static AsciiString toHeaderName(CharSequence name) {\n-        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public void setDefaultExportPrefix(String defaultExportPrefix) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33afe47fa7486ce6bd683a24861655b81935f4a0"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEzMDE5NQ==", "bodyText": "I think we need to separate the core API from Logback integration. Could we ensure this builder API doesn't expose the default constructor and doesn't have the set prefix? Instead, we could define some additional public class that provides a bridge between this class and Logback configuration, e.g.\nprivate ExportGroupBuilder builder = ExportGroup.builder();\npublic void setPrefix(String prefix) {\n  builder.prefix(prefix);\n}", "url": "https://github.com/line/armeria/pull/3112#discussion_r506130195", "createdAt": "2020-10-16T07:40:53Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    /**\n+     * Returns a new {@link ExportGroupBuilder}.\n+     */\n+    public ExportGroupBuilder() {\n+        builtIns = new HashSet<>();\n+        attrs = new HashSet<>();\n+        reqHeaders = new HashSet<>();\n+        resHeaders = new HashSet<>();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33afe47fa7486ce6bd683a24861655b81935f4a0"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMzc4MTky", "url": "https://github.com/line/armeria/pull/3112#pullrequestreview-511378192", "createdAt": "2020-10-19T02:41:02Z", "commit": {"oid": "aabb9c9b39aedc13eb5cd0110d08919e095a1941"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwMjo0MTowMlrOHj3_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwMzowMjoxN1rOHj4s5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM3OTY0Mw==", "bodyText": "We can make those collections immutable.\nFor example:\nbuiltIns = ImmutableSet.builder();\nbuiltIns.add(...)\nnew ExportGroup(builtIns.build(), ...)", "url": "https://github.com/line/armeria/pull/3112#discussion_r507379643", "createdAt": "2020-10-19T02:41:02Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = new HashSet<>();\n+        attrs = new HashSet<>();\n+        reqHeaders = new HashSet<>();\n+        resHeaders = new HashSet<>();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns, attrs, reqHeaders, resHeaders);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aabb9c9b39aedc13eb5cd0110d08919e095a1941"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM4MTEyNg==", "bodyText": "We can optimize this a bit by initializing this lazily. I think some features are not used when a user does not customize heavily. In that case, we can use ImmutableSet.of().", "url": "https://github.com/line/armeria/pull/3112#discussion_r507381126", "createdAt": "2020-10-19T02:43:37Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = new HashSet<>();\n+        attrs = new HashSet<>();\n+        reqHeaders = new HashSet<>();\n+        resHeaders = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aabb9c9b39aedc13eb5cd0110d08919e095a1941"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM4NzA4NQ==", "bodyText": "Use ImmutableSet.toImmutableSet()?", "url": "https://github.com/line/armeria/pull/3112#discussion_r507387085", "createdAt": "2020-10-19T02:55:15Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = new HashSet<>();\n+        attrs = new HashSet<>();\n+        reqHeaders = new HashSet<>();\n+        resHeaders = new HashSet<>();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns, attrs, reqHeaders, resHeaders);\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns, prefix),\n+                    ExportEntry.withPrefix(attrs, prefix),\n+                    ExportEntry.withPrefix(reqHeaders, prefix),\n+                    ExportEntry.withPrefix(resHeaders, prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {\n+        requireNonNull(property, \"BuiltInProperty\");\n+        requireNonNull(alias, \"alias\");\n+        builtIns.add(new ExportEntry<>(property, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        attrs.add(new ExportEntry<>(attrKey, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     * @param stringifier the {@link Function} that converts the attribute value into a {@link String}\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey, Function<?, String> stringifier) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        requireNonNull(stringifier, \"stringifier\");\n+        attrs.add(new ExportEntry<>(attrKey, alias, stringifier));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        reqHeaders.add(new ExportEntry<>(key, PREFIX_REQ_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        reqHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        resHeaders.add(new ExportEntry<>(key, PREFIX_RES_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        resHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    private static AsciiString toHeaderName(CharSequence name) {\n+        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list. Please refer to the\n+     * <a href=\"https://armeria.dev/docs/advanced-logging\">Logging contextual information</a>\n+     * in order to learn how to specify a key pattern.\n+     */\n+    public ExportGroupBuilder keyPattern(String keyPattern) {\n+        requireNonNull(keyPattern, \"keyPattern\");\n+\n+        final int exportKeyPos = keyPattern.indexOf('=');\n+\n+        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n+            if (exportKeyPos > 0) {\n+                throw new IllegalArgumentException(\n+                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n+            }\n+            BuiltInProperty.findByKeyPattern(keyPattern)\n+                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n+                           .forEach(builtIns::add);\n+            return this;\n+        }\n+\n+        String exportKey = null;\n+        if (exportKeyPos > 0) {\n+            exportKey = keyPattern.substring(0, exportKeyPos);\n+            keyPattern = keyPattern.substring(exportKeyPos + 1);\n+        }\n+\n+        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n+        if (property != null) {\n+            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n+            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n+            attrs.add(attrExportEntry);\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        KEY_SPLITTER.split(keyPatterns)\n+                    .forEach(keyPattern -> {\n+                        checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n+                        keyPattern(keyPattern);\n+                    });\n+        return this;\n+    }\n+\n+    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n+        final String[] components = keyPattern.split(\":\");\n+        if (components.length < 2 || components.length > 3) {\n+            if (exportKey == null) {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            }\n+        }\n+\n+        if (exportKey == null) {\n+            exportKey = components[0];\n+        }\n+        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n+        if (components.length == 3) {\n+            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n+        } else {\n+            return new ExportEntry<>(attributeKey, exportKey);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Function<?, String> newStringifier(String keyPattern, String className) {\n+        final Function<?, String> stringifier;\n+        try {\n+            stringifier = (Function<?, String>)\n+                    Class.forName(className, true, getClass().getClassLoader())\n+                         .getDeclaredConstructor()\n+                         .newInstance();\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n+                                               keyPattern, e);\n+        }\n+        return stringifier;\n+    }\n+\n+    static final class ExportEntry<T> {\n+        final T key;\n+        final String exportKey;\n+        @Nullable\n+        final Function<Object, String> stringifier;\n+\n+        ExportEntry(T key, String exportKey) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            stringifier = null;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ExportEntry(T key, String exportKey, Function<?, ?> stringifier) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            requireNonNull(stringifier);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            this.stringifier = (Function<Object, String>) stringifier;\n+        }\n+\n+        @Nullable\n+        String stringify(@Nullable Object value) {\n+            if (stringifier == null) {\n+                return value != null ? value.toString() : null;\n+            } else {\n+                return stringifier.apply(value);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return key.hashCode() * 31 + exportKey.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(@Nullable Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+\n+            if (!(o instanceof ExportEntry)) {\n+                return false;\n+            }\n+\n+            return key.equals(((ExportEntry<?>) o).key) &&\n+                   exportKey.equals(((ExportEntry<?>) o).exportKey);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return exportKey + ':' + key;\n+        }\n+\n+        public ExportEntry<T> withPrefix(String exportPrefix) {\n+            checkArgument(!exportPrefix.isEmpty(), \"exportPrefix must not be empty\");\n+\n+            if (stringifier == null) {\n+                return new ExportEntry<>(key, exportPrefix + exportKey);\n+            } else {\n+                return new ExportEntry<>(key, exportPrefix + exportKey, stringifier);\n+            }\n+        }\n+\n+        public static <T> Set<ExportEntry<T>> withPrefix(Set<ExportEntry<T>> entries, String exportPrefix) {\n+            checkArgument(!exportPrefix.isEmpty(), \"exportPrefix must not be empty\");\n+\n+            return entries.stream().map(entry -> entry.withPrefix(exportPrefix)).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aabb9c9b39aedc13eb5cd0110d08919e095a1941"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM5MDY4Mw==", "bodyText": "I think <exportGroup> is an optional feature. Don't we need to initialize this by default.\nHow about make it @Nullable and initailzed it when it is actually used.", "url": "https://github.com/line/armeria/pull/3112#discussion_r507390683", "createdAt": "2020-10-19T03:01:28Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -15,34 +15,23 @@\n  */\n package com.linecorp.armeria.common.logging;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.logging.RequestContextExporter.ExportEntry;\n-\n-import io.netty.util.AsciiString;\n import io.netty.util.AttributeKey;\n \n /**\n  * Builds a new {@link RequestContextExporter}.\n  */\n public final class RequestContextExporterBuilder {\n \n-    static final String PREFIX_ATTRS = \"attrs.\";\n-    private static final String ATTR_NAMESPACE = \"attr:\";\n-    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n-    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n-\n-    private final Set<ExportEntry<BuiltInProperty>> builtIns = new HashSet<>();\n-    private final Set<ExportEntry<AttributeKey<?>>> attrs = new HashSet<>();\n-    private final Set<ExportEntry<AsciiString>> reqHeaders = new HashSet<>();\n-    private final Set<ExportEntry<AsciiString>> resHeaders = new HashSet<>();\n+    private final ExportGroupBuilder defaultExportGroupBuilder = ExportGroup.builder();\n+    private final List<ExportGroup> exportGroups = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aabb9c9b39aedc13eb5cd0110d08919e095a1941"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM5MTAwOA==", "bodyText": "Ditto. Use toImmutableSet()?", "url": "https://github.com/line/armeria/pull/3112#discussion_r507391008", "createdAt": "2020-10-19T03:01:55Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -153,103 +142,39 @@ private static AsciiString toHeaderName(CharSequence name) {\n      */\n     public RequestContextExporterBuilder keyPattern(String keyPattern) {\n         requireNonNull(keyPattern, \"keyPattern\");\n-\n-        final int exportKeyPos = keyPattern.indexOf('=');\n-\n-        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n-            if (exportKeyPos > 0) {\n-                throw new IllegalArgumentException(\n-                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n-            }\n-            BuiltInProperty.findByKeyPattern(keyPattern)\n-                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n-                           .forEach(builtIns::add);\n-            return this;\n-        }\n-\n-        String exportKey = null;\n-        if (exportKeyPos > 0) {\n-            exportKey = keyPattern.substring(0, exportKeyPos);\n-            keyPattern = keyPattern.substring(exportKeyPos + 1);\n-        }\n-\n-        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n-        if (property != null) {\n-            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n-            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n-            attrs.add(attrExportEntry);\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n-            if (exportKey == null) {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n-            } else {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n-            if (exportKey == null) {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n-            } else {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+        checkArgument(!keyPattern.isEmpty(), \"keyPattern must not be empty\");\n+        defaultExportGroupBuilder.keyPattern(keyPattern);\n+        return this;\n     }\n \n-    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n-        final String[] components = keyPattern.split(\":\");\n-        if (components.length < 2 || components.length > 3) {\n-            if (exportKey == null) {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            } else {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            }\n-        }\n-\n-        if (exportKey == null) {\n-            exportKey = components[0];\n-        }\n-        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n-        if (components.length == 3) {\n-            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n-        } else {\n-            return new ExportEntry<>(attributeKey, exportKey);\n-        }\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public RequestContextExporterBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n+        checkArgument(!keyPatterns.isEmpty(), \"keyPatterns must not be empty\");\n+        defaultExportGroupBuilder.keyPatterns(keyPatterns);\n+        return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private Function<?, String> newStringifier(String keyPattern, String className) {\n-        final Function<?, String> stringifier;\n-        try {\n-            stringifier = (Function<?, String>)\n-                    Class.forName(className, true, getClass().getClassLoader())\n-                         .getDeclaredConstructor()\n-                         .newInstance();\n-        } catch (Exception e) {\n-            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n-                                               keyPattern, e);\n-        }\n-        return stringifier;\n+    /**\n+     * Adds the export group.\n+     */\n+    public RequestContextExporterBuilder addExportGroup(ExportGroup exportGroup) {\n+        exportGroups.add(exportGroup);\n+        return this;\n     }\n \n     /**\n      * Returns a newly-created {@link RequestContextExporter} instance.\n      */\n     public RequestContextExporter build() {\n-        return new RequestContextExporter(builtIns, attrs, reqHeaders, resHeaders);\n+        exportGroups.add(defaultExportGroupBuilder.build());\n+        return new RequestContextExporter(\n+                exportGroups.stream().flatMap(it -> it.getBuiltIns().stream()).collect(Collectors.toSet()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aabb9c9b39aedc13eb5cd0110d08919e095a1941"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM5MTIwNg==", "bodyText": "Add final?", "url": "https://github.com/line/armeria/pull/3112#discussion_r507391206", "createdAt": "2020-10-19T03:02:17Z", "author": {"login": "ikhoon"}, "path": "logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logback;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.logging.ExportGroup;\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n+\n+/**\n+ * Bridge class for Logback configuration.\n+ *\n+ * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfiguration)\n+ */\n+public class ExportGroupConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aabb9c9b39aedc13eb5cd0110d08919e095a1941"}, "originalPosition": 29}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6977ee5745e748b3eca4d178ace005622b634526", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/6977ee5745e748b3eca4d178ace005622b634526", "committedDate": "2020-10-19T03:40:46Z", "message": "address comments by @ikhoon"}, "afterCommit": {"oid": "7b571b262014ce8093511b282b464b2ba3811922", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/7b571b262014ce8093511b282b464b2ba3811922", "committedDate": "2020-10-19T03:46:18Z", "message": "address comments by @ikhoon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMzU2MTk2", "url": "https://github.com/line/armeria/pull/3112#pullrequestreview-513356196", "createdAt": "2020-10-21T06:53:25Z", "commit": {"oid": "7b571b262014ce8093511b282b464b2ba3811922"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNjo1MzoyNVrOHlcv9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNjo1NToyNVrOHlcz0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzMDM5MA==", "bodyText": "Could we remove the get prefixes from the methods in this class for consistency?", "url": "https://github.com/line/armeria/pull/3112#discussion_r509030390", "createdAt": "2020-10-21T06:53:25Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder.ExportEntry;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Holds a set of {@link ExportEntry}s.\n+ *\n+ * @see RequestContextExporterBuilder\n+ */\n+public final class ExportGroup {\n+\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroup(Set<ExportEntry<BuiltInProperty>> builtIns,\n+                Set<ExportEntry<AttributeKey<?>>> attrs,\n+                Set<ExportEntry<AsciiString>> reqHeaders,\n+                Set<ExportEntry<AsciiString>> resHeaders) {\n+        requireNonNull(builtIns, \"builtIns\");\n+        requireNonNull(attrs, \"attrs\");\n+        requireNonNull(reqHeaders, \"reqHeaders\");\n+        requireNonNull(resHeaders, \"resHeaders\");\n+        this.builtIns = builtIns;\n+        this.attrs = attrs;\n+        this.reqHeaders = reqHeaders;\n+        this.resHeaders = resHeaders;\n+    }\n+\n+    /**\n+     * Returns a new {@link ExportGroupBuilder}.\n+     */\n+    public static ExportGroupBuilder builder() {\n+        return new ExportGroupBuilder();\n+    }\n+\n+    /**\n+     * Returns a set of {@link ExportEntry} of {@link BuiltInProperty}.\n+     */\n+    public Set<ExportEntry<BuiltInProperty>> getBuiltIns() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b571b262014ce8093511b282b464b2ba3811922"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzMTE5Ng==", "bodyText": "nit: how about just ExportGroupConfig?", "url": "https://github.com/line/armeria/pull/3112#discussion_r509031196", "createdAt": "2020-10-21T06:55:04Z", "author": {"login": "trustin"}, "path": "logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logback;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.logging.ExportGroup;\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n+\n+/**\n+ * Bridge class for Logback configuration.\n+ *\n+ * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfiguration)\n+ */\n+public final class ExportGroupConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b571b262014ce8093511b282b464b2ba3811922"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzMTM3Nw==", "bodyText": "How about just exportGroup()?", "url": "https://github.com/line/armeria/pull/3112#discussion_r509031377", "createdAt": "2020-10-21T06:55:25Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -153,103 +146,52 @@ private static AsciiString toHeaderName(CharSequence name) {\n      */\n     public RequestContextExporterBuilder keyPattern(String keyPattern) {\n         requireNonNull(keyPattern, \"keyPattern\");\n-\n-        final int exportKeyPos = keyPattern.indexOf('=');\n-\n-        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n-            if (exportKeyPos > 0) {\n-                throw new IllegalArgumentException(\n-                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n-            }\n-            BuiltInProperty.findByKeyPattern(keyPattern)\n-                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n-                           .forEach(builtIns::add);\n-            return this;\n-        }\n-\n-        String exportKey = null;\n-        if (exportKeyPos > 0) {\n-            exportKey = keyPattern.substring(0, exportKeyPos);\n-            keyPattern = keyPattern.substring(exportKeyPos + 1);\n-        }\n-\n-        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n-        if (property != null) {\n-            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n-            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n-            attrs.add(attrExportEntry);\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n-            if (exportKey == null) {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n-            } else {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n-            if (exportKey == null) {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n-            } else {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+        checkArgument(!keyPattern.isEmpty(), \"keyPattern must not be empty\");\n+        defaultExportGroupBuilder.keyPattern(keyPattern);\n+        return this;\n     }\n \n-    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n-        final String[] components = keyPattern.split(\":\");\n-        if (components.length < 2 || components.length > 3) {\n-            if (exportKey == null) {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            } else {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            }\n-        }\n-\n-        if (exportKey == null) {\n-            exportKey = components[0];\n-        }\n-        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n-        if (components.length == 3) {\n-            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n-        } else {\n-            return new ExportEntry<>(attributeKey, exportKey);\n-        }\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public RequestContextExporterBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n+        checkArgument(!keyPatterns.isEmpty(), \"keyPatterns must not be empty\");\n+        defaultExportGroupBuilder.keyPatterns(keyPatterns);\n+        return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private Function<?, String> newStringifier(String keyPattern, String className) {\n-        final Function<?, String> stringifier;\n-        try {\n-            stringifier = (Function<?, String>)\n-                    Class.forName(className, true, getClass().getClassLoader())\n-                         .getDeclaredConstructor()\n-                         .newInstance();\n-        } catch (Exception e) {\n-            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n-                                               keyPattern, e);\n+    /**\n+     * Adds the export group.\n+     */\n+    public RequestContextExporterBuilder addExportGroup(ExportGroup exportGroup) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b571b262014ce8093511b282b464b2ba3811922"}, "originalPosition": 246}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48231cd70b1f753096be26634a38cdf04dc24920", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/48231cd70b1f753096be26634a38cdf04dc24920", "committedDate": "2020-10-22T02:58:05Z", "message": "Support prefix option for Logback integration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a12535d3240e325f766ce69a04cfa4644e2c1277", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/a12535d3240e325f766ce69a04cfa4644e2c1277", "committedDate": "2020-10-22T02:58:06Z", "message": "address comments by @trustin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ead1671d483255493ed143002d767d98e10a20e", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/9ead1671d483255493ed143002d767d98e10a20e", "committedDate": "2020-10-22T02:58:06Z", "message": "address comments by @ikhoon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/2d74ad4385820fb0366ecc9e788b382c6856be9c", "committedDate": "2020-10-22T03:30:58Z", "message": "address comments by @trustin"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7b571b262014ce8093511b282b464b2ba3811922", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/7b571b262014ce8093511b282b464b2ba3811922", "committedDate": "2020-10-19T03:46:18Z", "message": "address comments by @ikhoon"}, "afterCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/2d74ad4385820fb0366ecc9e788b382c6856be9c", "committedDate": "2020-10-22T03:30:58Z", "message": "address comments by @trustin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NDQwMjEw", "url": "https://github.com/line/armeria/pull/3112#pullrequestreview-516440210", "createdAt": "2020-10-26T02:47:39Z", "commit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMjo0NzozOVrOHn_X4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMzo1OToyOFrOHoAN3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY5NDgxNg==", "bodyText": "nit: could remove public and could you move this up to right under the class definition as we usually to?", "url": "https://github.com/line/armeria/pull/3112#discussion_r511694816", "createdAt": "2020-10-26T02:47:39Z", "author": {"login": "minwoox"}, "path": "logback/src/test/java/com/linecorp/armeria/common/logback/CustomObject.java", "diffHunk": "@@ -33,4 +35,8 @@ public String toString() {\n                           .add(\"name\", name)\n                           .add(\"value\", value).toString();\n     }\n+\n+    public static final AttributeKey<CustomObject> ATTR = AttributeKey.valueOf(CustomObject.class, \"ATTR\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY5NTg3Mg==", "bodyText": "nit: requireNonNull?", "url": "https://github.com/line/armeria/pull/3112#discussion_r511695872", "createdAt": "2020-10-26T02:52:57Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {\n+        requireNonNull(property, \"BuiltInProperty\");\n+        requireNonNull(alias, \"alias\");\n+        builtIns.add(new ExportEntry<>(property, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        attrs.add(new ExportEntry<>(attrKey, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     * @param stringifier the {@link Function} that converts the attribute value into a {@link String}\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey, Function<?, String> stringifier) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        requireNonNull(stringifier, \"stringifier\");\n+        attrs.add(new ExportEntry<>(attrKey, alias, stringifier));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        reqHeaders.add(new ExportEntry<>(key, PREFIX_REQ_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        reqHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        resHeaders.add(new ExportEntry<>(key, PREFIX_RES_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        resHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    private static AsciiString toHeaderName(CharSequence name) {\n+        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list. Please refer to the\n+     * <a href=\"https://armeria.dev/docs/advanced-logging\">Logging contextual information</a>\n+     * in order to learn how to specify a key pattern.\n+     */\n+    public ExportGroupBuilder keyPattern(String keyPattern) {\n+        requireNonNull(keyPattern, \"keyPattern\");\n+\n+        final int exportKeyPos = keyPattern.indexOf('=');\n+\n+        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n+            if (exportKeyPos > 0) {\n+                throw new IllegalArgumentException(\n+                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n+            }\n+            BuiltInProperty.findByKeyPattern(keyPattern)\n+                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n+                           .forEach(builtIns::add);\n+            return this;\n+        }\n+\n+        String exportKey = null;\n+        if (exportKeyPos > 0) {\n+            exportKey = keyPattern.substring(0, exportKeyPos);\n+            keyPattern = keyPattern.substring(exportKeyPos + 1);\n+        }\n+\n+        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n+        if (property != null) {\n+            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n+            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n+            attrs.add(attrExportEntry);\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        KEY_SPLITTER.split(keyPatterns)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwMzAyMw==", "bodyText": "nit: we could just do this.builtIns = requireNonNull(builtIns, \"builtIns\"); if you want. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/3112#discussion_r511703023", "createdAt": "2020-10-26T03:28:54Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder.ExportEntry;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Holds a set of {@link ExportEntry}s.\n+ *\n+ * @see RequestContextExporterBuilder\n+ */\n+public final class ExportGroup {\n+\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroup(Set<ExportEntry<BuiltInProperty>> builtIns,\n+                Set<ExportEntry<AttributeKey<?>>> attrs,\n+                Set<ExportEntry<AsciiString>> reqHeaders,\n+                Set<ExportEntry<AsciiString>> resHeaders) {\n+        requireNonNull(builtIns, \"builtIns\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNTk1OA==", "bodyText": "Could just build()?", "url": "https://github.com/line/armeria/pull/3112#discussion_r511705958", "createdAt": "2020-10-26T03:44:42Z", "author": {"login": "minwoox"}, "path": "logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logback;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.logging.ExportGroup;\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n+\n+/**\n+ * Bridge class for Logback configuration.\n+ *\n+ * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfig)\n+ */\n+public final class ExportGroupConfig {\n+\n+    private final ExportGroupBuilder builder = ExportGroup.builder();\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     * Note: this method is meant to be used for XML configuration.\n+     */\n+    public void setPrefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        builder.prefix(prefix);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified MDC key to the export list.\n+     * Note: this method is meant to be used for XML configuration.\n+     */\n+    public void setExport(String mdcKey) {\n+        requireNonNull(mdcKey, \"mdcKey\");\n+        checkArgument(!mdcKey.isEmpty(), \"mdcKey must not be empty\");\n+        builder.keyPattern(mdcKey);\n+    }\n+\n+    /**\n+     * Adds the properties represented by the specified comma-separated MDC keys to the export list.\n+     * Note: this method is meant to be used for XML configuration.\n+     */\n+    public void setExports(String mdcKeys) {\n+        requireNonNull(mdcKeys, \"mdcKeys\");\n+        checkArgument(!mdcKeys.isEmpty(), \"mdcKeys must not be empty\");\n+        builder.keyPatterns(mdcKeys);\n+    }\n+\n+    /**\n+     * Returns {@link ExportGroup}.\n+     */\n+    ExportGroup exportGroup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzY2Mw==", "bodyText": "I think we can make some methods in this class as package-private. Could you check it, please?", "url": "https://github.com/line/armeria/pull/3112#discussion_r511707663", "createdAt": "2020-10-26T03:54:18Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzk5MA==", "bodyText": "Could be private?", "url": "https://github.com/line/armeria/pull/3112#discussion_r511707990", "createdAt": "2020-10-26T03:56:03Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {\n+        requireNonNull(property, \"BuiltInProperty\");\n+        requireNonNull(alias, \"alias\");\n+        builtIns.add(new ExportEntry<>(property, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        attrs.add(new ExportEntry<>(attrKey, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     * @param stringifier the {@link Function} that converts the attribute value into a {@link String}\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey, Function<?, String> stringifier) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        requireNonNull(stringifier, \"stringifier\");\n+        attrs.add(new ExportEntry<>(attrKey, alias, stringifier));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        reqHeaders.add(new ExportEntry<>(key, PREFIX_REQ_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        reqHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        resHeaders.add(new ExportEntry<>(key, PREFIX_RES_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        resHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    private static AsciiString toHeaderName(CharSequence name) {\n+        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list. Please refer to the\n+     * <a href=\"https://armeria.dev/docs/advanced-logging\">Logging contextual information</a>\n+     * in order to learn how to specify a key pattern.\n+     */\n+    public ExportGroupBuilder keyPattern(String keyPattern) {\n+        requireNonNull(keyPattern, \"keyPattern\");\n+\n+        final int exportKeyPos = keyPattern.indexOf('=');\n+\n+        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n+            if (exportKeyPos > 0) {\n+                throw new IllegalArgumentException(\n+                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n+            }\n+            BuiltInProperty.findByKeyPattern(keyPattern)\n+                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n+                           .forEach(builtIns::add);\n+            return this;\n+        }\n+\n+        String exportKey = null;\n+        if (exportKeyPos > 0) {\n+            exportKey = keyPattern.substring(0, exportKeyPos);\n+            keyPattern = keyPattern.substring(exportKeyPos + 1);\n+        }\n+\n+        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n+        if (property != null) {\n+            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n+            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n+            attrs.add(attrExportEntry);\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        KEY_SPLITTER.split(keyPatterns)\n+                    .forEach(keyPattern -> {\n+                        checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n+                        keyPattern(keyPattern);\n+                    });\n+        return this;\n+    }\n+\n+    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n+        final String[] components = keyPattern.split(\":\");\n+        if (components.length < 2 || components.length > 3) {\n+            if (exportKey == null) {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            }\n+        }\n+\n+        if (exportKey == null) {\n+            exportKey = components[0];\n+        }\n+        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n+        if (components.length == 3) {\n+            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n+        } else {\n+            return new ExportEntry<>(attributeKey, exportKey);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Function<?, String> newStringifier(String keyPattern, String className) {\n+        final Function<?, String> stringifier;\n+        try {\n+            stringifier = (Function<?, String>)\n+                    Class.forName(className, true, getClass().getClassLoader())\n+                         .getDeclaredConstructor()\n+                         .newInstance();\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n+                                               keyPattern, e);\n+        }\n+        return stringifier;\n+    }\n+\n+    static final class ExportEntry<T> {\n+        final T key;\n+        final String exportKey;\n+        @Nullable\n+        final Function<Object, String> stringifier;\n+\n+        ExportEntry(T key, String exportKey) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            stringifier = null;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ExportEntry(T key, String exportKey, Function<?, ?> stringifier) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            requireNonNull(stringifier);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            this.stringifier = (Function<Object, String>) stringifier;\n+        }\n+\n+        @Nullable\n+        String stringify(@Nullable Object value) {\n+            if (stringifier == null) {\n+                return value != null ? value.toString() : null;\n+            } else {\n+                return stringifier.apply(value);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return key.hashCode() * 31 + exportKey.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(@Nullable Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+\n+            if (!(o instanceof ExportEntry)) {\n+                return false;\n+            }\n+\n+            return key.equals(((ExportEntry<?>) o).key) &&\n+                   exportKey.equals(((ExportEntry<?>) o).exportKey);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return exportKey + ':' + key;\n+        }\n+\n+        public ExportEntry<T> withPrefix(String exportPrefix) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzk5OQ==", "bodyText": "Could be private?", "url": "https://github.com/line/armeria/pull/3112#discussion_r511707999", "createdAt": "2020-10-26T03:56:08Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {\n+        requireNonNull(property, \"BuiltInProperty\");\n+        requireNonNull(alias, \"alias\");\n+        builtIns.add(new ExportEntry<>(property, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        attrs.add(new ExportEntry<>(attrKey, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     * @param stringifier the {@link Function} that converts the attribute value into a {@link String}\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey, Function<?, String> stringifier) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        requireNonNull(stringifier, \"stringifier\");\n+        attrs.add(new ExportEntry<>(attrKey, alias, stringifier));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        reqHeaders.add(new ExportEntry<>(key, PREFIX_REQ_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        reqHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        resHeaders.add(new ExportEntry<>(key, PREFIX_RES_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        resHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    private static AsciiString toHeaderName(CharSequence name) {\n+        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list. Please refer to the\n+     * <a href=\"https://armeria.dev/docs/advanced-logging\">Logging contextual information</a>\n+     * in order to learn how to specify a key pattern.\n+     */\n+    public ExportGroupBuilder keyPattern(String keyPattern) {\n+        requireNonNull(keyPattern, \"keyPattern\");\n+\n+        final int exportKeyPos = keyPattern.indexOf('=');\n+\n+        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n+            if (exportKeyPos > 0) {\n+                throw new IllegalArgumentException(\n+                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n+            }\n+            BuiltInProperty.findByKeyPattern(keyPattern)\n+                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n+                           .forEach(builtIns::add);\n+            return this;\n+        }\n+\n+        String exportKey = null;\n+        if (exportKeyPos > 0) {\n+            exportKey = keyPattern.substring(0, exportKeyPos);\n+            keyPattern = keyPattern.substring(exportKeyPos + 1);\n+        }\n+\n+        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n+        if (property != null) {\n+            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n+            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n+            attrs.add(attrExportEntry);\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        KEY_SPLITTER.split(keyPatterns)\n+                    .forEach(keyPattern -> {\n+                        checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n+                        keyPattern(keyPattern);\n+                    });\n+        return this;\n+    }\n+\n+    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n+        final String[] components = keyPattern.split(\":\");\n+        if (components.length < 2 || components.length > 3) {\n+            if (exportKey == null) {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            }\n+        }\n+\n+        if (exportKey == null) {\n+            exportKey = components[0];\n+        }\n+        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n+        if (components.length == 3) {\n+            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n+        } else {\n+            return new ExportEntry<>(attributeKey, exportKey);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Function<?, String> newStringifier(String keyPattern, String className) {\n+        final Function<?, String> stringifier;\n+        try {\n+            stringifier = (Function<?, String>)\n+                    Class.forName(className, true, getClass().getClassLoader())\n+                         .getDeclaredConstructor()\n+                         .newInstance();\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n+                                               keyPattern, e);\n+        }\n+        return stringifier;\n+    }\n+\n+    static final class ExportEntry<T> {\n+        final T key;\n+        final String exportKey;\n+        @Nullable\n+        final Function<Object, String> stringifier;\n+\n+        ExportEntry(T key, String exportKey) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            stringifier = null;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ExportEntry(T key, String exportKey, Function<?, ?> stringifier) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            requireNonNull(stringifier);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            this.stringifier = (Function<Object, String>) stringifier;\n+        }\n+\n+        @Nullable\n+        String stringify(@Nullable Object value) {\n+            if (stringifier == null) {\n+                return value != null ? value.toString() : null;\n+            } else {\n+                return stringifier.apply(value);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return key.hashCode() * 31 + exportKey.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(@Nullable Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+\n+            if (!(o instanceof ExportEntry)) {\n+                return false;\n+            }\n+\n+            return key.equals(((ExportEntry<?>) o).key) &&\n+                   exportKey.equals(((ExportEntry<?>) o).exportKey);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return exportKey + ':' + key;\n+        }\n+\n+        public ExportEntry<T> withPrefix(String exportPrefix) {\n+            checkArgument(!exportPrefix.isEmpty(), \"exportPrefix must not be empty\");\n+\n+            if (stringifier == null) {\n+                return new ExportEntry<>(key, exportPrefix + exportKey);\n+            } else {\n+                return new ExportEntry<>(key, exportPrefix + exportKey, stringifier);\n+            }\n+        }\n+\n+        public static <T> Set<ExportEntry<T>> withPrefix(Set<ExportEntry<T>> entries, String exportPrefix) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 353}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwODYzNg==", "bodyText": "How about using a separate list so that if build() is called twice, defaultExportGroupBuilder is not added twice.", "url": "https://github.com/line/armeria/pull/3112#discussion_r511708636", "createdAt": "2020-10-26T03:59:28Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -153,103 +146,52 @@ private static AsciiString toHeaderName(CharSequence name) {\n      */\n     public RequestContextExporterBuilder keyPattern(String keyPattern) {\n         requireNonNull(keyPattern, \"keyPattern\");\n-\n-        final int exportKeyPos = keyPattern.indexOf('=');\n-\n-        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n-            if (exportKeyPos > 0) {\n-                throw new IllegalArgumentException(\n-                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n-            }\n-            BuiltInProperty.findByKeyPattern(keyPattern)\n-                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n-                           .forEach(builtIns::add);\n-            return this;\n-        }\n-\n-        String exportKey = null;\n-        if (exportKeyPos > 0) {\n-            exportKey = keyPattern.substring(0, exportKeyPos);\n-            keyPattern = keyPattern.substring(exportKeyPos + 1);\n-        }\n-\n-        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n-        if (property != null) {\n-            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n-            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n-            attrs.add(attrExportEntry);\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n-            if (exportKey == null) {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n-            } else {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n-            if (exportKey == null) {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n-            } else {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+        checkArgument(!keyPattern.isEmpty(), \"keyPattern must not be empty\");\n+        defaultExportGroupBuilder.keyPattern(keyPattern);\n+        return this;\n     }\n \n-    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n-        final String[] components = keyPattern.split(\":\");\n-        if (components.length < 2 || components.length > 3) {\n-            if (exportKey == null) {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            } else {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            }\n-        }\n-\n-        if (exportKey == null) {\n-            exportKey = components[0];\n-        }\n-        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n-        if (components.length == 3) {\n-            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n-        } else {\n-            return new ExportEntry<>(attributeKey, exportKey);\n-        }\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public RequestContextExporterBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n+        checkArgument(!keyPatterns.isEmpty(), \"keyPatterns must not be empty\");\n+        defaultExportGroupBuilder.keyPatterns(keyPatterns);\n+        return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private Function<?, String> newStringifier(String keyPattern, String className) {\n-        final Function<?, String> stringifier;\n-        try {\n-            stringifier = (Function<?, String>)\n-                    Class.forName(className, true, getClass().getClassLoader())\n-                         .getDeclaredConstructor()\n-                         .newInstance();\n-        } catch (Exception e) {\n-            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n-                                               keyPattern, e);\n+    /**\n+     * Adds the export group.\n+     */\n+    public RequestContextExporterBuilder exportGroup(ExportGroup exportGroup) {\n+        if (exportGroups == null) {\n+            exportGroups = new ArrayList<>();\n         }\n-        return stringifier;\n+        exportGroups.add(exportGroup);\n+        return this;\n     }\n \n     /**\n      * Returns a newly-created {@link RequestContextExporter} instance.\n      */\n     public RequestContextExporter build() {\n-        return new RequestContextExporter(builtIns, attrs, reqHeaders, resHeaders);\n+        if (exportGroups == null) {\n+            final ExportGroup defaultExportGroup = defaultExportGroupBuilder.build();\n+            return new RequestContextExporter(\n+                    defaultExportGroup.builtIns(), defaultExportGroup.attrs(),\n+                    defaultExportGroup.reqHeaders(), defaultExportGroup.resHeaders());\n+        }\n+        exportGroups.add(defaultExportGroupBuilder.build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 266}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/9db88f5696ce9ebbbddc984b5286668c4381c4fb", "committedDate": "2020-10-26T05:11:36Z", "message": "address comments by @minwoox"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96833fb8fcea46c63229801a8750f21dcd0f7768", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/96833fb8fcea46c63229801a8750f21dcd0f7768", "committedDate": "2020-10-26T05:16:58Z", "message": "make ExportGroup methods package-private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "381f03231ead868a94d18c9482ce1604a72aef89", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/381f03231ead868a94d18c9482ce1604a72aef89", "committedDate": "2020-10-26T05:40:55Z", "message": "Remove keyPatterns method from ExportGroupBuilder & RequestContextExporterBuilder"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ea8d163f03fbe7bc9cf59ab5353242f1a0ae2816", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/ea8d163f03fbe7bc9cf59ab5353242f1a0ae2816", "committedDate": "2020-10-26T05:38:18Z", "message": "Remove keyPatterns method from ExportGroupBuilder & RequestContextExporterBuilder"}, "afterCommit": {"oid": "381f03231ead868a94d18c9482ce1604a72aef89", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/381f03231ead868a94d18c9482ce1604a72aef89", "committedDate": "2020-10-26T05:40:55Z", "message": "Remove keyPatterns method from ExportGroupBuilder & RequestContextExporterBuilder"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjc1MzEx", "url": "https://github.com/line/armeria/pull/3112#pullrequestreview-513275311", "createdAt": "2020-10-21T03:10:21Z", "commit": {"oid": "7b571b262014ce8093511b282b464b2ba3811922"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzoxMDoyMlrOHlYlzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNjowODoxM1rOHoB2Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2MjI1Mw==", "bodyText": "Could be private?", "url": "https://github.com/line/armeria/pull/3112#discussion_r508962253", "createdAt": "2020-10-21T03:10:22Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b571b262014ce8093511b282b464b2ba3811922"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczNTEwMA==", "bodyText": "nit: Declare static before the member field?", "url": "https://github.com/line/armeria/pull/3112#discussion_r511735100", "createdAt": "2020-10-26T06:07:05Z", "author": {"login": "ikhoon"}, "path": "logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logback;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.logging.ExportGroup;\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n+\n+/**\n+ * Bridge class for Logback configuration.\n+ *\n+ * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfig)\n+ */\n+public final class ExportGroupConfig {\n+\n+    private final ExportGroupBuilder builder = ExportGroup.builder();\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "381f03231ead868a94d18c9482ce1604a72aef89"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczNTMzMA==", "bodyText": "nit: Declare static before the member field?", "url": "https://github.com/line/armeria/pull/3112#discussion_r511735330", "createdAt": "2020-10-26T06:08:13Z", "author": {"login": "ikhoon"}, "path": "logback/src/main/java/com/linecorp/armeria/common/logback/RequestContextExportingAppender.java", "diffHunk": "@@ -66,13 +66,13 @@\n         }\n     }\n \n-    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n-\n     private final AppenderAttachableImpl<ILoggingEvent> aai = new AppenderAttachableImpl<>();\n     private final RequestContextExporterBuilder builder = RequestContextExporter.builder();\n     @Nullable\n     private RequestContextExporter exporter;\n \n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "381f03231ead868a94d18c9482ce1604a72aef89"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2571a029e6781e2a6ffa53dfc3d201714e897e98", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/2571a029e6781e2a6ffa53dfc3d201714e897e98", "committedDate": "2020-10-26T06:16:36Z", "message": "address comments by @ikhoon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63216459662423b894bab015d9a53c80356d2656", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/63216459662423b894bab015d9a53c80356d2656", "committedDate": "2020-10-26T07:32:42Z", "message": "Add documentation for exportGroup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MzIyMDQ2", "url": "https://github.com/line/armeria/pull/3112#pullrequestreview-519322046", "createdAt": "2020-10-29T04:18:21Z", "commit": {"oid": "63216459662423b894bab015d9a53c80356d2656"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNDoxODoyMVrOHqJFcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNDozMDo0NVrOHqJhSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk1MTA5MA==", "bodyText": "Could remove public?", "url": "https://github.com/line/armeria/pull/3112#discussion_r513951090", "createdAt": "2020-10-29T04:18:21Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzY2Mw=="}, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk1ODIxNw==", "bodyText": "How about iterating only once using foreach?\nfinal Builder<ExportEntry<BuiltInProperty>> builtInBuilder = ImmutableSet.builder();\n...\nfor (ExportGroup exportGroup : exportGroupList) {\n    builtInBuilder.addAll(exportGroup.builtIns());\n    ...\n}\nreturn new RequestContextExporter(builtInBuilder.build(), ...);", "url": "https://github.com/line/armeria/pull/3112#discussion_r513958217", "createdAt": "2020-10-29T04:30:45Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -153,103 +146,43 @@ private static AsciiString toHeaderName(CharSequence name) {\n      */\n     public RequestContextExporterBuilder keyPattern(String keyPattern) {\n         requireNonNull(keyPattern, \"keyPattern\");\n-\n-        final int exportKeyPos = keyPattern.indexOf('=');\n-\n-        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n-            if (exportKeyPos > 0) {\n-                throw new IllegalArgumentException(\n-                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n-            }\n-            BuiltInProperty.findByKeyPattern(keyPattern)\n-                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n-                           .forEach(builtIns::add);\n-            return this;\n-        }\n-\n-        String exportKey = null;\n-        if (exportKeyPos > 0) {\n-            exportKey = keyPattern.substring(0, exportKeyPos);\n-            keyPattern = keyPattern.substring(exportKeyPos + 1);\n-        }\n-\n-        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n-        if (property != null) {\n-            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n-            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n-            attrs.add(attrExportEntry);\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n-            if (exportKey == null) {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n-            } else {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n-            if (exportKey == null) {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n-            } else {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n-    }\n-\n-    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n-        final String[] components = keyPattern.split(\":\");\n-        if (components.length < 2 || components.length > 3) {\n-            if (exportKey == null) {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            } else {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            }\n-        }\n-\n-        if (exportKey == null) {\n-            exportKey = components[0];\n-        }\n-        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n-        if (components.length == 3) {\n-            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n-        } else {\n-            return new ExportEntry<>(attributeKey, exportKey);\n-        }\n+        checkArgument(!keyPattern.isEmpty(), \"keyPattern must not be empty\");\n+        defaultExportGroupBuilder.keyPattern(keyPattern);\n+        return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private Function<?, String> newStringifier(String keyPattern, String className) {\n-        final Function<?, String> stringifier;\n-        try {\n-            stringifier = (Function<?, String>)\n-                    Class.forName(className, true, getClass().getClassLoader())\n-                         .getDeclaredConstructor()\n-                         .newInstance();\n-        } catch (Exception e) {\n-            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n-                                               keyPattern, e);\n+    /**\n+     * Adds the export group.\n+     */\n+    public RequestContextExporterBuilder exportGroup(ExportGroup exportGroup) {\n+        if (exportGroups == null) {\n+            exportGroups = new ArrayList<>();\n         }\n-        return stringifier;\n+        exportGroups.add(exportGroup);\n+        return this;\n     }\n \n     /**\n      * Returns a newly-created {@link RequestContextExporter} instance.\n      */\n     public RequestContextExporter build() {\n-        return new RequestContextExporter(builtIns, attrs, reqHeaders, resHeaders);\n+        if (exportGroups == null) {\n+            final ExportGroup defaultExportGroup = defaultExportGroupBuilder.build();\n+            return new RequestContextExporter(\n+                    defaultExportGroup.builtIns(), defaultExportGroup.attrs(),\n+                    defaultExportGroup.reqHeaders(), defaultExportGroup.resHeaders());\n+        }\n+        final List<ExportGroup> exportGroupList = new ArrayList<>(exportGroups);\n+        exportGroupList.add(defaultExportGroupBuilder.build());\n+        return new RequestContextExporter(\n+                exportGroupList.stream().flatMap(it -> it.builtIns().stream())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63216459662423b894bab015d9a53c80356d2656"}, "originalPosition": 261}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNTY5ODEw", "url": "https://github.com/line/armeria/pull/3112#pullrequestreview-520569810", "createdAt": "2020-10-30T11:11:55Z", "commit": {"oid": "63216459662423b894bab015d9a53c80356d2656"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxMTo1NVrOHrKfDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxMzoxMlrOHrKhSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMjYwNA==", "bodyText": "Would it be safe to use ImmutableSet.copyOf() or accept ImmutableSets only?", "url": "https://github.com/line/armeria/pull/3112#discussion_r515022604", "createdAt": "2020-10-30T11:11:55Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder.ExportEntry;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Holds a set of {@link ExportEntry}s.\n+ *\n+ * @see RequestContextExporterBuilder\n+ */\n+public final class ExportGroup {\n+\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroup(Set<ExportEntry<BuiltInProperty>> builtIns,\n+                Set<ExportEntry<AttributeKey<?>>> attrs,\n+                Set<ExportEntry<AsciiString>> reqHeaders,\n+                Set<ExportEntry<AsciiString>> resHeaders) {\n+        this.builtIns = requireNonNull(builtIns, \"builtIns\");\n+        this.attrs = requireNonNull(attrs, \"attrs\");\n+        this.reqHeaders = requireNonNull(reqHeaders, \"reqHeaders\");\n+        this.resHeaders = requireNonNull(resHeaders, \"resHeaders\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63216459662423b894bab015d9a53c80356d2656"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMzE3OQ==", "bodyText": "Really? Why? I guess these methods are supposed to be invoked manually by a user code, not by Logback.", "url": "https://github.com/line/armeria/pull/3112#discussion_r515023179", "createdAt": "2020-10-30T11:13:12Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzY2Mw=="}, "originalCommit": {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f8c1a3efaabd8b41d1997c9db9438bf56e1b798", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/5f8c1a3efaabd8b41d1997c9db9438bf56e1b798", "committedDate": "2020-10-30T12:26:55Z", "message": "address comments by @minwoox"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a46535b95dabd048016f0d77c352ff67f8bf82e", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/6a46535b95dabd048016f0d77c352ff67f8bf82e", "committedDate": "2020-10-30T12:40:04Z", "message": "use ImmutableSet.copyOf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjU4Njg1", "url": "https://github.com/line/armeria/pull/3112#pullrequestreview-520658685", "createdAt": "2020-10-30T13:20:28Z", "commit": {"oid": "6a46535b95dabd048016f0d77c352ff67f8bf82e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyMDoyOFrOHrOopw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyMDoyOFrOHrOopw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5MDU5OQ==", "bodyText": "I think If <prefix> is not defined is more natural.", "url": "https://github.com/line/armeria/pull/3112#discussion_r515090599", "createdAt": "2020-10-30T13:20:28Z", "author": {"login": "minwoox"}, "path": "site/src/pages/docs/advanced-logging.mdx", "diffHunk": "@@ -158,4 +158,57 @@ For example, if you want to change `req.id` to `request_id`, use `request_id=req\n \n Note that a custom MDC key cannot be used with a wildcard expression `*` or `req.*`.\n \n+### Specifying a prefix for MDC keys\n+\n+You can specify a prefix for MDC keys using the `<prefix>` element.\n+If you want to add a prefix `armeria.` to all MDC keys,\n+you need to add `<prefix>armeria.</prefix>` to the XML configuration.\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<configuration>\n+  ...\n+  <appender name=\"RCEA\" class=\"com.linecorp.armeria.common.logback.RequestContextExportingAppender\">\n+    ...\n+    <!-- set the prefix of MDC keys -->\n+    <prefix>armeria.</prefix>\n+    <export>remote.id</export>\n+    <export>req.headers.user-agent</export>\n+    <export>some_value=attr:com.example.AttrKeys#SOME_KEY</export>\n+    ...\n+  </appender>\n+  ...\n+</configuration>\n+```\n+\n+When you want to specify a different prefix, you can define `<prefix>`, `<export>`, and `<exports>` elements\n+in the `<exportGroup>` element.\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<configuration>\n+  ...\n+  <appender name=\"RCEA\" class=\"com.linecorp.armeria.common.logback.RequestContextExportingAppender\">\n+    ...\n+    <!-- set the prefix of exports which is not wrapped with the <exportGroup> element -->\n+    <prefix>armeria.</prefix>\n+    <export>remote.id</export>\n+    <export>req.headers.user-agent</export>\n+    ...\n+    <exportGroup>\n+      <!-- set the prefix of exports in this <exportGroup> -->\n+      <prefix>some_prefix.</prefix>\n+      <export>some_value=attr:com.example.AttrKeys#SOME_KEY</export>\n+      ...\n+    </exportGroup>\n+    <exportGroup>\n+      <!-- if no <prefix> is defined, no prefix is added to exports -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a46535b95dabd048016f0d77c352ff67f8bf82e"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNjk1ODM5", "url": "https://github.com/line/armeria/pull/3112#pullrequestreview-520695839", "createdAt": "2020-10-30T14:00:52Z", "commit": {"oid": "6a46535b95dabd048016f0d77c352ff67f8bf82e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDowMDo1MlrOHrQXKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDowMDo1MlrOHrQXKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTExODg5MQ==", "bodyText": "Don't we need to return RequestContextExporterBuilder?", "url": "https://github.com/line/armeria/pull/3112#discussion_r515118891", "createdAt": "2020-10-30T14:00:52Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -134,16 +130,17 @@ public RequestContextExporterBuilder responseHeader(CharSequence headerName) {\n     public RequestContextExporterBuilder responseHeader(CharSequence headerName, String alias) {\n         requireNonNull(headerName, \"headerName\");\n         requireNonNull(alias, \"alias\");\n-        return addResponseHeader(toHeaderName(headerName), alias);\n-    }\n-\n-    private RequestContextExporterBuilder addResponseHeader(AsciiString headerKey, String alias) {\n-        resHeaders.add(new ExportEntry<>(headerKey, alias));\n+        defaultExportGroupBuilder.responseHeader(headerName, alias);\n         return this;\n     }\n \n-    private static AsciiString toHeaderName(CharSequence name) {\n-        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public void prefix(String prefix) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a46535b95dabd048016f0d77c352ff67f8bf82e"}, "originalPosition": 133}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f74ae1525f8e0591e18fc89b60d8d4b9b3da7e68", "author": {"user": {"login": "okue", "name": "Okue"}}, "url": "https://github.com/line/armeria/commit/f74ae1525f8e0591e18fc89b60d8d4b9b3da7e68", "committedDate": "2020-10-31T04:59:03Z", "message": "address comments by @ikhoon and @minwoox"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4745, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}