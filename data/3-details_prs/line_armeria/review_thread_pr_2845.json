{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNDUwMzI1", "number": 2845, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo1NDoyM1rOEJDosw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMzo1NjoyNVrOEJ66EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTMyMjExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/stream/DeferredStreamMessage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo1NDoyM1rOGpZIVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo1NDoyM1rOGpZIVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NjUzNQ==", "bodyText": "Thanks!", "url": "https://github.com/line/armeria/pull/2845#discussion_r446056535", "createdAt": "2020-06-26T08:54:23Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/stream/DeferredStreamMessage.java", "diffHunk": "@@ -66,7 +66,7 @@\n             DeferredStreamMessage.class, Throwable.class, \"abortCause\");\n \n     @Nullable\n-    @SuppressWarnings(\"unused\") // Updated only via delegateUpdater\n+    @SuppressWarnings(\"unused\") // Updated only via upstreamUpdater", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2a93cd29e37a30086952fdf5a7f799d1a10b3ce"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODE1NTk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/file/AbstractBlockingHttpVfs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMTo1MzoyMlrOGqovfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMjo1MjoxMFrOGqpukg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2MDg5Mw==", "bodyText": "nit: rnn for path and fileReadExecutor?", "url": "https://github.com/line/armeria/pull/2845#discussion_r447360893", "createdAt": "2020-06-30T01:53:22Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/server/file/AbstractBlockingHttpVfs.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.file;\n+\n+import java.time.Clock;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+\n+/**\n+ * A skeletal {@link HttpVfs} implementation for accessing file system with blocking I/O.\n+ * All its operations are executed in the given {@code fileReadExecutor} via the blocking I/O methods,\n+ * such as {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}.\n+ */\n+public abstract class AbstractBlockingHttpVfs extends AbstractHttpVfs {\n+\n+    private final boolean directoryListingSupported;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param directoryListingSupported whether this {@link HttpVfs} supports directory listing.\n+     *                                  If {@code false}, {@link #blockingCanList(Executor, String)} and\n+     *                                  {@link #blockingList(Executor, String)} will never be invoked.\n+     */\n+    protected AbstractBlockingHttpVfs(boolean directoryListingSupported) {\n+        this.directoryListingSupported = directoryListingSupported;\n+    }\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}\n+     * from the specified {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final HttpFile get(\n+            Executor fileReadExecutor, String path, Clock clock,\n+            @Nullable String contentEncoding, HttpHeaders additionalHeaders) {\n+\n+        return HttpFile.from(CompletableFuture.supplyAsync(\n+                () -> blockingGet(fileReadExecutor, path, clock, contentEncoding, additionalHeaders),\n+                fileReadExecutor));\n+    }\n+\n+    /**\n+     * Finds the file at the specified {@code path}.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @param clock the {@link Clock} which provides the current date and time\n+     * @param contentEncoding the desired {@code 'content-encoding'} header value of the file.\n+     *                        {@code null} to omit the header.\n+     * @param additionalHeaders the additional HTTP headers to add to the returned {@link HttpFile}.\n+     *\n+     * @return the {@link HttpFile} at the specified {@code path}\n+     */\n+    protected abstract HttpFile blockingGet(Executor fileReadExecutor, String path, Clock clock,\n+                                            @Nullable String contentEncoding, HttpHeaders additionalHeaders);\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingCanList(Executor, String)} from the specified\n+     * {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final CompletableFuture<Boolean> canList(Executor fileReadExecutor, String path) {\n+        if (directoryListingSupported) {\n+            return CompletableFuture.supplyAsync(() -> blockingCanList(fileReadExecutor, path),\n+                                                 fileReadExecutor);\n+        } else {\n+            return super.canList(fileReadExecutor, path);\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the file at the specified {@code path} is a listable directory. This method returns\n+     * {@code false} by default.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @return {@code true} if the file is a listable directory. {@code false} if the directory does not exist\n+     *         or the file listing is not available.\n+     */\n+    protected boolean blockingCanList(Executor fileReadExecutor, String path) {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingList(Executor, String)} from the specified\n+     * {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final CompletableFuture<List<String>> list(Executor fileReadExecutor, String path) {\n+        if (directoryListingSupported) {\n+            return CompletableFuture.supplyAsync(() -> blockingList(fileReadExecutor, path),\n+                                                 fileReadExecutor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678a5a301dee43815b28bdb6ff03abb2785dd031"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3NzA0Mg==", "bodyText": "Added rnn in various places", "url": "https://github.com/line/armeria/pull/2845#discussion_r447377042", "createdAt": "2020-06-30T02:52:10Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/file/AbstractBlockingHttpVfs.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.file;\n+\n+import java.time.Clock;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+\n+/**\n+ * A skeletal {@link HttpVfs} implementation for accessing file system with blocking I/O.\n+ * All its operations are executed in the given {@code fileReadExecutor} via the blocking I/O methods,\n+ * such as {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}.\n+ */\n+public abstract class AbstractBlockingHttpVfs extends AbstractHttpVfs {\n+\n+    private final boolean directoryListingSupported;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param directoryListingSupported whether this {@link HttpVfs} supports directory listing.\n+     *                                  If {@code false}, {@link #blockingCanList(Executor, String)} and\n+     *                                  {@link #blockingList(Executor, String)} will never be invoked.\n+     */\n+    protected AbstractBlockingHttpVfs(boolean directoryListingSupported) {\n+        this.directoryListingSupported = directoryListingSupported;\n+    }\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}\n+     * from the specified {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final HttpFile get(\n+            Executor fileReadExecutor, String path, Clock clock,\n+            @Nullable String contentEncoding, HttpHeaders additionalHeaders) {\n+\n+        return HttpFile.from(CompletableFuture.supplyAsync(\n+                () -> blockingGet(fileReadExecutor, path, clock, contentEncoding, additionalHeaders),\n+                fileReadExecutor));\n+    }\n+\n+    /**\n+     * Finds the file at the specified {@code path}.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @param clock the {@link Clock} which provides the current date and time\n+     * @param contentEncoding the desired {@code 'content-encoding'} header value of the file.\n+     *                        {@code null} to omit the header.\n+     * @param additionalHeaders the additional HTTP headers to add to the returned {@link HttpFile}.\n+     *\n+     * @return the {@link HttpFile} at the specified {@code path}\n+     */\n+    protected abstract HttpFile blockingGet(Executor fileReadExecutor, String path, Clock clock,\n+                                            @Nullable String contentEncoding, HttpHeaders additionalHeaders);\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingCanList(Executor, String)} from the specified\n+     * {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final CompletableFuture<Boolean> canList(Executor fileReadExecutor, String path) {\n+        if (directoryListingSupported) {\n+            return CompletableFuture.supplyAsync(() -> blockingCanList(fileReadExecutor, path),\n+                                                 fileReadExecutor);\n+        } else {\n+            return super.canList(fileReadExecutor, path);\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the file at the specified {@code path} is a listable directory. This method returns\n+     * {@code false} by default.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @return {@code true} if the file is a listable directory. {@code false} if the directory does not exist\n+     *         or the file listing is not available.\n+     */\n+    protected boolean blockingCanList(Executor fileReadExecutor, String path) {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingList(Executor, String)} from the specified\n+     * {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final CompletableFuture<List<String>> list(Executor fileReadExecutor, String path) {\n+        if (directoryListingSupported) {\n+            return CompletableFuture.supplyAsync(() -> blockingList(fileReadExecutor, path),\n+                                                 fileReadExecutor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2MDg5Mw=="}, "originalCommit": {"oid": "678a5a301dee43815b28bdb6ff03abb2785dd031"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODE2NjA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/file/HttpDataFile.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMTo1ODozNlrOGqo1OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMTo1ODozNlrOGqo1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2MjM2MA==", "bodyText": "nit: can remove super.", "url": "https://github.com/line/armeria/pull/2845#discussion_r447362360", "createdAt": "2020-06-30T01:58:36Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/server/file/HttpDataFile.java", "diffHunk": "@@ -75,13 +75,19 @@ public HttpFileAttributes readAttributes() {\n         return attrs;\n     }\n \n+    @Override\n+    public CompletableFuture<HttpFileAttributes> readAttributes(Executor fileReadExecutor) {\n+        return AggregatedHttpFile.super.readAttributes(fileReadExecutor);\n+    }\n+\n     @Override\n     public ResponseHeaders readHeaders() {\n-        try {\n-            return super.readHeaders();\n-        } catch (IOException e) {\n-            throw new Error(e); // Never reaches here.\n-        }\n+        return super.readHeaders(attrs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f748dfddb39122b54945167622d94888de2bbca2"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODE3NTU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/file/ClassPathHttpFile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMjowMzozMFrOGqo6sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMjo1MjowMFrOGqpuaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2Mzc2Mg==", "bodyText": "Shouldn't this be }, fileReadExecutor);?\nAnd rnn for fileReadExecutor.", "url": "https://github.com/line/armeria/pull/2845#discussion_r447363762", "createdAt": "2020-06-30T02:03:30Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/server/file/ClassPathHttpFile.java", "diffHunk": "@@ -54,14 +57,21 @@ protected String pathOrUri() {\n     }\n \n     @Override\n-    public HttpFileAttributes readAttributes() throws IOException {\n-        if (attrs == null) {\n-            final URLConnection conn = url.openConnection();\n-            final long length = conn.getContentLengthLong();\n-            final long lastModifiedMillis = conn.getLastModified();\n-            attrs = new HttpFileAttributes(length, lastModifiedMillis);\n+    public CompletableFuture<HttpFileAttributes> readAttributes(Executor fileReadExecutor) {\n+        if (attrsFuture != null) {\n+            return attrsFuture;\n         }\n-        return attrs;\n+\n+        return attrsFuture = CompletableFuture.supplyAsync(() -> {\n+            try {\n+                final URLConnection conn = url.openConnection();\n+                final long length = conn.getContentLengthLong();\n+                final long lastModifiedMillis = conn.getLastModified();\n+                return new HttpFileAttributes(length, lastModifiedMillis);\n+            } catch (IOException e) {\n+                return Exceptions.throwUnsafely(e);\n+            }\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f748dfddb39122b54945167622d94888de2bbca2"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3NzAwMA==", "bodyText": "\ud83d\ude31", "url": "https://github.com/line/armeria/pull/2845#discussion_r447377000", "createdAt": "2020-06-30T02:52:00Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/file/ClassPathHttpFile.java", "diffHunk": "@@ -54,14 +57,21 @@ protected String pathOrUri() {\n     }\n \n     @Override\n-    public HttpFileAttributes readAttributes() throws IOException {\n-        if (attrs == null) {\n-            final URLConnection conn = url.openConnection();\n-            final long length = conn.getContentLengthLong();\n-            final long lastModifiedMillis = conn.getLastModified();\n-            attrs = new HttpFileAttributes(length, lastModifiedMillis);\n+    public CompletableFuture<HttpFileAttributes> readAttributes(Executor fileReadExecutor) {\n+        if (attrsFuture != null) {\n+            return attrsFuture;\n         }\n-        return attrs;\n+\n+        return attrsFuture = CompletableFuture.supplyAsync(() -> {\n+            try {\n+                final URLConnection conn = url.openConnection();\n+                final long length = conn.getContentLengthLong();\n+                final long lastModifiedMillis = conn.getLastModified();\n+                return new HttpFileAttributes(length, lastModifiedMillis);\n+            } catch (IOException e) {\n+                return Exceptions.throwUnsafely(e);\n+            }\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2Mzc2Mg=="}, "originalCommit": {"oid": "f748dfddb39122b54945167622d94888de2bbca2"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODE5MzAxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/file/DeferredHttpFile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMjoxMjoyNFrOGqpEtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMjo1MTo1NFrOGqpuVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NjMyNg==", "bodyText": "nit: can remove this.", "url": "https://github.com/line/armeria/pull/2845#discussion_r447366326", "createdAt": "2020-06-30T02:12:24Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/server/file/DeferredHttpFile.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.file;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.HttpService;\n+\n+import io.netty.buffer.ByteBufAllocator;\n+\n+final class DeferredHttpFile implements HttpFile {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DeferredHttpFile.class);\n+\n+    private static boolean warnedNullDelegate;\n+\n+    private final CompletableFuture<? extends HttpFile> stage;\n+    @Nullable\n+    private volatile HttpFile delegate;\n+\n+    DeferredHttpFile(CompletionStage<? extends HttpFile> stage) {\n+        this.stage = requireNonNull(stage, \"stage\").toCompletableFuture();\n+        if (this.stage.isDone() && !this.stage.isCompletedExceptionally()) {\n+            setDelegate(this.stage.getNow(null));\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpFileAttributes> readAttributes(Executor fileReadExecutor) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.readAttributes(fileReadExecutor);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.readAttributes(fileReadExecutor);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<ResponseHeaders> readHeaders(Executor fileReadExecutor) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.readHeaders(fileReadExecutor);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.readHeaders(fileReadExecutor);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpResponse> read(Executor fileReadExecutor, ByteBufAllocator alloc) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.read(fileReadExecutor, alloc);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.read(fileReadExecutor, alloc);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<AggregatedHttpFile> aggregate(Executor fileReadExecutor) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.aggregate(fileReadExecutor);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.aggregate(fileReadExecutor);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<AggregatedHttpFile> aggregateWithPooledObjects(Executor fileReadExecutor,\n+                                                                            ByteBufAllocator alloc) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.aggregateWithPooledObjects(fileReadExecutor, alloc);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.aggregateWithPooledObjects(fileReadExecutor, alloc);\n+        });\n+    }\n+\n+    @Override\n+    public HttpService asService() {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.asService();\n+        }\n+\n+        return (ctx, req) -> HttpResponse.from(stage.thenApply(file -> {\n+            setDelegate(file);\n+            try {\n+                return file.asService().serve(ctx, req);\n+            } catch (Exception e) {\n+                return Exceptions.throwUnsafely(e);\n+            }\n+        }));\n+    }\n+\n+    private void setDelegate(@Nullable HttpFile file) {\n+        if (file == null) {\n+            if (!warnedNullDelegate) {\n+                warnedNullDelegate = true;\n+                logger.warn(\"The delegate stage produced a null file; treating as a non-existent file.\");\n+            }\n+            file = HttpFile.nonExistent();\n+        }\n+        this.delegate = file;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f748dfddb39122b54945167622d94888de2bbca2"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3Njk4MA==", "bodyText": "Renamed file to delegate", "url": "https://github.com/line/armeria/pull/2845#discussion_r447376980", "createdAt": "2020-06-30T02:51:54Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/file/DeferredHttpFile.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.file;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.HttpService;\n+\n+import io.netty.buffer.ByteBufAllocator;\n+\n+final class DeferredHttpFile implements HttpFile {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DeferredHttpFile.class);\n+\n+    private static boolean warnedNullDelegate;\n+\n+    private final CompletableFuture<? extends HttpFile> stage;\n+    @Nullable\n+    private volatile HttpFile delegate;\n+\n+    DeferredHttpFile(CompletionStage<? extends HttpFile> stage) {\n+        this.stage = requireNonNull(stage, \"stage\").toCompletableFuture();\n+        if (this.stage.isDone() && !this.stage.isCompletedExceptionally()) {\n+            setDelegate(this.stage.getNow(null));\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpFileAttributes> readAttributes(Executor fileReadExecutor) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.readAttributes(fileReadExecutor);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.readAttributes(fileReadExecutor);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<ResponseHeaders> readHeaders(Executor fileReadExecutor) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.readHeaders(fileReadExecutor);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.readHeaders(fileReadExecutor);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpResponse> read(Executor fileReadExecutor, ByteBufAllocator alloc) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.read(fileReadExecutor, alloc);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.read(fileReadExecutor, alloc);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<AggregatedHttpFile> aggregate(Executor fileReadExecutor) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.aggregate(fileReadExecutor);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.aggregate(fileReadExecutor);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<AggregatedHttpFile> aggregateWithPooledObjects(Executor fileReadExecutor,\n+                                                                            ByteBufAllocator alloc) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.aggregateWithPooledObjects(fileReadExecutor, alloc);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.aggregateWithPooledObjects(fileReadExecutor, alloc);\n+        });\n+    }\n+\n+    @Override\n+    public HttpService asService() {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.asService();\n+        }\n+\n+        return (ctx, req) -> HttpResponse.from(stage.thenApply(file -> {\n+            setDelegate(file);\n+            try {\n+                return file.asService().serve(ctx, req);\n+            } catch (Exception e) {\n+                return Exceptions.throwUnsafely(e);\n+            }\n+        }));\n+    }\n+\n+    private void setDelegate(@Nullable HttpFile file) {\n+        if (file == null) {\n+            if (!warnedNullDelegate) {\n+                warnedNullDelegate = true;\n+                logger.warn(\"The delegate stage produced a null file; treating as a non-existent file.\");\n+            }\n+            file = HttpFile.nonExistent();\n+        }\n+        this.delegate = file;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NjMyNg=="}, "originalCommit": {"oid": "f748dfddb39122b54945167622d94888de2bbca2"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODM3Nzc3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/file/AbstractBlockingHttpVfs.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMzo1NjoyNVrOGqqvkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNDozMzoxNVrOGqrUPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM5MzY4MQ==", "bodyText": "Isn't this directoryListingSupported?", "url": "https://github.com/line/armeria/pull/2845#discussion_r447393681", "createdAt": "2020-06-30T03:56:25Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/server/file/AbstractBlockingHttpVfs.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.file;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Clock;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+\n+/**\n+ * A skeletal {@link HttpVfs} implementation for accessing file system with blocking I/O.\n+ * All its operations are executed in the given {@code fileReadExecutor} via the blocking I/O methods,\n+ * such as {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}.\n+ */\n+public abstract class AbstractBlockingHttpVfs extends AbstractHttpVfs {\n+\n+    private final boolean directoryListingSupported;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param directoryListingSupported whether this {@link HttpVfs} supports directory listing.\n+     *                                  If {@code false}, {@link #blockingCanList(Executor, String)} and\n+     *                                  {@link #blockingList(Executor, String)} will never be invoked.\n+     */\n+    protected AbstractBlockingHttpVfs(boolean directoryListingSupported) {\n+        this.directoryListingSupported = directoryListingSupported;\n+    }\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}\n+     * from the specified {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final HttpFile get(\n+            Executor fileReadExecutor, String path, Clock clock,\n+            @Nullable String contentEncoding, HttpHeaders additionalHeaders) {\n+\n+        requireNonNull(fileReadExecutor, \"fileReadExecutor\");\n+        requireNonNull(path, \"path\");\n+        requireNonNull(clock, \"clock\");\n+        requireNonNull(additionalHeaders, \"additionalHeaders\");\n+\n+        return HttpFile.from(CompletableFuture.supplyAsync(\n+                () -> blockingGet(fileReadExecutor, path, clock, contentEncoding, additionalHeaders),\n+                fileReadExecutor));\n+    }\n+\n+    /**\n+     * Finds the file at the specified {@code path}.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @param clock the {@link Clock} which provides the current date and time\n+     * @param contentEncoding the desired {@code 'content-encoding'} header value of the file.\n+     *                        {@code null} to omit the header.\n+     * @param additionalHeaders the additional HTTP headers to add to the returned {@link HttpFile}.\n+     *\n+     * @return the {@link HttpFile} at the specified {@code path}\n+     */\n+    protected abstract HttpFile blockingGet(Executor fileReadExecutor, String path, Clock clock,\n+                                            @Nullable String contentEncoding, HttpHeaders additionalHeaders);\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingCanList(Executor, String)} from the specified\n+     * {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final CompletableFuture<Boolean> canList(Executor fileReadExecutor, String path) {\n+        requireNonNull(fileReadExecutor, \"fileReadExecutor\");\n+        requireNonNull(path, \"path\");\n+\n+        if (directoryListingSupported) {\n+            return CompletableFuture.supplyAsync(() -> blockingCanList(fileReadExecutor, path),\n+                                                 fileReadExecutor);\n+        } else {\n+            return super.canList(fileReadExecutor, path);\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the file at the specified {@code path} is a listable directory. This method returns\n+     * {@code false} by default.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @return {@code true} if the file is a listable directory. {@code false} if the directory does not exist\n+     *         or the file listing is not available.\n+     */\n+    protected boolean blockingCanList(Executor fileReadExecutor, String path) {\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f72c9532e9c2301d71ea0140c75552170651cc"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQwMzA3MA==", "bodyText": "It has to return true only when the path exists and it is a directory. We can't return true here because only a subclass has such information.", "url": "https://github.com/line/armeria/pull/2845#discussion_r447403070", "createdAt": "2020-06-30T04:33:15Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/file/AbstractBlockingHttpVfs.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.file;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Clock;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+\n+/**\n+ * A skeletal {@link HttpVfs} implementation for accessing file system with blocking I/O.\n+ * All its operations are executed in the given {@code fileReadExecutor} via the blocking I/O methods,\n+ * such as {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}.\n+ */\n+public abstract class AbstractBlockingHttpVfs extends AbstractHttpVfs {\n+\n+    private final boolean directoryListingSupported;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param directoryListingSupported whether this {@link HttpVfs} supports directory listing.\n+     *                                  If {@code false}, {@link #blockingCanList(Executor, String)} and\n+     *                                  {@link #blockingList(Executor, String)} will never be invoked.\n+     */\n+    protected AbstractBlockingHttpVfs(boolean directoryListingSupported) {\n+        this.directoryListingSupported = directoryListingSupported;\n+    }\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}\n+     * from the specified {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final HttpFile get(\n+            Executor fileReadExecutor, String path, Clock clock,\n+            @Nullable String contentEncoding, HttpHeaders additionalHeaders) {\n+\n+        requireNonNull(fileReadExecutor, \"fileReadExecutor\");\n+        requireNonNull(path, \"path\");\n+        requireNonNull(clock, \"clock\");\n+        requireNonNull(additionalHeaders, \"additionalHeaders\");\n+\n+        return HttpFile.from(CompletableFuture.supplyAsync(\n+                () -> blockingGet(fileReadExecutor, path, clock, contentEncoding, additionalHeaders),\n+                fileReadExecutor));\n+    }\n+\n+    /**\n+     * Finds the file at the specified {@code path}.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @param clock the {@link Clock} which provides the current date and time\n+     * @param contentEncoding the desired {@code 'content-encoding'} header value of the file.\n+     *                        {@code null} to omit the header.\n+     * @param additionalHeaders the additional HTTP headers to add to the returned {@link HttpFile}.\n+     *\n+     * @return the {@link HttpFile} at the specified {@code path}\n+     */\n+    protected abstract HttpFile blockingGet(Executor fileReadExecutor, String path, Clock clock,\n+                                            @Nullable String contentEncoding, HttpHeaders additionalHeaders);\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingCanList(Executor, String)} from the specified\n+     * {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final CompletableFuture<Boolean> canList(Executor fileReadExecutor, String path) {\n+        requireNonNull(fileReadExecutor, \"fileReadExecutor\");\n+        requireNonNull(path, \"path\");\n+\n+        if (directoryListingSupported) {\n+            return CompletableFuture.supplyAsync(() -> blockingCanList(fileReadExecutor, path),\n+                                                 fileReadExecutor);\n+        } else {\n+            return super.canList(fileReadExecutor, path);\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the file at the specified {@code path} is a listable directory. This method returns\n+     * {@code false} by default.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @return {@code true} if the file is a listable directory. {@code false} if the directory does not exist\n+     *         or the file listing is not available.\n+     */\n+    protected boolean blockingCanList(Executor fileReadExecutor, String path) {\n+        return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM5MzY4MQ=="}, "originalCommit": {"oid": "55f72c9532e9c2301d71ea0140c75552170651cc"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2440, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}