{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyOTYyMDI3", "number": 2399, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMTo0N1rODYEPGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowMTo1MlrODYHsLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTYxODE5OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMTo0N1rOFdtl1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMTo0N1rOFdtl1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY5OTk5MQ==", "bodyText": "Remove", "url": "https://github.com/line/armeria/pull/2399#discussion_r366699991", "createdAt": "2020-01-15T05:21:47Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/build.gradle", "diffHunk": "@@ -0,0 +1,25 @@\n+plugins {\n+    id 'application'\n+    id \"org.jetbrains.kotlin.jvm\"\n+}\n+\n+dependencies {\n+    implementation project(':core')\n+\n+    implementation 'io.reactivex.rxjava2:rxjava'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef731e514ca70fc662793b82203e5c68cefa70d"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTYxODIzOnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMTo1MVrOFdtl4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMTo1MVrOFdtl4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwMDAwMQ==", "bodyText": "Remove", "url": "https://github.com/line/armeria/pull/2399#discussion_r366700001", "createdAt": "2020-01-15T05:21:51Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/build.gradle", "diffHunk": "@@ -0,0 +1,25 @@\n+plugins {\n+    id 'application'\n+    id \"org.jetbrains.kotlin.jvm\"\n+}\n+\n+dependencies {\n+    implementation project(':core')\n+\n+    implementation 'io.reactivex.rxjava2:rxjava'\n+    implementation 'org.jetbrains.kotlin:kotlin-stdlib-jdk8'\n+    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core'\n+    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-jdk8'\n+    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-rx2'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef731e514ca70fc662793b82203e5c68cefa70d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTYxODg2OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/Main.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMjoyNlrOFdtmRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMjoyNlrOFdtmRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwMDEwMQ==", "bodyText": "Do you need : ServiceRequestContext? Or is it just more idiomatic in kotlin?", "url": "https://github.com/line/armeria/pull/2399#discussion_r366700101", "createdAt": "2020-01-15T05:22:26Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/Main.kt", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.common.HttpStatus\n+import com.linecorp.armeria.server.Server\n+import com.linecorp.armeria.server.ServiceRequestContext\n+\n+fun main(args: Array<String>) {\n+    val backend = Server.builder()\n+        .service(\"/square/{num}\") { ctx: ServiceRequestContext, _ ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef731e514ca70fc662793b82203e5c68cefa70d"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTYxOTY5OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/Main.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMzoxOFrOFdtmxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMzoxOFrOFdtmxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwMDIyOQ==", "bodyText": "We're not bothering being safe about this check this in other examples, probably fine not to here (or otherwise we could update the other examples", "url": "https://github.com/line/armeria/pull/2399#discussion_r366700229", "createdAt": "2020-01-15T05:23:18Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/Main.kt", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.common.HttpStatus\n+import com.linecorp.armeria.server.Server\n+import com.linecorp.armeria.server.ServiceRequestContext\n+\n+fun main(args: Array<String>) {\n+    val backend = Server.builder()\n+        .service(\"/square/{num}\") { ctx: ServiceRequestContext, _ ->\n+            val num = try {\n+                ctx.pathParam(\"num\")?.toLong()\n+            } catch (e: NumberFormatException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef731e514ca70fc662793b82203e5c68cefa70d"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTYyMDM2OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/Main.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMzo1MVrOFdtnLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyMzo1MVrOFdtnLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwMDMzNQ==", "bodyText": "Do you need Runnable?", "url": "https://github.com/line/armeria/pull/2399#discussion_r366700335", "createdAt": "2020-01-15T05:23:51Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/Main.kt", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.common.HttpStatus\n+import com.linecorp.armeria.server.Server\n+import com.linecorp.armeria.server.ServiceRequestContext\n+\n+fun main(args: Array<String>) {\n+    val backend = Server.builder()\n+        .service(\"/square/{num}\") { ctx: ServiceRequestContext, _ ->\n+            val num = try {\n+                ctx.pathParam(\"num\")?.toLong()\n+            } catch (e: NumberFormatException) {\n+                return@service HttpResponse.of(HttpStatus.BAD_REQUEST)\n+            }\n+            if (num != null) {\n+                HttpResponse.of((num * num).toString())\n+            } else {\n+                HttpResponse.of(HttpStatus.BAD_REQUEST)\n+            }\n+        }\n+        .http(8081)\n+        .build()\n+    val backendClient = WebClient.of(\"http://localhost:8081\")\n+    val frontend = Server.builder()\n+        .http(8080)\n+        .serviceUnder(\"/\", MainService(backendClient))\n+        .build()\n+    Runtime.getRuntime().addShutdownHook(Thread(Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef731e514ca70fc662793b82203e5c68cefa70d"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTYyMTM4OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyNTowN1rOFdtn4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyNTowN1rOFdtn4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwMDUxMg==", "bodyText": "I think we should be able to use Armeria's code style at least for the imports (we do in grpc-kotlin example)", "url": "https://github.com/line/armeria/pull/2399#discussion_r366700512", "createdAt": "2020-01-15T05:25:07Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.google.common.base.Splitter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef731e514ca70fc662793b82203e5c68cefa70d"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTYyMzI5OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyNzoxNVrOFdtpKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyNzoxNVrOFdtpKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwMDg0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private suspend fun fetchFromRequest(req: HttpRequest): List<Long> {\n          \n          \n            \n                private suspend fun fetchFromRequest(req: HttpRequest): List<Long> {\n          \n          \n            \n                  // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n          \n          \n            \n                  require(ServiceRequestContext.current() === ctx)\n          \n          \n            \n                  require(ctx.eventLoop().inEventLoop())", "url": "https://github.com/line/armeria/pull/2399#discussion_r366700840", "createdAt": "2020-01-15T05:27:15Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.google.common.base.Splitter\n+import com.google.common.collect.ImmutableList\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+import kotlinx.coroutines.withContext\n+import java.time.Duration\n+import java.util.function.Function\n+import java.util.stream.Collectors\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+            val numsFromRequest = async { fetchFromRequest(req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+            val backendResponses = awaitAll(\n+                *nums.map { num ->\n+                    // The context is mounted in a thread-local, meaning it is available to all logic such\n+                    // as tracing.\n+                    require(ServiceRequestContext.current() === ctx)\n+                    require(ctx.eventLoop().inEventLoop())\n+                    backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                }.toTypedArray()\n+            ).toList()\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(Function { obj: AggregatedHttpResponse -> obj.contentUtf8() })\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(req: HttpRequest): List<Long> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef731e514ca70fc662793b82203e5c68cefa70d"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTYyNDEzOnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyODoxMFrOFdtpug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNToyODoxMFrOFdtpug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwMDk4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    val nums = mutableListOf<Long>()\n          \n          \n            \n                    // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n          \n          \n            \n                    require(ServiceRequestContext.current() === ctx)\n          \n          \n            \n                    require(ctx.eventLoop().inEventLoop())\n          \n          \n            \n                    val nums = mutableListOf<Long>()", "url": "https://github.com/line/armeria/pull/2399#discussion_r366700986", "createdAt": "2020-01-15T05:28:10Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.google.common.base.Splitter\n+import com.google.common.collect.ImmutableList\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+import kotlinx.coroutines.withContext\n+import java.time.Duration\n+import java.util.function.Function\n+import java.util.stream.Collectors\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+            val numsFromRequest = async { fetchFromRequest(req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+            val backendResponses = awaitAll(\n+                *nums.map { num ->\n+                    // The context is mounted in a thread-local, meaning it is available to all logic such\n+                    // as tracing.\n+                    require(ServiceRequestContext.current() === ctx)\n+                    require(ctx.eventLoop().inEventLoop())\n+                    backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                }.toTypedArray()\n+            ).toList()\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(Function { obj: AggregatedHttpResponse -> obj.contentUtf8() })\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(req: HttpRequest): List<Long> {\n+        val aggregatedHttpRequest = req.aggregate().await()\n+        val nums = mutableListOf<Long>()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef731e514ca70fc662793b82203e5c68cefa70d"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTYzNTg3OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNTozODowNFrOFdtw3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNTozODowNFrOFdtw3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwMjgxMg==", "bodyText": "Doesn't Kotlin have method reference too? obj::contentUtf8?", "url": "https://github.com/line/armeria/pull/2399#discussion_r366702812", "createdAt": "2020-01-15T05:38:04Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.google.common.base.Splitter\n+import com.google.common.collect.ImmutableList\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+import kotlinx.coroutines.withContext\n+import java.time.Duration\n+import java.util.function.Function\n+import java.util.stream.Collectors\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+            val numsFromRequest = async { fetchFromRequest(req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+            val backendResponses = awaitAll(\n+                *nums.map { num ->\n+                    // The context is mounted in a thread-local, meaning it is available to all logic such\n+                    // as tracing.\n+                    require(ServiceRequestContext.current() === ctx)\n+                    require(ctx.eventLoop().inEventLoop())\n+                    backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                }.toTypedArray()\n+            ).toList()\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(Function { obj: AggregatedHttpResponse -> obj.contentUtf8() })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef731e514ca70fc662793b82203e5c68cefa70d"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTc2MTcwOnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNzoxMDo0NlrOFdu8Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNzoxMDo0NlrOFdu8Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcyMjE0Mg==", "bodyText": "Can we write this file in kotlin since it's a kotlin project?", "url": "https://github.com/line/armeria/pull/2399#discussion_r366722142", "createdAt": "2020-01-15T07:10:46Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/build.gradle", "diffHunk": "@@ -0,0 +1,23 @@\n+plugins {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1347547769ad01554b6c6769bc1615076c683c39"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTc2MzEwOnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNzoxMTozNlrOFdu9Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNzoxMTozNlrOFdu9Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcyMjM1NA==", "bodyText": "I think this is required in our build because of the way we run tests. Maybe we should apply in top level build file instead?", "url": "https://github.com/line/armeria/pull/2399#discussion_r366722354", "createdAt": "2020-01-15T07:11:36Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/build.gradle", "diffHunk": "@@ -0,0 +1,23 @@\n+plugins {\n+    id 'application'\n+    id \"org.jetbrains.kotlin.jvm\"\n+}\n+\n+dependencies {\n+    implementation project(':core')\n+\n+    implementation 'org.jetbrains.kotlin:kotlin-stdlib-jdk8'\n+    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core'\n+    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-jdk8'\n+}\n+\n+application {\n+    mainClassName = 'example.armeria.contextpropagation.kotlin.Main'\n+}\n+\n+compileKotlin {\n+    kotlinOptions.jvmTarget = \"1.8\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1347547769ad01554b6c6769bc1615076c683c39"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTc2NTA4OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNzoxMjo1M1rOFdu-Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNzoxMjo1M1rOFdu-Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcyMjY1OA==", "bodyText": "Can we check context / event loop after await too? I guess that's the equivalent of a callback in future style and it would be incorrect if the context was wrong here and we needed to make another backend call.", "url": "https://github.com/line/armeria/pull/2399#discussion_r366722658", "createdAt": "2020-01-15T07:12:53Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.google.common.base.Splitter\n+import com.google.common.collect.ImmutableList\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly\n+import java.time.Duration\n+import java.util.stream.Collectors\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+import kotlinx.coroutines.withContext\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+            val numsFromRequest = async { fetchFromRequest(ctx, req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+\n+            val backendResponses =\n+                awaitAll(\n+                    *nums.map { num ->\n+                        // The context is mounted in a thread-local, meaning it is available to all logic such\n+                        // as tracing.\n+                        require(ServiceRequestContext.current() === ctx)\n+                        require(ctx.eventLoop().inEventLoop())\n+                        backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                    }.toTypedArray()\n+                ).toList()\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(AggregatedHttpResponse::contentUtf8)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(ctx: ServiceRequestContext, req: HttpRequest): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+        val aggregatedHttpRequest = req.aggregate().await()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1347547769ad01554b6c6769bc1615076c683c39"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTc2ODQwOnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNzoxNToxNVrOFdvArg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowMzoyNlrOFdy-fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcyMzI0Ng==", "bodyText": "What do you think about withContext vs CompletableFuture.supplyAsync().await()? I'm a bit worried about using a suspending function inside this block which I think would change threads and possibly break something like a transaction. I guess suspension should generally be prevented for uses of blocking executor, do you know if there's a simpler way to do that?", "url": "https://github.com/line/armeria/pull/2399#discussion_r366723246", "createdAt": "2020-01-15T07:15:15Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.google.common.base.Splitter\n+import com.google.common.collect.ImmutableList\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly\n+import java.time.Duration\n+import java.util.stream.Collectors\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+import kotlinx.coroutines.withContext\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+            val numsFromRequest = async { fetchFromRequest(ctx, req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+\n+            val backendResponses =\n+                awaitAll(\n+                    *nums.map { num ->\n+                        // The context is mounted in a thread-local, meaning it is available to all logic such\n+                        // as tracing.\n+                        require(ServiceRequestContext.current() === ctx)\n+                        require(ctx.eventLoop().inEventLoop())\n+                        backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                    }.toTypedArray()\n+                ).toList()\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(AggregatedHttpResponse::contentUtf8)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(ctx: ServiceRequestContext, req: HttpRequest): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+        val aggregatedHttpRequest = req.aggregate().await()\n+        val nums = mutableListOf<Long>()\n+        for (token in Iterables.concat(\n+            NUM_SPLITTER.split(aggregatedHttpRequest.path().substring(1)),\n+            NUM_SPLITTER.split(aggregatedHttpRequest.contentUtf8())\n+        )) {\n+            nums.add(token.toLong())\n+        }\n+        return nums\n+    }\n+\n+    private suspend fun fetchFromFakeDb(ctx: ServiceRequestContext): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        return withContext(ctx.blockingTaskExecutor().asCoroutineDispatcher()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1347547769ad01554b6c6769bc1615076c683c39"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NzE2Ng==", "bodyText": "You mean user may do like below?\nreturn withContext(ctx.blockingTaskExecutor().asCoroutineDispatcher()) {\n            ..\n            // begin tx\n            ..\n            anotherSuspendFunction();\n            ..\n            // end tx\n        }\n\nIf so, maybe as you said we should wrap whole tx in one CompletableFuture.supplyAsync().", "url": "https://github.com/line/armeria/pull/2399#discussion_r366767166", "createdAt": "2020-01-15T09:21:06Z", "author": {"login": "kojilin"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.google.common.base.Splitter\n+import com.google.common.collect.ImmutableList\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly\n+import java.time.Duration\n+import java.util.stream.Collectors\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+import kotlinx.coroutines.withContext\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+            val numsFromRequest = async { fetchFromRequest(ctx, req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+\n+            val backendResponses =\n+                awaitAll(\n+                    *nums.map { num ->\n+                        // The context is mounted in a thread-local, meaning it is available to all logic such\n+                        // as tracing.\n+                        require(ServiceRequestContext.current() === ctx)\n+                        require(ctx.eventLoop().inEventLoop())\n+                        backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                    }.toTypedArray()\n+                ).toList()\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(AggregatedHttpResponse::contentUtf8)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(ctx: ServiceRequestContext, req: HttpRequest): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+        val aggregatedHttpRequest = req.aggregate().await()\n+        val nums = mutableListOf<Long>()\n+        for (token in Iterables.concat(\n+            NUM_SPLITTER.split(aggregatedHttpRequest.path().substring(1)),\n+            NUM_SPLITTER.split(aggregatedHttpRequest.contentUtf8())\n+        )) {\n+            nums.add(token.toLong())\n+        }\n+        return nums\n+    }\n+\n+    private suspend fun fetchFromFakeDb(ctx: ServiceRequestContext): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        return withContext(ctx.blockingTaskExecutor().asCoroutineDispatcher()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcyMzI0Ng=="}, "originalCommit": {"oid": "1347547769ad01554b6c6769bc1615076c683c39"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MDQxOQ==", "bodyText": "Yeah that's what I'm a bit worried about - maybe it's too much worrying ;) But I wish there were a good pattern to prevent suspension within a certain block of code, couldn't find anything with some googling but it seems important enough to be in Kotlin.", "url": "https://github.com/line/armeria/pull/2399#discussion_r366770419", "createdAt": "2020-01-15T09:27:53Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.google.common.base.Splitter\n+import com.google.common.collect.ImmutableList\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly\n+import java.time.Duration\n+import java.util.stream.Collectors\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+import kotlinx.coroutines.withContext\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+            val numsFromRequest = async { fetchFromRequest(ctx, req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+\n+            val backendResponses =\n+                awaitAll(\n+                    *nums.map { num ->\n+                        // The context is mounted in a thread-local, meaning it is available to all logic such\n+                        // as tracing.\n+                        require(ServiceRequestContext.current() === ctx)\n+                        require(ctx.eventLoop().inEventLoop())\n+                        backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                    }.toTypedArray()\n+                ).toList()\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(AggregatedHttpResponse::contentUtf8)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(ctx: ServiceRequestContext, req: HttpRequest): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+        val aggregatedHttpRequest = req.aggregate().await()\n+        val nums = mutableListOf<Long>()\n+        for (token in Iterables.concat(\n+            NUM_SPLITTER.split(aggregatedHttpRequest.path().substring(1)),\n+            NUM_SPLITTER.split(aggregatedHttpRequest.contentUtf8())\n+        )) {\n+            nums.add(token.toLong())\n+        }\n+        return nums\n+    }\n+\n+    private suspend fun fetchFromFakeDb(ctx: ServiceRequestContext): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        return withContext(ctx.blockingTaskExecutor().asCoroutineDispatcher()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcyMzI0Ng=="}, "originalCommit": {"oid": "1347547769ad01554b6c6769bc1615076c683c39"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4ODIyMA==", "bodyText": "Agree, I have updated the code.\nI'm not familiar with reactive transaction. https://spring.io/blog/2019/05/16/reactive-transactions-with-spring. Looks like it can allow us to suspend during tx.", "url": "https://github.com/line/armeria/pull/2399#discussion_r366788220", "createdAt": "2020-01-15T10:03:26Z", "author": {"login": "kojilin"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/MainService.kt", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.google.common.base.Splitter\n+import com.google.common.collect.ImmutableList\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly\n+import java.time.Duration\n+import java.util.stream.Collectors\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+import kotlinx.coroutines.withContext\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+            val numsFromRequest = async { fetchFromRequest(ctx, req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+\n+            val backendResponses =\n+                awaitAll(\n+                    *nums.map { num ->\n+                        // The context is mounted in a thread-local, meaning it is available to all logic such\n+                        // as tracing.\n+                        require(ServiceRequestContext.current() === ctx)\n+                        require(ctx.eventLoop().inEventLoop())\n+                        backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                    }.toTypedArray()\n+                ).toList()\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(AggregatedHttpResponse::contentUtf8)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(ctx: ServiceRequestContext, req: HttpRequest): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+        val aggregatedHttpRequest = req.aggregate().await()\n+        val nums = mutableListOf<Long>()\n+        for (token in Iterables.concat(\n+            NUM_SPLITTER.split(aggregatedHttpRequest.path().substring(1)),\n+            NUM_SPLITTER.split(aggregatedHttpRequest.contentUtf8())\n+        )) {\n+            nums.add(token.toLong())\n+        }\n+        return nums\n+    }\n+\n+    private suspend fun fetchFromFakeDb(ctx: ServiceRequestContext): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        return withContext(ctx.blockingTaskExecutor().asCoroutineDispatcher()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcyMzI0Ng=="}, "originalCommit": {"oid": "1347547769ad01554b6c6769bc1615076c683c39"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTg4ODQ2OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/Main.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoxOToxOVrOFdwIkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoxOToxOVrOFdwIkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MTY0OQ==", "bodyText": "nit: Could you add empty lines for improving readability?", "url": "https://github.com/line/armeria/pull/2399#discussion_r366741649", "createdAt": "2020-01-15T08:19:19Z", "author": {"login": "ikhoon"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/manual/Main.kt", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.manual\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.common.HttpStatus\n+import com.linecorp.armeria.server.Server\n+\n+fun main(args: Array<String>) {\n+    val backend = Server.builder()\n+        .service(\"/square/{num}\") { ctx, _ ->\n+            val num = ctx.pathParam(\"num\")?.toLong()\n+            if (num != null) {\n+                HttpResponse.of((num * num).toString())\n+            } else {\n+                HttpResponse.of(HttpStatus.BAD_REQUEST)\n+            }\n+        }\n+        .http(8081)\n+        .build()\n+    val backendClient = WebClient.of(\"http://localhost:8081\")\n+    val frontend = Server.builder()\n+        .http(8080)\n+        .serviceUnder(\"/\", MainService(backendClient))\n+        .build()\n+    Runtime.getRuntime().addShutdownHook(Thread {\n+        backend.stop().join()\n+        frontend.stop().join()\n+    })\n+    backend.start().join()\n+    frontend.start().join()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1347547769ad01554b6c6769bc1615076c683c39"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjE4MzMwOnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/kotlin/MainService.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowMTozOFrOFdy6rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowNjo1MFrOFdzFRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NzI0Nw==", "bodyText": "Maybe this type came automatically from intellij", "url": "https://github.com/line/armeria/pull/2399#discussion_r366787247", "createdAt": "2020-01-15T10:01:38Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/kotlin/MainService.kt", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.kotlin\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.google.common.base.Splitter\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles\n+import java.time.Duration\n+import java.util.concurrent.CompletableFuture\n+import java.util.function.Supplier\n+import java.util.stream.Collectors\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+\n+            val numsFromRequest = async { fetchFromRequest(ctx, req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+\n+            // The context is kept after resume.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+\n+            val backendResponses =\n+                awaitAll(\n+                    *nums.map { num ->\n+                        // The context is mounted in a thread-local, meaning it is available to all logic such\n+                        // as tracing.\n+                        require(ServiceRequestContext.current() === ctx)\n+                        require(ctx.eventLoop().inEventLoop())\n+\n+                        backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                    }.toTypedArray()\n+                ).toList()\n+\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(AggregatedHttpResponse::contentUtf8)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(ctx: ServiceRequestContext, req: HttpRequest): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+\n+        val aggregatedHttpRequest = req.aggregate().await()\n+\n+        // The context is kept after resume.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+\n+        val nums = mutableListOf<Long>()\n+        for (token in Iterables.concat(\n+            NUM_SPLITTER.split(aggregatedHttpRequest.path().substring(1)),\n+            NUM_SPLITTER.split(aggregatedHttpRequest.contentUtf8())\n+        )) {\n+            nums.add(token.toLong())\n+        }\n+        return nums\n+    }\n+\n+    private suspend fun fetchFromFakeDb(ctx: ServiceRequestContext): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        return CompletableFuture.supplyAsync(\n+            Supplier<List<Long>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df41f1c27f3e4b2d57c62ddcdd060c5e2608c91e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4OTk1Nw==", "bodyText": "Looks like kotlin failed to infer the type, so I need to add it explicitly.", "url": "https://github.com/line/armeria/pull/2399#discussion_r366789957", "createdAt": "2020-01-15T10:06:50Z", "author": {"login": "kojilin"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/kotlin/MainService.kt", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.kotlin\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.google.common.base.Splitter\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles\n+import java.time.Duration\n+import java.util.concurrent.CompletableFuture\n+import java.util.function.Supplier\n+import java.util.stream.Collectors\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+\n+            val numsFromRequest = async { fetchFromRequest(ctx, req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+\n+            // The context is kept after resume.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+\n+            val backendResponses =\n+                awaitAll(\n+                    *nums.map { num ->\n+                        // The context is mounted in a thread-local, meaning it is available to all logic such\n+                        // as tracing.\n+                        require(ServiceRequestContext.current() === ctx)\n+                        require(ctx.eventLoop().inEventLoop())\n+\n+                        backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                    }.toTypedArray()\n+                ).toList()\n+\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(AggregatedHttpResponse::contentUtf8)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(ctx: ServiceRequestContext, req: HttpRequest): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+\n+        val aggregatedHttpRequest = req.aggregate().await()\n+\n+        // The context is kept after resume.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+\n+        val nums = mutableListOf<Long>()\n+        for (token in Iterables.concat(\n+            NUM_SPLITTER.split(aggregatedHttpRequest.path().substring(1)),\n+            NUM_SPLITTER.split(aggregatedHttpRequest.contentUtf8())\n+        )) {\n+            nums.add(token.toLong())\n+        }\n+        return nums\n+    }\n+\n+    private suspend fun fetchFromFakeDb(ctx: ServiceRequestContext): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        return CompletableFuture.supplyAsync(\n+            Supplier<List<Long>> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NzI0Nw=="}, "originalCommit": {"oid": "df41f1c27f3e4b2d57c62ddcdd060c5e2608c91e"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjE4NDE0OnYy", "diffSide": "RIGHT", "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/kotlin/MainService.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowMTo1MlrOFdy7NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowMTo1MlrOFdy7NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NzM4MA==", "bodyText": "Static import was lost (not a big deal) and spaces around parens (bigger deal)", "url": "https://github.com/line/armeria/pull/2399#discussion_r366787380", "createdAt": "2020-01-15T10:01:52Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/kotlin/MainService.kt", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.contextpropagation.kotlin\n+\n+import com.linecorp.armeria.client.WebClient\n+import com.linecorp.armeria.common.AggregatedHttpResponse\n+import com.linecorp.armeria.common.HttpRequest\n+import com.linecorp.armeria.common.HttpResponse\n+import com.linecorp.armeria.server.HttpService\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.google.common.base.Splitter\n+import com.google.common.collect.Iterables\n+import com.google.common.util.concurrent.Uninterruptibles\n+import java.time.Duration\n+import java.util.concurrent.CompletableFuture\n+import java.util.function.Supplier\n+import java.util.stream.Collectors\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.awaitAll\n+import kotlinx.coroutines.future.asDeferred\n+import kotlinx.coroutines.future.await\n+import kotlinx.coroutines.future.future\n+\n+class MainService(private val backendClient: WebClient) : HttpService {\n+    override fun serve(ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {\n+        val ctxExecutor = ctx.contextAwareExecutor()\n+        val response = GlobalScope.future(ctxExecutor.asCoroutineDispatcher()) {\n+\n+            val numsFromRequest = async { fetchFromRequest(ctx, req) }\n+            val numsFromDb = async { fetchFromFakeDb(ctx) }\n+            val nums = awaitAll(numsFromRequest, numsFromDb).flatten()\n+\n+            // The context is kept after resume.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+\n+            val backendResponses =\n+                awaitAll(\n+                    *nums.map { num ->\n+                        // The context is mounted in a thread-local, meaning it is available to all logic such\n+                        // as tracing.\n+                        require(ServiceRequestContext.current() === ctx)\n+                        require(ctx.eventLoop().inEventLoop())\n+\n+                        backendClient.get(\"/square/$num\").aggregate().asDeferred()\n+                    }.toTypedArray()\n+                ).toList()\n+\n+            // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+            require(ServiceRequestContext.current() === ctx)\n+            require(ctx.eventLoop().inEventLoop())\n+\n+            HttpResponse.of(\n+                backendResponses.stream()\n+                    .map(AggregatedHttpResponse::contentUtf8)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            )\n+        }\n+        return HttpResponse.from(response)\n+    }\n+\n+    private suspend fun fetchFromRequest(ctx: ServiceRequestContext, req: HttpRequest): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+\n+        val aggregatedHttpRequest = req.aggregate().await()\n+\n+        // The context is kept after resume.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+\n+        val nums = mutableListOf<Long>()\n+        for (token in Iterables.concat(\n+            NUM_SPLITTER.split(aggregatedHttpRequest.path().substring(1)),\n+            NUM_SPLITTER.split(aggregatedHttpRequest.contentUtf8())\n+        )) {\n+            nums.add(token.toLong())\n+        }\n+        return nums\n+    }\n+\n+    private suspend fun fetchFromFakeDb(ctx: ServiceRequestContext): List<Long> {\n+        // The context is mounted in a thread-local, meaning it is available to all logic such as tracing.\n+        require(ServiceRequestContext.current() === ctx)\n+        require(ctx.eventLoop().inEventLoop())\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        return CompletableFuture.supplyAsync(\n+            Supplier<List<Long>> {\n+                // The context is mounted in a thread-local, meaning it is available to all logic such\n+                // as tracing.\n+                require(ServiceRequestContext.current() === ctx)\n+                require(!ctx.eventLoop().inEventLoop())\n+\n+                Uninterruptibles.sleepUninterruptibly( Duration.ofMillis( 50 ) )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df41f1c27f3e4b2d57c62ddcdd060c5e2608c91e"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2902, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}