{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4NzcxNjU1", "number": 3203, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDo0ODozNVrOE-HAyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNzoyNzowOFrOE-OmKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTYyMDU4OnYy", "diffSide": "RIGHT", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ArmeriaServerCall.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDo0ODozNVrOH7Ja2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNzo0MzoyN1rOH7Wdvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc4MjM2MQ==", "bodyText": "Any idea to use an other way? This is the last reference to HttpDeframer.close().", "url": "https://github.com/line/armeria/pull/3203#discussion_r531782361", "createdAt": "2020-11-27T20:48:35Z", "author": {"login": "trustin"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ArmeriaServerCall.java", "diffHunk": "@@ -502,10 +502,22 @@ public void transportReportStatus(Status status, Metadata unused) {\n     private void closeListener(Status newStatus) {\n         if (!listenerClosed) {\n             listenerClosed = true;\n+\n             ctx.logBuilder().responseContent(GrpcLogUtil.rpcResponse(newStatus, firstResponse), null);\n+\n             final boolean ok = newStatus.isOk();\n-            setClientStreamClosed(ok);\n-            messageFramer.close();\n+            if (!clientStreamClosed) {\n+                clientStreamClosed = true;\n+                if (ok) {\n+                    requestDeframer.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29150cbbfd5ee28d39223eeb1815f699e173ce62"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk5NjA5NA==", "bodyText": "I think it is safe to call HttpDeframer.abort() here", "url": "https://github.com/line/armeria/pull/3203#discussion_r531996094", "createdAt": "2020-11-28T07:43:27Z", "author": {"login": "ikhoon"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ArmeriaServerCall.java", "diffHunk": "@@ -502,10 +502,22 @@ public void transportReportStatus(Status status, Metadata unused) {\n     private void closeListener(Status newStatus) {\n         if (!listenerClosed) {\n             listenerClosed = true;\n+\n             ctx.logBuilder().responseContent(GrpcLogUtil.rpcResponse(newStatus, firstResponse), null);\n+\n             final boolean ok = newStatus.isOk();\n-            setClientStreamClosed(ok);\n-            messageFramer.close();\n+            if (!clientStreamClosed) {\n+                clientStreamClosed = true;\n+                if (ok) {\n+                    requestDeframer.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc4MjM2MQ=="}, "originalCommit": {"oid": "29150cbbfd5ee28d39223eeb1815f699e173ce62"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNjY3Njg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/stream/DefaultHttpDeframer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNjo0MzoxMlrOH7Tptg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNjo0MzoxMlrOH7Tptg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk1MDAwNg==", "bodyText": "nit: Remove redundant cast?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n          \n          \n            \n                            final ByteBuf byteBuf = byteBufConverter.apply(data);", "url": "https://github.com/line/armeria/pull/3203#discussion_r531950006", "createdAt": "2020-11-28T06:43:12Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/stream/DefaultHttpDeframer.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * The default {@link HttpDeframer} implementation.\n+ */\n+final class DefaultHttpDeframer<T>\n+        extends DefaultStreamMessage<T>\n+        implements HttpDeframer<T>, HttpDeframerOutput<T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultHttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<DefaultHttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(DefaultHttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<DefaultHttpDeframer> askedUpstreamForElementUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(DefaultHttpDeframer.class, \"askedUpstreamForElement\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean handlerProduced;\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile int initialized;\n+    private volatile int askedUpstreamForElement;\n+\n+    @Nullable\n+    private volatile Throwable cause;\n+    private volatile boolean cancelled;\n+    private volatile boolean completing;\n+\n+    /**\n+     * Returns a new {@link DefaultHttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    DefaultHttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+\n+        whenComplete().handle((unused1, unused2)  -> {\n+            // In addition to 'onComplete()', 'onError()' and 'cancel()',\n+            // make sure to call 'cleanup()' even when 'abort()' or 'close()' is invoked directly\n+            cleanup();\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public void add(T e) {\n+        if (tryWrite(e)) {\n+            handlerProduced = true;\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscriptionImpl == subscription) {\n+            final EventExecutor eventLoop = subscription.executor();\n+            this.eventLoop = eventLoop;\n+            deferredInit(eventLoop);\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit(@Nullable EventExecutor eventLoop) {\n+        final Subscription upstream = this.upstream;\n+\n+        if (upstream != null && eventLoop != null) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (cancelled) {\n+                    upstream.cancel();\n+                    return;\n+                }\n+\n+                final Throwable cause = this.cause;\n+                if (cause != null) {\n+                    if (eventLoop.inEventLoop()) {\n+                        onError0(cause);\n+                    } else {\n+                        eventLoop.execute(() -> onError0(cause));\n+                    }\n+                    return;\n+                }\n+\n+                if (completing) {\n+                    if (eventLoop.inEventLoop()) {\n+                        onComplete0();\n+                    } else {\n+                        eventLoop.execute(this::onComplete0);\n+                    }\n+                    return;\n+                }\n+\n+                if (demand() > 0) {\n+                    askUpstreamForElement();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        // Fetch from upstream only when this deframer is initialized and the given demand is valid.\n+        if (initialized != 0 && n > 0) {\n+            askUpstreamForElement();\n+        }\n+\n+        super.request(n);\n+    }\n+\n+    private void askUpstreamForElement() {\n+        if (askedUpstreamForElementUpdater.compareAndSet(this, 0, 1)) {\n+            final Subscription upstream = this.upstream;\n+            assert upstream != null;\n+            upstream.request(1);\n+        }\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit(eventLoop);\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        assert eventLoop != null;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject obj) {\n+        askedUpstreamForElement = 0;\n+        handlerProduced = false;\n+        try {\n+            // Call the handler so that it publishes something.\n+            if (obj instanceof HttpHeaders) {\n+                final HttpHeaders headers = (HttpHeaders) obj;\n+                if (headers instanceof ResponseHeaders &&\n+                    ((ResponseHeaders) headers).status().isInformational()) {\n+                    handler.processInformationalHeaders((ResponseHeaders) headers, this);\n+                } else if (!sawLeadingHeaders) {\n+                    sawLeadingHeaders = true;\n+                    handler.processHeaders((HttpHeaders) obj, this);\n+                } else {\n+                    handler.processTrailers((HttpHeaders) obj, this);\n+                }\n+            } else if (obj instanceof HttpData) {\n+                final HttpData data = (HttpData) obj;\n+                final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fafdd12ac516c3608ca25554d07bf512458ebda"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNjg2MzEzOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNzoyNzowOFrOH7VsnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQxNjowOTowOFrOH7aHVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MzUxNw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/line/armeria/pull/3203#discussion_r531983517", "createdAt": "2020-11-28T07:27:08Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -147,7 +154,7 @@ void timeout() {\n                         () -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n                                      .aggregate().join());\n                 assertThat(cause.getCause()).isInstanceOf(UnprocessedRequestException.class);\n-                assertThat(cause.getCause().getCause())\n+                assertThat(Throwables.getRootCause(cause))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fafdd12ac516c3608ca25554d07bf512458ebda"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAzNDI3NQ==", "bodyText": "The root cause is UnknownHostException?\nhttps://ci.appveyor.com/project/line/armeria/builds/36552679/job/omd5r3ft1vwdxa44#L595", "url": "https://github.com/line/armeria/pull/3203#discussion_r532034275", "createdAt": "2020-11-28T12:23:51Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -147,7 +154,7 @@ void timeout() {\n                         () -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n                                      .aggregate().join());\n                 assertThat(cause.getCause()).isInstanceOf(UnprocessedRequestException.class);\n-                assertThat(cause.getCause().getCause())\n+                assertThat(Throwables.getRootCause(cause))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MzUxNw=="}, "originalCommit": {"oid": "8fafdd12ac516c3608ca25554d07bf512458ebda"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA1NTg5Mw==", "bodyText": "No, it's not? \ud83d\ude04", "url": "https://github.com/line/armeria/pull/3203#discussion_r532055893", "createdAt": "2020-11-28T16:09:08Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -147,7 +154,7 @@ void timeout() {\n                         () -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n                                      .aggregate().join());\n                 assertThat(cause.getCause()).isInstanceOf(UnprocessedRequestException.class);\n-                assertThat(cause.getCause().getCause())\n+                assertThat(Throwables.getRootCause(cause))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MzUxNw=="}, "originalCommit": {"oid": "8fafdd12ac516c3608ca25554d07bf512458ebda"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2072, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}