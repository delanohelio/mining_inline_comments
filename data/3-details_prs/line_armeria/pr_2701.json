{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2MTE4OTQ2", "number": 2701, "title": "Support Eureka service discovery", "bodyText": "Motivation:\nIt will be nice if a user can easily do the service discovery using Eureka.\nModifications:\n\nAdd EurekEndointGroup and EurekaUpdatingListerner.\n\nResult:\n\nYou can now use Eureka for service discovery with Ameria server and client.\n\nTo-dos:\n\nSupport Eureka service discovery using a property file so that Spring users can easily migrate.\nSupport automatic health check using healthCheckUrl\nProvide a way to get information of InstanceInfos from EurekaEndpointGroup\nAdd document.", "createdAt": "2020-05-11T13:51:34Z", "url": "https://github.com/line/armeria/pull/2701", "merged": true, "mergeCommit": {"oid": "c7954d9b49871ebdb66bf055caa9ba40f3662f91"}, "closed": true, "closedAt": "2020-05-14T04:40:51Z", "author": {"login": "minwoox"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgQA_GgH2gAyNDE2MTE4OTQ2OjAyNDFlMjA3NWY2YzVmNmVmN2VlNDk0NDNlNGEyYTIwNzJlYmYwYTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchF7fIgFqTQxMTQ1OTY5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0241e2075f6c5f6ef7ee49443e4a2a2072ebf0a6", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/0241e2075f6c5f6ef7ee49443e4a2a2072ebf0a6", "committedDate": "2020-05-11T13:51:13Z", "message": "Support Eureka service discovery\nMotivation:\nIt will be nice if a user can easily do the service discovery using Eureka.\n\nModifications:\n- Add `EurekEndointGroup` and `EurekaUpdatingListerner`.\n\nResult:\n- You can now use Eureka for service discovery with Ameria server and client.\n\nTo-do:\n- Support Eureka service discovery using a property file so that Spring users can easily migrate.\n- Add document."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/e1d86e7bd8c552ecae204805938154c69c7f5b47", "committedDate": "2020-05-12T03:58:23Z", "message": "Fix javadoc and add license"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5d24441f103a0998e3afef22e39bcce8d26dd36", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/d5d24441f103a0998e3afef22e39bcce8d26dd36", "committedDate": "2020-05-12T06:48:04Z", "message": "Add test case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NzM4OTYx", "url": "https://github.com/line/armeria/pull/2701#pullrequestreview-409738961", "createdAt": "2020-05-12T06:40:19Z", "commit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNjo0MDoxOVrOGT4G3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzowMDoxOFrOGT4qsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NTM5MQ==", "bodyText": "How about sorting alphabetically instead?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423495391", "createdAt": "2020-05-12T06:40:19Z", "author": {"login": "trustin"}, "path": "dependencies.yml", "diffHunk": "@@ -103,14 +103,19 @@ com.google.j2objc:\n # See: https://github.com/grpc/grpc-java/blob/master/build.gradle\n #      (Switch to the right tag and look for 'protobufVersion' and 'protocVersion'.)\n com.google.protobuf:\n-  protoc: { version: '3.11.4' }\n-  protobuf-java: { version: &PROTOBUF_VERSION '3.11.4' }\n+  protoc: { version: &PROTOBUF_VERSION '3.11.4' }\n+  protobuf-java: { version: *PROTOBUF_VERSION }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzM1MQ==", "bodyText": "You need to respect content.length().", "url": "https://github.com/line/armeria/pull/2701#discussion_r423497351", "createdAt": "2020-05-12T06:44:39Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    private final long registryFetchIntervalSeconds;\n+\n+    private final RequestHeaders requestHeaders;\n+    private final Function<byte[], List<Endpoint>> responseConverter;\n+    private final WebClient webClient;\n+    @Nullable\n+    private volatile ScheduledFuture<?> scheduledFuture;\n+    private volatile boolean closed;\n+\n+    EurekaEndpointGroup(URI eurekaUri, long registryFetchIntervalSeconds, @Nullable String appName,\n+                        @Nullable String instanceId, @Nullable String vipAddress,\n+                        @Nullable String secureVipAddress, @Nullable List<String> regions,\n+                        @Nullable Consumer<WebClientBuilder> customizer) {\n+        this.registryFetchIntervalSeconds = registryFetchIntervalSeconds;\n+\n+        final RequestHeadersBuilder headersBuilder = RequestHeaders.builder();\n+        headersBuilder.method(HttpMethod.GET);\n+        headersBuilder.add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON_UTF_8);\n+        responseConverter = responseConverter(headersBuilder, appName, instanceId,\n+                                              vipAddress, secureVipAddress, regions);\n+        requestHeaders = headersBuilder.build();\n+\n+        final WebClientBuilder webClientBuilder = WebClient.builder(eurekaUri);\n+        if (customizer != null) {\n+            customizer.accept(webClientBuilder);\n+        }\n+        webClient = webClientBuilder.build();\n+        webClient.options().factory().whenClosed().thenRun(this::closeAsync);\n+        fetchRegistry();\n+    }\n+\n+    private void fetchRegistry() {\n+        final HttpResponse response;\n+        final ClientRequestContext ctx;\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            response = webClient.execute(requestHeaders);\n+            ctx = captor.get();\n+        }\n+\n+        final EventLoop eventLoop = ctx.eventLoop();\n+        response.aggregateWithPooledObjects(eventLoop, ctx.alloc()).handle((aggregatedRes, cause) -> {\n+            try {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Unexpected exception while fetching the registry from: {}.\" +\n+                                \" (requestHeaders: {})\", webClient.uri(), requestHeaders, cause);\n+                } else {\n+                    final HttpStatus status = aggregatedRes.status();\n+                    if (!status.isSuccess()) {\n+                        logger.warn(\"Unexpected response from: {}. (status: {}, content: {}, \" +\n+                                    \"requestHeaders: {})\", webClient.uri(), status,\n+                                    aggregatedRes.contentUtf8(), requestHeaders);\n+                    } else {\n+                        final HttpData content = aggregatedRes.content();\n+                        try {\n+                            final List<Endpoint> endpoints = responseConverter.apply(content.array());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzQ4Mg==", "bodyText": "Probably an overkill to use with pooled objects?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423497482", "createdAt": "2020-05-12T06:44:58Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    private final long registryFetchIntervalSeconds;\n+\n+    private final RequestHeaders requestHeaders;\n+    private final Function<byte[], List<Endpoint>> responseConverter;\n+    private final WebClient webClient;\n+    @Nullable\n+    private volatile ScheduledFuture<?> scheduledFuture;\n+    private volatile boolean closed;\n+\n+    EurekaEndpointGroup(URI eurekaUri, long registryFetchIntervalSeconds, @Nullable String appName,\n+                        @Nullable String instanceId, @Nullable String vipAddress,\n+                        @Nullable String secureVipAddress, @Nullable List<String> regions,\n+                        @Nullable Consumer<WebClientBuilder> customizer) {\n+        this.registryFetchIntervalSeconds = registryFetchIntervalSeconds;\n+\n+        final RequestHeadersBuilder headersBuilder = RequestHeaders.builder();\n+        headersBuilder.method(HttpMethod.GET);\n+        headersBuilder.add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON_UTF_8);\n+        responseConverter = responseConverter(headersBuilder, appName, instanceId,\n+                                              vipAddress, secureVipAddress, regions);\n+        requestHeaders = headersBuilder.build();\n+\n+        final WebClientBuilder webClientBuilder = WebClient.builder(eurekaUri);\n+        if (customizer != null) {\n+            customizer.accept(webClientBuilder);\n+        }\n+        webClient = webClientBuilder.build();\n+        webClient.options().factory().whenClosed().thenRun(this::closeAsync);\n+        fetchRegistry();\n+    }\n+\n+    private void fetchRegistry() {\n+        final HttpResponse response;\n+        final ClientRequestContext ctx;\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            response = webClient.execute(requestHeaders);\n+            ctx = captor.get();\n+        }\n+\n+        final EventLoop eventLoop = ctx.eventLoop();\n+        response.aggregateWithPooledObjects(eventLoop, ctx.alloc()).handle((aggregatedRes, cause) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzcxOQ==", "bodyText": "parsing a response", "url": "https://github.com/line/armeria/pull/2701#discussion_r423497719", "createdAt": "2020-05-12T06:45:29Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    private final long registryFetchIntervalSeconds;\n+\n+    private final RequestHeaders requestHeaders;\n+    private final Function<byte[], List<Endpoint>> responseConverter;\n+    private final WebClient webClient;\n+    @Nullable\n+    private volatile ScheduledFuture<?> scheduledFuture;\n+    private volatile boolean closed;\n+\n+    EurekaEndpointGroup(URI eurekaUri, long registryFetchIntervalSeconds, @Nullable String appName,\n+                        @Nullable String instanceId, @Nullable String vipAddress,\n+                        @Nullable String secureVipAddress, @Nullable List<String> regions,\n+                        @Nullable Consumer<WebClientBuilder> customizer) {\n+        this.registryFetchIntervalSeconds = registryFetchIntervalSeconds;\n+\n+        final RequestHeadersBuilder headersBuilder = RequestHeaders.builder();\n+        headersBuilder.method(HttpMethod.GET);\n+        headersBuilder.add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON_UTF_8);\n+        responseConverter = responseConverter(headersBuilder, appName, instanceId,\n+                                              vipAddress, secureVipAddress, regions);\n+        requestHeaders = headersBuilder.build();\n+\n+        final WebClientBuilder webClientBuilder = WebClient.builder(eurekaUri);\n+        if (customizer != null) {\n+            customizer.accept(webClientBuilder);\n+        }\n+        webClient = webClientBuilder.build();\n+        webClient.options().factory().whenClosed().thenRun(this::closeAsync);\n+        fetchRegistry();\n+    }\n+\n+    private void fetchRegistry() {\n+        final HttpResponse response;\n+        final ClientRequestContext ctx;\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            response = webClient.execute(requestHeaders);\n+            ctx = captor.get();\n+        }\n+\n+        final EventLoop eventLoop = ctx.eventLoop();\n+        response.aggregateWithPooledObjects(eventLoop, ctx.alloc()).handle((aggregatedRes, cause) -> {\n+            try {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Unexpected exception while fetching the registry from: {}.\" +\n+                                \" (requestHeaders: {})\", webClient.uri(), requestHeaders, cause);\n+                } else {\n+                    final HttpStatus status = aggregatedRes.status();\n+                    if (!status.isSuccess()) {\n+                        logger.warn(\"Unexpected response from: {}. (status: {}, content: {}, \" +\n+                                    \"requestHeaders: {})\", webClient.uri(), status,\n+                                    aggregatedRes.contentUtf8(), requestHeaders);\n+                    } else {\n+                        final HttpData content = aggregatedRes.content();\n+                        try {\n+                            final List<Endpoint> endpoints = responseConverter.apply(content.array());\n+                            setEndpoints(endpoints);\n+                        } catch (Exception e) {\n+                            logger.warn(\"Unexpected exception while parsing response from: {}. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTI2Mg==", "bodyText": "Would it make sense to extend AbstractClientOptionsBuilder instead of exposing customizer(), like we did for ArmeriaRetrofitBuilder?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423499262", "createdAt": "2020-05-12T06:49:00Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+\n+/**\n+ * Builds a {@link EurekaEndpointGroup}.\n+ */\n+public final class EurekaEndpointGroupBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTgzMQ==", "bodyText": "Is there any chance this could be an arbitrary string?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423499831", "createdAt": "2020-05-12T06:50:15Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/common/eureka/DataCenterName.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.eureka;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The data center names.\n+ */\n+public enum DataCenterName {\n+    Netflix,\n+    Amazon,\n+    MyOwn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTAwNA==", "bodyText": "This could be removed?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501004", "createdAt": "2020-05-12T06:52:55Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTI0MA==", "bodyText": "This could be removed?\nderegisters", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501240", "createdAt": "2020-05-12T06:53:27Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTQ1Mg==", "bodyText": "a cancellation request?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501452", "createdAt": "2020-05-12T06:53:59Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTgxOA==", "bodyText": "What's an instance ID? Is it possible to use the current hostname, IP address or some hashed value of them as the default instance ID?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501818", "createdAt": "2020-05-12T06:54:46Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTk1Nw==", "bodyText": "Ditto - overkill?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501957", "createdAt": "2020-05-12T06:55:01Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMjcyNw==", "bodyText": "Would !...isSuccess() work here?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423502727", "createdAt": "2020-05-12T06:56:36Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                try {\n+                    if (cause != null) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                    newInfo.getHostName(), client.uri(), cause);\n+                        return null;\n+                    }\n+                    final ResponseHeaders headers = res.headers();\n+                    if (headers.status() != HttpStatus.NO_CONTENT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMzE4Nw==", "bodyText": "Curious if we need to renew the lease a little bit sooner than specified to avoid timing issues. Thoughts?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423503187", "createdAt": "2020-05-12T06:57:29Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                try {\n+                    if (cause != null) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                    newInfo.getHostName(), client.uri(), cause);\n+                        return null;\n+                    }\n+                    final ResponseHeaders headers = res.headers();\n+                    if (headers.status() != HttpStatus.NO_CONTENT) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                    newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());\n+                    }\n+                    logger.info(\"Registered {} to Eureka: {}\", newInfo.getHostName(), client.uri());\n+                    scheduleHeartBeat(ctx, newInfo);\n+                    return null;\n+                } finally {\n+                    ReferenceCountUtil.release(res.content());\n+                }\n+            });\n+        }\n+    }\n+\n+    private void scheduleHeartBeat(ClientRequestContext ctx, InstanceInfo newInfo) {\n+        heartBeatFuture = ctx.eventLoop().schedule(new HeartBeatTask(ctx, newInfo),\n+                                                   newInfo.getLeaseInfo().getRenewalIntervalInSecs(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDU2MQ==", "bodyText": "Ditto - overkill", "url": "https://github.com/line/armeria/pull/2701#discussion_r423504561", "createdAt": "2020-05-12T07:00:18Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                try {\n+                    if (cause != null) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                    newInfo.getHostName(), client.uri(), cause);\n+                        return null;\n+                    }\n+                    final ResponseHeaders headers = res.headers();\n+                    if (headers.status() != HttpStatus.NO_CONTENT) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                    newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());\n+                    }\n+                    logger.info(\"Registered {} to Eureka: {}\", newInfo.getHostName(), client.uri());\n+                    scheduleHeartBeat(ctx, newInfo);\n+                    return null;\n+                } finally {\n+                    ReferenceCountUtil.release(res.content());\n+                }\n+            });\n+        }\n+    }\n+\n+    private void scheduleHeartBeat(ClientRequestContext ctx, InstanceInfo newInfo) {\n+        heartBeatFuture = ctx.eventLoop().schedule(new HeartBeatTask(ctx, newInfo),\n+                                                   newInfo.getLeaseInfo().getRenewalIntervalInSecs(),\n+                                                   TimeUnit.SECONDS);\n+    }\n+\n+    private InstanceInfo fillAndCreateNewInfo(InstanceInfo oldInfo, Server server) {\n+        final String defaultHostname = server.defaultHostname();\n+        final String hostName = oldInfo.getHostName() != null ? oldInfo.getHostName() : defaultHostname;\n+        appName = oldInfo.getAppName() != null ? oldInfo.getAppName() : defaultHostname;\n+\n+        final Inet4Address defaultInet4Address = SystemInfo.defaultNonLoopbackIpV4Address();\n+        final String defaultIpAddr = defaultInet4Address != null ? defaultInet4Address.getHostAddress()\n+                                                                 : null;\n+        final String ipAddr = oldInfo.getIpAddr() != null ? oldInfo.getIpAddr() : defaultIpAddr;\n+        final PortWrapper oldPortWrapper = oldInfo.getPort();\n+        final PortWrapper portWrapper = portWrapper(server, oldPortWrapper, SessionProtocol.HTTP);\n+        final PortWrapper oldSecurePortWrapper = oldInfo.getSecurePort();\n+        final PortWrapper securePortWrapper = portWrapper(server, oldSecurePortWrapper, SessionProtocol.HTTPS);\n+\n+        final String vipAddress = vipAddress(oldInfo.getVipAddress(), hostName, portWrapper);\n+        final String secureVipAddress = vipAddress(oldInfo.getSecureVipAddress(), hostName, securePortWrapper);\n+\n+        final Optional<ServiceConfig> healthCheckService =\n+                server.serviceConfigs()\n+                      .stream()\n+                      .filter(cfg -> cfg.service().as(HealthCheckService.class) != null)\n+                      .findFirst();\n+\n+        final String hostnameOrIpAddr;\n+        if (oldInfo.getHostName() != null) {\n+            hostnameOrIpAddr = oldInfo.getHostName();\n+        } else if (ipAddr != null) {\n+            hostnameOrIpAddr = ipAddr;\n+        } else {\n+            hostnameOrIpAddr = hostName;\n+        }\n+        final String healthCheckUrl = healthCheckUrl(hostnameOrIpAddr, oldInfo.getHealthCheckUrl(), portWrapper,\n+                                                     healthCheckService, SessionProtocol.HTTP);\n+        final String secureHealthCheckUrl =\n+                healthCheckUrl(hostnameOrIpAddr, oldInfo.getSecureHealthCheckUrl(), securePortWrapper,\n+                               healthCheckService, SessionProtocol.HTTPS);\n+\n+        return new InstanceInfo(oldInfo.getInstanceId(), appName, oldInfo.getAppGroupName(), hostName, ipAddr,\n+                                vipAddress, secureVipAddress, portWrapper, securePortWrapper, InstanceStatus.UP,\n+                                oldInfo.getHomePageUrl(), oldInfo.getStatusPageUrl(), healthCheckUrl,\n+                                secureHealthCheckUrl, oldInfo.getDataCenterInfo(),\n+                                oldInfo.getLeaseInfo(), oldInfo.getMetadata());\n+    }\n+\n+    private static PortWrapper portWrapper(Server server, PortWrapper oldPortWrapper,\n+                                           SessionProtocol protocol) {\n+        if (oldPortWrapper.isEnabled()) {\n+            for (ServerPort serverPort : server.activePorts().values()) {\n+                if (serverPort.hasProtocol(protocol) &&\n+                    serverPort.localAddress().getPort() == oldPortWrapper.getPort()) {\n+                    return oldPortWrapper;\n+                }\n+            }\n+            logger.warn(\"The port number: {} (expected one of activePorts: {})\",\n+                        oldPortWrapper.getPort(), server.activePorts());\n+        }\n+\n+        final ServerPort serverPort = server.activePort(protocol);\n+        if (serverPort == null) {\n+            return disabledPort;\n+        }\n+        return new PortWrapper(true, serverPort.localAddress().getPort());\n+    }\n+\n+    @Nullable\n+    private static String vipAddress(@Nullable String vipAddress, String hostName, PortWrapper portWrapper) {\n+        if (!portWrapper.isEnabled()) {\n+            return null;\n+        }\n+        return vipAddress != null ? vipAddress : hostName + ':' + portWrapper.getPort();\n+    }\n+\n+    @Nullable\n+    private static String healthCheckUrl(String hostnameOrIpAddr, @Nullable String oldHealthCheckUrl,\n+                                         PortWrapper portWrapper,\n+                                         Optional<ServiceConfig> healthCheckService,\n+                                         SessionProtocol sessionProtocol) {\n+        if (oldHealthCheckUrl != null) {\n+            return oldHealthCheckUrl;\n+        }\n+        if (!portWrapper.isEnabled() || !healthCheckService.isPresent()) {\n+            return null;\n+        }\n+        final ServiceConfig healthCheckServiceConfig = healthCheckService.get();\n+        final Route route = healthCheckServiceConfig.route();\n+        if (route.pathType() != RoutePathType.EXACT && route.pathType() != RoutePathType.PREFIX) {\n+            return null;\n+        }\n+\n+        return sessionProtocol.uriText() + \"://\" + hostnameOrIpAddr + ':' + portWrapper.getPort() +\n+               route.paths().get(0);\n+    }\n+\n+    @Override\n+    public void serverStopping(Server server) throws Exception {\n+        closed = true;\n+        final ScheduledFuture<?> heartBeatFuture = this.heartBeatFuture;\n+        if (heartBeatFuture != null) {\n+            heartBeatFuture.cancel(false);\n+        }\n+        final String appName = this.appName;\n+        if (appName != null) {\n+            client.cancel(appName, instanceInfo.getInstanceId()).aggregate().handle((res, cause) -> {\n+                if (cause != null) {\n+                    logger.warn(\"Failed to deregister from Eureka: {}\", client.uri(), cause);\n+                } else if (!res.status().isSuccess()) {\n+                    logger.warn(\"Failed to deregister from Eureka: {} (status: {}, content: {})\",\n+                                client.uri(), res.status(), res.contentUtf8());\n+                }\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private class HeartBeatTask implements Runnable {\n+\n+        private final ClientRequestContext ctx;\n+        private final InstanceInfo instanceInfo;\n+\n+        HeartBeatTask(ClientRequestContext ctx, InstanceInfo instanceInfo) {\n+            this.ctx = ctx;\n+            this.instanceInfo = instanceInfo;\n+        }\n+\n+        @Override\n+        public void run() {\n+            final String appName = instanceInfo.getAppName();\n+            assert appName != null;\n+            client.sendHeartBeat(appName, instanceInfo.getInstanceId(), instanceInfo, null)\n+                  .aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47"}, "originalPosition": 265}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "committedDate": "2020-05-12T10:17:00Z", "message": "Address the comments by @trustin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5OTU0MTcx", "url": "https://github.com/line/armeria/pull/2701#pullrequestreview-409954171", "createdAt": "2020-05-12T11:38:56Z", "commit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTozODo1N1rOGUCgEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjozODoxNFrOGUEhAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2NTY4MA==", "bodyText": "Could replace with String.join(\",\", regions)?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423665680", "createdAt": "2020-05-12T11:38:57Z", "author": {"login": "ikhoon"}, "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.collect.Iterables;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+\n+/**\n+ * A Eureka {@link WebClient} which communicates to the\n+ * <a href=\"https://github.com/Netflix/eureka/wiki/Eureka-REST-operations\">Eureka registry</a>.\n+ */\n+public final class EurekaWebClient {\n+\n+    private static final String APPS = \"/apps/\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    private final WebClient webClient;\n+    private final ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.WRAP_ROOT_VALUE)\n+                                                          .setSerializationInclusion(Include.NON_NULL);\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public EurekaWebClient(WebClient webClient) {\n+        this.webClient = requireNonNull(webClient, \"webClient\");\n+    }\n+\n+    /**\n+     * Returns the {@link URI} of the Eureka registry.\n+     */\n+    public URI uri() {\n+        return webClient.uri();\n+    }\n+\n+    /**\n+     * Registers the specified {@link InstanceInfo} to the Eureka registry.\n+     */\n+    public HttpResponse register(InstanceInfo info) {\n+        requireNonNull(info, \"info\");\n+        final String path = APPS + info.getAppName();\n+        final RequestHeaders headers = RequestHeaders.builder(HttpMethod.POST, path)\n+                                                     .contentType(MediaType.JSON)\n+                                                     .build();\n+        try {\n+            return webClient.execute(headers, mapper.writeValueAsBytes(info));\n+        } catch (JsonProcessingException e) {\n+            return HttpResponse.ofFailure(e);\n+        }\n+    }\n+\n+    /**\n+     * Sends the heart beat to the Eureka registry.\n+     */\n+    public HttpResponse sendHeartBeat(String appName, String instanceId, InstanceInfo instanceInfo,\n+                                      @Nullable InstanceStatus overriddenStatus) {\n+        requireNonNull(appName, \"appName\");\n+        requireNonNull(instanceId, \"instanceId\");\n+        requireNonNull(instanceInfo, \"instanceInfo\");\n+        final String path = APPS + appName + '/' + instanceId;\n+        final QueryParamsBuilder queryBuilder =\n+                QueryParams.builder()\n+                           .add(\"status\", instanceInfo.getStatus().toString())\n+                           .addLong(\"lastDirtyTimestamp\", instanceInfo.getLastDirtyTimestamp());\n+        if (overriddenStatus != null) {\n+            queryBuilder.add(\"overriddenstatus\", overriddenStatus.toString());\n+        }\n+        final RequestHeaders headers =\n+                RequestHeaders.builder(HttpMethod.PUT, path + '?' + queryBuilder.toQueryString())\n+                              .add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON)\n+                              .build();\n+        return webClient.execute(headers);\n+    }\n+\n+    /**\n+     * Deregisters the specified {@code instanceId} in {@code appName} from the Eureka registry.\n+     */\n+    public HttpResponse cancel(String appName, String instanceId) {\n+        requireNonNull(appName, \"appName\");\n+        requireNonNull(instanceId, \"instanceId\");\n+        final String path = APPS + appName + '/' + instanceId;\n+        return webClient.delete(path);\n+    }\n+\n+    /**\n+     * Retrieves the registry information whose regions are the specified {@code regions} from the Eureka.\n+     */\n+    public HttpResponse getApplications(Iterable<String> regions) {\n+        return getApplications(APPS, requireNonNull(regions, \"regions\"));\n+    }\n+\n+    private HttpResponse getApplications(String path, Iterable<String> regions) {\n+        if (!Iterables.isEmpty(regions)) {\n+            final StringJoiner joiner = new StringJoiner(\",\");\n+            regions.forEach(joiner::add);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2ODI3NA==", "bodyText": "I'd prefer deregister as this method name so that we can make consistency with register(InstanceInfo info).", "url": "https://github.com/line/armeria/pull/2701#discussion_r423668274", "createdAt": "2020-05-12T11:44:06Z", "author": {"login": "ikhoon"}, "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.collect.Iterables;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+\n+/**\n+ * A Eureka {@link WebClient} which communicates to the\n+ * <a href=\"https://github.com/Netflix/eureka/wiki/Eureka-REST-operations\">Eureka registry</a>.\n+ */\n+public final class EurekaWebClient {\n+\n+    private static final String APPS = \"/apps/\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    private final WebClient webClient;\n+    private final ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.WRAP_ROOT_VALUE)\n+                                                          .setSerializationInclusion(Include.NON_NULL);\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public EurekaWebClient(WebClient webClient) {\n+        this.webClient = requireNonNull(webClient, \"webClient\");\n+    }\n+\n+    /**\n+     * Returns the {@link URI} of the Eureka registry.\n+     */\n+    public URI uri() {\n+        return webClient.uri();\n+    }\n+\n+    /**\n+     * Registers the specified {@link InstanceInfo} to the Eureka registry.\n+     */\n+    public HttpResponse register(InstanceInfo info) {\n+        requireNonNull(info, \"info\");\n+        final String path = APPS + info.getAppName();\n+        final RequestHeaders headers = RequestHeaders.builder(HttpMethod.POST, path)\n+                                                     .contentType(MediaType.JSON)\n+                                                     .build();\n+        try {\n+            return webClient.execute(headers, mapper.writeValueAsBytes(info));\n+        } catch (JsonProcessingException e) {\n+            return HttpResponse.ofFailure(e);\n+        }\n+    }\n+\n+    /**\n+     * Sends the heart beat to the Eureka registry.\n+     */\n+    public HttpResponse sendHeartBeat(String appName, String instanceId, InstanceInfo instanceInfo,\n+                                      @Nullable InstanceStatus overriddenStatus) {\n+        requireNonNull(appName, \"appName\");\n+        requireNonNull(instanceId, \"instanceId\");\n+        requireNonNull(instanceInfo, \"instanceInfo\");\n+        final String path = APPS + appName + '/' + instanceId;\n+        final QueryParamsBuilder queryBuilder =\n+                QueryParams.builder()\n+                           .add(\"status\", instanceInfo.getStatus().toString())\n+                           .addLong(\"lastDirtyTimestamp\", instanceInfo.getLastDirtyTimestamp());\n+        if (overriddenStatus != null) {\n+            queryBuilder.add(\"overriddenstatus\", overriddenStatus.toString());\n+        }\n+        final RequestHeaders headers =\n+                RequestHeaders.builder(HttpMethod.PUT, path + '?' + queryBuilder.toQueryString())\n+                              .add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON)\n+                              .build();\n+        return webClient.execute(headers);\n+    }\n+\n+    /**\n+     * Deregisters the specified {@code instanceId} in {@code appName} from the Eureka registry.\n+     */\n+    public HttpResponse cancel(String appName, String instanceId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MDI5OA==", "bodyText": "Could be static?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423670298", "createdAt": "2020-05-12T11:47:54Z", "author": {"login": "ikhoon"}, "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.collect.Iterables;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+\n+/**\n+ * A Eureka {@link WebClient} which communicates to the\n+ * <a href=\"https://github.com/Netflix/eureka/wiki/Eureka-REST-operations\">Eureka registry</a>.\n+ */\n+public final class EurekaWebClient {\n+\n+    private static final String APPS = \"/apps/\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    private final WebClient webClient;\n+    private final ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.WRAP_ROOT_VALUE)\n+                                                          .setSerializationInclusion(Include.NON_NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NTUwMA==", "bodyText": "Wow, TMI. \ud83d\ude4a", "url": "https://github.com/line/armeria/pull/2701#discussion_r423675500", "createdAt": "2020-05-12T11:57:49Z", "author": {"login": "ikhoon"}, "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * An instance information.\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonRootName(\"instance\")\n+public final class InstanceInfo {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InstanceInfo.class);\n+\n+    private final String instanceId;\n+\n+    @Nullable\n+    private final String hostName;\n+    @Nullable\n+    private final String appName;\n+    @Nullable\n+    private final String appGroupName;\n+    @Nullable\n+    private final String ipAddr;\n+    @Nullable\n+    private final String vipAddress;\n+    @Nullable\n+    private final String secureVipAddress;\n+\n+    private final PortWrapper port;\n+    private final PortWrapper securePort;\n+    private final InstanceStatus status;\n+\n+    @Nullable\n+    private final String homePageUrl;\n+    @Nullable\n+    private final String statusPageUrl;\n+    @Nullable\n+    private final String healthCheckUrl;\n+    @Nullable\n+    private final String secureHealthCheckUrl;\n+    private final DataCenterInfo dataCenterInfo;\n+    private final LeaseInfo leaseInfo;\n+    private final Map<String, String> metadata;\n+\n+    private final long lastUpdatedTimestamp;\n+    private final long lastDirtyTimestamp;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,\n+                        @Nullable @JsonProperty(\"app\") String appName,\n+                        @Nullable @JsonProperty(\"appGroupName\") String appGroupName,\n+                        @Nullable @JsonProperty(\"hostName\") String hostName,\n+                        @Nullable @JsonProperty(\"ipAddr\") String ipAddr,\n+                        @Nullable @JsonProperty(\"vipAddress\") String vipAddress,\n+                        @Nullable @JsonProperty(\"secureVipAddress\") String secureVipAddress,\n+                        @JsonProperty(\"port\") PortWrapper port,\n+                        @JsonProperty(\"securePort\") PortWrapper securePort,\n+                        @JsonProperty(\"status\") InstanceStatus status,\n+                        @Nullable @JsonProperty(\"homePageUrl\") String homePageUrl,\n+                        @Nullable @JsonProperty(\"statusPageUrl\") String statusPageUrl,\n+                        @Nullable @JsonProperty(\"healthCheckUrl\") String healthCheckUrl,\n+                        @Nullable @JsonProperty(\"secureHealthCheckUrl\") String secureHealthCheckUrl,\n+                        @JsonProperty(\"dataCenterInfo\") DataCenterInfo dataCenterInfo,\n+                        @JsonProperty(\"leaseInfo\") LeaseInfo leaseInfo,\n+                        @Nullable @JsonProperty(\"metadata\") Map<String, String> metadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3ODU4Nw==", "bodyText": "Do we need this information?  What do you think of ignoring this field from the JSON response?", "url": "https://github.com/line/armeria/pull/2701#discussion_r423678587", "createdAt": "2020-05-12T12:03:39Z", "author": {"login": "ikhoon"}, "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * An instance information.\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonRootName(\"instance\")\n+public final class InstanceInfo {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InstanceInfo.class);\n+\n+    private final String instanceId;\n+\n+    @Nullable\n+    private final String hostName;\n+    @Nullable\n+    private final String appName;\n+    @Nullable\n+    private final String appGroupName;\n+    @Nullable\n+    private final String ipAddr;\n+    @Nullable\n+    private final String vipAddress;\n+    @Nullable\n+    private final String secureVipAddress;\n+\n+    private final PortWrapper port;\n+    private final PortWrapper securePort;\n+    private final InstanceStatus status;\n+\n+    @Nullable\n+    private final String homePageUrl;\n+    @Nullable\n+    private final String statusPageUrl;\n+    @Nullable\n+    private final String healthCheckUrl;\n+    @Nullable\n+    private final String secureHealthCheckUrl;\n+    private final DataCenterInfo dataCenterInfo;\n+    private final LeaseInfo leaseInfo;\n+    private final Map<String, String> metadata;\n+\n+    private final long lastUpdatedTimestamp;\n+    private final long lastDirtyTimestamp;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,\n+                        @Nullable @JsonProperty(\"app\") String appName,\n+                        @Nullable @JsonProperty(\"appGroupName\") String appGroupName,\n+                        @Nullable @JsonProperty(\"hostName\") String hostName,\n+                        @Nullable @JsonProperty(\"ipAddr\") String ipAddr,\n+                        @Nullable @JsonProperty(\"vipAddress\") String vipAddress,\n+                        @Nullable @JsonProperty(\"secureVipAddress\") String secureVipAddress,\n+                        @JsonProperty(\"port\") PortWrapper port,\n+                        @JsonProperty(\"securePort\") PortWrapper securePort,\n+                        @JsonProperty(\"status\") InstanceStatus status,\n+                        @Nullable @JsonProperty(\"homePageUrl\") String homePageUrl,\n+                        @Nullable @JsonProperty(\"statusPageUrl\") String statusPageUrl,\n+                        @Nullable @JsonProperty(\"healthCheckUrl\") String healthCheckUrl,\n+                        @Nullable @JsonProperty(\"secureHealthCheckUrl\") String secureHealthCheckUrl,\n+                        @JsonProperty(\"dataCenterInfo\") DataCenterInfo dataCenterInfo,\n+                        @JsonProperty(\"leaseInfo\") LeaseInfo leaseInfo,\n+                        @Nullable @JsonProperty(\"metadata\") Map<String, String> metadata) {\n+        this.instanceId = instanceId;\n+        this.hostName = hostName;\n+        this.appName = appName;\n+        this.appGroupName = appGroupName;\n+        this.ipAddr = ipAddr;\n+        this.vipAddress = vipAddress;\n+        this.secureVipAddress = secureVipAddress;\n+        this.port = requireNonNull(port, \"port\");\n+        this.securePort = requireNonNull(securePort, \"securePort\");\n+        this.status = requireNonNull(status, \"status\");\n+        this.homePageUrl = homePageUrl;\n+        this.statusPageUrl = statusPageUrl;\n+        this.healthCheckUrl = healthCheckUrl;\n+        this.secureHealthCheckUrl = secureHealthCheckUrl;\n+        this.dataCenterInfo = dataCenterInfo;\n+        this.leaseInfo = requireNonNull(leaseInfo, \"leaseInfo\");\n+        if (metadata != null) {\n+            this.metadata = metadata;\n+        } else {\n+            this.metadata = ImmutableMap.of();\n+        }\n+\n+        lastUpdatedTimestamp = System.currentTimeMillis();\n+        lastDirtyTimestamp = lastUpdatedTimestamp;\n+    }\n+\n+    /**\n+     * Returns the ID of this instance.\n+     */\n+    @Nullable\n+    public String getInstanceId() {\n+        return instanceId;\n+    }\n+\n+    /**\n+     * Return the name of the application which this instance belongs to.\n+     */\n+    @Nullable\n+    @JsonProperty(\"app\")\n+    public String getAppName() {\n+        return appName;\n+    }\n+\n+    /**\n+     * Return the group name of the application which this instance belongs to.\n+     */\n+    @Nullable\n+    public String getAppGroupName() {\n+        return appGroupName;\n+    }\n+\n+    /**\n+     * Return the hostname of this instance.\n+     */\n+    @Nullable\n+    public String getHostName() {\n+        return hostName;\n+    }\n+\n+    /**\n+     * Returns the IP address of this instance.\n+     */\n+    @Nullable\n+    public String getIpAddr() {\n+        return ipAddr;\n+    }\n+\n+    /**\n+     * Returns the VIP address of this instance.\n+     */\n+    @Nullable\n+    public String getVipAddress() {\n+        return vipAddress;\n+    }\n+\n+    /**\n+     * Returns the secure VIP address of this instance.\n+     */\n+    @Nullable\n+    public String getSecureVipAddress() {\n+        return secureVipAddress;\n+    }\n+\n+    /**\n+     * Returns the {@link PortWrapper} of this instance.\n+     */\n+    public PortWrapper getPort() {\n+        return port;\n+    }\n+\n+    /**\n+     * Returns the secure {@link PortWrapper} of this instance.\n+     */\n+    public PortWrapper getSecurePort() {\n+        return securePort;\n+    }\n+\n+    /**\n+     * Returns the {@link InstanceStatus} of this instance.\n+     */\n+    public InstanceStatus getStatus() {\n+        return status;\n+    }\n+\n+    /**\n+     * Returns the home page URL of this instance.\n+     */\n+    @Nullable\n+    public String getHomePageUrl() {\n+        return homePageUrl;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5ODY5MA==", "bodyText": "Question: Don't we need to take multiple eureka URIs? From the HA spec of eureka, a client should attempt to connect other eureka servers if a eureka is sitting idle.\nhttps://blog.asarkar.org/technical/netflix-eureka/#high-availability-ha", "url": "https://github.com/line/armeria/pull/2701#discussion_r423698690", "createdAt": "2020-05-12T12:38:14Z", "author": {"login": "ikhoon"}, "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.AbstractClientOptionsBuilder;\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.ClientOption;\n+import com.linecorp.armeria.client.ClientOptionValue;\n+import com.linecorp.armeria.client.ClientOptions;\n+import com.linecorp.armeria.client.DecoratingHttpClientFunction;\n+import com.linecorp.armeria.client.DecoratingRpcClientFunction;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.RpcClient;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.RequestId;\n+import com.linecorp.armeria.common.auth.BasicToken;\n+import com.linecorp.armeria.common.auth.OAuth1aToken;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n+\n+/**\n+ * Builds a {@link EurekaEndpointGroup}.\n+ */\n+public final class EurekaEndpointGroupBuilder extends AbstractClientOptionsBuilder {\n+\n+    private static final long DEFAULT_REGISTRY_FETCH_INTERVAL_SECONDS = 30;\n+\n+    private final URI eurekaUri;\n+\n+    @Nullable\n+    private String appName;\n+\n+    @Nullable\n+    private String instanceId;\n+\n+    @Nullable\n+    private String vipAddress;\n+\n+    @Nullable\n+    private String secureVipAddress;\n+\n+    private long registryFetchIntervalSeconds = DEFAULT_REGISTRY_FETCH_INTERVAL_SECONDS;\n+\n+    @Nullable\n+    private List<String> regions;\n+    @Nullable\n+    private Consumer<WebClientBuilder> customizer;\n+\n+    EurekaEndpointGroupBuilder(URI eurekaUri) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTM3Mjc3", "url": "https://github.com/line/armeria/pull/2701#pullrequestreview-410537277", "createdAt": "2020-05-13T01:59:25Z", "commit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMTo1OToyNVrOGUe4Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMTo1OTo1MVrOGUe4mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDU5MQ==", "bodyText": "Case sensitive or insensitive?", "url": "https://github.com/line/armeria/pull/2701#discussion_r424130591", "createdAt": "2020-05-13T01:59:25Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/DataCenterInfoSerializer.java", "diffHunk": "@@ -37,12 +35,12 @@\n     public void serialize(DataCenterInfo value, JsonGenerator gen, SerializerProvider provider)\n             throws IOException {\n         gen.writeStartObject();\n-        if (value.getName() == DataCenterName.Amazon) {\n+        if (\"Amazon\".equalsIgnoreCase(value.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDcxNQ==", "bodyText": "Missing space before @", "url": "https://github.com/line/armeria/pull/2701#discussion_r424130715", "createdAt": "2020-05-13T01:59:51Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java", "diffHunk": "@@ -79,7 +79,7 @@\n     /**\n      * Creates a new instance.\n      */\n-    public InstanceInfo(@JsonProperty(\"instanceId\") String instanceId,\n+    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "161f7636495c4b4cb832403e14d5998dfc4e7674", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/161f7636495c4b4cb832403e14d5998dfc4e7674", "committedDate": "2020-05-13T04:06:30Z", "message": "Address comments by @trustin and @ikhoon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "244d88f37e48ffa51b0f4e7eee9b386e1e2ca521", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/244d88f37e48ffa51b0f4e7eee9b386e1e2ca521", "committedDate": "2020-05-13T04:18:39Z", "message": "Returns non local port first"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "269360b72da27d34a632f4b26b2ae3b8de0efe7a", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/269360b72da27d34a632f4b26b2ae3b8de0efe7a", "committedDate": "2020-05-13T05:52:32Z", "message": "Fix import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjA2MTUw", "url": "https://github.com/line/armeria/pull/2701#pullrequestreview-410606150", "createdAt": "2020-05-13T05:53:40Z", "commit": {"oid": "244d88f37e48ffa51b0f4e7eee9b386e1e2ca521"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNTo1Mzo0MVrOGUiYBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNjowMDoxNlrOGUigeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NzkxMQ==", "bodyText": "Should we add a variant that does not require path and make path here non-null?", "url": "https://github.com/line/armeria/pull/2701#discussion_r424187911", "createdAt": "2020-05-13T05:53:41Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListenerBuilder;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@link SessionProtocol},\n+     * {@link EndpointGroup} and path.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, @Nullable String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244d88f37e48ffa51b0f4e7eee9b386e1e2ca521"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4ODA1OA==", "bodyText": "How about adding some comment about priority?", "url": "https://github.com/line/armeria/pull/2701#discussion_r424188058", "createdAt": "2020-05-13T05:54:13Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/Server.java", "diffHunk": "@@ -180,9 +179,36 @@ public String defaultHostname() {\n      */\n     @Nullable\n     public ServerPort activePort() {\n+        return activePort0(null);\n+    }\n+\n+    /**\n+     * Returns the primary {@link ServerPort} which serves the given {@link SessionProtocol}\n+     * that this {@link Server} is listening to.\n+     *\n+     * @return the primary {@link ServerPort}, or {@code null} if there is no active port available for\n+     *         the given {@link SessionProtocol}.\n+     */\n+    @Nullable\n+    public ServerPort activePort(SessionProtocol protocol) {\n+        return activePort0(requireNonNull(protocol, \"protocol\"));\n+    }\n+\n+    @Nullable\n+    private ServerPort activePort0(@Nullable SessionProtocol protocol) {\n         synchronized (activePorts) {\n-            return Iterables.getFirst(activePorts.values(), null);\n+            for (ServerPort serverPort : activePorts.values()) {\n+                if (!isLocalPort(serverPort, protocol)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "269360b72da27d34a632f4b26b2ae3b8de0efe7a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MDA3Mg==", "bodyText": "Please handle the case of IPv6 address.", "url": "https://github.com/line/armeria/pull/2701#discussion_r424190072", "createdAt": "2020-05-13T06:00:16Z", "author": {"login": "trustin"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka.\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, {@link EurekaUpdatingListener} deregisters the\n+ * {@link Server} from Eureka by sending a cancellation request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@link SessionProtocol},\n+     * {@link EndpointGroup} and path.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, @Nullable String path) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, path);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregate().handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                newInfo.getHostName(), client.uri(), cause);\n+                    return null;\n+                }\n+                final ResponseHeaders headers = res.headers();\n+                if (headers.status() != HttpStatus.NO_CONTENT) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());\n+                } else {\n+                    logger.info(\"Registered {} to Eureka: {}\", newInfo.getHostName(), client.uri());\n+                    scheduleHeartBeat(ctx.eventLoop(), newInfo);\n+                }\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private void scheduleHeartBeat(EventLoop eventLoop, InstanceInfo newInfo) {\n+        heartBeatFuture = eventLoop.schedule(new HeartBeatTask(eventLoop, newInfo),\n+                                             newInfo.getLeaseInfo().getRenewalIntervalInSecs(),\n+                                             TimeUnit.SECONDS);\n+    }\n+\n+    private InstanceInfo fillAndCreateNewInfo(InstanceInfo oldInfo, Server server) {\n+        final String defaultHostname = server.defaultHostname();\n+        final String hostName = oldInfo.getHostName() != null ? oldInfo.getHostName() : defaultHostname;\n+        appName = oldInfo.getAppName() != null ? oldInfo.getAppName() : hostName;\n+        final String instanceId = oldInfo.getInstanceId() != null ? oldInfo.getInstanceId() : hostName;\n+\n+        final Inet4Address defaultInet4Address = SystemInfo.defaultNonLoopbackIpV4Address();\n+        final String defaultIpAddr = defaultInet4Address != null ? defaultInet4Address.getHostAddress()\n+                                                                 : null;\n+        final String ipAddr = oldInfo.getIpAddr() != null ? oldInfo.getIpAddr() : defaultIpAddr;\n+        final PortWrapper oldPortWrapper = oldInfo.getPort();\n+        final PortWrapper portWrapper = portWrapper(server, oldPortWrapper, SessionProtocol.HTTP);\n+        final PortWrapper oldSecurePortWrapper = oldInfo.getSecurePort();\n+        final PortWrapper securePortWrapper = portWrapper(server, oldSecurePortWrapper, SessionProtocol.HTTPS);\n+\n+        final String vipAddress = vipAddress(oldInfo.getVipAddress(), hostName, portWrapper);\n+        final String secureVipAddress = vipAddress(oldInfo.getSecureVipAddress(), hostName, securePortWrapper);\n+\n+        final Optional<ServiceConfig> healthCheckService =\n+                server.serviceConfigs()\n+                      .stream()\n+                      .filter(cfg -> cfg.service().as(HealthCheckService.class) != null)\n+                      .findFirst();\n+\n+        final String hostnameOrIpAddr;\n+        if (oldInfo.getHostName() != null) {\n+            hostnameOrIpAddr = oldInfo.getHostName();\n+        } else if (ipAddr != null) {\n+            hostnameOrIpAddr = ipAddr;\n+        } else {\n+            hostnameOrIpAddr = hostName;\n+        }\n+        final String healthCheckUrl = healthCheckUrl(hostnameOrIpAddr, oldInfo.getHealthCheckUrl(), portWrapper,\n+                                                     healthCheckService, SessionProtocol.HTTP);\n+        final String secureHealthCheckUrl =\n+                healthCheckUrl(hostnameOrIpAddr, oldInfo.getSecureHealthCheckUrl(), securePortWrapper,\n+                               healthCheckService, SessionProtocol.HTTPS);\n+\n+        return new InstanceInfo(instanceId, appName, oldInfo.getAppGroupName(), hostName, ipAddr,\n+                                vipAddress, secureVipAddress, portWrapper, securePortWrapper, InstanceStatus.UP,\n+                                oldInfo.getHomePageUrl(), oldInfo.getStatusPageUrl(), healthCheckUrl,\n+                                secureHealthCheckUrl, oldInfo.getDataCenterInfo(),\n+                                oldInfo.getLeaseInfo(), oldInfo.getMetadata());\n+    }\n+\n+    private static PortWrapper portWrapper(Server server, PortWrapper oldPortWrapper,\n+                                           SessionProtocol protocol) {\n+        if (oldPortWrapper.isEnabled()) {\n+            for (ServerPort serverPort : server.activePorts().values()) {\n+                if (serverPort.hasProtocol(protocol) &&\n+                    serverPort.localAddress().getPort() == oldPortWrapper.getPort()) {\n+                    return oldPortWrapper;\n+                }\n+            }\n+            logger.warn(\"The port number: {} (expected one of activePorts: {})\",\n+                        oldPortWrapper.getPort(), server.activePorts());\n+        }\n+\n+        final ServerPort serverPort = server.activePort(protocol);\n+        if (serverPort == null) {\n+            return disabledPort;\n+        }\n+        return new PortWrapper(true, serverPort.localAddress().getPort());\n+    }\n+\n+    @Nullable\n+    private static String vipAddress(@Nullable String vipAddress, String hostName, PortWrapper portWrapper) {\n+        if (!portWrapper.isEnabled()) {\n+            return null;\n+        }\n+        return vipAddress != null ? vipAddress : hostName + ':' + portWrapper.getPort();\n+    }\n+\n+    @Nullable\n+    private static String healthCheckUrl(String hostnameOrIpAddr, @Nullable String oldHealthCheckUrl,\n+                                         PortWrapper portWrapper,\n+                                         Optional<ServiceConfig> healthCheckService,\n+                                         SessionProtocol sessionProtocol) {\n+        if (oldHealthCheckUrl != null) {\n+            return oldHealthCheckUrl;\n+        }\n+        if (!portWrapper.isEnabled() || !healthCheckService.isPresent()) {\n+            return null;\n+        }\n+        final ServiceConfig healthCheckServiceConfig = healthCheckService.get();\n+        final Route route = healthCheckServiceConfig.route();\n+        if (route.pathType() != RoutePathType.EXACT && route.pathType() != RoutePathType.PREFIX) {\n+            return null;\n+        }\n+\n+        return sessionProtocol.uriText() + \"://\" + hostnameOrIpAddr + ':' + portWrapper.getPort() +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "269360b72da27d34a632f4b26b2ae3b8de0efe7a"}, "originalPosition": 232}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a715a618147a77fab8b7f9aecff8f20b0a9dda69", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/a715a618147a77fab8b7f9aecff8f20b0a9dda69", "committedDate": "2020-05-13T08:12:54Z", "message": "Address the comment by @trustin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ff3bbbdcac6d17e4317669bccbdc71fc4b79b2c", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/2ff3bbbdcac6d17e4317669bccbdc71fc4b79b2c", "committedDate": "2020-05-13T08:17:00Z", "message": "Merge branch 'master' into eureka"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjkyODE2", "url": "https://github.com/line/armeria/pull/2701#pullrequestreview-410692816", "createdAt": "2020-05-13T08:18:22Z", "commit": {"oid": "2ff3bbbdcac6d17e4317669bccbdc71fc4b79b2c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "523facbfe131a28f9ad250ad402e012fcce0baad", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/523facbfe131a28f9ad250ad402e012fcce0baad", "committedDate": "2020-05-13T08:28:42Z", "message": "Add publish tag"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNzE3Mjg3", "url": "https://github.com/line/armeria/pull/2701#pullrequestreview-410717287", "createdAt": "2020-05-13T08:48:58Z", "commit": {"oid": "523facbfe131a28f9ad250ad402e012fcce0baad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODo0ODo1OFrOGUnwWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODo0ODo1OFrOGUnwWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI3NjA1Ng==", "bodyText": "Don't we need to retry to other eureka servers? Or, does it happen in EurekaWebClient?", "url": "https://github.com/line/armeria/pull/2701#discussion_r424276056", "createdAt": "2020-05-13T08:48:58Z", "author": {"login": "ikhoon"}, "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.NetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka.\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, {@link EurekaUpdatingListener} deregisters the\n+ * {@link Server} from Eureka by sending a cancellation request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@link SessionProtocol}\n+     * and {@link EndpointGroup}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, null);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@link SessionProtocol},\n+     * {@link EndpointGroup} and path.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, String path) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, requireNonNull(path, \"path\"));\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregate().handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                newInfo.getHostName(), client.uri(), cause);\n+                    return null;\n+                }\n+                final ResponseHeaders headers = res.headers();\n+                if (headers.status() != HttpStatus.NO_CONTENT) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "523facbfe131a28f9ad250ad402e012fcce0baad"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d38ecc0c64c652a7d202e19d7e483df2a3105a2c", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/d38ecc0c64c652a7d202e19d7e483df2a3105a2c", "committedDate": "2020-05-13T13:08:44Z", "message": "Add retryingClient if not specified"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baf699cd8956f2dc9cc02238264c559ddbf8879f", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/baf699cd8956f2dc9cc02238264c559ddbf8879f", "committedDate": "2020-05-14T01:50:39Z", "message": "Fix import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3b62d87401fe19dca21ee16b66c2a7d8071f82c", "author": {"user": {"login": "minwoox", "name": "minux"}}, "url": "https://github.com/line/armeria/commit/c3b62d87401fe19dca21ee16b66c2a7d8071f82c", "committedDate": "2020-05-14T03:43:37Z", "message": "Add static factory methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDUyNTYw", "url": "https://github.com/line/armeria/pull/2701#pullrequestreview-411452560", "createdAt": "2020-05-14T04:13:11Z", "commit": {"oid": "c3b62d87401fe19dca21ee16b66c2a7d8071f82c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDU5Njk4", "url": "https://github.com/line/armeria/pull/2701#pullrequestreview-411459698", "createdAt": "2020-05-14T04:40:05Z", "commit": {"oid": "c3b62d87401fe19dca21ee16b66c2a7d8071f82c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 467, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}