{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NjQ0Mzc0", "number": 2935, "title": "Add facility to capture dns metrics", "bodyText": "The changes are to introduce DnsQueryLifecycleObserver that is responsible for capturing dns query metrics. Please see #1887 for details. I opened a new PR because I think I messed up my earlier rebase.\n--\nMotivation:\nWe currently only record the time taken for DNS queries. A user wants to learn more, such as:\n\nthe number of DNS queries\nthe number of connection attempts that required a domain name resolution\n\nwith some tags for aggregation, e.g.\n\nSuccess or failure\nDNS error code\n\nModifications:\n\nAutomatically add a metric-collecting DnsQueryLifecycleObserver when creating a Netty domain name resolver.\n\nResult:\n\nDetailed DNS query metrics\nCloses #1887", "createdAt": "2020-07-25T17:46:08Z", "url": "https://github.com/line/armeria/pull/2935", "merged": true, "mergeCommit": {"oid": "3869f47246cc79089b586f59cef9e2b2ae40de95"}, "closed": true, "closedAt": "2020-11-27T08:18:58Z", "author": {"login": "amitvc"}, "timelineItems": {"totalCount": 56, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc4cTgEgH2gAyNDU2NjQ0Mzc0OjhkMjRhNjg0NGNkMjI3NTYxZTIwYmRhOWNlYWY5MjBmZTYxMjI0YWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdggPDcgH2gAyNDU2NjQ0Mzc0OjE2NDU1MzYyYjg0ZGQwOTk1YzA1YmUwMTRkMDIzZWU2OGRiNzdmZjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/8d24a6844cd227561e20bda9ceaf920fe61224ae", "committedDate": "2020-07-25T17:44:29Z", "message": "Add facility to capture dns metrics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NDczMTY1", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-455473165", "createdAt": "2020-07-27T05:04:48Z", "commit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNTowNDo0OFrOG3TwBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNToxMzo1M1rOG3T4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODQ1NQ==", "bodyText": "I think this option is too early to introduce now. Could we hard-code for now and then add later when we get some user demands?", "url": "https://github.com/line/armeria/pull/2935#discussion_r460648455", "createdAt": "2020-07-27T05:04:48Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -184,6 +185,10 @@\n     public static final ClientFactoryOption<ProxyConfigSelector> PROXY_CONFIG_SELECTOR =\n             ClientFactoryOption.define(\"PROXY_CONFIG_SELECTOR\", ProxyConfigSelector.of(ProxyConfig.direct()));\n \n+    public static final ClientFactoryOption<MeterIdPrefix> DEFAULT_METER_ID_PREFIX =\n+            ClientFactoryOption.define(\"DEFAULT_DNS_METER_ID_PREFIX\",\n+                    new MeterIdPrefix(\"armeria.client.dns.queries\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODk2Mg==", "bodyText": "We never use IXFR or AXFR for DNS queries, so there's no way to tell if it's UDP or TCP. Let's remove protocol tag until the upstream provides a proper way to determine the protocol.", "url": "https://github.com/line/armeria/pull/2935#discussion_r460648962", "createdAt": "2020-07-27T05:06:50Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();\n+    }\n+\n+    private static String getProtocolType(DnsRecordType type) {\n+        if (DnsRecordType.IXFR.equals(type) ||\n+                DnsRecordType.AXFR.equals(type)) {\n+            return \"tcp\";\n+        }\n+        return \"udp\";\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ==", "bodyText": "There are many incorrectness in this block, so I'm not sure how I can advise on this. Please make sure to re-read my suggestions about the names and tags and try re-writing this block completely.\nFor example, you should have different counter for each error code. To do this, you must get the counter lazily in the callback.", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650131", "createdAt": "2020-07-27T05:11:54Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDIzNQ==", "bodyText": "Indentation", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650235", "createdAt": "2020-07-27T05:12:19Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,6 +369,7 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             }\n         };\n         return new RefreshingAddressResolverGroup(resolverConfigurator, minTtl, maxTtl, negativeTtl,\n-                                                  queryTimeoutMillis, refreshBackoff, resolvedAddressTypes);\n+                                                  queryTimeoutMillis, refreshBackoff, resolvedAddressTypes,\n+                                                   meterRegistry, meterIdPrefix);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ==", "bodyText": "When you create a ClientFactory, you can specify a MeterRegistry. Create a new MeterRegistry so that ClientFactory does not use the default MeterRegistry, then check what's recorded in the MeterRegistry you specified. I'd recommend using PrometheusMeterRegistries.newRegistry() to create one.", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650551", "createdAt": "2020-07-27T05:13:53Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void test() throws ExecutionException, InterruptedException {\n+\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78c156d413430822fe9088f60ea271c3442b3fbc", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/78c156d413430822fe9088f60ea271c3442b3fbc", "committedDate": "2020-08-09T05:05:07Z", "message": "changes made based on comments, added UT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NTg0MDAz", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-465584003", "createdAt": "2020-08-12T04:32:55Z", "commit": {"oid": "78c156d413430822fe9088f60ea271c3442b3fbc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDozMjo1NVrOG_Rb4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDozMzozOVrOG_Rcew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTEzNg==", "bodyText": "I don't think we need this at all. We can use the same MeterRegistry for DNS metrics.", "url": "https://github.com/line/armeria/pull/2935#discussion_r468999136", "createdAt": "2020-08-12T04:32:55Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactory.java", "diffHunk": "@@ -177,6 +178,11 @@ static void disableShutdownHook() {\n      */\n     MeterRegistry meterRegistry();\n \n+    /**\n+     * Returns the {@link PrometheusMeterRegistry} that collects various DNS stats.\n+     */\n+    PrometheusMeterRegistry dnsMetricRegistry();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78c156d413430822fe9088f60ea271c3442b3fbc"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTI5MQ==", "bodyText": "Ditto - We don't need this.", "url": "https://github.com/line/armeria/pull/2935#discussion_r468999291", "createdAt": "2020-08-12T04:33:39Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -178,6 +180,9 @@\n     public static final ClientFactoryOption<MeterRegistry> METER_REGISTRY =\n             ClientFactoryOption.define(\"METER_REGISTRY\", Metrics.globalRegistry);\n \n+    public static final ClientFactoryOption<PrometheusMeterRegistry> DNS_METRIC_REGISTRY =\n+            ClientFactoryOption.define(\"DNS_METER_REGISTRY\", PrometheusMeterRegistries.newRegistry());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78c156d413430822fe9088f60ea271c3442b3fbc"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1b3a01b5b6f221dce5de3aed8cbd32c9305e6c8", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/e1b3a01b5b6f221dce5de3aed8cbd32c9305e6c8", "committedDate": "2020-08-13T03:50:58Z", "message": "Removed dns specific metric registry and refactored some code based on feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "committedDate": "2020-08-15T23:51:12Z", "message": "Only enable DefaultDnsQueryLifecycleObserverFactory if user is expecting to capture dns metrics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTcyODAy", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-468972802", "createdAt": "2020-08-18T03:52:26Z", "commit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMzo1MjoyNlrOHCCXww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNDoxMTozN1rOHCCowQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODA1MQ==", "bodyText": "You can always do builder.metricRegistry(options.meterRegistry()).build(eventLoopGroup).", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898051", "createdAt": "2020-08-18T03:52:26Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return options.containsKey(ClientFactoryOptions.METER_REGISTRY) ? builder\n+                                .metricRegistry((PrometheusMeterRegistry)\n+                                        options.get(ClientFactoryOptions.METER_REGISTRY).value())\n+                                .build(eventLoopGroup) : builder.build(eventLoopGroup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODE1MQ==", "bodyText": "You can just accept MeterRegistry here.", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898151", "createdAt": "2020-08-18T03:52:52Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODIzNA==", "bodyText": "Could you move these fields before the member fields in this class?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898234", "createdAt": "2020-08-18T03:53:12Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDA5MA==", "bodyText": "Could you use .getAddress().getHostAddress() because we are only interested in an IP address?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900090", "createdAt": "2020-08-18T04:01:06Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDE0Ng==", "bodyText": "Could you use .getAddress().getHostAddress() because we are only interested in IP addresses?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900146", "createdAt": "2020-08-18T04:01:18Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDM1MA==", "bodyText": "intValue() instead of toString()?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900350", "createdAt": "2020-08-18T04:02:11Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDYwNw==", "bodyText": "Ditto - could use MeterRegistry", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900607", "createdAt": "2020-08-18T04:03:27Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserverFactory.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserverFactory;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserverFactory} factory that helps create DnsQueryLifecycleObserver.\n+ */\n+final class DefaultDnsQueryLifecycleObserverFactory implements DnsQueryLifecycleObserverFactory {\n+\n+    private final PrometheusMeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+\n+    DefaultDnsQueryLifecycleObserverFactory(PrometheusMeterRegistry meterRegistry,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDg5Mw==", "bodyText": "How about \"none\" instead of \"\"?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900893", "createdAt": "2020-08-18T04:04:44Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"\"))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA==", "bodyText": "I'm somewhat concerned about using an exception message as a tag value because it can increase the cardinality dramatically. How about categorizing the exceptions into a few?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901100", "createdAt": "2020-08-18T04:05:41Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTUwMQ==", "bodyText": "Should accept MeterRegistry.\nCould be package-private?", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901501", "createdAt": "2020-08-18T04:07:26Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param metricRegistry {@link PrometheusMeterRegistry}.\n+     * @return DnsResolverGroupBuilder.\n+     */\n+    public DnsResolverGroupBuilder metricRegistry(PrometheusMeterRegistry metricRegistry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTYyMQ==", "bodyText": "@Nonnull is redundant. Everything in our code is nonnull.\nShould accept MeterRegistry\nmetricRegistry -> meterRegistry", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901621", "createdAt": "2020-08-18T04:08:02Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -99,11 +102,13 @@\n     private final Backoff refreshBackoff;\n     private final List<DnsRecordType> dnsRecordTypes;\n     private final Consumer<DnsNameResolverBuilder> resolverConfigurator;\n+    private final PrometheusMeterRegistry metricRegistry;\n \n     RefreshingAddressResolverGroup(Consumer<DnsNameResolverBuilder> resolverConfigurator,\n                                    int minTtl, int maxTtl, int negativeTtl, long queryTimeoutMillis,\n                                    Backoff refreshBackoff,\n-                                   @Nullable ResolvedAddressTypes resolvedAddressTypes) {\n+                                   @Nullable ResolvedAddressTypes resolvedAddressTypes,\n+                                   @Nonnull PrometheusMeterRegistry metricRegistry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTcyOA==", "bodyText": "metricRegistry is always non-null. No need to check nullness.", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901728", "createdAt": "2020-08-18T04:08:27Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +134,11 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        if (metricRegistry != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjI4Mw==", "bodyText": "Could you use the TestDnsServer instead of using a public DNS server? This way, we can test all life cycle observer callbacks easily.", "url": "https://github.com/line/armeria/pull/2935#discussion_r471902283", "createdAt": "2020-08-18T04:11:05Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+\n+public class DnsMetricsTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjQwMQ==", "bodyText": "Global comment: ClientFactory must be closed at the end of the test. Use try-with-resources on it.", "url": "https://github.com/line/armeria/pull/2935#discussion_r471902401", "createdAt": "2020-08-18T04:11:37Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void dns_metric_test_for_successful_query_writes() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build();\n+\n+        final WebClient client2 = WebClient.builder()\n+                .factory(factory)\n+                .build();\n+\n+        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n+\n+        final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n+                .getPrometheusRegistry()\n+                .getSampleValue(\"armeria_client_dns_queries_total\",\n+                        new String[] {\"cause\",\"name\",\"result\"},\n+                        new String[] {\"\",\"wikipedia.com.\", \"success\"});\n+        assertThat(count > 1.0).isTrue();\n+    }\n+\n+    @Test\n+    void dns_metric_test_for_query_failures() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build();\n+        try {\n+            final WebClient client2 = WebClient.builder()\n+                    .factory(factory)\n+                    .build();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://googleusercontent.com\")).aggregate().get();\n+        } catch (Exception ex) {\n+            final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n+                    .getPrometheusRegistry()\n+                    .getSampleValue(\"armeria_client_dns_queries_total\",\n+                            new String[] {\"cause\",\"name\",\"result\"},\n+                            new String[] {\"No matching record type found\",\"googleusercontent.com.\", \"failure\"});\n+            assertThat(count > 1.0).isTrue();\n+        }\n+    }\n+\n+    @Test\n+    void no_dns_registry_used_when_not_provided_externally() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d51e2d7160aea93657a37175c4488cf81a162983", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/d51e2d7160aea93657a37175c4488cf81a162983", "committedDate": "2020-08-31T03:41:55Z", "message": "Rewrote unit test using DnsTestServer and address several cr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c471878e873c79203b3f1bd591ca1365e836f63", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/7c471878e873c79203b3f1bd591ca1365e836f63", "committedDate": "2020-09-02T03:44:24Z", "message": "Addressing code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/6129f8a064a38c572db68762f0b3039daa69c31d", "committedDate": "2020-09-02T03:54:24Z", "message": "wrap ClientFactory with try with resource block, general cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMjYzNTky", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-483263592", "createdAt": "2020-09-07T06:10:20Z", "commit": {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNjoxMDoyMVrOHNxTtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNjoxNDoxNFrOHNxYjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng==", "bodyText": "Could avoid using PrometheusMeterRegistries here, because we don't have a hard dependency on it. It has to be like the following IIUC:\nreturn builder.meterRegistry(options.meterRegistry()).build(eventLoopGroup);", "url": "https://github.com/line/armeria/pull/2935#discussion_r484201396", "createdAt": "2020-09-07T06:10:21Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return builder\n+                                .meterRegistry(options.containsKey(ClientFactoryOptions.METER_REGISTRY) ?\n+                                        (MeterRegistry) options.get(ClientFactoryOptions.METER_REGISTRY).value()\n+                                        : PrometheusMeterRegistries.newRegistry()).build(eventLoopGroup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjA5NA==", "bodyText": "Shouldn't SERVER_TAG be replaced with SERVERS_TAG (\"servers\")?", "url": "https://github.com/line/armeria/pull/2935#discussion_r484202094", "createdAt": "2020-09-07T06:12:21Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private final PrometheusMeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = (PrometheusMeterRegistry)meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjYzOA==", "bodyText": "If I understand correctly we want to see what is the type of exception and use that to add CAUSE_TAG instead of cause.getMessage()?\n\nYes, if Netty gives different exception type for different causes. If not, we'll have to categorize all possible exception types and messages into a set of well-defined strings. Makes sense?", "url": "https://github.com/line/armeria/pull/2935#discussion_r484202638", "createdAt": "2020-09-07T06:14:14Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, "originalCommit": {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0"}, "originalPosition": 101}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "committedDate": "2020-09-10T04:17:13Z", "message": "Removed prometheus registry dependency and minor cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NTU0MDkx", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-485554091", "createdAt": "2020-09-10T04:19:09Z", "commit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxOToxMFrOHPiVUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxOToxMFrOHPiVUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA==", "bodyText": "I do not see any metrics being recorded for this test. Where as if I pass in an external PrometheusMeterRegistries like I did in the other unit tests then I see the counters being incremented. Am I missing something here ?\n{armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.connections.lifespan#count{protocol=h1c}=0.0, armeria.client.connections.lifespan#total{protocol=h1c}=0.0, armeria.client.connections.lifespan#max{protocol=h1c}=0.0, armeria.client.dns.queries.written#count{name=google.com.,servers=2001:558:feed:0:0:0:0:1}=0.0, armeria.client.dns.queries#count{cause=none,name=google.com.,result=success}=0.0}", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053200", "createdAt": "2020-09-10T04:19:10Z", "author": {"login": "amitvc"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NTU0MDE4", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-485554018", "createdAt": "2020-09-10T04:18:51Z", "commit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxODo1MlrOHPiVGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxOToyMlrOHPiVfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzE0NA==", "bodyText": "You have to use SERVER_TAG here because this tag is for a single name server. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053144", "createdAt": "2020-09-10T04:18:52Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -61,7 +60,7 @@\n     public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n         meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n                 Arrays.asList(Tag.of(NAME_TAG, question.name()),\n-                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+                        Tag.of(SERVERS_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzI0NA==", "bodyText": "Bring the assertions back?", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053244", "createdAt": "2020-09-10T04:19:22Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NTU0NTMy", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-485554532", "createdAt": "2020-09-10T04:20:49Z", "commit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoyMDo0OVrOHPiWzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoyMDo0OVrOHPiWzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzU4Mg==", "bodyText": "You can still use PrometheusMeterRegistries.newRegistry() here because this class is a test class, i.e. You can revert the changes in this class.", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053582", "createdAt": "2020-09-10T04:20:49Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "084d9afad082712ba185ec3c65388b9bb95ad40c", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/084d9afad082712ba185ec3c65388b9bb95ad40c", "committedDate": "2020-09-13T14:32:39Z", "message": "code to categorize dns exceptions, cleanup unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25d4e0944fc4ff6da8d371f008c8314584f35c4c", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/25d4e0944fc4ff6da8d371f008c8314584f35c4c", "committedDate": "2020-09-13T16:01:58Z", "message": "Fix UT for RefreshingAddressResolverTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "593fe20ec4e78237b3943e900b91c308f490ebba", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/593fe20ec4e78237b3943e900b91c308f490ebba", "committedDate": "2020-09-16T00:58:16Z", "message": "fix failing ut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "744beaf10990521be775265eb98049c8e4f140d3", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/744beaf10990521be775265eb98049c8e4f140d3", "committedDate": "2020-09-16T01:52:59Z", "message": "Add debug code to investigate failing ut on CI pipeline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34b8c5fff113c58f61490b1b203a8783ca2818a2", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/34b8c5fff113c58f61490b1b203a8783ca2818a2", "committedDate": "2020-10-07T07:53:25Z", "message": "Merge branch 'master' into 1887_dns_metrics_latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4598719e5b45c0d715b485632293b24cc9d27744", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/4598719e5b45c0d715b485632293b24cc9d27744", "committedDate": "2020-10-07T08:55:06Z", "message": "Trying to figure out which is null"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "24465968d776ef757ed095c6faff552c708c9c43", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/24465968d776ef757ed095c6faff552c708c9c43", "committedDate": "2020-10-07T08:38:51Z", "message": "Trying to figure out which is null"}, "afterCommit": {"oid": "4598719e5b45c0d715b485632293b24cc9d27744", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/4598719e5b45c0d715b485632293b24cc9d27744", "committedDate": "2020-10-07T08:55:06Z", "message": "Trying to figure out which is null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9aa502f6566931169e84ef79287e62d5c33034ff", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/9aa502f6566931169e84ef79287e62d5c33034ff", "committedDate": "2020-10-07T11:20:53Z", "message": "Fix test failures\n\n- Use `MoreMeters.measureAll()` which is more convenient for testing.\n  - Fixed a `NullPointerException` which occurs when unboxing `Double`.\n    - `null` is returned instead of `Double` when a meter is missing.\n- Use `await()` where necessary.\n- Add a test case for `NXDOMAIN`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6028e40959ecd997cf01b4e2516203d9c89bfd69", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/6028e40959ecd997cf01b4e2516203d9c89bfd69", "committedDate": "2020-10-07T11:48:16Z", "message": "Remove flaky test method / Shorten the timeout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "932575fe080f1519d32dce0c8733975b9f8516c3", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/932575fe080f1519d32dce0c8733975b9f8516c3", "committedDate": "2020-10-09T13:33:31Z", "message": "Adding unit test for cname"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd789c06ec86cba2a89eb79a410cfda6adde4357", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/cd789c06ec86cba2a89eb79a410cfda6adde4357", "committedDate": "2020-10-09T19:40:51Z", "message": "Fix timeout ut for dns metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d55ee3f168892cb3b0a69b75e848c0d8a8568a03", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/d55ee3f168892cb3b0a69b75e848c0d8a8568a03", "committedDate": "2020-10-14T01:23:09Z", "message": "Remove NAME_SERVERS_EXHAUSTED_EXCEPTION exception assertion from noAnswer ut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6409f1ce95cd97099c79bfbdffe7699bf5491856", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/6409f1ce95cd97099c79bfbdffe7699bf5491856", "committedDate": "2020-10-14T02:05:02Z", "message": "Change the loopback address to ipv4 instead of ipv6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7b9f15834f26408ce5a254bba5d4b60558e3a9c", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/c7b9f15834f26408ce5a254bba5d4b60558e3a9c", "committedDate": "2020-10-17T04:24:53Z", "message": "Fix unit test for timeout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8428c533153b0d9284668f5b0a2cde09508a8b36", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/8428c533153b0d9284668f5b0a2cde09508a8b36", "committedDate": "2020-11-02T01:57:12Z", "message": "Merge branch 'master' into 1887_dns_metrics_latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/5bd61790c1672d8f2ef33bb957516cf85505d564", "committedDate": "2020-11-02T02:45:08Z", "message": "Fix flakiness"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMzA0MzM3", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-521304337", "createdAt": "2020-11-02T02:50:27Z", "commit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1MDoyN1rOHr01-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNDozOFrOHr1AoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYwMg==", "bodyText": "How about inlining this method? It's used only in determineDNSExceptionTag.", "url": "https://github.com/line/armeria/pull/2935#discussion_r515716602", "createdAt": "2020-11-02T02:50:27Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDNSExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.DNS_TIMEOUT_EXCEPTION;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.DNS_RESOLVER_TIMEOUT_EXCEPTION;\n+        }\n+        return discoverExceptionType(cause.getMessage());\n+    }\n+\n+    private static DnsExceptionTypes discoverExceptionType(String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYzMw==", "bodyText": "DNS -> Dns (convention)", "url": "https://github.com/line/armeria/pull/2935#discussion_r515716633", "createdAt": "2020-11-02T02:50:41Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDNSExceptionTag(Throwable cause) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNzkxMQ==", "bodyText": "How about:\n\nremoving _QUERY_FAILED, _EXCEPTION and DNS_ from all values? e.g.\n\nNX_DOMAIN_QUERY_FAILED_EXCEPTION -> NX_DOMAIN\nDNS_TIMEOUT_EXCEPTION -> TIMEOUT\n\n\nrenaming DNS_EXCEPTION to OTHERS?\nrenaming DNS_TIMEOUT_EXCEPTION to SERVER_TIMEOUT so a user can distinguish it better from RESOLVER_TIMEOUT?\nproviding lower-cased values so we can use them as tag values? i.e.\nprivate enum DnsExceptionTypes {\n    ...;\n\n    final String lowerCasedName;\n\n    DnsExceptionTypes() {\n        tag = Ascii.toLowerCase(name());\n    }\n}\n...\n\nTag.of(CAUSE_TAG, type.lowerCasedName)", "url": "https://github.com/line/armeria/pull/2935#discussion_r515717911", "createdAt": "2020-11-02T02:57:09Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODkwNA==", "bodyText": "I guess almost all failed queries will end up getting NAME_SERVERS_EXHAUSTED_EXCEPTION, which means it's a kind of duplicate. Could we ignore it until we have a clear reason why we would want to record it?", "url": "https://github.com/line/armeria/pull/2935#discussion_r515718904", "createdAt": "2020-11-02T03:02:10Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxOTMyOQ==", "bodyText": "If we're going to make this class public, we have to hide it from the public API. Could you move this class to internal.client? We could also merge it into internal.client.DnsUtil.", "url": "https://github.com/line/armeria/pull/2935#discussion_r515719329", "createdAt": "2020-11-02T03:04:38Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {\n \n-    static void encodeName(String name, ByteBuf out) {\n+    public static void encodeName(String name, ByteBuf out) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "committedDate": "2020-11-03T05:28:38Z", "message": "Removed DnsNameEncoder and reconciled the code to DnsUtil, Cleaned up DnsExceptionTypes enum for better readability"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMjAwMTE4", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-522200118", "createdAt": "2020-11-03T05:41:42Z", "commit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo0MTo0MlrOHsg1KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjoxOTowM1rOHshW8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ==", "bodyText": "How about just using Metrics.globalRegistry?\nBecause I have to track down which registry will be used if it's not specified.\nfinal MeterRegistry registry;\nfinal ClientFactoryOptionValue<?> opt = options.get(\n        ClientFactoryOptions.METER_REGISTRY);\nif (opt != null) {\n    registry = (MeterRegistry) opt.value();\n} else {\n    registry = Metrics.globalRegistry;\n}\n\nreturn builder.meterRegistry(registry)\n              .build(eventLoopGroup);", "url": "https://github.com/line/armeria/pull/2935#discussion_r516437289", "createdAt": "2020-11-03T05:41:42Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions.METER_REGISTRY", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw==", "bodyText": "THis is not used. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2935#discussion_r516439463", "createdAt": "2020-11-03T05:51:44Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA==", "bodyText": "I think we should set this in DnsResolverGroupBuilder so that this factory is not overridden by the observer factory that the user configures.", "url": "https://github.com/line/armeria/pull/2935#discussion_r516442260", "createdAt": "2020-11-03T06:04:01Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjY5NQ==", "bodyText": "Let's remove this return statement and just do:\nSets {@link MeterRegistry} to collect the DNS query metrics.", "url": "https://github.com/line/armeria/pull/2935#discussion_r516442695", "createdAt": "2020-11-03T06:05:45Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param meterRegistry {@link MeterRegistry}.\n+     * @return DnsResolverGroupBuilder.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzE3NQ==", "bodyText": "Could you check the indentation of this class?", "url": "https://github.com/line/armeria/pull/2935#discussion_r516443175", "createdAt": "2020-11-03T06:07:44Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzM1MQ==", "bodyText": "Let's just use + as IDEA suggested which is more readable:\nmeterIdPrefix.name() + \".written\"", "url": "https://github.com/line/armeria/pull/2935#discussion_r516443351", "createdAt": "2020-11-03T06:08:35Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NDc0MA==", "bodyText": "Perhaps we can make Tag.of(NAME_TAG, question.name()) in the constructor and reuse it?", "url": "https://github.com/line/armeria/pull/2935#discussion_r516444740", "createdAt": "2020-11-03T06:13:51Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA==", "bodyText": "Can we remove this CAUSE_TAG?", "url": "https://github.com/line/armeria/pull/2935#discussion_r516445444", "createdAt": "2020-11-03T06:16:49Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg==", "bodyText": "How about moving this method and the class to a test class because they are only used by tests?", "url": "https://github.com/line/armeria/pull/2935#discussion_r516445936", "createdAt": "2020-11-03T06:19:03Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "diffHunk": "@@ -98,4 +99,24 @@ public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordT\n     }\n \n     private DnsUtil() {}\n+\n+    public static void encodeName(String name, ByteBuf out) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "committedDate": "2020-11-04T01:08:03Z", "message": "Fix indentation, revert deleted code, initializing name tag for reuse"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1OTcyMTAy", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-525972102", "createdAt": "2020-11-09T07:11:51Z", "commit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoxMTo1MVrOHvhO3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzoyNzo0N1rOHvh22w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4OTU5Ng==", "bodyText": "This seems unused as well \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2935#discussion_r519589596", "createdAt": "2020-11-09T07:11:51Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDAxOA==", "bodyText": "How about keeping the names as member fields so we don't have to do string concatenation every time?", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590018", "createdAt": "2020-11-09T07:13:00Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDMyMw==", "bodyText": "else is redundant.", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590323", "createdAt": "2020-11-09T07:13:46Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA==", "bodyText": "Shouldn't we ignore the 'exhausted name servers' error here instead of returning OTHERS, so that the counter doesn't increase?", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590784", "createdAt": "2020-11-09T07:14:39Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.RESOLVER_TIMEOUT;\n+        }\n+        final String message = cause.getMessage();\n+        if (NXDOMAIN_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NX_DOMAIN;\n+        }\n+\n+        if (CNAME_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.CNAME_NOT_FOUND;\n+        }\n+\n+        if (NO_MATCHING_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NO_MATCHING_RECORD;\n+        }\n+\n+        if (UNRECOGNIZED_TYPE_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.UNRECOGNIZED_TYPE;\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTA4NA==", "bodyText": "How about moving the modifications in this class to DnsResolverGroupBuilder, so that:\n\nRefreshingAddressResolverGroup doesn't change.\nDnsResolverGroupBuilder creates the default observer factory;\nDnsResolverGroupBuilder.build() creates the resolverConfigurator that calls DnsNameResolverBuilder.dnsQueryLifecycleObserverFactory() with the default observer factory.\n\nUse io.netty.resolver.dns.BiDnsQueryLifecycleObserverFactory to combine the default observer factory and the user-specified observer factory.\n\n\n\nMakes sense?", "url": "https://github.com/line/armeria/pull/2935#discussion_r519599084", "createdAt": "2020-11-09T07:26:26Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, "originalCommit": {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ==", "bodyText": "Global comment: Could we also make sure that no other unexpected counters are created or increased for all test cases? e.g. the meter with cause=others should be 0 or non-existent.", "url": "https://github.com/line/armeria/pull/2935#discussion_r519599835", "createdAt": "2020-11-09T07:27:47Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsRecordType.CNAME;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.DnsNameEncoder;\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsRawRecord;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void success() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String successMeterId =\n+                        \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId, successMeterId);\n+\n+                client.get(\"http://foo.com:1/\").aggregate();\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writeMeterId, 1.0)\n+                            .containsEntry(successMeterId, 1.0);\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void timeout() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+        ), new AlwaysTimeoutHandler())) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                        builder.queryTimeout(Duration.ofSeconds(1));\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client2 = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId_ipv4_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=127.0.0.1}\";\n+                final String writeMeterId_ipv6_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\";\n+                final String timeoutMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=resolver_timeout,name=foo.com.,result=failure}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId_ipv4_addr,writeMeterId_ipv6_addr, timeoutMeterId);\n+\n+                assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                        .aggregate().join())\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                        .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsAnyOf(entry(writeMeterId_ipv6_addr, 1.0),\n+                                    entry(writeMeterId_ipv4_addr, 1.0));\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void nxDomain() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NXDOMAIN)\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.searchDomains();\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writtenMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=bar.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String nxDomainMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=nx_domain,name=bar.com.,result=failure}\";\n+                assertThatThrownBy(() -> client.get(\"http://bar.com\").aggregate().join())\n+                        .hasRootCauseInstanceOf(UnknownHostException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writtenMeterId, 2.0)\n+                            .containsEntry(nxDomainMeterId, 2.0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e"}, "originalPosition": 182}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/4e6a235c83cecdd402ef5995d45ec218ac731252", "committedDate": "2020-11-12T01:46:21Z", "message": "Merge master into 1887_dns_metrics_latest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4Njg4MzM0", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-528688334", "createdAt": "2020-11-12T02:22:49Z", "commit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMjoyMjo0OVrOHxmspA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMjoyNjoxNVrOHxmwcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NjI5Mg==", "bodyText": "Don't we need \\ after unrecognized?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n          \n          \n            \n                private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");", "url": "https://github.com/line/armeria/pull/2935#discussion_r521776292", "createdAt": "2020-11-12T02:22:49Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzE2OQ==", "bodyText": "How about creating a singleton instance for Tag.of(RESULT_TAG, \"success\") and reuse?", "url": "https://github.com/line/armeria/pull/2935#discussion_r521777169", "createdAt": "2020-11-12T02:25:50Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzI2Nw==", "bodyText": "How about creating a singleton instance for Tag.of(RESULT_TAG, \"failure\") and reuse?", "url": "https://github.com/line/armeria/pull/2935#discussion_r521777267", "createdAt": "2020-11-12T02:26:15Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252"}, "originalPosition": 130}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/c87bff10cf7978200b5cce4469d3096ad01a01bf", "committedDate": "2020-11-12T03:23:45Z", "message": "addressing several code review comments - Moved meterRegistry from RefreshingAddressResolverGroup, move initialization of DefaultDnsQueryLifecycleObserverFactory to DnsResolverGroupBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48c4621c689b0c9e39b88f58c5f1ba2489679d3d", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/48c4621c689b0c9e39b88f58c5f1ba2489679d3d", "committedDate": "2020-11-16T08:40:15Z", "message": "Merge branch 'master' into 1887_dns_metrics_latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e67f3f650a8a2ca5eb7677ffbebd075ecff5d136", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/e67f3f650a8a2ca5eb7677ffbebd075ecff5d136", "committedDate": "2020-11-17T03:54:54Z", "message": "Added no name server tag to the counters and ut for it"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eee42f7ce0241a3edfb8ea9ca3d76efcfe190df9", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/eee42f7ce0241a3edfb8ea9ca3d76efcfe190df9", "committedDate": "2020-11-17T03:56:47Z", "message": "Merge branch '1887_dns_metrics_latest' of https://github.com/amitvc/armeria into 1887_dns_metrics_latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "committedDate": "2020-11-17T05:08:42Z", "message": "Ignore NAME_SERVERS_EXHAUSTED_EXCEPTION (No name servers returned an answer) exception from being measured with a metric"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MDI4Njcw", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-534028670", "createdAt": "2020-11-19T02:14:45Z", "commit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjoxNDo0NlrOH2J43g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMjo0MjowNFrOH2KbTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0NzE2Ng==", "bodyText": "nit: indentation?", "url": "https://github.com/line/armeria/pull/2935#discussion_r526547166", "createdAt": "2020-11-19T02:14:46Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,16 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions\n+                                .METER_REGISTRY", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0OTk3MQ==", "bodyText": "extra slash?", "url": "https://github.com/line/armeria/pull/2935#discussion_r526549971", "createdAt": "2020-11-19T02:23:52Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1MDAwOA==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2935#discussion_r526550008", "createdAt": "2020-11-19T02:23:58Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1MDM0MA==", "bodyText": "nit: indentation?", "url": "https://github.com/line/armeria/pull/2935#discussion_r526550340", "createdAt": "2020-11-19T02:24:53Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Pattern NO_NS_RETURNED_EXCEPTION = Pattern.compile(\"\\\\bservers returned an answer\\\\b\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+        meterIdPrefixWritten = meterIdPrefix.name() + \".written\";\n+        meterIdPrefixCancelled = meterIdPrefix.name() + \".cancelled\";\n+        meterIdPrefixRedirected = meterIdPrefix.name() + \".redirected\";\n+        meterIdPrefixCnamed = meterIdPrefix.name() + \".cnamed\";\n+        meterIdPrefixNoAnswer = meterIdPrefix.name() + \".noanswer\";\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefixWritten,\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDM2OQ==", "bodyText": "How about making this public?", "url": "https://github.com/line/armeria/pull/2935#discussion_r526554369", "createdAt": "2020-11-19T02:36:52Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -297,6 +302,14 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets {@link MeterRegistry} to collect the DNS query metrics.\n+     */\n+    DnsResolverGroupBuilder meterRegistry(MeterRegistry meterRegistry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ==", "bodyText": "Let's add assert meterRegistry != null so that IDE does not complain.\nLet's exctrat\nnew DefaultDnsQueryLifecycleObserverFactory(\n    meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\"))\nbefore line 359", "url": "https://github.com/line/armeria/pull/2935#discussion_r526554771", "createdAt": "2020-11-19T02:38:18Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,8 +356,15 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             if (dnsServerAddressStreamProvider != null) {\n                 builder.nameServerProvider(dnsServerAddressStreamProvider);\n             }\n-            if (dnsQueryLifecycleObserverFactory != null) {\n-                builder.dnsQueryLifecycleObserverFactory(dnsQueryLifecycleObserverFactory);\n+            if (dnsQueryLifecycleObserverFactory == null) {\n+                builder.dnsQueryLifecycleObserverFactory(new DefaultDnsQueryLifecycleObserverFactory(\n+                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA==", "bodyText": "Let's move this class to a test package. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2935#discussion_r526555980", "createdAt": "2020-11-19T02:42:04Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "committedDate": "2020-11-20T03:06:06Z", "message": "removed unnessary chars from regex, indentation fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4a10dacf4ab1e87d737b91c02f3657ecba97637", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/d4a10dacf4ab1e87d737b91c02f3657ecba97637", "committedDate": "2020-11-20T03:39:54Z", "message": "extract construction of DefaultDnsQueryLifecycleObserverFactory in build method of dnsresolvergroupbuilder so we don't create multiple instances of it"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bba534b85d278725ee203f9f7ffba2b8decc7cbd", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/bba534b85d278725ee203f9f7ffba2b8decc7cbd", "committedDate": "2020-11-23T14:07:32Z", "message": "Merge branch 'master' into 1887_dns_metrics_latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/4da165e7209dbe5339709b00a068c22a103953c0", "committedDate": "2020-11-23T14:26:24Z", "message": "Add assertions to confirm exception type others is not being emitted"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDA2OTE3", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-537006917", "createdAt": "2020-11-24T01:42:16Z", "commit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MTExMTgz", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-537111183", "createdAt": "2020-11-24T06:31:17Z", "commit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4MjI0MjEx", "url": "https://github.com/line/armeria/pull/2935#pullrequestreview-538224211", "createdAt": "2020-11-25T07:42:29Z", "commit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNzo0MjoyOVrOH5mjuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNzo0NDo1OVrOH5moDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MjYxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    final ClientFactoryOptionValue<?> opt = options\n          \n          \n            \n                                            .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n          \n          \n            \n                                            .METER_REGISTRY\n          \n          \n            \n                                            .newValue(ClientFactoryOptions.of().meterRegistry()));\n          \n          \n            \n                                    final ClientFactoryOptionValue<?> opt = options.getOrDefault(\n          \n          \n            \n                                            ClientFactoryOptions.METER_REGISTRY,\n          \n          \n            \n                                            ClientFactoryOptions.METER_REGISTRY.newValue(\n          \n          \n            \n                                                    ClientFactoryOptions.of().meterRegistry()));", "url": "https://github.com/line/armeria/pull/2935#discussion_r530162619", "createdAt": "2020-11-25T07:42:29Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -631,7 +631,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n+                                .METER_REGISTRY\n+                                .newValue(ClientFactoryOptions.of().meterRegistry()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ==", "bodyText": "Could you explain why we have this change? This test case doesn't seem to check and DNS metrics.", "url": "https://github.com/line/armeria/pull/2935#discussion_r530163725", "createdAt": "2020-11-25T07:44:59Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/client/RefreshingAddressResolverTest.java", "diffHunk": "@@ -405,6 +406,7 @@ private static DnsResolverGroupBuilder builder(TestDnsServer... servers) {\n                         Stream.of(servers).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n         return new DnsResolverGroupBuilder()\n                 .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da165e7209dbe5339709b00a068c22a103953c0"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9b744c92ae247a8e217108a09cf17cc515e63cf", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/c9b744c92ae247a8e217108a09cf17cc515e63cf", "committedDate": "2020-11-25T17:41:22Z", "message": "Fix indentations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a1af56eb4037e780b90bf1076fc9b7f16828c83", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/4a1af56eb4037e780b90bf1076fc9b7f16828c83", "committedDate": "2020-11-26T05:23:53Z", "message": "Merge master into the branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad71406d3ea81235b2899fd74a0e5c01022386c4", "author": {"user": {"login": "amitvc", "name": "Amit Chavan"}}, "url": "https://github.com/line/armeria/commit/ad71406d3ea81235b2899fd74a0e5c01022386c4", "committedDate": "2020-11-26T05:24:36Z", "message": "increase clientfactory timeout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64571bb7ab4790e99fcfa932ad6dbf3cc4545d10", "author": {"user": {"login": "ikhoon", "name": "Ikhun Um"}}, "url": "https://github.com/line/armeria/commit/64571bb7ab4790e99fcfa932ad6dbf3cc4545d10", "committedDate": "2020-11-27T03:22:30Z", "message": "Fix flaky test and code format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16455362b84dd0995c05be014d023ee68db77ff3", "author": {"user": {"login": "trustin", "name": "Trustin Lee"}}, "url": "https://github.com/line/armeria/commit/16455362b84dd0995c05be014d023ee68db77ff3", "committedDate": "2020-11-27T04:56:13Z", "message": "Checkstyle"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4946, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}