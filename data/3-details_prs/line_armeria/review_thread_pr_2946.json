{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4ODcxNDA3", "number": 2946, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNTozM1rOETlKWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyODowMlrOETlOBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTY3MjU3OnYy", "diffSide": "RIGHT", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/Base64Decoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNTozM1rOG5ZHxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMToxMjowM1rOG5enYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzYwNg==", "bodyText": "Could be decodedByte < EQUALS_SIGN_ENC ?", "url": "https://github.com/line/armeria/pull/2946#discussion_r462833606", "createdAt": "2020-07-30T08:25:33Z", "author": {"login": "trustin"}, "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/Base64Decoder.java", "diffHunk": "@@ -125,17 +123,11 @@ private int decodedBufferSize(int len) {\n     @Override\n     public boolean process(byte value) throws Exception {\n         final byte decodedByte = DECODABET[value & 0xFF];\n-        if (decodedByte < WHITE_SPACE_ENC) {\n+        if (decodedByte <= WHITE_SPACE_ENC) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyMzYxOA==", "bodyText": "Fixed. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2946#discussion_r462923618", "createdAt": "2020-07-30T11:12:03Z", "author": {"login": "minwoox"}, "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/Base64Decoder.java", "diffHunk": "@@ -125,17 +123,11 @@ private int decodedBufferSize(int len) {\n     @Override\n     public boolean process(byte value) throws Exception {\n         final byte decodedByte = DECODABET[value & 0xFF];\n-        if (decodedByte < WHITE_SPACE_ENC) {\n+        if (decodedByte <= WHITE_SPACE_ENC) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzYwNg=="}, "originalCommit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTY3NDA5OnYy", "diffSide": "RIGHT", "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNjowMlrOG5ZIwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMToxMTo1NlrOG5enJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzg1Ng==", "bodyText": "Could use @CsvSource instead?", "url": "https://github.com/line/armeria/pull/2946#discussion_r462833856", "createdAt": "2020-07-30T08:26:02Z", "author": {"login": "trustin"}, "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "diffHunk": "@@ -19,63 +19,65 @@\n \n import java.nio.charset.Charset;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n-import java.util.Random;\n+import java.util.stream.Stream;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.base64.Base64;\n \n class Base64DecoderTest {\n \n-    private static final ByteBuf[] EMPTY_BYTE_BUF = new ByteBuf[0];\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decode(String expected, String encoded) {\n+        final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(encoded.getBytes()));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        decoded.release();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeConcatenatedBufs(String expected, String encoded) {\n+        final ByteBuf buf1 = Unpooled.wrappedBuffer(encoded.getBytes());\n+        final ByteBuf buf2 = buf1.retainedDuplicate();\n \n-    @Test\n-    void decodeConcatenatedBufsWithPadding() {\n-        final String str = \"abcd\"; // YWJjZA==\n-        final ByteBuf buf = Unpooled.wrappedBuffer(str.getBytes());\n-        final ByteBuf encoded1 = Base64.encode(buf);\n-        buf.readerIndex(0);\n-        final ByteBuf encoded2 = Base64.encode(buf);\n-        final ByteBuf concatenated = Unpooled.wrappedBuffer(encoded1, encoded2); // YWJjZA==YWJjZA==\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decoded = base64Decoder.decode(concatenated);\n-        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(\"abcdabcd\");\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(buf1, buf2));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected + expected);\n         decoded.release();\n     }\n \n-    @Test\n-    void decodeMultipleEncodedBytes() {\n-        final String str = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz1234567890\";\n-        final byte[] bytes = str.getBytes();\n-        final List<ByteBuf> fragments = fragmentRandomly(bytes);\n-        final int half = fragments.size() / 2;\n-        final ByteBuf first =\n-                Unpooled.wrappedBuffer(fragments.subList(0, half).toArray(EMPTY_BYTE_BUF));\n-        final ByteBuf second =\n-                Unpooled.wrappedBuffer(fragments.subList(half, fragments.size()).toArray(EMPTY_BYTE_BUF));\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeEachByteSeparately(String expected, String encoded) {\n+        final ByteBuf buf = Unpooled.wrappedBuffer(encoded.getBytes());\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decodedFirst = base64Decoder.decode(first);\n-        final ByteBuf decodedSecond = base64Decoder.decode(second);\n-        assertThat(Unpooled.wrappedBuffer(decodedFirst, decodedSecond).toString(Charset.defaultCharset()))\n-                .isEqualTo(str);\n-        decodedFirst.release();\n-        decodedSecond.release();\n+        final int readableBytes = buf.readableBytes();\n+        final List<ByteBuf> bufs = new ArrayList<>();\n+        for (int i = 0; i < readableBytes; i++) {\n+            bufs.add(base64Decoder.decode(buf.retainedSlice(i, 1)));\n+        }\n+        buf.release();\n+        final ByteBuf wrappedBuffer = Unpooled.wrappedBuffer(bufs.toArray(new ByteBuf[0]));\n+        assertThat(wrappedBuffer.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        wrappedBuffer.release();\n     }\n \n-    private static List<ByteBuf> fragmentRandomly(byte[] bytes) {\n-        final List<ByteBuf> fragments = new ArrayList<>();\n-        for (int i = 0; i < bytes.length;) {\n-            final int to = Math.min(bytes.length,\n-                                    new Random().nextInt(5) + 1 + i); // One byte is selected at least.\n-            final ByteBuf encoded = Base64.encode(Unpooled.wrappedBuffer(Arrays.copyOfRange(bytes, i, to)));\n-            fragments.add(encoded);\n-            i = to;\n+    private static final class EncodedStringProvider implements ArgumentsProvider {\n+\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext context) throws Exception {\n+            return Stream.of(Arguments.of(\"abcde\", \"YWJjZGU=\"),\n+                             Arguments.of(\"123456789\", \"MTIzNDU2Nzg5\"),\n+                             Arguments.of(\"~!@#$%^&*()-_\", \"fiFAIyQlXiYqKCktXw==\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyMzU1OQ==", "bodyText": "Fixed. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2946#discussion_r462923559", "createdAt": "2020-07-30T11:11:56Z", "author": {"login": "minwoox"}, "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "diffHunk": "@@ -19,63 +19,65 @@\n \n import java.nio.charset.Charset;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n-import java.util.Random;\n+import java.util.stream.Stream;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.base64.Base64;\n \n class Base64DecoderTest {\n \n-    private static final ByteBuf[] EMPTY_BYTE_BUF = new ByteBuf[0];\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decode(String expected, String encoded) {\n+        final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(encoded.getBytes()));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        decoded.release();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeConcatenatedBufs(String expected, String encoded) {\n+        final ByteBuf buf1 = Unpooled.wrappedBuffer(encoded.getBytes());\n+        final ByteBuf buf2 = buf1.retainedDuplicate();\n \n-    @Test\n-    void decodeConcatenatedBufsWithPadding() {\n-        final String str = \"abcd\"; // YWJjZA==\n-        final ByteBuf buf = Unpooled.wrappedBuffer(str.getBytes());\n-        final ByteBuf encoded1 = Base64.encode(buf);\n-        buf.readerIndex(0);\n-        final ByteBuf encoded2 = Base64.encode(buf);\n-        final ByteBuf concatenated = Unpooled.wrappedBuffer(encoded1, encoded2); // YWJjZA==YWJjZA==\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decoded = base64Decoder.decode(concatenated);\n-        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(\"abcdabcd\");\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(buf1, buf2));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected + expected);\n         decoded.release();\n     }\n \n-    @Test\n-    void decodeMultipleEncodedBytes() {\n-        final String str = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz1234567890\";\n-        final byte[] bytes = str.getBytes();\n-        final List<ByteBuf> fragments = fragmentRandomly(bytes);\n-        final int half = fragments.size() / 2;\n-        final ByteBuf first =\n-                Unpooled.wrappedBuffer(fragments.subList(0, half).toArray(EMPTY_BYTE_BUF));\n-        final ByteBuf second =\n-                Unpooled.wrappedBuffer(fragments.subList(half, fragments.size()).toArray(EMPTY_BYTE_BUF));\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeEachByteSeparately(String expected, String encoded) {\n+        final ByteBuf buf = Unpooled.wrappedBuffer(encoded.getBytes());\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decodedFirst = base64Decoder.decode(first);\n-        final ByteBuf decodedSecond = base64Decoder.decode(second);\n-        assertThat(Unpooled.wrappedBuffer(decodedFirst, decodedSecond).toString(Charset.defaultCharset()))\n-                .isEqualTo(str);\n-        decodedFirst.release();\n-        decodedSecond.release();\n+        final int readableBytes = buf.readableBytes();\n+        final List<ByteBuf> bufs = new ArrayList<>();\n+        for (int i = 0; i < readableBytes; i++) {\n+            bufs.add(base64Decoder.decode(buf.retainedSlice(i, 1)));\n+        }\n+        buf.release();\n+        final ByteBuf wrappedBuffer = Unpooled.wrappedBuffer(bufs.toArray(new ByteBuf[0]));\n+        assertThat(wrappedBuffer.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        wrappedBuffer.release();\n     }\n \n-    private static List<ByteBuf> fragmentRandomly(byte[] bytes) {\n-        final List<ByteBuf> fragments = new ArrayList<>();\n-        for (int i = 0; i < bytes.length;) {\n-            final int to = Math.min(bytes.length,\n-                                    new Random().nextInt(5) + 1 + i); // One byte is selected at least.\n-            final ByteBuf encoded = Base64.encode(Unpooled.wrappedBuffer(Arrays.copyOfRange(bytes, i, to)));\n-            fragments.add(encoded);\n-            i = to;\n+    private static final class EncodedStringProvider implements ArgumentsProvider {\n+\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext context) throws Exception {\n+            return Stream.of(Arguments.of(\"abcde\", \"YWJjZGU=\"),\n+                             Arguments.of(\"123456789\", \"MTIzNDU2Nzg5\"),\n+                             Arguments.of(\"~!@#$%^&*()-_\", \"fiFAIyQlXiYqKCktXw==\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzg1Ng=="}, "originalCommit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTY4MTk2OnYy", "diffSide": "RIGHT", "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyODowMlrOG5ZNng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMToxMjozNlrOG5eoSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNTEwMg==", "bodyText": "Could be simplified into:\nwhile (buf.isReadable()) {\n    bufs.add(base64Decoder.decode(buf.readRetainedSlice(1)));\n}", "url": "https://github.com/line/armeria/pull/2946#discussion_r462835102", "createdAt": "2020-07-30T08:28:02Z", "author": {"login": "trustin"}, "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "diffHunk": "@@ -19,63 +19,65 @@\n \n import java.nio.charset.Charset;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n-import java.util.Random;\n+import java.util.stream.Stream;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.base64.Base64;\n \n class Base64DecoderTest {\n \n-    private static final ByteBuf[] EMPTY_BYTE_BUF = new ByteBuf[0];\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decode(String expected, String encoded) {\n+        final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(encoded.getBytes()));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        decoded.release();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeConcatenatedBufs(String expected, String encoded) {\n+        final ByteBuf buf1 = Unpooled.wrappedBuffer(encoded.getBytes());\n+        final ByteBuf buf2 = buf1.retainedDuplicate();\n \n-    @Test\n-    void decodeConcatenatedBufsWithPadding() {\n-        final String str = \"abcd\"; // YWJjZA==\n-        final ByteBuf buf = Unpooled.wrappedBuffer(str.getBytes());\n-        final ByteBuf encoded1 = Base64.encode(buf);\n-        buf.readerIndex(0);\n-        final ByteBuf encoded2 = Base64.encode(buf);\n-        final ByteBuf concatenated = Unpooled.wrappedBuffer(encoded1, encoded2); // YWJjZA==YWJjZA==\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decoded = base64Decoder.decode(concatenated);\n-        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(\"abcdabcd\");\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(buf1, buf2));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected + expected);\n         decoded.release();\n     }\n \n-    @Test\n-    void decodeMultipleEncodedBytes() {\n-        final String str = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz1234567890\";\n-        final byte[] bytes = str.getBytes();\n-        final List<ByteBuf> fragments = fragmentRandomly(bytes);\n-        final int half = fragments.size() / 2;\n-        final ByteBuf first =\n-                Unpooled.wrappedBuffer(fragments.subList(0, half).toArray(EMPTY_BYTE_BUF));\n-        final ByteBuf second =\n-                Unpooled.wrappedBuffer(fragments.subList(half, fragments.size()).toArray(EMPTY_BYTE_BUF));\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeEachByteSeparately(String expected, String encoded) {\n+        final ByteBuf buf = Unpooled.wrappedBuffer(encoded.getBytes());\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decodedFirst = base64Decoder.decode(first);\n-        final ByteBuf decodedSecond = base64Decoder.decode(second);\n-        assertThat(Unpooled.wrappedBuffer(decodedFirst, decodedSecond).toString(Charset.defaultCharset()))\n-                .isEqualTo(str);\n-        decodedFirst.release();\n-        decodedSecond.release();\n+        final int readableBytes = buf.readableBytes();\n+        final List<ByteBuf> bufs = new ArrayList<>();\n+        for (int i = 0; i < readableBytes; i++) {\n+            bufs.add(base64Decoder.decode(buf.retainedSlice(i, 1)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyMzg0OA==", "bodyText": "Fixed. \ud83d\ude09  Didn't know that ByteBuf has this API. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2946#discussion_r462923848", "createdAt": "2020-07-30T11:12:36Z", "author": {"login": "minwoox"}, "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "diffHunk": "@@ -19,63 +19,65 @@\n \n import java.nio.charset.Charset;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n-import java.util.Random;\n+import java.util.stream.Stream;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.base64.Base64;\n \n class Base64DecoderTest {\n \n-    private static final ByteBuf[] EMPTY_BYTE_BUF = new ByteBuf[0];\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decode(String expected, String encoded) {\n+        final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(encoded.getBytes()));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        decoded.release();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeConcatenatedBufs(String expected, String encoded) {\n+        final ByteBuf buf1 = Unpooled.wrappedBuffer(encoded.getBytes());\n+        final ByteBuf buf2 = buf1.retainedDuplicate();\n \n-    @Test\n-    void decodeConcatenatedBufsWithPadding() {\n-        final String str = \"abcd\"; // YWJjZA==\n-        final ByteBuf buf = Unpooled.wrappedBuffer(str.getBytes());\n-        final ByteBuf encoded1 = Base64.encode(buf);\n-        buf.readerIndex(0);\n-        final ByteBuf encoded2 = Base64.encode(buf);\n-        final ByteBuf concatenated = Unpooled.wrappedBuffer(encoded1, encoded2); // YWJjZA==YWJjZA==\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decoded = base64Decoder.decode(concatenated);\n-        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(\"abcdabcd\");\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(buf1, buf2));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected + expected);\n         decoded.release();\n     }\n \n-    @Test\n-    void decodeMultipleEncodedBytes() {\n-        final String str = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz1234567890\";\n-        final byte[] bytes = str.getBytes();\n-        final List<ByteBuf> fragments = fragmentRandomly(bytes);\n-        final int half = fragments.size() / 2;\n-        final ByteBuf first =\n-                Unpooled.wrappedBuffer(fragments.subList(0, half).toArray(EMPTY_BYTE_BUF));\n-        final ByteBuf second =\n-                Unpooled.wrappedBuffer(fragments.subList(half, fragments.size()).toArray(EMPTY_BYTE_BUF));\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeEachByteSeparately(String expected, String encoded) {\n+        final ByteBuf buf = Unpooled.wrappedBuffer(encoded.getBytes());\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decodedFirst = base64Decoder.decode(first);\n-        final ByteBuf decodedSecond = base64Decoder.decode(second);\n-        assertThat(Unpooled.wrappedBuffer(decodedFirst, decodedSecond).toString(Charset.defaultCharset()))\n-                .isEqualTo(str);\n-        decodedFirst.release();\n-        decodedSecond.release();\n+        final int readableBytes = buf.readableBytes();\n+        final List<ByteBuf> bufs = new ArrayList<>();\n+        for (int i = 0; i < readableBytes; i++) {\n+            bufs.add(base64Decoder.decode(buf.retainedSlice(i, 1)));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNTEwMg=="}, "originalCommit": {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2156, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}