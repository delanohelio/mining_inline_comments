{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NjAyMzAw", "number": 2363, "title": "Add examples for context propagation", "bodyText": "This changeset adds the examples for context propagation using Dagger, RxJava and Armeria's builtin API. The purpose of the examples is to show good patterns for context propagation.\nThe same pattern here can be applied regardless of if there are other libraries like MySQL / Redis involved and hopefully can be helpful for understanding context in complex server codebases.\nSee #2347 for the context.", "createdAt": "2020-01-02T09:47:38Z", "url": "https://github.com/line/armeria/pull/2363", "merged": true, "mergeCommit": {"oid": "26dd639dc538befbd0a20edc76918d022e1c7517"}, "closed": true, "closedAt": "2020-01-14T06:46:19Z", "author": {"login": "anuraaga"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2Wi1cAH2gAyMzU4NjAyMzAwOmU2OTRhNmJhNDM2MjE1ZmQ3NmQ2YTVhZTUxMGQ4MjFiZWQwZjk5NzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb4juPEAH2gAyMzU4NjAyMzAwOjNmMDAwN2ZmOTA0OWRlYzY5NWQ3MTE1OWEwYmJiNDY3YjIyNzE5ODc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e694a6ba436215fd76d6a5ae510d821bed0f9973", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/e694a6ba436215fd76d6a5ae510d821bed0f9973", "committedDate": "2020-01-02T09:42:48Z", "message": "Add examples for context propagation using manual propagation and Dagger."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3f5e2a22d68c403a9b5f3eea6024b63421d8a0d", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/c3f5e2a22d68c403a9b5f3eea6024b63421d8a0d", "committedDate": "2020-01-05T06:08:12Z", "message": "Squares"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d8fd5c594182c5e81d854fb6910c8b8f7373153", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/6d8fd5c594182c5e81d854fb6910c8b8f7373153", "committedDate": "2020-01-05T06:25:15Z", "message": "Indent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa7127b2e77c02da3605cc98ce70697bf5d72c0f", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/fa7127b2e77c02da3605cc98ce70697bf5d72c0f", "committedDate": "2020-01-05T06:26:45Z", "message": "Remove too-inner import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NDQ0NzU3", "url": "https://github.com/line/armeria/pull/2363#pullrequestreview-338444757", "createdAt": "2020-01-06T02:23:59Z", "commit": {"oid": "fa7127b2e77c02da3605cc98ce70697bf5d72c0f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQwMjoyMzo1OVrOFaUPRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQwMjoyMzo1OVrOFaUPRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEzODg4Ng==", "bodyText": "nit: indentation.", "url": "https://github.com/line/armeria/pull/2363#discussion_r363138886", "createdAt": "2020-01-06T02:23:59Z", "author": {"login": "minwoox"}, "path": "examples/context-propagation/manual/src/main/java/example/armeria/contextpropagation/manual/MainService.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package example.armeria.contextpropagation.manual;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.spotify.futures.CompletableFutures;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+public class MainService implements HttpService {\n+\n+    private static final Splitter NUM_SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Executor ctxExecutor = ctx.contextAwareExecutor();\n+\n+        final CompletableFuture<AggregatedHttpRequest> aggregated = req.aggregate();\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final CompletableFuture<List<Long>> fetchFromFakeDb = CompletableFuture.supplyAsync(\n+                () -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic such\n+                    // as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+\n+                    Uninterruptibles.sleepUninterruptibly(Duration.ofMillis(50));\n+                    return ImmutableList.of(23L, -23L);\n+                },\n+                // Always run blocking logic on the blocking task executor. By using\n+                // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted inside the\n+                // logic (e.g., your DB call will be traced!).\n+                ctx.blockingTaskExecutor());\n+\n+        final CompletableFuture<List<CompletableFuture<AggregatedHttpResponse>>> fetchFromBackend =\n+                CompletableFuture.allOf(\n+                        aggregated, fetchFromFakeDb).thenApplyAsync(\n+                        unused -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all logic\n+                            // such as tracing.\n+                            checkState(ServiceRequestContext.current() == ctx);\n+\n+                            final AggregatedHttpRequest request = aggregated.join();\n+\n+                            final Stream.Builder<Long> nums = Stream.builder();\n+                            for (String token : Iterables.concat(\n+                                    NUM_SPLITTER.split(request.path().substring(1)),\n+                                    NUM_SPLITTER.split(request.contentUtf8()))) {\n+                                nums.add(Long.parseLong(token));\n+                            }\n+                            fetchFromFakeDb.join().forEach(nums::add);\n+\n+                            return nums.build()\n+                                       .map(num -> backendClient.get(\"/square/\" + num).aggregate())\n+                                       .collect(toImmutableList());\n+                        },\n+                        // Unless you know what you're doing, always use then*Async type methods with the\n+                        // context executor to have the context mounted and stay on a single thread to reduce\n+                        // concurrency issues.\n+                        ctxExecutor);\n+\n+        final CompletableFuture<HttpResponse> response =\n+                // When using CompletableFuture, boiler-plate invocations to wrap / unwrap futures are sometimes\n+                // required. Such boilerplate has no chance of using Armeria's context and it is ok to not\n+                // use ctxExecutor for them. But if in doubt, it doesn't hurt too much to use it everywhere.\n+                fetchFromBackend.thenApply(CompletableFutures::allAsList)\n+                                .thenCompose(u -> u)\n+                                .thenApplyAsync(\n+                                        (backendResponse) -> {\n+                                            // The context is mounted in a thread-local, meaning it is\n+                                            // available to all logic such as tracing.\n+                                            checkState(ServiceRequestContext.current() == ctx);\n+                                            return HttpResponse.of(backendResponse.stream()\n+                                                                   .map(AggregatedHttpResponse::contentUtf8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa7127b2e77c02da3605cc98ce70697bf5d72c0f"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dadedd35b2ee515c726efdb100118515fd6cb14e", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/dadedd35b2ee515c726efdb100118515fd6cb14e", "committedDate": "2020-01-06T05:27:56Z", "message": "Indent"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NDg0NTEw", "url": "https://github.com/line/armeria/pull/2363#pullrequestreview-338484510", "createdAt": "2020-01-06T06:27:40Z", "commit": {"oid": "dadedd35b2ee515c726efdb100118515fd6cb14e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90a29b732928d0518c23350f49baef643f70844b", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/90a29b732928d0518c23350f49baef643f70844b", "committedDate": "2020-01-06T06:32:37Z", "message": "Update README"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "053d054de82088d18accb072dc1ad116ef78f3fb", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/053d054de82088d18accb072dc1ad116ef78f3fb", "committedDate": "2020-01-06T06:33:33Z", "message": "Period"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NTI0Mzk3", "url": "https://github.com/line/armeria/pull/2363#pullrequestreview-338524397", "createdAt": "2020-01-06T08:49:26Z", "commit": {"oid": "053d054de82088d18accb072dc1ad116ef78f3fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQwODo0OToyNlrOFaYJXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQwODo0OToyNlrOFaYJXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIwMjkwOQ==", "bodyText": "Better hyperlinking for the Dagger asynchronous framework?", "url": "https://github.com/line/armeria/pull/2363#discussion_r363202909", "createdAt": "2020-01-06T08:49:26Z", "author": {"login": "trustin"}, "path": "examples/README.md", "diffHunk": "@@ -4,6 +4,12 @@\n   - Learn how to write an HTTP service using annotations.\n   - See [Annotated services](https://line.github.io/armeria/server-annotated-service.html).\n \n+- `context-propagation`\n+  - Learn how to propagate Armeria's `RequestContext` for use in scenarios like tracing.\n+  - [`dagger`](https://dagger.dev) provides an example using the Dagger asynchronous framework for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "053d054de82088d18accb072dc1ad116ef78f3fb"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NTMwOTY0", "url": "https://github.com/line/armeria/pull/2363#pullrequestreview-338530964", "createdAt": "2020-01-06T09:06:03Z", "commit": {"oid": "053d054de82088d18accb072dc1ad116ef78f3fb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac5286aea75ee90739397f6e2d961c634c73f151", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/ac5286aea75ee90739397f6e2d961c634c73f151", "committedDate": "2020-01-06T09:56:17Z", "message": "Add rxjava example"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NTU0MzY1", "url": "https://github.com/line/armeria/pull/2363#pullrequestreview-338554365", "createdAt": "2020-01-06T09:56:31Z", "commit": {"oid": "ac5286aea75ee90739397f6e2d961c634c73f151"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NTYyNDQw", "url": "https://github.com/line/armeria/pull/2363#pullrequestreview-338562440", "createdAt": "2020-01-06T10:13:26Z", "commit": {"oid": "ac5286aea75ee90739397f6e2d961c634c73f151"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQxMDoxMzoyNlrOFaZ6iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQxMDoxMzoyNlrOFaZ6iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIzMTg4Mw==", "bodyText": "One aspect of rxjava integration I noticed is methods like these are fairly ridiculously slow due to context mounting. An inevitable downside of having the integration be a single static method invocation in main I guess.", "url": "https://github.com/line/armeria/pull/2363#discussion_r363231883", "createdAt": "2020-01-06T10:13:26Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/rxjava/src/main/java/example/armeria/contextpropagation/rxjava/MainService.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package example.armeria.contextpropagation.rxjava;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import net.javacrumbs.futureconverter.java8rx2.FutureConverter;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.reactivex.Observable;\n+import io.reactivex.Single;\n+\n+public class MainService implements HttpService {\n+\n+    private static final Splitter NUM_SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final CompletableFuture<List<Long>> fetchFromFakeDb = CompletableFuture.supplyAsync(\n+                () -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic such\n+                    // as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+\n+                    Uninterruptibles.sleepUninterruptibly(Duration.ofMillis(50));\n+                    return ImmutableList.of(23L, -23L);\n+                },\n+                // Always run blocking logic on the blocking task executor. By using\n+                // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted inside the\n+                // logic (e.g., your DB call will be traced!).\n+                ctx.blockingTaskExecutor());\n+\n+        final Single<HttpResponse> response = FutureConverter\n+                .toSingle(req.aggregate())\n+                .flatMapObservable(request -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic\n+                    // such as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+\n+                    final List<Long> nums = new ArrayList<>();\n+                    for (String token : Iterables.concat(\n+                            NUM_SPLITTER.split(request.path().substring(1)),\n+                            NUM_SPLITTER.split(request.contentUtf8()))) {\n+                        nums.add(Long.parseLong(token));\n+                    }\n+\n+                    return Observable.fromIterable(nums);\n+                })\n+                .mergeWith(FutureConverter.toSingle(fetchFromFakeDb)\n+                                          .flatMapObservable(Observable::fromIterable))\n+                .flatMapSingle(num -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic\n+                    // such as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+\n+                    return FutureConverter.toSingle(backendClient.get(\"/square/\" + num).aggregate());\n+                })\n+                .map(AggregatedHttpResponse::contentUtf8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5286aea75ee90739397f6e2d961c634c73f151"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cb89b8a3f18042571380b8dbf2b73b06eb9bb3d", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/2cb89b8a3f18042571380b8dbf2b73b06eb9bb3d", "committedDate": "2020-01-06T10:21:59Z", "message": "More idiomatic?"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99cb82cd2e71e53ac353c72bb7c06ede9ff1648e", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/99cb82cd2e71e53ac353c72bb7c06ede9ff1648e", "committedDate": "2020-01-06T10:25:05Z", "message": "More idiomatic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9d22a9ca24dcd386ec13ed6e08b963c82534cad", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/a9d22a9ca24dcd386ec13ed6e08b963c82534cad", "committedDate": "2020-01-06T10:37:14Z", "message": "Add thread assertions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10c61933509bf0397e60098d026c0df3f4621076", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/10c61933509bf0397e60098d026c0df3f4621076", "committedDate": "2020-01-06T10:58:45Z", "message": "Manual subscription instead to stay on same thread."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5MDEyMzQ4", "url": "https://github.com/line/armeria/pull/2363#pullrequestreview-339012348", "createdAt": "2020-01-07T03:16:11Z", "commit": {"oid": "10c61933509bf0397e60098d026c0df3f4621076"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwMzoxNjoxMlrOFau9PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwMzoxNjo0MlrOFau9pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3NjYzNw==", "bodyText": "Maybe Flowable.concatEager is more suitable comapring to other example.", "url": "https://github.com/line/armeria/pull/2363#discussion_r363576637", "createdAt": "2020-01-07T03:16:12Z", "author": {"login": "kojilin"}, "path": "examples/context-propagation/rxjava/src/main/java/example/armeria/contextpropagation/rxjava/MainService.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package example.armeria.contextpropagation.rxjava;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import net.javacrumbs.futureconverter.java8rx2.FutureConverter;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.reactivex.Observable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.Single;\n+import io.reactivex.schedulers.Schedulers;\n+\n+public class MainService implements HttpService {\n+\n+    private static final Splitter NUM_SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Scheduler contextAwareScheduler = Schedulers.from(ctx.contextAwareExecutor());\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final Observable<Long> fetchFromFakeDb =\n+                Single.fromCallable(\n+                        () -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all\n+                            // logic such as tracing.\n+                            checkState(ServiceRequestContext.current() == ctx);\n+                            checkState(!ctx.eventLoop().inEventLoop());\n+\n+                            Uninterruptibles.sleepUninterruptibly(Duration.ofMillis(50));\n+                            return ImmutableList.of(23L, -23L);\n+                        })\n+                      // Always run blocking logic on the blocking task executor. By using\n+                      // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted\n+                      // inside the logic (e.g., your DB call will be traced!).\n+                      .subscribeOn(Schedulers.from(ctx.blockingTaskExecutor()))\n+                      // Make sure callbacks still stay on the context executor using observeOn.\n+                      .observeOn(contextAwareScheduler)\n+                      .flattenAsObservable(l -> l);\n+\n+        final Single<HttpResponse> response = FutureConverter\n+                .toSingle(req.aggregate())\n+                // Unless you know what you're doing, always use subscribeOn with the context executor to have\n+                // the context mounted and stay on a single thread to reduce concurrency issues.\n+                .subscribeOn(contextAwareScheduler)\n+                .flatMapObservable(request -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic\n+                    // such as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+                    checkState(ctx.eventLoop().inEventLoop());\n+\n+                    final List<Long> nums = new ArrayList<>();\n+                    for (String token : Iterables.concat(\n+                            NUM_SPLITTER.split(request.path().substring(1)),\n+                            NUM_SPLITTER.split(request.contentUtf8()))) {\n+                        nums.add(Long.parseLong(token));\n+                    }\n+\n+                    return Observable.fromIterable(nums);\n+                })\n+                .mergeWith(fetchFromFakeDb)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10c61933509bf0397e60098d026c0df3f4621076"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Njc0Mw==", "bodyText": "Maybe put at chaining phase?", "url": "https://github.com/line/armeria/pull/2363#discussion_r363576743", "createdAt": "2020-01-07T03:16:42Z", "author": {"login": "kojilin"}, "path": "examples/context-propagation/rxjava/src/main/java/example/armeria/contextpropagation/rxjava/MainService.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package example.armeria.contextpropagation.rxjava;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import net.javacrumbs.futureconverter.java8rx2.FutureConverter;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.reactivex.Observable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.Single;\n+import io.reactivex.schedulers.Schedulers;\n+\n+public class MainService implements HttpService {\n+\n+    private static final Splitter NUM_SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Scheduler contextAwareScheduler = Schedulers.from(ctx.contextAwareExecutor());\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final Observable<Long> fetchFromFakeDb =\n+                Single.fromCallable(\n+                        () -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all\n+                            // logic such as tracing.\n+                            checkState(ServiceRequestContext.current() == ctx);\n+                            checkState(!ctx.eventLoop().inEventLoop());\n+\n+                            Uninterruptibles.sleepUninterruptibly(Duration.ofMillis(50));\n+                            return ImmutableList.of(23L, -23L);\n+                        })\n+                      // Always run blocking logic on the blocking task executor. By using\n+                      // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted\n+                      // inside the logic (e.g., your DB call will be traced!).\n+                      .subscribeOn(Schedulers.from(ctx.blockingTaskExecutor()))\n+                      // Make sure callbacks still stay on the context executor using observeOn.\n+                      .observeOn(contextAwareScheduler)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10c61933509bf0397e60098d026c0df3f4621076"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23ab20ec713ad69cfbb3fd396842ab4f0ad232bf", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/23ab20ec713ad69cfbb3fd396842ab4f0ad232bf", "committedDate": "2020-01-08T05:15:15Z", "message": "Merge branch 'master' of github.com:line/armeria into context-propagation-examples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69581a8730e18db6cd005661db8eb7e978f031a4", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/69581a8730e18db6cd005661db8eb7e978f031a4", "committedDate": "2020-01-08T05:25:27Z", "message": "Flowable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5NjUyMzc3", "url": "https://github.com/line/armeria/pull/2363#pullrequestreview-339652377", "createdAt": "2020-01-08T05:27:57Z", "commit": {"oid": "69581a8730e18db6cd005661db8eb7e978f031a4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNToyNzo1N1rOFbM_7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNToyNzo1N1rOFbM_7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2ODg0NQ==", "bodyText": "Can you provide your reasoning for that? I can add as a comment and update :) I figured it's better to be here since the reason we need to observeOn is because of the blocking subscription, so having the two close to each other seems more readable.", "url": "https://github.com/line/armeria/pull/2363#discussion_r364068845", "createdAt": "2020-01-08T05:27:57Z", "author": {"login": "anuraaga"}, "path": "examples/context-propagation/rxjava/src/main/java/example/armeria/contextpropagation/rxjava/MainService.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package example.armeria.contextpropagation.rxjava;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import net.javacrumbs.futureconverter.java8rx2.FutureConverter;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.reactivex.Observable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.Single;\n+import io.reactivex.schedulers.Schedulers;\n+\n+public class MainService implements HttpService {\n+\n+    private static final Splitter NUM_SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Scheduler contextAwareScheduler = Schedulers.from(ctx.contextAwareExecutor());\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final Observable<Long> fetchFromFakeDb =\n+                Single.fromCallable(\n+                        () -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all\n+                            // logic such as tracing.\n+                            checkState(ServiceRequestContext.current() == ctx);\n+                            checkState(!ctx.eventLoop().inEventLoop());\n+\n+                            Uninterruptibles.sleepUninterruptibly(Duration.ofMillis(50));\n+                            return ImmutableList.of(23L, -23L);\n+                        })\n+                      // Always run blocking logic on the blocking task executor. By using\n+                      // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted\n+                      // inside the logic (e.g., your DB call will be traced!).\n+                      .subscribeOn(Schedulers.from(ctx.blockingTaskExecutor()))\n+                      // Make sure callbacks still stay on the context executor using observeOn.\n+                      .observeOn(contextAwareScheduler)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Njc0Mw=="}, "originalCommit": {"oid": "10c61933509bf0397e60098d026c0df3f4621076"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f0007ff9049dec695d71159a0bbb467b2271987", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/line/armeria/commit/3f0007ff9049dec695d71159a0bbb467b2271987", "committedDate": "2020-01-09T06:11:52Z", "message": "Move observeOn to composition layer."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1037, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}