{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMDEzMTM4", "number": 2837, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNTozNTo0OFrOEJAi5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo0Njo1MlrOEJDeyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODgxNTcyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/AbstractEndpointSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNTozNTo0OFrOGpUP4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNTozNTo0OFrOGpUP4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk3NjU0Nw==", "bodyText": "Could remove AbstractEndpointSelector.this.?", "url": "https://github.com/line/armeria/pull/2837#discussion_r445976547", "createdAt": "2020-06-26T05:35:48Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/AbstractEndpointSelector.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+\n+/**\n+ * A skeletal {@link EndpointSelector} implementation. This abstract class implements the\n+ * {@link #select(ClientRequestContext, ScheduledExecutorService, long)} method by listening to\n+ * the change events emitted by {@link EndpointGroup} specified at construction time.\n+ */\n+public abstract class AbstractEndpointSelector implements EndpointSelector {\n+\n+    private final EndpointGroup endpointGroup;\n+\n+    /**\n+     * Creates a new instance that selects an {@link Endpoint} from the specified {@link EndpointGroup}.\n+     */\n+    protected AbstractEndpointSelector(EndpointGroup endpointGroup) {\n+        this.endpointGroup = requireNonNull(endpointGroup, \"endpointGroup\");\n+    }\n+\n+    /**\n+     * Returns the {@link EndpointGroup} being selected by this {@link EndpointSelector}.\n+     */\n+    protected final EndpointGroup group() {\n+        return endpointGroup;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<Endpoint> select(ClientRequestContext ctx,\n+                                                    ScheduledExecutorService executor,\n+                                                    long timeoutMillis) {\n+        Endpoint endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        final ListeningFuture listeningFuture = new ListeningFuture(ctx, executor);\n+        endpointGroup.addListener(listeningFuture);\n+\n+        // Try to select again because the EndpointGroup might have been updated\n+        // between selectNow() and addListener() above.\n+        endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            endpointGroup.removeListener(listeningFuture);\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        // Schedule the timeout task.\n+        final ScheduledFuture<?> timeoutFuture =\n+                executor.schedule(() -> listeningFuture.complete(null),\n+                                  timeoutMillis, TimeUnit.MILLISECONDS);\n+        listeningFuture.timeoutFuture = timeoutFuture;\n+\n+        // Cancel the timeout task if necessary, just in case listeningFuture is\n+        // completed even before we assign timeoutFuture to listeningFuture.timeoutFuture.\n+        if (listeningFuture.isDone()) {\n+            timeoutFuture.cancel(false);\n+        }\n+\n+        return listeningFuture;\n+    }\n+\n+    private class ListeningFuture extends CompletableFuture<Endpoint> implements Consumer<List<Endpoint>> {\n+        private final ClientRequestContext ctx;\n+        private final Executor executor;\n+        @Nullable\n+        private volatile Endpoint selectedEndpoint;\n+        @Nullable\n+        private volatile ScheduledFuture<?> timeoutFuture;\n+\n+        ListeningFuture(ClientRequestContext ctx, Executor executor) {\n+            this.ctx = ctx;\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void accept(List<Endpoint> unused) {\n+            if (selectedEndpoint != null || isDone()) {\n+                return;\n+            }\n+\n+            try {\n+                final Endpoint endpoint = AbstractEndpointSelector.this.selectNow(ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODgyOTcwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNTo0NDoxNlrOGpUYTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNTo0NDoxNlrOGpUYTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk3ODcwMg==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.endpointGroup = null;\n          \n          \n            \n                    endpointGroup = null;", "url": "https://github.com/line/armeria/pull/2837#discussion_r445978702", "createdAt": "2020-06-26T05:44:16Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODgzOTU4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNTo1MDoxN1rOGpUeZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMTozMzozN1rOGqMqJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4MDI2Mg==", "bodyText": "Question: Why thenCompose(Function.identity()) is needed here? \ud83e\uddd0", "url": "https://github.com/line/armeria/pull/2837#discussion_r445980262", "createdAt": "2020-06-26T05:50:17Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();\n+        return endpointGroup.select(this, temporaryEventLoop, connectTimeoutMillis()).handle((e, cause) -> {\n+            updateEndpoint(e);\n+            acquireEventLoop(endpointGroup);\n+\n+            final boolean success;\n+            if (cause != null) {\n+                failEarly(cause);\n+                success = false;\n+            } else {\n+                success = true;\n+            }\n \n-        return true;\n+            final EventLoop acquiredEventLoop = eventLoop();\n+            if (acquiredEventLoop == temporaryEventLoop) {\n+                // We were lucky. No need to hand over to other EventLoop.\n+                return UnmodifiableFuture.completedFuture(success);\n+            } else {\n+                // We need to hand over to the acquired EventLoop.\n+                return CompletableFuture.supplyAsync(() -> success, acquiredEventLoop);\n+            }\n+        }).thenCompose(Function.identity());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMzk4Nw==", "bodyText": "To make CompletableFuture<CompletableFuture<Boolean>> to CompletableFuture<Boolean>?", "url": "https://github.com/line/armeria/pull/2837#discussion_r446023987", "createdAt": "2020-06-26T07:48:53Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();\n+        return endpointGroup.select(this, temporaryEventLoop, connectTimeoutMillis()).handle((e, cause) -> {\n+            updateEndpoint(e);\n+            acquireEventLoop(endpointGroup);\n+\n+            final boolean success;\n+            if (cause != null) {\n+                failEarly(cause);\n+                success = false;\n+            } else {\n+                success = true;\n+            }\n \n-        return true;\n+            final EventLoop acquiredEventLoop = eventLoop();\n+            if (acquiredEventLoop == temporaryEventLoop) {\n+                // We were lucky. No need to hand over to other EventLoop.\n+                return UnmodifiableFuture.completedFuture(success);\n+            } else {\n+                // We need to hand over to the acquired EventLoop.\n+                return CompletableFuture.supplyAsync(() -> success, acquiredEventLoop);\n+            }\n+        }).thenCompose(Function.identity());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4MDI2Mg=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwMDc3NQ==", "bodyText": "Ah, flatten! \ud83e\udd23", "url": "https://github.com/line/armeria/pull/2837#discussion_r446900775", "createdAt": "2020-06-29T11:33:37Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();\n+        return endpointGroup.select(this, temporaryEventLoop, connectTimeoutMillis()).handle((e, cause) -> {\n+            updateEndpoint(e);\n+            acquireEventLoop(endpointGroup);\n+\n+            final boolean success;\n+            if (cause != null) {\n+                failEarly(cause);\n+                success = false;\n+            } else {\n+                success = true;\n+            }\n \n-        return true;\n+            final EventLoop acquiredEventLoop = eventLoop();\n+            if (acquiredEventLoop == temporaryEventLoop) {\n+                // We were lucky. No need to hand over to other EventLoop.\n+                return UnmodifiableFuture.completedFuture(success);\n+            } else {\n+                // We need to hand over to the acquired EventLoop.\n+                return CompletableFuture.supplyAsync(() -> success, acquiredEventLoop);\n+            }\n+        }).thenCompose(Function.identity());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4MDI2Mg=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODg2NTA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNjowMzoyNVrOGpUtng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNjowMzoyNVrOGpUtng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4NDE1OA==", "bodyText": "Could merge two lines?", "url": "https://github.com/line/armeria/pull/2837#discussion_r445984158", "createdAt": "2020-06-26T06:03:25Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);\n                 }\n \n-                // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n-                final Throwable cause = ctx.log().partial().requestCause();\n-                assert cause != null;\n-                return fallbackResponseFactory.apply(ctx, cause);\n+                return initContextAndExecuteWithFallback(delegate, ctx, errorResponseFactory, success);\n+            } else {\n+                return futureConverter.apply(initFuture.handle((success, cause) -> {\n+                    try {\n+                        if (cause != null) {\n+                            throw cause;\n+                        }\n+\n+                        return initContextAndExecuteWithFallback(\n+                                delegate, ctx, errorResponseFactory, success);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODg4MTE5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNjoxMjoxMVrOGpU3fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMDoxNjozOVrOGpbnRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4NjY4Ng==", "bodyText": "Wrap with UnprocessedRequestException.wrap(e) once #2836 is merged?", "url": "https://github.com/line/armeria/pull/2837#discussion_r445986686", "createdAt": "2020-06-26T06:12:11Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NzIyMQ==", "bodyText": "Done.", "url": "https://github.com/line/armeria/pull/2837#discussion_r446097221", "createdAt": "2020-06-26T10:16:39Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4NjY4Ng=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODkwMzYwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNjoyMzo1NVrOGpVFbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo1NDo1M1rOGpZJdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5MDI1Mg==", "bodyText": "Not related to this PR. Could we propagrate the cause to res via res.abort(cause)?", "url": "https://github.com/line/armeria/pull/2837#discussion_r445990252", "createdAt": "2020-06-26T06:23:55Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);\n                 }\n \n-                // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n-                final Throwable cause = ctx.log().partial().requestCause();\n-                assert cause != null;\n-                return fallbackResponseFactory.apply(ctx, cause);\n+                return initContextAndExecuteWithFallback(delegate, ctx, errorResponseFactory, success);\n+            } else {\n+                return futureConverter.apply(initFuture.handle((success, cause) -> {\n+                    try {\n+                        if (cause != null) {\n+                            throw cause;\n+                        }\n+\n+                        return initContextAndExecuteWithFallback(\n+                                delegate, ctx, errorResponseFactory, success);\n+                    } catch (Throwable t) {\n+                        fail(ctx, t);\n+                        return errorResponseFactory.apply(ctx, t);\n+                    }\n+                }));\n             }\n         } catch (Throwable cause) {\n             fail(ctx, cause);\n-            return fallbackResponseFactory.apply(ctx, cause);\n+            return errorResponseFactory.apply(ctx, cause);\n+        }\n+    }\n+\n+    private static <I extends Request, O extends Response, U extends Client<I, O>>\n+    O initContextAndExecuteWithFallback(\n+            U delegate, DefaultClientRequestContext ctx,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory, boolean succeeded)\n+            throws Exception {\n+\n+        if (succeeded) {\n+            return pushAndExecute(delegate, ctx);\n+        } else {\n+            // Context initialization has failed, which means:\n+            // - ctx.log() has been completed with an exception.\n+            // - ctx.request() has been aborted (if not null).\n+            // - the decorator chain was not invoked at all.\n+            // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n+\n+            // Call the decorator chain anyway so that the request is seen by the decorators.\n+            final O res = pushAndExecute(delegate, ctx);\n+\n+            // We will use the fallback response which is created from the exception\n+            // raised in ctx.init(), so the response returned can be aborted.\n+            if (res instanceof StreamMessage) {\n+                ((StreamMessage<?>) res).abort();\n+            }\n+\n+            // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n+            final Throwable cause = ctx.log().partial().requestCause();\n+            assert cause != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NjgyMg==", "bodyText": "Done :-)", "url": "https://github.com/line/armeria/pull/2837#discussion_r446056822", "createdAt": "2020-06-26T08:54:53Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);\n                 }\n \n-                // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n-                final Throwable cause = ctx.log().partial().requestCause();\n-                assert cause != null;\n-                return fallbackResponseFactory.apply(ctx, cause);\n+                return initContextAndExecuteWithFallback(delegate, ctx, errorResponseFactory, success);\n+            } else {\n+                return futureConverter.apply(initFuture.handle((success, cause) -> {\n+                    try {\n+                        if (cause != null) {\n+                            throw cause;\n+                        }\n+\n+                        return initContextAndExecuteWithFallback(\n+                                delegate, ctx, errorResponseFactory, success);\n+                    } catch (Throwable t) {\n+                        fail(ctx, t);\n+                        return errorResponseFactory.apply(ctx, t);\n+                    }\n+                }));\n             }\n         } catch (Throwable cause) {\n             fail(ctx, cause);\n-            return fallbackResponseFactory.apply(ctx, cause);\n+            return errorResponseFactory.apply(ctx, cause);\n+        }\n+    }\n+\n+    private static <I extends Request, O extends Response, U extends Client<I, O>>\n+    O initContextAndExecuteWithFallback(\n+            U delegate, DefaultClientRequestContext ctx,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory, boolean succeeded)\n+            throws Exception {\n+\n+        if (succeeded) {\n+            return pushAndExecute(delegate, ctx);\n+        } else {\n+            // Context initialization has failed, which means:\n+            // - ctx.log() has been completed with an exception.\n+            // - ctx.request() has been aborted (if not null).\n+            // - the decorator chain was not invoked at all.\n+            // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n+\n+            // Call the decorator chain anyway so that the request is seen by the decorators.\n+            final O res = pushAndExecute(delegate, ctx);\n+\n+            // We will use the fallback response which is created from the exception\n+            // raised in ctx.init(), so the response returned can be aborted.\n+            if (res instanceof StreamMessage) {\n+                ((StreamMessage<?>) res).abort();\n+            }\n+\n+            // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n+            final Throwable cause = ctx.log().partial().requestCause();\n+            assert cause != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5MDI1Mg=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTEwNTU3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0NDowNlrOGpXAbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTowMDo1NlrOGpZVVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTc0Mw==", "bodyText": "How about making this private static final and reusing it?", "url": "https://github.com/line/armeria/pull/2837#discussion_r446021743", "createdAt": "2020-06-26T07:44:06Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NDg0OA==", "bodyText": "It's reused inside UnmodifiableFuture.", "url": "https://github.com/line/armeria/pull/2837#discussion_r446054848", "createdAt": "2020-06-26T08:51:05Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTc0Mw=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1OTg2MA==", "bodyText": "Ah I missed that as well. \ud83d\ude05", "url": "https://github.com/line/armeria/pull/2837#discussion_r446059860", "createdAt": "2020-06-26T09:00:56Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTc0Mw=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTEwOTkwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0NToyOFrOGpXDCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOToxNzo0OVrOGpZ2eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMjQwOQ==", "bodyText": "Can't we do acquireEventLoop(endpointGroup); first and use the eventLoop?", "url": "https://github.com/line/armeria/pull/2837#discussion_r446022409", "createdAt": "2020-06-26T07:45:28Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NTM5MA==", "bodyText": "We can, but why?", "url": "https://github.com/line/armeria/pull/2837#discussion_r446055390", "createdAt": "2020-06-26T08:52:06Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMjQwOQ=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA2ODM0Ng==", "bodyText": "Forget about this. \ud83d\ude05", "url": "https://github.com/line/armeria/pull/2837#discussion_r446068346", "createdAt": "2020-06-26T09:17:49Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMjQwOQ=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTIzMjM0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/AbstractEndpointSelector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODoyNjoxMFrOGpYQPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOToxMjoyOVrOGpZr6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0MjE3Mg==", "bodyText": "If so listeningFuture.timeoutFuture = timeoutFuture; this line should move down.\nHowever, I'm wondering if there's a chance that listeningFuture.isDone() is true after we call endpoint = selectNow(ctx); when endpoint is null. \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2837#discussion_r446042172", "createdAt": "2020-06-26T08:26:10Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/AbstractEndpointSelector.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+\n+/**\n+ * A skeletal {@link EndpointSelector} implementation. This abstract class implements the\n+ * {@link #select(ClientRequestContext, ScheduledExecutorService, long)} method by listening to\n+ * the change events emitted by {@link EndpointGroup} specified at construction time.\n+ */\n+public abstract class AbstractEndpointSelector implements EndpointSelector {\n+\n+    private final EndpointGroup endpointGroup;\n+\n+    /**\n+     * Creates a new instance that selects an {@link Endpoint} from the specified {@link EndpointGroup}.\n+     */\n+    protected AbstractEndpointSelector(EndpointGroup endpointGroup) {\n+        this.endpointGroup = requireNonNull(endpointGroup, \"endpointGroup\");\n+    }\n+\n+    /**\n+     * Returns the {@link EndpointGroup} being selected by this {@link EndpointSelector}.\n+     */\n+    protected final EndpointGroup group() {\n+        return endpointGroup;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<Endpoint> select(ClientRequestContext ctx,\n+                                                    ScheduledExecutorService executor,\n+                                                    long timeoutMillis) {\n+        Endpoint endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        final ListeningFuture listeningFuture = new ListeningFuture(ctx, executor);\n+        endpointGroup.addListener(listeningFuture);\n+\n+        // Try to select again because the EndpointGroup might have been updated\n+        // between selectNow() and addListener() above.\n+        endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            endpointGroup.removeListener(listeningFuture);\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        // Schedule the timeout task.\n+        final ScheduledFuture<?> timeoutFuture =\n+                executor.schedule(() -> listeningFuture.complete(null),\n+                                  timeoutMillis, TimeUnit.MILLISECONDS);\n+        listeningFuture.timeoutFuture = timeoutFuture;\n+\n+        // Cancel the timeout task if necessary, just in case listeningFuture is\n+        // completed even before we assign timeoutFuture to listeningFuture.timeoutFuture.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA2NTY0Mg==", "bodyText": "Updated the comment to explain better.", "url": "https://github.com/line/armeria/pull/2837#discussion_r446065642", "createdAt": "2020-06-26T09:12:29Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/AbstractEndpointSelector.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+\n+/**\n+ * A skeletal {@link EndpointSelector} implementation. This abstract class implements the\n+ * {@link #select(ClientRequestContext, ScheduledExecutorService, long)} method by listening to\n+ * the change events emitted by {@link EndpointGroup} specified at construction time.\n+ */\n+public abstract class AbstractEndpointSelector implements EndpointSelector {\n+\n+    private final EndpointGroup endpointGroup;\n+\n+    /**\n+     * Creates a new instance that selects an {@link Endpoint} from the specified {@link EndpointGroup}.\n+     */\n+    protected AbstractEndpointSelector(EndpointGroup endpointGroup) {\n+        this.endpointGroup = requireNonNull(endpointGroup, \"endpointGroup\");\n+    }\n+\n+    /**\n+     * Returns the {@link EndpointGroup} being selected by this {@link EndpointSelector}.\n+     */\n+    protected final EndpointGroup group() {\n+        return endpointGroup;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<Endpoint> select(ClientRequestContext ctx,\n+                                                    ScheduledExecutorService executor,\n+                                                    long timeoutMillis) {\n+        Endpoint endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        final ListeningFuture listeningFuture = new ListeningFuture(ctx, executor);\n+        endpointGroup.addListener(listeningFuture);\n+\n+        // Try to select again because the EndpointGroup might have been updated\n+        // between selectNow() and addListener() above.\n+        endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            endpointGroup.removeListener(listeningFuture);\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        // Schedule the timeout task.\n+        final ScheduledFuture<?> timeoutFuture =\n+                executor.schedule(() -> listeningFuture.complete(null),\n+                                  timeoutMillis, TimeUnit.MILLISECONDS);\n+        listeningFuture.timeoutFuture = timeoutFuture;\n+\n+        // Cancel the timeout task if necessary, just in case listeningFuture is\n+        // completed even before we assign timeoutFuture to listeningFuture.timeoutFuture.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0MjE3Mg=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTI5NTc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/common/util/IdentityHashStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo0NjozM1rOGpY4mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo1ODowMlrOGpZPog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjUwNw==", "bodyText": "Can we make this as an enum? \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2837#discussion_r446052507", "createdAt": "2020-06-26T08:46:33Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/util/IdentityHashStrategy.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.util;\n+\n+import it.unimi.dsi.fastutil.Hash.Strategy;\n+\n+public final class IdentityHashStrategy<T> implements Strategy<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NjIyMw==", "bodyText": "Then we will lose the type parameter, i.e. the caller has to do an unchecked cast.", "url": "https://github.com/line/armeria/pull/2837#discussion_r446056223", "createdAt": "2020-06-26T08:53:45Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/util/IdentityHashStrategy.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.util;\n+\n+import it.unimi.dsi.fastutil.Hash.Strategy;\n+\n+public final class IdentityHashStrategy<T> implements Strategy<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjUwNw=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1ODQwMg==", "bodyText": "Oops, I missed that. \ud83d\ude13", "url": "https://github.com/line/armeria/pull/2837#discussion_r446058402", "createdAt": "2020-06-26T08:58:02Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/util/IdentityHashStrategy.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.util;\n+\n+import it.unimi.dsi.fastutil.Hash.Strategy;\n+\n+public final class IdentityHashStrategy<T> implements Strategy<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjUwNw=="}, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTI5Njc1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/client/ClientRequestContextDelayedInitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo0Njo1MlrOGpY5Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODo0Njo1MlrOGpY5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjY2Mw==", "bodyText": "2020?", "url": "https://github.com/line/armeria/pull/2837#discussion_r446052663", "createdAt": "2020-06-26T08:46:52Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/client/ClientRequestContextDelayedInitTest.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright 2019 LINE Corporation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2400, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}