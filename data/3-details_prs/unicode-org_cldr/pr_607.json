{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyOTY3OTM4", "number": 607, "title": "CLDR-13857 Add normalized XMLSource cache", "bodyText": "Add a normalized XMLSource cache\nAdd a new CLDRFile constructor\n\nChecklist\n\n Issue filed: https://unicode-org.atlassian.net/browse/CLDR-13857\n Updated PR title and link in previous line to include Issue number", "createdAt": "2020-08-04T19:36:26Z", "url": "https://github.com/unicode-org/cldr/pull/607", "merged": true, "mergeCommit": {"oid": "b7075f7faee64624ceb20a995a9159b6e2692588"}, "closed": true, "closedAt": "2020-08-11T15:41:11Z", "author": {"login": "AlintaLu"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7rxtvAH2gAyNDYyOTY3OTM4OjE1ZDdlYWZhYWMzNWQ5M2ZhOWIzYmJjMjU2NzkwYmJkNGQxMGNjNGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9STRMAFqTQ2Mzg5NTU4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "author": {"user": {"login": "AlintaLu", "name": "Yiqing Lu"}}, "url": "https://github.com/unicode-org/cldr/commit/15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "committedDate": "2020-08-04T19:27:50Z", "message": "CLDR-13857 Add normalized XMLSource cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTgxNDE3", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461181417", "createdAt": "2020-08-04T21:17:16Z", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToxNzoxN1rOG7x1Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToxNzoxN1rOG7x1Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzNTY0Ng==", "bodyText": "Set instead of List", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465335646", "createdAt": "2020-08-04T21:17:17Z", "author": {"login": "AlintaLu"}, "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTgyNDcx", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461182471", "createdAt": "2020-08-04T21:19:06Z", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToxOTowNlrOG7x4fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToxOTowNlrOG7x4fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzNjQ0Nw==", "bodyText": "throw if empty", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465336447", "createdAt": "2020-08-04T21:19:06Z", "author": {"login": "AlintaLu"}, "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTg0NDE1", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461184415", "createdAt": "2020-08-04T21:22:35Z", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToyMjozNVrOG7x-0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToyMjozNVrOG7x-0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzODA2NQ==", "bodyText": "Add\nif(hashCode != other.hashCode) {\nreturn false;\n}", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465338065", "createdAt": "2020-08-04T21:22:35Z", "author": {"login": "macchiati"}, "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTkxODYx", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461191861", "createdAt": "2020-08-04T21:36:20Z", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTozNjoyMFrOG7yWjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTozNjoyMFrOG7yWjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDE0Mg==", "bodyText": "NO need StringBuilder, String plus", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465344142", "createdAt": "2020-08-04T21:36:20Z", "author": {"login": "AlintaLu"}, "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;\n+        try {\n+            fullFileName = f.getCanonicalPath();\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTkyMDg4", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461192088", "createdAt": "2020-08-04T21:36:41Z", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTozNjo0MVrOG7yXXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTozNjo0MVrOG7yXXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDM1MA==", "bodyText": "No StringBuilder", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465344350", "createdAt": "2020-08-04T21:36:41Z", "author": {"login": "AlintaLu"}, "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;\n+        try {\n+            fullFileName = f.getCanonicalPath();\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+        // use try-with-resources statement\n+        try (\n+            InputStream fis = new StripUTF8BOMInputStream(new FileInputStream(f));\n+            InputStreamReader reader = new InputStreamReader(fis, Charset.forName(\"UTF-8\"))\n+        ) {\n+            XMLSource source = new SimpleXMLSource(localeId);\n+            XMLNormalizingHandler XML_HANDLER = new XMLNormalizingHandler(source, minimalDraftStatus);\n+            XMLFileReader.read(fullFileName, reader, -1, true, XML_HANDLER);\n+            if (XML_HANDLER.supplementalStatus == SupplementalStatus.NEVER_SET) {\n+                throw new IllegalArgumentException(\"root of file must be either ldml or supplementalData\");\n+            }\n+            source.setNonInheriting(XML_HANDLER.supplementalStatus == SupplementalStatus.NOT_SUPPLEMENTAL);\n+            if (XML_HANDLER.overrideCount > 0) {\n+                throw new IllegalArgumentException(\"Internal problems: either data file has duplicate path, or\" +\n+                    \" CLDRFile.isDistinguishing() or CLDRFile.isOrdered() need updating: \"\n+                    + XML_HANDLER.overrideCount\n+                    + \"; The exact problems are printed on the console above.\");\n+            }\n+            return source;\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "originalPosition": 178}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjgyMDE4", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461282018", "createdAt": "2020-08-05T01:36:27Z", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTozNjoyN1rOG73Dgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTozNjoyN1rOG73Dgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMTE4Ng==", "bodyText": "Nitpick: the cast to IllegalArgumentException is not needed.", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465421186", "createdAt": "2020-08-05T01:36:27Z", "author": {"login": "mihnita"}, "path": "tools/java/org/unicode/cldr/util/XMLSource.java", "diffHunk": "@@ -1747,4 +1749,84 @@ public DtdType getDtdType() {\n         }\n         return null;\n     }\n+\n+    /**\n+     * XMLNormalizingDtdType is set in XMLNormalizingHandler loading XML process\n+     */\n+    private DtdType XMLNormalizingDtdType;\n+    private static final boolean LOG_PROGRESS = false;\n+\n+    public DtdType getXMLNormalizingDtdType() {\n+        return this.XMLNormalizingDtdType;\n+    }\n+\n+    public void setXMLNormalizingDtdType(DtdType dtdType) {\n+        this.XMLNormalizingDtdType = dtdType;\n+    }\n+\n+    /**\n+     * Sets the initial comment, replacing everything that was there\n+     * Use in XMLNormalizingHandler only\n+     */\n+    public XMLSource setInitialComment(String comment) {\n+        if (locked) throw new UnsupportedOperationException(\"Attempt to modify locked object\");\n+        Log.logln(LOG_PROGRESS, \"SET initial Comment: \\t\" + comment);\n+        this.getXpathComments().setInitialComment(comment);\n+        return this;\n+    }\n+\n+    /**\n+     * Use in XMLNormalizingHandler only\n+     */\n+    public XMLSource addComment(String xpath, String comment, Comments.CommentType type) {\n+        if (locked) throw new UnsupportedOperationException(\"Attempt to modify locked object\");\n+        Log.logln(LOG_PROGRESS, \"ADDING Comment: \\t\" + type + \"\\t\" + xpath + \" \\t\" + comment);\n+        if (xpath == null || xpath.length() == 0) {\n+            this.getXpathComments().setFinalComment(\n+                CldrUtility.joinWithSeparation(this.getXpathComments().getFinalComment(), XPathParts.NEWLINE,\n+                    comment));\n+        } else {\n+            xpath = CLDRFile.getDistinguishingXPath(xpath, null);\n+            this.getXpathComments().addComment(type, xpath, comment);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Use in XMLNormalizingHandler only\n+     */\n+    public String getFullXPath(String xpath) {\n+        if (xpath == null) {\n+            throw new NullPointerException(\"Null distinguishing xpath\");\n+        }\n+        String result = this.getFullPath(xpath);\n+        return result != null ? result : xpath; // we can't add any non-distinguishing values if there is nothing there.\n+    }\n+\n+    /**\n+     * Add a new element to a XMLSource\n+     * Use in XMLNormalizingHandler only\n+     */\n+    public XMLSource add(String currentFullXPath, String value) {\n+        if (locked) throw new UnsupportedOperationException(\"Attempt to modify locked object\");\n+        Log.logln(LOG_PROGRESS, \"ADDING: \\t\" + currentFullXPath + \" \\t\" + value + \"\\t\" + currentFullXPath);\n+        try {\n+            this.putValueAtPath(currentFullXPath, value);\n+        } catch (RuntimeException e) {\n+            throw (IllegalArgumentException) new IllegalArgumentException(\"failed adding \" + currentFullXPath + \",\\t\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjgzNDU3", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461283457", "createdAt": "2020-08-05T01:41:27Z", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTo0MToyN1rOG73IoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTo0MToyN1rOG73IoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMjQ5Nw==", "bodyText": "Nitpick: final static and uppercase (it is a constant, never changes)", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465422497", "createdAt": "2020-08-05T01:41:27Z", "author": {"login": "mihnita"}, "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;\n+        try {\n+            fullFileName = f.getCanonicalPath();\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+        // use try-with-resources statement\n+        try (\n+            InputStream fis = new StripUTF8BOMInputStream(new FileInputStream(f));\n+            InputStreamReader reader = new InputStreamReader(fis, Charset.forName(\"UTF-8\"))\n+        ) {\n+            XMLSource source = new SimpleXMLSource(localeId);\n+            XMLNormalizingHandler XML_HANDLER = new XMLNormalizingHandler(source, minimalDraftStatus);\n+            XMLFileReader.read(fullFileName, reader, -1, true, XML_HANDLER);\n+            if (XML_HANDLER.supplementalStatus == SupplementalStatus.NEVER_SET) {\n+                throw new IllegalArgumentException(\"root of file must be either ldml or supplementalData\");\n+            }\n+            source.setNonInheriting(XML_HANDLER.supplementalStatus == SupplementalStatus.NOT_SUPPLEMENTAL);\n+            if (XML_HANDLER.overrideCount > 0) {\n+                throw new IllegalArgumentException(\"Internal problems: either data file has duplicate path, or\" +\n+                    \" CLDRFile.isDistinguishing() or CLDRFile.isOrdered() need updating: \"\n+                    + XML_HANDLER.overrideCount\n+                    + \"; The exact problems are printed on the console above.\");\n+            }\n+            return source;\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+    }\n+\n+    private static class XMLNormalizingHandler implements AllHandler {\n+        private DraftStatus minimalDraftStatus;\n+        private static final boolean SHOW_START_END = false;\n+        private int commentStackIndex;\n+        private boolean justPopped = false;\n+        private String lastChars = \"\";\n+        private StringBuilder currentFullXPathSb = new StringBuilder(\"/\");\n+        private String comment = null;\n+        private Map<String, String> attributeOrder;\n+        private DtdData dtdData;\n+        private XMLSource source;\n+        private String lastActiveLeafNode;\n+        private String lastLeafNode;\n+        private SupplementalStatus supplementalStatus = SupplementalStatus.NEVER_SET;\n+        private int maxDepth = 30; // just make deep enough to handle any CLDR file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "originalPosition": 198}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjg2NjQ2", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461286646", "createdAt": "2020-08-05T01:52:22Z", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTo1MjoyMlrOG73UqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTo1MjoyMlrOG73UqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNTU3Nw==", "bodyText": "Nitpick: you can move String fullFileName = f.getCanonicalPath();  to be the first thing in the main try { }\nIt is not used outside the try, and that already catches the exception.\nSo instead of 2 try-catch blocks you only have one.", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465425577", "createdAt": "2020-08-05T01:52:22Z", "author": {"login": "mihnita"}, "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjg3NzE1", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461287715", "createdAt": "2020-08-05T01:55:53Z", "commit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTo1NTo1M1rOG73YlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMTo1NTo1M1rOG73YlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNjU4MA==", "bodyText": "Nitpick: you can make this line comment (//).\nThe types are private, so they don't need to generate javadoc.\nA regular comment for the programmer reading this code is enough, and only takes 1 line, not 3.", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465426580", "createdAt": "2020-08-05T01:55:53Z", "author": {"login": "mihnita"}, "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;\n+        try {\n+            fullFileName = f.getCanonicalPath();\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+        // use try-with-resources statement\n+        try (\n+            InputStream fis = new StripUTF8BOMInputStream(new FileInputStream(f));\n+            InputStreamReader reader = new InputStreamReader(fis, Charset.forName(\"UTF-8\"))\n+        ) {\n+            XMLSource source = new SimpleXMLSource(localeId);\n+            XMLNormalizingHandler XML_HANDLER = new XMLNormalizingHandler(source, minimalDraftStatus);\n+            XMLFileReader.read(fullFileName, reader, -1, true, XML_HANDLER);\n+            if (XML_HANDLER.supplementalStatus == SupplementalStatus.NEVER_SET) {\n+                throw new IllegalArgumentException(\"root of file must be either ldml or supplementalData\");\n+            }\n+            source.setNonInheriting(XML_HANDLER.supplementalStatus == SupplementalStatus.NOT_SUPPLEMENTAL);\n+            if (XML_HANDLER.overrideCount > 0) {\n+                throw new IllegalArgumentException(\"Internal problems: either data file has duplicate path, or\" +\n+                    \" CLDRFile.isDistinguishing() or CLDRFile.isOrdered() need updating: \"\n+                    + XML_HANDLER.overrideCount\n+                    + \"; The exact problems are printed on the console above.\");\n+            }\n+            return source;\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+    }\n+\n+    private static class XMLNormalizingHandler implements AllHandler {\n+        private DraftStatus minimalDraftStatus;\n+        private static final boolean SHOW_START_END = false;\n+        private int commentStackIndex;\n+        private boolean justPopped = false;\n+        private String lastChars = \"\";\n+        private StringBuilder currentFullXPathSb = new StringBuilder(\"/\");\n+        private String comment = null;\n+        private Map<String, String> attributeOrder;\n+        private DtdData dtdData;\n+        private XMLSource source;\n+        private String lastActiveLeafNode;\n+        private String lastLeafNode;\n+        private SupplementalStatus supplementalStatus = SupplementalStatus.NEVER_SET;\n+        private int maxDepth = 30; // just make deep enough to handle any CLDR file.\n+        // orderedCounter, orderedString, and level logically form a single class that allows adding elements, but never removed.\n+        private int[] orderedCounter = new int[maxDepth];\n+        private String[] orderedString = new String[maxDepth];\n+        private int level = 0;\n+        private int overrideCount = 0;\n+        /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b"}, "originalPosition": 204}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bbf03f7a8e619365959600a2539e15987e9f0fa", "author": {"user": {"login": "AlintaLu", "name": "Yiqing Lu"}}, "url": "https://github.com/unicode-org/cldr/commit/7bbf03f7a8e619365959600a2539e15987e9f0fa", "committedDate": "2020-08-05T18:10:06Z", "message": "CLDR-13857 Fix reviews for XMLNormalizingLoader and XMLSource"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxOTI5NTUy", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-461929552", "createdAt": "2020-08-05T18:43:56Z", "commit": {"oid": "7bbf03f7a8e619365959600a2539e15987e9f0fa"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfd43f233557a3a8b23530554d861934e816f64c", "author": {"user": {"login": "AlintaLu", "name": "Yiqing Lu"}}, "url": "https://github.com/unicode-org/cldr/commit/bfd43f233557a3a8b23530554d861934e816f64c", "committedDate": "2020-08-07T22:19:59Z", "message": "CLDR-13857 disabling SimpleFactory.combinedCache and only use XMLNormalizingLoader.cache to avoid double-caching"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzODk1NTgz", "url": "https://github.com/unicode-org/cldr/pull/607#pullrequestreview-463895583", "createdAt": "2020-08-09T18:54:48Z", "commit": {"oid": "bfd43f233557a3a8b23530554d861934e816f64c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2028, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}