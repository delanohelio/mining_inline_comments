{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0Mzk0NzQx", "number": 1364, "title": "Simple dynamic item state updates SSE endpoint & API.", "bodyText": "Implements #1363.\nSigned-off-by: Yannick Schaus github@schaus.net", "createdAt": "2020-02-12T16:10:53Z", "url": "https://github.com/openhab/openhab-core/pull/1364", "merged": true, "mergeCommit": {"oid": "4b772cb6b350b5be11755cce4a9c0cda47943ba4"}, "closed": true, "closedAt": "2020-02-24T17:36:40Z", "author": {"login": "ghys"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDphpjgBqjMwMzE2ODY0Mjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHhFhXgFqTM2MzU3Mjk0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "219cb32dc114906800e304a461b0dfa300b23dd4", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/219cb32dc114906800e304a461b0dfa300b23dd4", "committedDate": "2020-02-12T17:07:14Z", "message": "Consider transformation\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}, "afterCommit": {"oid": "e619fcaa2cbe5eb2b31a613fd1f0c0fdb446bb85", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/e619fcaa2cbe5eb2b31a613fd1f0c0fdb446bb85", "committedDate": "2020-02-12T17:10:29Z", "message": "Consider transformation\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzcwNjE0", "url": "https://github.com/openhab/openhab-core/pull/1364#pullrequestreview-359370614", "createdAt": "2020-02-15T22:56:15Z", "commit": {"oid": "e619fcaa2cbe5eb2b31a613fd1f0c0fdb446bb85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMjo1NjoxNVrOFqQ5RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMjo1NjoxNVrOFqQ5RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2MTMxNw==", "bodyText": "As mentioned in the issue, I am pretty sure that you will additionally require the raw state as well in the UI, e.g. for being able to request the correct item for the state, apply ui-based logic on visibility or colors, etc. So the current item->state map might be too simplistic after all.\nAlso, we might add further metadata to the ItemStateChangedEvent in future, such as the reason why it changed (manual command, rule triggered, or whatever). Serializing the whole content of ItemStateChangedEvent would somehow feel more future-proof, wdyt?", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r379861317", "createdAt": "2020-02-15T22:56:15Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseActivator;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.openhab.core.transform.TransformationException;\n+import org.openhab.core.transform.TransformationHelper;\n+import org.openhab.core.types.StateDescription;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference\n+    protected void setItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+    }\n+\n+    protected void unsetItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+    }\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Context\n+    private HttpServletResponse response;\n+\n+    @Context\n+    private HttpServletRequest request;\n+\n+    public SseStatesResource() {\n+        this.executorService = Executors.newSingleThreadExecutor();\n+        this.broadcaster = new ItemStateChangesSseBroadcaster(itemRegistry);\n+    }\n+\n+    /**\n+     * Subscribes the connecting client for state updates. It will initially only send a \"ready\" event with an unique\n+     * connectionId that the client can use to dynamically alter the list of tracked items.\n+     *\n+     * @return {@link EventOutput} object associated with the incoming\n+     *         connection.\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    @GET\n+    @Produces(SseFeature.SERVER_SENT_EVENTS)\n+    @ApiOperation(value = \"Initiates a new item state tracker connection\", response = EventOutput.class)\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Object getStateEvents() throws IOException, InterruptedException {\n+\n+        final SseStateEventOutput eventOutput = new SseStateEventOutput();\n+        broadcaster.add(eventOutput);\n+\n+        // Disables proxy buffering when using an nginx http server proxy for this response.\n+        // This allows you to not disable proxy buffering in nginx and still have working sse\n+        response.addHeader(X_ACCEL_BUFFERING_HEADER, \"no\");\n+\n+        // We want to make sure that the response is not compressed and buffered so that the client receives server sent\n+        // events at the moment of sending them.\n+        response.addHeader(HttpHeaders.CONTENT_ENCODING, \"identity\");\n+\n+        return eventOutput;\n+    }\n+\n+    /**\n+     * Alters the list of tracked items for a given state update connection\n+     *\n+     * @param connectionId the connection Id to change\n+     * @param itemNames the list of items to track\n+     */\n+    @POST\n+    @Path(\"{connectionId}\")\n+    @ApiOperation(value = \"Changes the list of items a SSE connection will receive state updates to.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\"),\n+            @ApiResponse(code = 404, message = \"Unknown connectionId\") })\n+    public Object updateTrackedItems(@PathParam(\"connectionId\") String connectionId,\n+            @ApiParam(\"items\") Collection<String> itemNames) {\n+\n+        // Send the current states of the new tracked items on the SSE connection\n+        Map<String, String> newTrackedItems = new HashMap<>();\n+        itemNames.stream().forEach(i -> {\n+            Item item = itemRegistry.get(i);\n+            if (item != null) {\n+                String transformedState = considerTransformation(item.getState().toString(), item, null);\n+                newTrackedItems.put(item.getName(), transformedState);\n+            }\n+        });\n+\n+        try {\n+            broadcaster.updateTrackedItems(connectionId, newTrackedItems);\n+        } catch (IllegalArgumentException e) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+\n+        return Response.ok().build();\n+    }\n+\n+    /**\n+     * Broadcasts a state event to all currently listening clients, after transforming it to a simple map.\n+     *\n+     * @param stateChangeEvent the {@link ItemStateChangedEvent} containing the new state\n+     */\n+    public void broadcastEvent(final ItemStateChangedEvent stateChangeEvent) {\n+        executorService.execute(new Runnable() {\n+            @Override\n+            public void run() {\n+                OutboundEvent.Builder builder = new OutboundEvent.Builder();\n+                Map<String, String> payload = new HashMap<>();\n+                Item item = itemRegistry.get(stateChangeEvent.getItemName());\n+                if (item != null) {\n+                    String transformedState = considerTransformation(item.getState().toString(), item, null);\n+                    payload.put(item.getName(), transformedState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e619fcaa2cbe5eb2b31a613fd1f0c0fdb446bb85"}, "originalPosition": 187}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e806c8f340d4378bbda472354f5ae1113468316b", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/e806c8f340d4378bbda472354f5ae1113468316b", "committedDate": "2020-02-18T10:24:14Z", "message": "Simple dynamic item state updates SSE endpoint & API.\n\nImplements #1363.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f92f6d9b897b3c07339bd91f491934e2b38cf00", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/5f92f6d9b897b3c07339bd91f491934e2b38cf00", "committedDate": "2020-02-18T10:24:14Z", "message": "Consider transformation\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/1d11fa4e8076410e9dde8e3eb3243b944c041d09", "committedDate": "2020-02-18T10:58:29Z", "message": "Provide reliable displayStates using the state description\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e619fcaa2cbe5eb2b31a613fd1f0c0fdb446bb85", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/e619fcaa2cbe5eb2b31a613fd1f0c0fdb446bb85", "committedDate": "2020-02-12T17:10:29Z", "message": "Consider transformation\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}, "afterCommit": {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/1d11fa4e8076410e9dde8e3eb3243b944c041d09", "committedDate": "2020-02-18T10:58:29Z", "message": "Provide reliable displayStates using the state description\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTIwMjc0", "url": "https://github.com/openhab/openhab-core/pull/1364#pullrequestreview-363120274", "createdAt": "2020-02-23T20:32:35Z", "commit": {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QyMDozMjozNVrOFtSqvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QyMDo0ODowNVrOFtSu8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjA5Mw==", "bodyText": "again, this annotation can be put on the field and the setter and getter removed.", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383036093", "createdAt": "2020-02-23T20:32:35Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjI1Mg==", "bodyText": "How about using () -> {} syntax instead of the Runnable?", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383036252", "createdAt": "2020-02-23T20:34:53Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference\n+    protected void setItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+        this.broadcaster.setItemRegistry(itemRegistry);\n+    }\n+\n+    protected void unsetItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+    }\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Context\n+    private HttpServletResponse response;\n+\n+    @Context\n+    private HttpServletRequest request;\n+\n+    public SseStatesResource() {\n+        this.executorService = Executors.newSingleThreadExecutor();\n+        this.broadcaster = new ItemStateChangesSseBroadcaster();\n+    }\n+\n+    /**\n+     * Subscribes the connecting client for state updates. It will initially only send a \"ready\" event with an unique\n+     * connectionId that the client can use to dynamically alter the list of tracked items.\n+     *\n+     * @return {@link EventOutput} object associated with the incoming\n+     *         connection.\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    @GET\n+    @Produces(SseFeature.SERVER_SENT_EVENTS)\n+    @ApiOperation(value = \"Initiates a new item state tracker connection\", response = EventOutput.class)\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Object getStateEvents() throws IOException, InterruptedException {\n+\n+        final SseStateEventOutput eventOutput = new SseStateEventOutput();\n+        broadcaster.add(eventOutput);\n+\n+        // Disables proxy buffering when using an nginx http server proxy for this response.\n+        // This allows you to not disable proxy buffering in nginx and still have working sse\n+        response.addHeader(X_ACCEL_BUFFERING_HEADER, \"no\");\n+\n+        // We want to make sure that the response is not compressed and buffered so that the client receives server sent\n+        // events at the moment of sending them.\n+        response.addHeader(HttpHeaders.CONTENT_ENCODING, \"identity\");\n+\n+        return eventOutput;\n+    }\n+\n+    /**\n+     * Alters the list of tracked items for a given state update connection\n+     *\n+     * @param connectionId the connection Id to change\n+     * @param itemNames the list of items to track\n+     */\n+    @POST\n+    @Path(\"{connectionId}\")\n+    @ApiOperation(value = \"Changes the list of items a SSE connection will receive state updates to.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\"),\n+            @ApiResponse(code = 404, message = \"Unknown connectionId\") })\n+    public Object updateTrackedItems(@PathParam(\"connectionId\") String connectionId,\n+            @ApiParam(\"items\") Set<String> itemNames) {\n+\n+        try {\n+            broadcaster.updateTrackedItems(connectionId, itemNames);\n+        } catch (IllegalArgumentException e) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+\n+        return Response.ok().build();\n+    }\n+\n+    /**\n+     * Broadcasts a state event to all currently listening clients, after transforming it to a simple map.\n+     *\n+     * @param stateChangeEvent the {@link ItemStateChangedEvent} containing the new state\n+     */\n+    public void broadcastEvent(final ItemStateChangedEvent stateChangeEvent) {\n+        executorService.execute(new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjQyMA==", "bodyText": "remove empty line", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383036420", "createdAt": "2020-02-23T20:36:57Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/internal/ItemStateChangesSseBroadcaster.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse.internal;\n+\n+import java.io.IOException;\n+import java.time.DateTimeException;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.measure.Unit;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseBroadcaster;\n+import org.glassfish.jersey.server.ChunkedOutput;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemNotFoundException;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.transform.TransformationException;\n+import org.openhab.core.transform.TransformationHelper;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.openhab.core.types.util.UnitUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This {@link SseBroadcaster} keeps track of the {@link SseStateEventOutput} listeners to state changes and tracks them\n+ * by their connectionId.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+public class ItemStateChangesSseBroadcaster extends SseBroadcaster {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ItemStateChangesSseBroadcaster.class);\n+\n+    private Map<String, SseStateEventOutput> eventOutputs = new HashMap<>();\n+\n+    private ItemRegistry itemRegistry;\n+\n+    public ItemStateChangesSseBroadcaster() {\n+        super();\n+    }\n+\n+    @Override\n+    public <OUT extends ChunkedOutput<OutboundEvent>> boolean add(OUT chunkedOutput) {\n+        if (chunkedOutput instanceof SseStateEventOutput) {\n+            SseStateEventOutput eventOutput = (SseStateEventOutput) chunkedOutput;\n+            OutboundEvent.Builder builder = new OutboundEvent.Builder();\n+            String connectionId = eventOutput.getConnectionId();\n+            try {\n+                eventOutputs.put(connectionId, eventOutput);\n+                eventOutput.writeDirect(builder.id(\"0\").name(\"ready\").data(connectionId).build());\n+            } catch (IOException e) {\n+                logger.error(\"Cannot write initial ready event to {}, discarding connection\", connectionId);\n+                return false;\n+            }\n+        }\n+\n+        return super.add(chunkedOutput);\n+    }\n+\n+    @Override\n+    public <OUT extends ChunkedOutput<OutboundEvent>> boolean remove(OUT chunkedOutput) {\n+        eventOutputs.values().remove(chunkedOutput);\n+        return super.remove(chunkedOutput);\n+    }\n+\n+    @Override\n+    public void onClose(ChunkedOutput<OutboundEvent> chunkedOutput) {\n+        remove(chunkedOutput);\n+    }\n+\n+    @Override\n+    public void onException(ChunkedOutput<OutboundEvent> chunkedOutput, Exception exception) {\n+        remove(chunkedOutput);\n+    }\n+\n+    /**\n+     * Updates the list of tracked items for a connection\n+     *\n+     * @param connectionId the connection id\n+     * @param newTrackedItems the list of items and their current state to send to the client\n+     */\n+    public void updateTrackedItems(String connectionId, Set<String> newTrackedItems) {\n+        SseStateEventOutput eventOutput = eventOutputs.get(connectionId);\n+\n+        if (eventOutput == null) {\n+            throw new IllegalArgumentException(\"ConnectionId not found\");\n+        }\n+\n+        eventOutput.setTrackedItems(newTrackedItems);\n+\n+        try {\n+            if (!eventOutput.isClosed()) {\n+                OutboundEvent event = buildStateEvent(newTrackedItems);\n+                if (event != null) {\n+                    eventOutput.writeDirect(event);\n+                }\n+            }\n+            if (eventOutput.isClosed()) {\n+                onClose(eventOutput);\n+            }\n+        } catch (IOException e) {\n+            onException(eventOutput, e);\n+        }\n+    }\n+\n+    public OutboundEvent buildStateEvent(Set<String> itemNames) {\n+        Map<String, StateDTO> payload = new HashMap<>();\n+        for (String itemName : itemNames) {\n+            try {\n+                // Check that the item is tracked by at least one connection\n+                if (itemRegistry != null\n+                        && eventOutputs.values().stream().anyMatch(c -> c.getTrackedItems().contains(itemName))) {\n+                    Item item = itemRegistry.getItem(itemName);\n+                    StateDTO stateDto = new StateDTO();\n+                    stateDto.state = item.getState().toString();\n+                    String displayState = getDisplayState(item, Locale.getDefault());\n+                    // Only include the display state if it's different than the raw state\n+                    if (stateDto.state != null && !stateDto.state.equals(displayState)) {\n+                        stateDto.displayState = displayState;\n+                    }\n+                    payload.put(itemName, stateDto);\n+                }\n+            } catch (ItemNotFoundException e) {\n+                logger.warn(\"Attempting to send a state update of an item which doesn't exist: {}\", itemName);\n+            }\n+        }\n+\n+        if (!payload.isEmpty()) {\n+            OutboundEvent.Builder builder = new OutboundEvent.Builder();\n+            OutboundEvent event = builder.mediaType(MediaType.APPLICATION_JSON_TYPE).data(payload).build();\n+            return event;\n+        }\n+\n+        return null;\n+    }\n+\n+    protected String getDisplayState(Item item, Locale locale) {\n+        StateDescription stateDescription = item.getStateDescription(locale);\n+        State state = item.getState();\n+        String displayState = state.toString();\n+\n+        if (!(state instanceof UnDefType)) {\n+            if (stateDescription != null) {\n+                if (!stateDescription.getOptions().isEmpty()) {\n+                    // Look for a state option with a label corresponding to the state\n+                    for (StateOption option : stateDescription.getOptions()) {\n+                        if (option.getValue().equals(state.toString()) && option.getLabel() != null) {\n+                            displayState = option.getLabel();\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    // If there's a pattern, first check if it's a transformation\n+                    String pattern = stateDescription.getPattern();\n+                    if (pattern != null) {\n+                        if (TransformationHelper.isTransform(pattern)) {\n+                            try {\n+                                displayState = TransformationHelper.transform(SseActivator.getContext(), pattern,\n+                                        state.toString());\n+                            } catch (NoClassDefFoundError ex) {\n+                                // TransformationHelper is optional dependency, so ignore if class not found\n+                                // return state as it is without transformation\n+                            } catch (TransformationException e) {\n+                                logger.warn(\"Failed transforming the state '{}' on item '{}' with pattern '{}': {}\",\n+                                        state, item.getName(), pattern, e.getMessage());\n+                            }\n+                        } else {\n+                            // if it's not a transformation pattern, then it must be a format string\n+\n+                            if (state instanceof QuantityType) {\n+                                QuantityType<?> quantityState = (QuantityType<?>) state;\n+                                // sanity convert current state to the item state description unit in case it was\n+                                // updated in the meantime. The item state is still in the \"original\" unit while the\n+                                // state description will display the new unit:\n+                                Unit<?> patternUnit = UnitUtils.parseUnit(pattern);\n+                                if (patternUnit != null && !quantityState.getUnit().equals(patternUnit)) {\n+                                    quantityState = quantityState.toUnit(patternUnit);\n+                                }\n+\n+                                if (quantityState != null) {\n+                                    state = quantityState;\n+                                }\n+                            } else if (state instanceof DateTimeType) {\n+                                // Translate a DateTimeType state to the local time zone\n+                                try {\n+                                    state = ((DateTimeType) state).toLocaleZone();\n+                                } catch (DateTimeException e) {\n+                                }\n+                            }\n+\n+                            // The following exception handling has been added to work around a Java bug with formatting\n+                            // numbers. See http://bugs.sun.com/view_bug.do?bug_id=6476425\n+                            // This also handles IllegalFormatConversionException, which is a subclass of\n+                            // IllegalArgument.\n+                            try {\n+                                displayState = state.format(pattern);\n+                            } catch (IllegalArgumentException e) {\n+                                logger.warn(\"Exception while formatting value '{}' of item {} with format '{}': {}\",\n+                                        state, item.getName(), pattern, e.getMessage());\n+                                displayState = new String(\"Err\");\n+                            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjYzNA==", "bodyText": "for symmetry reasons it would be good to unset the item registry in the broadcaster here as well.", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383036634", "createdAt": "2020-02-23T20:39:40Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference\n+    protected void setItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+        this.broadcaster.setItemRegistry(itemRegistry);\n+    }\n+\n+    protected void unsetItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNzAzNA==", "bodyText": "Better to have named threads, so that we can identify them when debugging:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.executorService = Executors.newSingleThreadExecutor();\n          \n          \n            \n                    this.executorService = Executors.newSingleThreadExecutor(new NamedThreadFactory(\"SseStatesResource\"));", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383037034", "createdAt": "2020-02-23T20:45:40Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference\n+    protected void setItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+        this.broadcaster.setItemRegistry(itemRegistry);\n+    }\n+\n+    protected void unsetItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+    }\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Context\n+    private HttpServletResponse response;\n+\n+    @Context\n+    private HttpServletRequest request;\n+\n+    public SseStatesResource() {\n+        this.executorService = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNzE3MQ==", "bodyText": "The executor creation should be move to an activate method and it should be terminated in deactivated again to ensure we do not have any zombie threads when the bundle is shut down.", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383037171", "createdAt": "2020-02-23T20:48:05Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference\n+    protected void setItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+        this.broadcaster.setItemRegistry(itemRegistry);\n+    }\n+\n+    protected void unsetItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+    }\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Context\n+    private HttpServletResponse response;\n+\n+    @Context\n+    private HttpServletRequest request;\n+\n+    public SseStatesResource() {\n+        this.executorService = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNzAzNA=="}, "originalCommit": {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "647b0ca730b3e2735e8f3b478423c1ff4a273ba0", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/647b0ca730b3e2735e8f3b478423c1ff4a273ba0", "committedDate": "2020-02-24T14:28:15Z", "message": "Merge state tracking into main SSE resource\n\nAddress review comments.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNTcyOTQx", "url": "https://github.com/openhab/openhab-core/pull/1364#pullrequestreview-363572941", "createdAt": "2020-02-24T17:36:27Z", "commit": {"oid": "647b0ca730b3e2735e8f3b478423c1ff4a273ba0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4549, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}