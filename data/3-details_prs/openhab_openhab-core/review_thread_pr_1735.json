{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MTg0Mjgy", "number": 1735, "reviewThreads": {"totalCount": 46, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwODowMDoxOVrOEvpe4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOToyODo0N1rOExWCJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Mzk4MTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwODowMDoxOVrOHkvhJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNTo1MzozM1rOHlE7tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4OTMxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");\n          \n          \n            \n                            throw new AuthenticationException(\"User not found in registry\");", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r508289316", "createdAt": "2020-10-20T08:00:19Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "diffHunk": "@@ -93,6 +96,32 @@ protected void modified(@Nullable Map<String, @Nullable Object> properties) {\n         }\n     }\n \n+    private SecurityContext authenticateBearerToken(String token) throws AuthenticationException {\n+        if (token.startsWith(API_TOKEN_PREFIX)) {\n+            UserApiTokenCredentials credentials = new UserApiTokenCredentials(token);\n+            Authentication auth = userRegistry.authenticate(credentials);\n+            User user = userRegistry.get(auth.getUsername());\n+            if (user == null) {\n+                throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c3c0a5bf0059aabbb01eff285911c46dca211af"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0MDE4MQ==", "bodyText": "Thanks, I rebased and addressed it in the process.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r508640181", "createdAt": "2020-10-20T15:53:33Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "diffHunk": "@@ -93,6 +96,32 @@ protected void modified(@Nullable Map<String, @Nullable Object> properties) {\n         }\n     }\n \n+    private SecurityContext authenticateBearerToken(String token) throws AuthenticationException {\n+        if (token.startsWith(API_TOKEN_PREFIX)) {\n+            UserApiTokenCredentials credentials = new UserApiTokenCredentials(token);\n+            Authentication auth = userRegistry.authenticate(credentials);\n+            User user = userRegistry.get(auth.getUsername());\n+            if (user == null) {\n+                throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4OTMxNg=="}, "originalCommit": {"oid": "8c3c0a5bf0059aabbb01eff285911c46dca211af"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Mzk4MjY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwODowMDozMFrOHkvhqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwODowMDozMFrOHkvhqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4OTQ1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");\n          \n          \n            \n                        throw new AuthenticationException(\"User not found in registry\");", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r508289450", "createdAt": "2020-10-20T08:00:30Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "diffHunk": "@@ -93,6 +96,32 @@ protected void modified(@Nullable Map<String, @Nullable Object> properties) {\n         }\n     }\n \n+    private SecurityContext authenticateBearerToken(String token) throws AuthenticationException {\n+        if (token.startsWith(API_TOKEN_PREFIX)) {\n+            UserApiTokenCredentials credentials = new UserApiTokenCredentials(token);\n+            Authentication auth = userRegistry.authenticate(credentials);\n+            User user = userRegistry.get(auth.getUsername());\n+            if (user == null) {\n+                throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");\n+            }\n+            return new UserSecurityContext(user, \"ApiToken\");\n+        } else {\n+            Authentication auth = jwtHelper.verifyAndParseJwtAccessToken(token);\n+            return new JwtSecurityContext(auth);\n+        }\n+    }\n+\n+    private SecurityContext authenticateUsernamePassword(String username, String password)\n+            throws AuthenticationException {\n+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n+        Authentication auth = userRegistry.authenticate(credentials);\n+        User user = userRegistry.get(auth.getUsername());\n+        if (user == null) {\n+            throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c3c0a5bf0059aabbb01eff285911c46dca211af"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzAwNDM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowMDo0NlrOHmH98w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNDoxMzo1NlrOHmj6Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczODQ4Mw==", "bodyText": "Usually List.of(..) can be used instead of  Arrays.asList(new String[] {}) in Java 11.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509738483", "createdAt": "2020-10-21T22:00:46Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5NjMyNg==", "bodyText": "I see there's inconsistencies in the other CommandExtensions:\n\n  \n    \n      openhab-core/bundles/org.openhab.core.voice/src/main/java/org/openhab/core/voice/internal/VoiceConsoleCommandExtension.java\n    \n    \n        Lines 65 to 68\n      in\n      5d75bce\n    \n    \n    \n    \n\n        \n          \n           public List<String> getUsages() { \n        \n\n        \n          \n               return List.of(buildCommandUsage(SUBCMD_SAY + \" <text>\", \"speaks a text\"), \n        \n\n        \n          \n                       buildCommandUsage(SUBCMD_INTERPRET + \" <command>\", \"interprets a human language command\"), \n        \n\n        \n          \n                       buildCommandUsage(SUBCMD_VOICES, \"lists available voices of the TTS services\")); \n        \n    \n  \n\n\n\n  \n    \n      openhab-core/bundles/org.openhab.core.audio/src/main/java/org/openhab/core/audio/internal/AudioConsoleCommandExtension.java\n    \n    \n        Lines 66 to 69\n      in\n      5d75bce\n    \n    \n    \n    \n\n        \n          \n           public List<String> getUsages() { \n        \n\n        \n          \n               return Arrays.asList(new String[] { \n        \n\n        \n          \n                       buildCommandUsage(SUBCMD_PLAY + \" [<sink>] <filename>\", \n        \n\n        \n          \n                               \"plays a sound file from the sounds folder through the optionally specified audio sink(s)\"), \n        \n    \n  \n\n\nI happened to take the code from the AudioConsoleCommandExtension :) But I will change it to List.of nonetheless.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510196326", "createdAt": "2020-10-22T14:13:56Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczODQ4Mw=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzAxMjkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowMjozN1rOHmIDnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowMjozN1rOHmIDnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczOTkzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (managedUser.getApiTokens().size() > 0) {\n          \n          \n            \n                                    if (!managedUser.getApiTokens().isEmpty()) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509739935", "createdAt": "2020-10-21T22:02:37Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzAxNzg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowMzo1NVrOHmIG1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowMzo1NVrOHmIG1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MDc1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        managedUser.getApiTokens().forEach(t -> {\n          \n          \n            \n                                            console.println(\"user=\" + user.toString() + \", \" + t.toString());\n          \n          \n            \n                                        });\n          \n          \n            \n                                        managedUser.getApiTokens().forEach(t -> console.println(\"user=\" + user.toString() + \", \" + t.toString()));", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509740756", "createdAt": "2020-10-21T22:03:55Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzAyMDY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowNDo0M1rOHmII5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowNDo0M1rOHmII5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MTI4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                protected Instant lastAuthenticationFailure;\n          \n          \n            \n                protected @Nullable Instant lastAuthenticationFailure;", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509741286", "createdAt": "2020-10-21T22:04:43Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzAyMjI0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowNTowNFrOHmIJzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowNTowNFrOHmIJzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MTUxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n          \n          \n            \n                protected Map<String, Instant> csrfTokens = new HashMap<>();", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509741517", "createdAt": "2020-10-21T22:05:04Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzA0NzMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxMjoyMlrOHmIaYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxMjoyMlrOHmIaYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NTc2Mg==", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509745762", "createdAt": "2020-10-21T22:12:22Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzA0OTkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxMjo0OFrOHmIb_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxMjo0OFrOHmIb_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NjE3NQ==", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509746175", "createdAt": "2020-10-21T22:12:48Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzA1NDg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxMzo1NlrOHmIfPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxMzo1NlrOHmIfPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzAwNw==", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509747007", "createdAt": "2020-10-21T22:13:56Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzA1NzkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxNDoyNlrOHmIhGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwODoxNDozMFrOHmV1gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzQ4Mg==", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509747482", "createdAt": "2020-10-21T22:14:26Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5MTY4Mw==", "bodyText": "This is against what was decided before. Otherwise using @NonNullByDefault({}) would also be possible for mandatory config fields or the config itself of set in the thing handler\u2019s initialize(). The decision was to only use the @NonNullByDefault({})-annotation for injected ressources of the OSGi-framework.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509791683", "createdAt": "2020-10-21T23:25:35Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzQ4Mg=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk2NTY5OA==", "bodyText": "The agreed upon guidelines don't mention anything about how to deal with annotating classes that implement methods from unannotated classes.\nThese issues also did not occur previously because we did not annotate classes with @NonNullByDefault({}) if they were overriding methods from unannotated classes.\nIf there were EEAs for this dependency, these parameters would probably be analyzed to be @NonNull so in that case it makes more sense to use @NonNullByDefault({}) which would prevent these unnecessary null checks.\nAnother case not mentioned in the guidelines is how to deal with generics. The @NonNullByDefault({}) defined on classes is not used by the analysis for generic types. So in that case the only way to make them non-null is by annotating the generic types with @NonNull, see for example the AbstractRegistry.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509965698", "createdAt": "2020-10-22T08:14:30Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzQ4Mg=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzExMDc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoyNToxOVrOHmJEng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDo1MjoyN1rOHm4vGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA==", "bodyText": "I think it would be helpful to print it. The UI also informs users of this.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509756574", "createdAt": "2020-10-21T22:25:19Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });\n+                        }\n+                    });\n+                    break;\n+                case SUBCMD_ADDAPITOKEN:\n+                    if (args.length == 4) {\n+                        ManagedUser user = (ManagedUser) userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                                    .filter(t -> args[2].equals(t.getName())).findAny();\n+                            if (userApiToken.isEmpty()) {\n+                                String tokenString = userRegistry.addUserApiToken(user, args[2], args[3]);\n+                                // inform the user that the token will not be printed again, and they should save it?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5Mjk1OA==", "bodyText": "Is it even true the tokens cannot be retrieved?\nI see there is a command to list them:\nopenhab:users listApiTokens - lists the API keys for all users", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510092958", "createdAt": "2020-10-22T11:42:23Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });\n+                        }\n+                    });\n+                    break;\n+                case SUBCMD_ADDAPITOKEN:\n+                    if (args.length == 4) {\n+                        ManagedUser user = (ManagedUser) userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                                    .filter(t -> args[2].equals(t.getName())).findAny();\n+                            if (userApiToken.isEmpty()) {\n+                                String tokenString = userRegistry.addUserApiToken(user, args[2], args[3]);\n+                                // inform the user that the token will not be printed again, and they should save it?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5MzAzNA==", "bodyText": "I think it would be helpful to print it. The UI also informs users of this.\n\nI don't know, in the end I figured it's best to leave the command ouputs as no-frills as possible, in case the output is redirected to a file/piped to another command. The admin who masters these commands is supposed to know that it's the only opportunity to save the token.\n\nI see there is a command to list them\n\nYou only see the metadata like below, but not the actual token (and you can't even retrieve it from the JSON DB since it's not stored in plain text):\nopenhab> openhab:users listApiTokens\nuser=ysc (administrator), name=service1, createdTime=Mon Oct 19 20:17:40 CEST 2020, scope=admin\nuser=ysc (administrator), name=service2, createdTime=Mon Oct 19 20:17:46 CEST 2020, scope=admin\nuser=ysc (administrator), name=service3, createdTime=Mon Oct 19 20:17:50 CEST 2020, scope=admin", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510193034", "createdAt": "2020-10-22T14:09:44Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });\n+                        }\n+                    });\n+                    break;\n+                case SUBCMD_ADDAPITOKEN:\n+                    if (args.length == 4) {\n+                        ManagedUser user = (ManagedUser) userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                                    .filter(t -> args[2].equals(t.getName())).findAny();\n+                            if (userApiToken.isEmpty()) {\n+                                String tokenString = userRegistry.addUserApiToken(user, args[2], args[3]);\n+                                // inform the user that the token will not be printed again, and they should save it?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MDg1OQ==", "bodyText": "Great! \ud83d\udc4d I didn't have time to compile and execute the command myself or figure out if it was hashed or plain text when I made the comment. Otherwise the next comment would have been to hash it. \ud83d\ude09", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510270859", "createdAt": "2020-10-22T15:49:33Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });\n+                        }\n+                    });\n+                    break;\n+                case SUBCMD_ADDAPITOKEN:\n+                    if (args.length == 4) {\n+                        ManagedUser user = (ManagedUser) userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                                    .filter(t -> args[2].equals(t.getName())).findAny();\n+                            if (userApiToken.isEmpty()) {\n+                                String tokenString = userRegistry.addUserApiToken(user, args[2], args[3]);\n+                                // inform the user that the token will not be printed again, and they should save it?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NTQ2OQ==", "bodyText": "I don't know, in the end I figured it's best to leave the command ouputs as no-frills as possible, in case the output is redirected to a file/piped to another command. The admin who masters these commands is supposed to know that it's the only opportunity to save the token.\n\nThen the question has been answered and we should remove the comment. :-)", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510485469", "createdAt": "2020-10-22T22:06:44Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });\n+                        }\n+                    });\n+                    break;\n+                case SUBCMD_ADDAPITOKEN:\n+                    if (args.length == 4) {\n+                        ManagedUser user = (ManagedUser) userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                                    .filter(t -> args[2].equals(t.getName())).findAny();\n+                            if (userApiToken.isEmpty()) {\n+                                String tokenString = userRegistry.addUserApiToken(user, args[2], args[3]);\n+                                // inform the user that the token will not be printed again, and they should save it?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNzQ5Nw==", "bodyText": "I still wanted to hear opinions about this ;) Done now.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510537497", "createdAt": "2020-10-23T00:52:27Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });\n+                        }\n+                    });\n+                    break;\n+                case SUBCMD_ADDAPITOKEN:\n+                    if (args.length == 4) {\n+                        ManagedUser user = (ManagedUser) userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                                    .filter(t -> args[2].equals(t.getName())).findAny();\n+                            if (userApiToken.isEmpty()) {\n+                                String tokenString = userRegistry.addUserApiToken(user, args[2], args[3]);\n+                                // inform the user that the token will not be printed again, and they should save it?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzEzODcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/pages/authorize.html", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjozMjoyNFrOHmJXMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjozMjoyNFrOHmJXMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc2MTMyOA==", "bodyText": "Can you fix the indentation so it only uses tabs or spaces?", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509761328", "createdAt": "2020-10-21T22:32:24Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/pages/authorize.html", "diffHunk": "@@ -54,41 +62,69 @@\n \tmargin-bottom: 1rem;\n }\n \n-input.submit {\n+.submit {\n \tcursor: pointer;\n \tmargin-top: 2rem;\n \tbackground-color: rgb(33, 150, 243);\n+\ttext-decoration: none;\n \tcolor: white;\n \tborder-radius: 4px;\n \tfont-size: 14px;\n \tfont-weight: 600;\n+\tmin-width: 80px;\n+\tpadding-top: 10px;\n+    padding-bottom: 10px;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzE4OTI0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjozOTo1MFrOHmJ7iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjozOTo1MFrOHmJ7iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MDYzNQ==", "bodyText": "You might want to use a try-with-resources statement here to be sure the stream is always closed.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509770635", "createdAt": "2020-10-21T22:39:50Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n+\n+    protected String pageTemplate;\n+\n+    public AbstractAuthPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+        if (resource != null) {\n+            try {\n+                pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzIwMDcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo0MzoyOVrOHmKCLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowMDoyNlrOHm1Z3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MjMzMg==", "bodyText": "You could add a helpful message here what file could not be opened.\nDo these kind of authentication related exceptions also show in the browser or only in logging?", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509772332", "createdAt": "2020-10-21T22:43:29Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n+\n+    protected String pageTemplate;\n+\n+    public AbstractAuthPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+        if (resource != null) {\n+            try {\n+                pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1NzI0Ng==", "bodyText": "This is only when the page cannot be loaded from the bundle resources, I don't think it will ever happen. I didn't know how to handle this exception, any suggestion is welcome.\nIn general authentication failures are logged but not shown in detail to the user on the webpage (it only says \"Please try again\") because you don't want to divulge too much (i.e. does the account exist, and only the password is wrong, etc.).", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510257246", "createdAt": "2020-10-22T15:31:18Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n+\n+    protected String pageTemplate;\n+\n+    public AbstractAuthPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+        if (resource != null) {\n+            try {\n+                pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MjMzMg=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4MjkwOA==", "bodyText": "You'll run into this whenever one day the file is deleted/renamed or moved to another directory.\nSo I would add a message to the exception that it cannot open \"pages/authorize.html\".\nOr if there is something wrong with the storage or permissions.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510482908", "createdAt": "2020-10-22T22:00:26Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n+\n+    protected String pageTemplate;\n+\n+    public AbstractAuthPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+        if (resource != null) {\n+            try {\n+                pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MjMzMg=="}, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzIzNjk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1MTo0MVrOHmKazA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1MTo0MVrOHmKazA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3ODYzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n          \n          \n            \n                        logger.error(\"Error during change password page registration: {}\", e.getMessage());", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509778636", "createdAt": "2020-10-21T22:51:41Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI0NzA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1Mzo1OVrOHmKh2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1Mzo1OVrOHmKh2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MDQ0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"username\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"username\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509780440", "createdAt": "2020-10-21T22:53:59Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI0ODg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NDoyMlrOHmKi6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NDoyMlrOHmKi6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MDcxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"password\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"password\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509780712", "createdAt": "2020-10-21T22:54:22Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI1MDE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NDozNlrOHmKjww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NDozNlrOHmKjww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MDkzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"new_password\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"new_password\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509780931", "createdAt": "2020-10-21T22:54:36Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey((\"new_password\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI1Mzg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NToyOFrOHmKmAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NToyOFrOHmKmAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MTUwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    responseBody = responseBody.replace(\"{formClass}\", (hideForm) ? \"hide\" : \"show\");\n          \n          \n            \n                    responseBody = responseBody.replace(\"{formClass}\", hideForm ? \"hide\" : \"show\");", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509781507", "createdAt": "2020-10-21T22:55:28Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey((\"new_password\"))) {\n+                    throw new AuthenticationException(\"no new password\");\n+                }\n+                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                    throw new AuthenticationException(\"CSRF check failed\");\n+                }\n+\n+                removeCsrfToken(params.get(\"csrf_token\")[0]);\n+\n+                String username = params.get(\"username\")[0];\n+                String password = params.get(\"password\")[0];\n+                String newPassword = params.get(\"new_password\")[0];\n+\n+                if (!params.containsKey(\"password_repeat\") || !newPassword.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n+                }\n+\n+                User user = login(username, password);\n+\n+                if (user instanceof ManagedUser) {\n+                    userRegistry.changePassword(user, newPassword);\n+                } else {\n+                    throw new AuthenticationException(\"User is not managed\");\n+                }\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getResultPageBody(params, \"Password changed.\")); // TODO: i18n\n+                resp.getWriter().close();\n+            } catch (AuthenticationException e) {\n+                processFailedLogin(resp, params, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n+        String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n+        String buttonLabel = \"Change Password\"; // TODO: i18n\n+        responseBody = responseBody.replace(\"{message}\", message);\n+        responseBody = responseBody.replace(\"{formAction}\", \"/changePassword\");\n+        responseBody = responseBody.replace(\"{formClass}\", (hideForm) ? \"hide\" : \"show\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI1Njk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1Njo1NVrOHmKn9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1Njo1NVrOHmKn9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjAwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"username\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"username\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509782006", "createdAt": "2020-10-21T22:56:55Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI1NzMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NzowNVrOHmKoMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NzowNVrOHmKoMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjA2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"password\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"password\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509782066", "createdAt": "2020-10-21T22:57:05Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI1Nzc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NzoxNVrOHmKocg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NzoxNVrOHmKocg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjEzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"token_name\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"token_name\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509782130", "createdAt": "2020-10-21T22:57:15Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey((\"token_name\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI3Njk2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNTo1NFrOHmK0fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNTo1NFrOHmK0fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTIxNA==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785214", "createdAt": "2020-10-21T23:05:54Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI3NzE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNjowMFrOHmK0mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNjowMFrOHmK0mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTI0Mg==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785242", "createdAt": "2020-10-21T23:06:00Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI3NzU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNjoxMVrOHmK01A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNjoxMVrOHmK01A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTMwMA==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785300", "createdAt": "2020-10-21T23:06:11Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Stream<UserApiTokenDTO> sessions = user.getApiTokens().stream().map(this::toUserApiTokenDTO);\n+        return Response.ok(new Stream2JSONInputStream(sessions)).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"/apitokens/{name}\")\n+    @Operation(summary = \"Revoke a specified API token associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    public Response removeApiToken(@Context SecurityContext securityContext, @PathParam(\"name\") String name) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI3Nzc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNjoxNVrOHmK07g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNjoxNVrOHmK07g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTMyNg==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785326", "createdAt": "2020-10-21T23:06:15Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Stream<UserApiTokenDTO> sessions = user.getApiTokens().stream().map(this::toUserApiTokenDTO);\n+        return Response.ok(new Stream2JSONInputStream(sessions)).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"/apitokens/{name}\")\n+    @Operation(summary = \"Revoke a specified API token associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    public Response removeApiToken(@Context SecurityContext securityContext, @PathParam(\"name\") String name) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI3ODEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNjoyMFrOHmK1Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNjoyMFrOHmK1Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTM3MA==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785370", "createdAt": "2020-10-21T23:06:20Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Stream<UserApiTokenDTO> sessions = user.getApiTokens().stream().map(this::toUserApiTokenDTO);\n+        return Response.ok(new Stream2JSONInputStream(sessions)).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"/apitokens/{name}\")\n+    @Operation(summary = \"Revoke a specified API token associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    public Response removeApiToken(@Context SecurityContext securityContext, @PathParam(\"name\") String name) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                .filter(apiToken -> apiToken.getName().equals(name)).findAny();\n+        if (userApiToken.isEmpty()) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"No API token found with that name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI4NzgwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMDo0NFrOHmK6ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMDo0NFrOHmK6ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njc2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        User user = this.get(usernamePasswordCreds.getUsername());\n          \n          \n            \n                        User user = get(usernamePasswordCreds.getUsername());", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786762", "createdAt": "2020-10-21T23:10:44Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI4ODI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMDo1N1rOHmK61g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMDo1N1rOHmK61g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NjgzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786838", "createdAt": "2020-10-21T23:10:57Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI4ODU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMTowNVrOHmK6_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMTowNVrOHmK6_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njg3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786877", "createdAt": "2020-10-21T23:11:05Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI4ODgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMToxNFrOHmK7KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMToxNFrOHmK7KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NjkyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786921", "createdAt": "2020-10-21T23:11:14Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI4OTEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMToyNFrOHmK7Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMToyNFrOHmK7Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njk3OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786978", "createdAt": "2020-10-21T23:11:24Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void clearSessions(User user) {\n         if (!(user instanceof ManagedUser)) {\n-            throw new AuthenticationException(\"User is not managed: \" + usernamePasswordCreds.getUsername());\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n \n         ManagedUser managedUser = (ManagedUser) user;\n-        String hashedPassword = hashPassword(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt()).get();\n-        if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n-            throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+        managedUser.getSessions().clear();\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI4OTQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMTozMlrOHmK7kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMTozMlrOHmK7kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NzAyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509787026", "createdAt": "2020-10-21T23:11:32Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void clearSessions(User user) {\n         if (!(user instanceof ManagedUser)) {\n-            throw new AuthenticationException(\"User is not managed: \" + usernamePasswordCreds.getUsername());\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n \n         ManagedUser managedUser = (ManagedUser) user;\n-        String hashedPassword = hashPassword(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt()).get();\n-        if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n-            throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+        managedUser.getSessions().clear();\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public String addUserApiToken(User user, String name, String scope) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+        if (!name.matches(\"[a-zA-Z0-9]*\")) {\n+            throw new IllegalArgumentException(\"API token name format invalid, alphanumeric characters only\");\n         }\n \n-        Authentication authentication = new Authentication(managedUser.getName());\n-        return authentication;\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String tokenSalt = generateSalt(KEY_LENGTH / 8).get();\n+        byte[] rnd = new byte[64];\n+        RAND.nextBytes(rnd);\n+        String token = APITOKEN_PREFIX + \".\" + name + \".\"\n+                + Base64.getEncoder().encodeToString(rnd).replaceAll(\"(\\\\+|/|=)\", \"\");\n+        String tokenHash = hash(token, tokenSalt, APITOKEN_ITERATIONS).get();\n+\n+        UserApiToken userApiToken = new UserApiToken(name, tokenHash + \":\" + tokenSalt, scope);\n+\n+        managedUser.getApiTokens().add(userApiToken);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI5MDA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMTo0NVrOHmK76A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMTo0NVrOHmK76A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NzExMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509787112", "createdAt": "2020-10-21T23:11:45Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void clearSessions(User user) {\n         if (!(user instanceof ManagedUser)) {\n-            throw new AuthenticationException(\"User is not managed: \" + usernamePasswordCreds.getUsername());\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n \n         ManagedUser managedUser = (ManagedUser) user;\n-        String hashedPassword = hashPassword(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt()).get();\n-        if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n-            throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+        managedUser.getSessions().clear();\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public String addUserApiToken(User user, String name, String scope) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+        if (!name.matches(\"[a-zA-Z0-9]*\")) {\n+            throw new IllegalArgumentException(\"API token name format invalid, alphanumeric characters only\");\n         }\n \n-        Authentication authentication = new Authentication(managedUser.getName());\n-        return authentication;\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String tokenSalt = generateSalt(KEY_LENGTH / 8).get();\n+        byte[] rnd = new byte[64];\n+        RAND.nextBytes(rnd);\n+        String token = APITOKEN_PREFIX + \".\" + name + \".\"\n+                + Base64.getEncoder().encodeToString(rnd).replaceAll(\"(\\\\+|/|=)\", \"\");\n+        String tokenHash = hash(token, tokenSalt, APITOKEN_ITERATIONS).get();\n+\n+        UserApiToken userApiToken = new UserApiToken(name, tokenHash + \":\" + tokenSalt, scope);\n+\n+        managedUser.getApiTokens().add(userApiToken);\n+        this.update(user);\n+\n+        return token;\n+    }\n+\n+    @Override\n+    public void removeUserApiToken(User user, UserApiToken userApiToken) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getApiTokens().remove(userApiToken);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc0NzUzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowMzoxOFrOHm1ehQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowMzoxOFrOHm1ehQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NDEwMQ==", "bodyText": "These checks can be removed now.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510484101", "createdAt": "2020-10-22T22:03:18Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -57,43 +56,41 @@ public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpSer\n         try {\n             httpService.registerServlet(\"/changePassword\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n-            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+            logger.error(\"Error during change password page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message, false));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n-            }\n+        try {\n+            String message = \"\";\n+\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n         if (req != null && resp != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea523afb6804cd8674fd1a31805ab4939698db3a"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc2MTIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowODozN1rOHm1mlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowODozN1rOHm1mlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjE2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (!(\"code\".equals(responseType))) {\n          \n          \n            \n                        if (!\"code\".equals(responseType)) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486165", "createdAt": "2020-10-22T22:08:37Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc2MjcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOToxMFrOHm1ncg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOToxMFrOHm1ncg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjM4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n          \n          \n            \n                            String codeChallenge = params.containsKey(\"code_challenge\") ? params.get(\"code_challenge\")[0] : null;", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486386", "createdAt": "2020-10-22T22:09:10Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc2MzQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOToyNVrOHm1n3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOToyNVrOHm1n3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjQ5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n          \n          \n            \n                            String codeChallengeMethod = params.containsKey(\"code_challenge_method\")", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486492", "createdAt": "2020-10-22T22:09:25Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc2NDU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOTo1M1rOHm1ofg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOTo1M1rOHm1ofg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjY1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";\n          \n          \n            \n                    String repeatPasswordFieldType = isSignupMode() ? \"password\" : \"hidden\";", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486654", "createdAt": "2020-10-22T22:09:53Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                        ? params.get(\"code_challenge_method\")[0]\n+                        : null;\n+                ManagedUser managedUser = (ManagedUser) user;\n+                PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                        codeChallenge, codeChallengeMethod);\n+                managedUser.setPendingToken(pendingToken);\n+                userRegistry.update(managedUser);\n+            }\n+\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+            resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n+        } catch (AuthenticationException e) {\n+            processFailedLogin(resp, params, e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            @Nullable\n+            String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n+            @Nullable\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            if (baseRedirectUri != null) {\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n                 resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-            } catch (AuthenticationException e) {\n-                lastAuthenticationFailure = Instant.now();\n-                authenticationFailureCount += 1;\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                logger.warn(\"Authentication failed: {}\", e.getMessage());\n-                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n\n+            } else {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n                 resp.getWriter().close();\n-            } catch (IllegalArgumentException e) {\n-                @Nullable\n-                String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n-                @Nullable\n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                if (baseRedirectUri != null) {\n-                    resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n-                    resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-                } else {\n-                    resp.setContentType(\"text/plain;charset=UTF-8\");\n-                    resp.getWriter().append(e.getMessage());\n-                    resp.getWriter().close();\n-                }\n             }\n         }\n     }\n \n-    private String getPageBody(Map<String, String[]> params, String message) {\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n         String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n         String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 344}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc2NTU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMDoxNVrOHm1pFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMDoxNVrOHm1pFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjgwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String buttonLabel = (isSignupMode()) ? \"Create Account\" : \"Sign In\"; // TODO: i18n\n          \n          \n            \n                    String buttonLabel = isSignupMode() ? \"Create Account\" : \"Sign In\"; // TODO: i18n", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486807", "createdAt": "2020-10-22T22:10:15Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                        ? params.get(\"code_challenge_method\")[0]\n+                        : null;\n+                ManagedUser managedUser = (ManagedUser) user;\n+                PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                        codeChallenge, codeChallengeMethod);\n+                managedUser.setPendingToken(pendingToken);\n+                userRegistry.update(managedUser);\n+            }\n+\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+            resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n+        } catch (AuthenticationException e) {\n+            processFailedLogin(resp, params, e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            @Nullable\n+            String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n+            @Nullable\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            if (baseRedirectUri != null) {\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n                 resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-            } catch (AuthenticationException e) {\n-                lastAuthenticationFailure = Instant.now();\n-                authenticationFailureCount += 1;\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                logger.warn(\"Authentication failed: {}\", e.getMessage());\n-                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n\n+            } else {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n                 resp.getWriter().close();\n-            } catch (IllegalArgumentException e) {\n-                @Nullable\n-                String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n-                @Nullable\n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                if (baseRedirectUri != null) {\n-                    resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n-                    resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-                } else {\n-                    resp.setContentType(\"text/plain;charset=UTF-8\");\n-                    resp.getWriter().append(e.getMessage());\n-                    resp.getWriter().close();\n-                }\n             }\n         }\n     }\n \n-    private String getPageBody(Map<String, String[]> params, String message) {\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n         String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n         String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";\n         String buttonLabel = (isSignupMode()) ? \"Create Account\" : \"Sign In\"; // TODO: i18n", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc2NjU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMDozM1rOHm1pow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMDozM1rOHm1pow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4Njk0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!params.containsKey((\"redirect_uri\"))) {\n          \n          \n            \n                    if (!params.containsKey(\"redirect_uri\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486947", "createdAt": "2020-10-22T22:10:33Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                        ? params.get(\"code_challenge_method\")[0]\n+                        : null;\n+                ManagedUser managedUser = (ManagedUser) user;\n+                PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                        codeChallenge, codeChallengeMethod);\n+                managedUser.setPendingToken(pendingToken);\n+                userRegistry.update(managedUser);\n+            }\n+\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+            resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n+        } catch (AuthenticationException e) {\n+            processFailedLogin(resp, params, e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            @Nullable\n+            String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n+            @Nullable\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            if (baseRedirectUri != null) {\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n                 resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-            } catch (AuthenticationException e) {\n-                lastAuthenticationFailure = Instant.now();\n-                authenticationFailureCount += 1;\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                logger.warn(\"Authentication failed: {}\", e.getMessage());\n-                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n\n+            } else {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n                 resp.getWriter().close();\n-            } catch (IllegalArgumentException e) {\n-                @Nullable\n-                String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n-                @Nullable\n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                if (baseRedirectUri != null) {\n-                    resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n-                    resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-                } else {\n-                    resp.setContentType(\"text/plain;charset=UTF-8\");\n-                    resp.getWriter().append(e.getMessage());\n-                    resp.getWriter().close();\n-                }\n             }\n         }\n     }\n \n-    private String getPageBody(Map<String, String[]> params, String message) {\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n         String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n         String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";\n         String buttonLabel = (isSignupMode()) ? \"Create Account\" : \"Sign In\"; // TODO: i18n\n         responseBody = responseBody.replace(\"{message}\", message);\n+        responseBody = responseBody.replace(\"{formAction}\", \"/auth\");\n+        responseBody = responseBody.replace(\"{formClass}\", \"show\");\n         responseBody = responseBody.replace(\"{repeatPasswordFieldType}\", repeatPasswordFieldType);\n+        responseBody = responseBody.replace(\"{newPasswordFieldType}\", \"hidden\");\n+        responseBody = responseBody.replace(\"{tokenNameFieldType}\", \"hidden\");\n+        responseBody = responseBody.replace(\"{tokenScopeFieldType}\", \"hidden\");\n         responseBody = responseBody.replace(\"{buttonLabel}\", buttonLabel);\n+        responseBody = responseBody.replace(\"{resultClass}\", \"\");\n         return responseBody;\n     }\n \n-    private String getFormFields(Map<String, String[]> params) {\n+    @Override\n+    protected String getFormFields(Map<String, String[]> params) {\n         String hiddenFormFields = \"\";\n \n         if (!params.containsKey((\"redirect_uri\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 363}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc3MjQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/JwtHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMzowNVrOHm1tPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMzowNVrOHm1tPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4Nzg3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Authentication auth = new Authentication(username, roles.toArray(new String[roles.size()]), scope);\n          \n          \n            \n                        return auth;\n          \n          \n            \n                        return new Authentication(username, roles.toArray(new String[roles.size()]), scope);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510487870", "createdAt": "2020-10-22T22:13:05Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/JwtHelper.java", "diffHunk": "@@ -150,7 +149,8 @@ public Authentication verifyAndParseJwtAccessToken(String jwt) throws Authentica\n             JwtClaims jwtClaims = jwtConsumer.processToClaims(jwt);\n             String username = jwtClaims.getSubject();\n             List<String> roles = jwtClaims.getStringListClaimValue(\"role\");\n-            Authentication auth = new Authentication(username, roles.toArray(new String[roles.size()]));\n+            String scope = jwtClaims.getStringClaimValue(\"scope\");\n+            Authentication auth = new Authentication(username, roles.toArray(new String[roles.size()]), scope);\n             return auth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc3NzA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/auth/ManagedUser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxNDo1NlrOHm1wDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxNDo1NlrOHm1wDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4ODU4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param the new password hash\n          \n          \n            \n                 * @param passwordHash the new password hash", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510488588", "createdAt": "2020-10-22T22:14:56Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/auth/ManagedUser.java", "diffHunk": "@@ -59,6 +59,24 @@ public String getPasswordHash() {\n         return passwordHash;\n     }\n \n+    /**\n+     * Alters the password salt.\n+     *\n+     * @param passwordSalt the new password salt\n+     */\n+    public void setPasswordSalt(String passwordSalt) {\n+        this.passwordSalt = passwordSalt;\n+    }\n+\n+    /**\n+     * Alters the password hash.\n+     *\n+     * @param the new password hash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Nzc3OTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/auth/UserRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxNTo1NFrOHm1xmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxNTo1NFrOHm1xmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4ODk4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param password the new password\n          \n          \n            \n                 * @param newPassword the new password", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510488985", "createdAt": "2020-10-22T22:15:54Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/auth/UserRegistry.java", "diffHunk": "@@ -38,4 +38,55 @@\n      * @return the new registered {@link User} instance\n      */\n     public User register(String username, String password, Set<String> roles);\n+\n+    /**\n+     * Change the password for an {@link User} in this registry. The implementation receives the new password and is\n+     * responsible for their secure storage (for instance by hashing the password).\n+     *\n+     * @param username the username of the existing user\n+     * @param password the new password", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTc2Njc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOToyODo0OFrOHnbfSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzo0OTowNlrOHnpVlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA==", "bodyText": "That's probably because I am not very careful :) \ud83d\ude44", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511106888", "createdAt": "2020-10-23T19:28:48Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTExNDcyOQ==", "bodyText": "(and, admittedly, not too big on unit tests...)", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511114729", "createdAt": "2020-10-23T19:39:33Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}, "originalCommit": {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEyNDc5OQ==", "bodyText": "Yes that explains!", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511124799", "createdAt": "2020-10-23T19:52:41Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}, "originalCommit": {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEyOTQ5Mw==", "bodyText": "I also noticed the test coverage is lacking on such critical code. But I'm OK with that if you promise to make up for that in a follow up PR. \ud83d\ude09", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511129493", "createdAt": "2020-10-23T20:01:54Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}, "originalCommit": {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NzMyNQ==", "bodyText": "No time like the present, I added some test coverage to the UserRegistryImpl :)", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511167325", "createdAt": "2020-10-23T21:40:08Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}, "originalCommit": {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMzc4Mw==", "bodyText": "That's even better. \ud83d\udc4d I sometimes run out of time myself too to add them while very enthusiastically implementing lots of new functionalities. \ud83d\ude04", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511333783", "createdAt": "2020-10-24T07:49:06Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA=="}, "originalCommit": {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b"}, "originalPosition": 140}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3254, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}