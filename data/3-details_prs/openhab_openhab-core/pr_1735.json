{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MTg0Mjgy", "number": 1735, "title": "[REST Auth] API tokens & openhab:users console command", "bodyText": "This adds API tokens as a new credential type. Their format is:\noh.<name>.<random chars>\nThey are stored hashed in the user's profile, and can be listed, added\nor removed managed with the new openhab:users console command.\nCurrently the scopes are still not checked, but ultimately they could\nbe, for instance a scope of e.g. user admin.items would mean that the\nAPI token can be used to perform user operations like retrieving info\nor sending a command, and managing the items, but nothing else -\neven if the user has more permissions because of their role (which\nwill of course still be checked).\nTokens are normally passed in the Authorization header with the Bearer\nscheme, or the X-OPENHAB-TOKEN header, like access tokens.\nAs a special exception, API tokens can also be used with the Basic\nauthorization scheme, even if the allowBasicAuth option is not\nenabled in the \"API Security\" service, because there's no additional\nsecurity risk in allowing that. In that case, the token should be\npassed as the username and the password MUST be empty.\nIn short, this means that all these curl commands will work:\n\ncurl -H 'Authorization: Bearer <token>' http://localhost:8080/rest/inbox\ncurl -H 'X-OPENHAB-TOKEN: <token>' http://localhost:8080/rest/inbox\ncurl -u '<token>' http://localhost:8080/rest/inbox (will prompt for a password, just hit Return);\ncurl -u '<token>:' http://localhost:8080/rest/inbox (will not prompt for a password)\ncurl http://<token>@localhost:8080/rest/inbox\n\n2 REST API operations were adding to the AuthResource, to allow\nauthenticated users to list their tokens or remove (revoke) one.\nSelf-service for creating a token or changing the password is more\nsensitive so these are handled with a servlet and pages devoid\nof any JavaScript instead of REST API calls.\nCloses openhab/openhab-webui#332\nSigned-off-by: Yannick Schaus github@schaus.net", "createdAt": "2020-10-19T18:10:12Z", "url": "https://github.com/openhab/openhab-core/pull/1735", "merged": true, "mergeCommit": {"oid": "8b52cab5efbe2798369a30adb42b65ec059ecbec"}, "closed": true, "closedAt": "2020-10-25T11:04:41Z", "author": {"login": "ghys"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUKirdgBqjM4OTU0NzM2Mzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdV9eLagFqTUxNjM0NTc1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "489ad7bb319f87d4699cf808405e04407fe6acb6", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/489ad7bb319f87d4699cf808405e04407fe6acb6", "committedDate": "2020-10-19T18:09:10Z", "message": "[REST Auth] API tokens & openhab:users console command\n\nThis adds API tokens as a new credential type. Their format is:\n`oh.<name>.<random chars>`\n\nThe \"oh.\" prefix is used to tell them apart from a JWT access token,\nbecause they're both used as a Bearer authorization scheme, but there\nis no semantic value attached to any of the other parts.\n\nThey are stored hashed in the user's profile, and can be listed, added\nor removed managed with the new `openhab:users` console command.\n\nCurrently the scopes are still not checked, but ultimately they could\nbe, for instance a scope of e.g. `user admin.items` would mean that the\nAPI token can be used to perform user operations like retrieving info\nor sending a command, _and_ managing the items, but nothing else -\neven if the user has more permissions because of their role (which\nwill of course still be checked).\n\nTokens are normally passed in the Authorization header with the Bearer\nscheme, or the X-OPENHAB-TOKEN header, like access tokens.\nAs a special exception, API tokens can also be used with the Basic\nauthorization scheme, **even if the allowBasicAuth** option is not\nenabled in the \"API Security\" service, because there's no additional\nsecurity risk in allowing that. In that case, the token should be\npassed as the username and the password MUST be empty.\n\nIn short, this means that all these curl commands will work:\n- `curl -H 'Authorization: Bearer <token>' http://localhost:8080/rest/inbox`\n- `curl -H 'X-OPENHAB-TOKEN: <token>' http://localhost:8080/rest/inbox`\n- `curl -u '<token>[:]' http://localhost:8080/rest/inbox`\n- `curl http://<token>@localhost:8080/rest/inbox`\n\n2 REST API operations were adding to the AuthResource, to allow\nauthenticated users to list their tokens or remove (revoke) one.\nSelf-service for creating a token or changing the password is more\nsensitive so these should be handled with a servlet and pages devoid\nof any JavaScript instead of REST API calls, therefore for now they'll\nhave to be done with the console.\n\nThis also fixes regressions introduced with #1713 - the operations\nannotated with @RolesAllowed({ Role.USER }) only were not authorized\nfor administrators anymore.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}, "afterCommit": {"oid": "8c3c0a5bf0059aabbb01eff285911c46dca211af", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/8c3c0a5bf0059aabbb01eff285911c46dca211af", "committedDate": "2020-10-19T20:52:24Z", "message": "Generate a unique salt for each token\n\nReusing the password salt is bad practice, and changing the\npassword changes the salt as well which makes all tokens\ninvalid.\n\nPut the salt in the same field as the hash (concatenated\nwith a separator) to avoid modifying the JSON DB schema.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNDMxODkz", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-512431893", "createdAt": "2020-10-20T08:00:19Z", "commit": {"oid": "8c3c0a5bf0059aabbb01eff285911c46dca211af"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwODowMDoxOVrOHkvhJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwODowMDozMFrOHkvhqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4OTMxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");\n          \n          \n            \n                            throw new AuthenticationException(\"User not found in registry\");", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r508289316", "createdAt": "2020-10-20T08:00:19Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "diffHunk": "@@ -93,6 +96,32 @@ protected void modified(@Nullable Map<String, @Nullable Object> properties) {\n         }\n     }\n \n+    private SecurityContext authenticateBearerToken(String token) throws AuthenticationException {\n+        if (token.startsWith(API_TOKEN_PREFIX)) {\n+            UserApiTokenCredentials credentials = new UserApiTokenCredentials(token);\n+            Authentication auth = userRegistry.authenticate(credentials);\n+            User user = userRegistry.get(auth.getUsername());\n+            if (user == null) {\n+                throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c3c0a5bf0059aabbb01eff285911c46dca211af"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4OTQ1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");\n          \n          \n            \n                        throw new AuthenticationException(\"User not found in registry\");", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r508289450", "createdAt": "2020-10-20T08:00:30Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/AuthFilter.java", "diffHunk": "@@ -93,6 +96,32 @@ protected void modified(@Nullable Map<String, @Nullable Object> properties) {\n         }\n     }\n \n+    private SecurityContext authenticateBearerToken(String token) throws AuthenticationException {\n+        if (token.startsWith(API_TOKEN_PREFIX)) {\n+            UserApiTokenCredentials credentials = new UserApiTokenCredentials(token);\n+            Authentication auth = userRegistry.authenticate(credentials);\n+            User user = userRegistry.get(auth.getUsername());\n+            if (user == null) {\n+                throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");\n+            }\n+            return new UserSecurityContext(user, \"ApiToken\");\n+        } else {\n+            Authentication auth = jwtHelper.verifyAndParseJwtAccessToken(token);\n+            return new JwtSecurityContext(auth);\n+        }\n+    }\n+\n+    private SecurityContext authenticateUsernamePassword(String username, String password)\n+            throws AuthenticationException {\n+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n+        Authentication auth = userRegistry.authenticate(credentials);\n+        User user = userRegistry.get(auth.getUsername());\n+        if (user == null) {\n+            throw new org.openhab.core.auth.AuthenticationException(\"User not found in registry\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c3c0a5bf0059aabbb01eff285911c46dca211af"}, "originalPosition": 59}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b459cbc0cb5cf5586c796fe882b427eadc03d0d5", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/b459cbc0cb5cf5586c796fe882b427eadc03d0d5", "committedDate": "2020-10-20T15:06:55Z", "message": "[REST Auth] API tokens & openhab:users console command\n\nThis adds API tokens as a new credential type. Their format is:\n`oh.<name>.<random chars>`\n\nThe \"oh.\" prefix is used to tell them apart from a JWT access token,\nbecause they're both used as a Bearer authorization scheme, but there\nis no semantic value attached to any of the other parts.\n\nThey are stored hashed in the user's profile, and can be listed, added\nor removed managed with the new `openhab:users` console command.\n\nCurrently the scopes are still not checked, but ultimately they could\nbe, for instance a scope of e.g. `user admin.items` would mean that the\nAPI token can be used to perform user operations like retrieving info\nor sending a command, _and_ managing the items, but nothing else -\neven if the user has more permissions because of their role (which\nwill of course still be checked).\n\nTokens are normally passed in the Authorization header with the Bearer\nscheme, or the X-OPENHAB-TOKEN header, like access tokens.\nAs a special exception, API tokens can also be used with the Basic\nauthorization scheme, **even if the allowBasicAuth** option is not\nenabled in the \"API Security\" service, because there's no additional\nsecurity risk in allowing that. In that case, the token should be\npassed as the username and the password MUST be empty.\n\nIn short, this means that all these curl commands will work:\n- `curl -H 'Authorization: Bearer <token>' http://localhost:8080/rest/inbox`\n- `curl -H 'X-OPENHAB-TOKEN: <token>' http://localhost:8080/rest/inbox`\n- `curl -u '<token>[:]' http://localhost:8080/rest/inbox`\n- `curl http://<token>@localhost:8080/rest/inbox`\n\n2 REST API operations were adding to the AuthResource, to allow\nauthenticated users to list their tokens or remove (revoke) one.\nSelf-service for creating a token or changing the password is more\nsensitive so these should be handled with a servlet and pages devoid\nof any JavaScript instead of REST API calls, therefore for now they'll\nhave to be done with the console.\n\nThis also fixes regressions introduced with #1713 - the operations\nannotated with @RolesAllowed({ Role.USER }) only were not authorized\nfor administrators anymore.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d099c7694f8c5ea46551a4c36c9a12a2e9429b1", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/9d099c7694f8c5ea46551a4c36c9a12a2e9429b1", "committedDate": "2020-10-20T15:06:56Z", "message": "Generate a unique salt for each token\n\nReusing the password salt is bad practice, and changing the\npassword changes the salt as well which makes all tokens\ninvalid.\n\nPut the salt in the same field as the hash (concatenated\nwith a separator) to avoid modifying the JSON DB schema.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe67008e945d1a696a32105ac3bbbb212ab7c33b", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/fe67008e945d1a696a32105ac3bbbb212ab7c33b", "committedDate": "2020-10-20T15:48:05Z", "message": "Fix API token authentication, make scope available to security context\n\nThe X-OPENHAB-TOKEN header now has priority over the Authorization\nheader to credentials, if both are set.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c3c0a5bf0059aabbb01eff285911c46dca211af", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/8c3c0a5bf0059aabbb01eff285911c46dca211af", "committedDate": "2020-10-19T20:52:24Z", "message": "Generate a unique salt for each token\n\nReusing the password salt is bad practice, and changing the\npassword changes the salt as well which makes all tokens\ninvalid.\n\nPut the salt in the same field as the hash (concatenated\nwith a separator) to avoid modifying the JSON DB schema.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}, "afterCommit": {"oid": "fe67008e945d1a696a32105ac3bbbb212ab7c33b", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/fe67008e945d1a696a32105ac3bbbb212ab7c33b", "committedDate": "2020-10-20T15:48:05Z", "message": "Fix API token authentication, make scope available to security context\n\nThe X-OPENHAB-TOKEN header now has priority over the Authorization\nheader to credentials, if both are set.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07de0ce0460ccb872e7b09af09575a2c67c39691", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/07de0ce0460ccb872e7b09af09575a2c67c39691", "committedDate": "2020-10-20T18:10:33Z", "message": "Add self-service pages to change password & create new API token\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/6d9cbf96e22be1b7bbe4884f2477c119158fe6be", "committedDate": "2020-10-20T18:38:03Z", "message": "Fix SAT error\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjE3OTQ0", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-514217944", "createdAt": "2020-10-21T22:00:46Z", "commit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowMDo0NlrOHmH98w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMTo0NVrOHmK76A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczODQ4Mw==", "bodyText": "Usually List.of(..) can be used instead of  Arrays.asList(new String[] {}) in Java 11.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509738483", "createdAt": "2020-10-21T22:00:46Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczOTkzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (managedUser.getApiTokens().size() > 0) {\n          \n          \n            \n                                    if (!managedUser.getApiTokens().isEmpty()) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509739935", "createdAt": "2020-10-21T22:02:37Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MDc1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        managedUser.getApiTokens().forEach(t -> {\n          \n          \n            \n                                            console.println(\"user=\" + user.toString() + \", \" + t.toString());\n          \n          \n            \n                                        });\n          \n          \n            \n                                        managedUser.getApiTokens().forEach(t -> console.println(\"user=\" + user.toString() + \", \" + t.toString()));", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509740756", "createdAt": "2020-10-21T22:03:55Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MTI4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                protected Instant lastAuthenticationFailure;\n          \n          \n            \n                protected @Nullable Instant lastAuthenticationFailure;", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509741286", "createdAt": "2020-10-21T22:04:43Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MTUxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n          \n          \n            \n                protected Map<String, Instant> csrfTokens = new HashMap<>();", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509741517", "createdAt": "2020-10-21T22:05:04Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NTc2Mg==", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509745762", "createdAt": "2020-10-21T22:12:22Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NjE3NQ==", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509746175", "createdAt": "2020-10-21T22:12:48Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzAwNw==", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509747007", "createdAt": "2020-10-21T22:13:56Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NzQ4Mg==", "bodyText": "I think it is unlikely these parameters will ever be null so you can also use @NonNullByDefault({}) instead of @Nullable and remove the null check below.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509747482", "createdAt": "2020-10-21T22:14:26Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjU3NA==", "bodyText": "I think it would be helpful to print it. The UI also informs users of this.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509756574", "createdAt": "2020-10-21T22:25:19Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.console/src/main/java/org/openhab/core/io/console/internal/extension/UserConsoleCommandExtension.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.console.internal.extension;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserApiToken;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.io.console.Console;\n+import org.openhab.core.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.openhab.core.io.console.extensions.ConsoleCommandExtension;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * Console command extension to manage users, sessions and API tokens\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+@NonNullByDefault\n+public class UserConsoleCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String SUBCMD_LIST = \"list\";\n+    private static final String SUBCMD_ADD = \"add\";\n+    private static final String SUBCMD_REMOVE = \"remove\";\n+    private static final String SUBCMD_CHANGEPASSWORD = \"changePassword\";\n+    private static final String SUBCMD_LISTAPITOKENS = \"listApiTokens\";\n+    private static final String SUBCMD_ADDAPITOKEN = \"addApiToken\";\n+    private static final String SUBCMD_RMAPITOKEN = \"rmApiToken\";\n+    private static final String SUBCMD_CLEARSESSIONS = \"clearSessions\";\n+\n+    private final UserRegistry userRegistry;\n+\n+    @Activate\n+    public UserConsoleCommandExtension(final @Reference UserRegistry userRegistry) {\n+        super(\"users\", \"Access the user registry.\");\n+        this.userRegistry = userRegistry;\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST, \"lists all users\"),\n+                buildCommandUsage(SUBCMD_ADD + \" <userId> <password> <role>\",\n+                        \"adds a new user with the specified role\"),\n+                buildCommandUsage(SUBCMD_REMOVE + \" <userId>\", \"removes the given user\"),\n+                buildCommandUsage(SUBCMD_CHANGEPASSWORD + \" <userId> <newPassword>\", \"changes the password of a user\"),\n+                buildCommandUsage(SUBCMD_LISTAPITOKENS, \"lists the API keys for all users\"),\n+                buildCommandUsage(SUBCMD_ADDAPITOKEN + \" <userId> <tokenName> <scope>\",\n+                        \"adds a new API token on behalf of the specified user for the specified scope\"),\n+                buildCommandUsage(SUBCMD_RMAPITOKEN + \" <userId> <tokenName>\",\n+                        \"removes (revokes) the specified API token\"),\n+                buildCommandUsage(SUBCMD_CLEARSESSIONS + \" <userId>\",\n+                        \"clear the refresh tokens associated with the user (will sign the user out of all sessions)\") });\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case SUBCMD_LIST:\n+                    userRegistry.getAll().forEach(user -> console.println(user.toString()));\n+                    break;\n+                case SUBCMD_ADD:\n+                    if (args.length == 4) {\n+                        User existingUser = userRegistry.get(args[1]);\n+                        if (existingUser == null) {\n+                            User newUser = userRegistry.register(args[1], args[2], Set.of(args[3]));\n+                            console.println(newUser.toString());\n+                            console.println(\"User created.\");\n+                        } else {\n+                            console.println(\"The user already exists.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_ADD));\n+                    }\n+                    break;\n+                case SUBCMD_REMOVE:\n+                    if (args.length == 2) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.remove(user.getName());\n+                            console.println(\"User removed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_REMOVE));\n+                    }\n+                    break;\n+                case SUBCMD_CHANGEPASSWORD:\n+                    if (args.length == 3) {\n+                        User user = userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            userRegistry.changePassword(user, args[2]);\n+                            console.println(\"Password changed.\");\n+                        } else {\n+                            console.println(\"User not found.\");\n+                        }\n+                    } else {\n+                        console.printUsage(findUsage(SUBCMD_CHANGEPASSWORD));\n+                    }\n+                    break;\n+                case SUBCMD_LISTAPITOKENS:\n+                    userRegistry.getAll().forEach(user -> {\n+                        ManagedUser managedUser = (ManagedUser) user;\n+                        if (managedUser.getApiTokens().size() > 0) {\n+                            managedUser.getApiTokens().forEach(t -> {\n+                                console.println(\"user=\" + user.toString() + \", \" + t.toString());\n+                            });\n+                        }\n+                    });\n+                    break;\n+                case SUBCMD_ADDAPITOKEN:\n+                    if (args.length == 4) {\n+                        ManagedUser user = (ManagedUser) userRegistry.get(args[1]);\n+                        if (user != null) {\n+                            Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                                    .filter(t -> args[2].equals(t.getName())).findAny();\n+                            if (userApiToken.isEmpty()) {\n+                                String tokenString = userRegistry.addUserApiToken(user, args[2], args[3]);\n+                                // inform the user that the token will not be printed again, and they should save it?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc2MTMyOA==", "bodyText": "Can you fix the indentation so it only uses tabs or spaces?", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509761328", "createdAt": "2020-10-21T22:32:24Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/pages/authorize.html", "diffHunk": "@@ -54,41 +62,69 @@\n \tmargin-bottom: 1rem;\n }\n \n-input.submit {\n+.submit {\n \tcursor: pointer;\n \tmargin-top: 2rem;\n \tbackground-color: rgb(33, 150, 243);\n+\ttext-decoration: none;\n \tcolor: white;\n \tborder-radius: 4px;\n \tfont-size: 14px;\n \tfont-weight: 600;\n+\tmin-width: 80px;\n+\tpadding-top: 10px;\n+    padding-bottom: 10px;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MDYzNQ==", "bodyText": "You might want to use a try-with-resources statement here to be sure the stream is always closed.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509770635", "createdAt": "2020-10-21T22:39:50Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n+\n+    protected String pageTemplate;\n+\n+    public AbstractAuthPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+        if (resource != null) {\n+            try {\n+                pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MjMzMg==", "bodyText": "You could add a helpful message here what file could not be opened.\nDo these kind of authentication related exceptions also show in the browser or only in logging?", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509772332", "createdAt": "2020-10-21T22:43:29Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AbstractAuthPageServlet.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.Authentication;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.openhab.core.auth.UsernamePasswordCredentials;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for servlets to perform sensible operations requiring user authentication.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class AbstractAuthPageServlet extends HttpServlet {\n+\n+    protected static final long serialVersionUID = 5340598701104679840L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(AbstractAuthPageServlet.class);\n+\n+    protected HttpService httpService;\n+    protected UserRegistry userRegistry;\n+    protected AuthenticationProvider authProvider;\n+    @Nullable\n+    protected Instant lastAuthenticationFailure;\n+    protected int authenticationFailureCount = 0;\n+\n+    protected HashMap<String, Instant> csrfTokens = new HashMap<>();\n+\n+    protected String pageTemplate;\n+\n+    public AbstractAuthPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        this.httpService = httpService;\n+        this.userRegistry = userRegistry;\n+        this.authProvider = authProvider;\n+\n+        pageTemplate = \"\";\n+        URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n+        if (resource != null) {\n+            try {\n+                pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3ODYzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n          \n          \n            \n                        logger.error(\"Error during change password page registration: {}\", e.getMessage());", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509778636", "createdAt": "2020-10-21T22:51:41Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MDQ0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"username\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"username\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509780440", "createdAt": "2020-10-21T22:53:59Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MDcxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"password\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"password\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509780712", "createdAt": "2020-10-21T22:54:22Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MDkzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"new_password\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"new_password\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509780931", "createdAt": "2020-10-21T22:54:36Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey((\"new_password\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MTUwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    responseBody = responseBody.replace(\"{formClass}\", (hideForm) ? \"hide\" : \"show\");\n          \n          \n            \n                    responseBody = responseBody.replace(\"{formClass}\", hideForm ? \"hide\" : \"show\");", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509781507", "createdAt": "2020-10-21T22:55:28Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to change their password, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class ChangePasswordPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangePasswordPageServlet.class);\n+\n+    @Activate\n+    public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/changePassword\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"\";\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey((\"new_password\"))) {\n+                    throw new AuthenticationException(\"no new password\");\n+                }\n+                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                    throw new AuthenticationException(\"CSRF check failed\");\n+                }\n+\n+                removeCsrfToken(params.get(\"csrf_token\")[0]);\n+\n+                String username = params.get(\"username\")[0];\n+                String password = params.get(\"password\")[0];\n+                String newPassword = params.get(\"new_password\")[0];\n+\n+                if (!params.containsKey(\"password_repeat\") || !newPassword.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n+                }\n+\n+                User user = login(username, password);\n+\n+                if (user instanceof ManagedUser) {\n+                    userRegistry.changePassword(user, newPassword);\n+                } else {\n+                    throw new AuthenticationException(\"User is not managed\");\n+                }\n+\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getResultPageBody(params, \"Password changed.\")); // TODO: i18n\n+                resp.getWriter().close();\n+            } catch (AuthenticationException e) {\n+                processFailedLogin(resp, params, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n+        String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n+        String buttonLabel = \"Change Password\"; // TODO: i18n\n+        responseBody = responseBody.replace(\"{message}\", message);\n+        responseBody = responseBody.replace(\"{formAction}\", \"/changePassword\");\n+        responseBody = responseBody.replace(\"{formClass}\", (hideForm) ? \"hide\" : \"show\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjAwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"username\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"username\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509782006", "createdAt": "2020-10-21T22:56:55Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjA2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"password\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"password\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509782066", "createdAt": "2020-10-21T22:57:05Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjEzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!params.containsKey((\"token_name\"))) {\n          \n          \n            \n                            if (!params.containsKey(\"token_name\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509782130", "createdAt": "2020-10-21T22:57:15Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/CreateAPITokenPageServlet.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.http.auth.internal;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.AuthenticationException;\n+import org.openhab.core.auth.AuthenticationProvider;\n+import org.openhab.core.auth.ManagedUser;\n+import org.openhab.core.auth.User;\n+import org.openhab.core.auth.UserRegistry;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A servlet serving a page allowing users to create a new API token, after confirming their identity by signing in.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class CreateAPITokenPageServlet extends AbstractAuthPageServlet {\n+\n+    private static final long serialVersionUID = 5340598701104679843L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateAPITokenPageServlet.class);\n+\n+    @Activate\n+    public CreateAPITokenPageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n+            @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n+        super(bundleContext, httpService, userRegistry, authProvider);\n+        try {\n+            httpService.registerServlet(\"/createApiToken\", this, null, null);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.error(\"Error during create API token page registration: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+\n+            try {\n+                String message = \"Create a new API token to authorize external services.\";\n+\n+                // TODO: i18n\n+                resp.setContentType(\"text/html;charset=UTF-8\");\n+                resp.getWriter().append(getPageBody(params, message, false));\n+                resp.getWriter().close();\n+            } catch (Exception e) {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n+                resp.getWriter().close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req != null && resp != null) {\n+            Map<String, String[]> params = req.getParameterMap();\n+            try {\n+                if (!params.containsKey((\"username\"))) {\n+                    throw new AuthenticationException(\"no username\");\n+                }\n+                if (!params.containsKey((\"password\"))) {\n+                    throw new AuthenticationException(\"no password\");\n+                }\n+                if (!params.containsKey((\"token_name\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTIxNA==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785214", "createdAt": "2020-10-21T23:05:54Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTI0Mg==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785242", "createdAt": "2020-10-21T23:06:00Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTMwMA==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785300", "createdAt": "2020-10-21T23:06:11Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Stream<UserApiTokenDTO> sessions = user.getApiTokens().stream().map(this::toUserApiTokenDTO);\n+        return Response.ok(new Stream2JSONInputStream(sessions)).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"/apitokens/{name}\")\n+    @Operation(summary = \"Revoke a specified API token associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    public Response removeApiToken(@Context SecurityContext securityContext, @PathParam(\"name\") String name) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTMyNg==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785326", "createdAt": "2020-10-21T23:06:15Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Stream<UserApiTokenDTO> sessions = user.getApiTokens().stream().map(this::toUserApiTokenDTO);\n+        return Response.ok(new Stream2JSONInputStream(sessions)).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"/apitokens/{name}\")\n+    @Operation(summary = \"Revoke a specified API token associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    public Response removeApiToken(@Context SecurityContext securityContext, @PathParam(\"name\") String name) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NTM3MA==", "bodyText": "This response seems to be missing from the OpenAPI responses of the @Operation.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509785370", "createdAt": "2020-10-21T23:06:20Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/TokenResource.java", "diffHunk": "@@ -154,6 +158,49 @@ public Response getSessions(@Context SecurityContext securityContext) {\n         return Response.ok(new Stream2JSONInputStream(sessions)).build();\n     }\n \n+    @GET\n+    @Path(\"/apitokens\")\n+    @Operation(summary = \"List the API tokens associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    public Response getApiTokens(@Context SecurityContext securityContext) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Stream<UserApiTokenDTO> sessions = user.getApiTokens().stream().map(this::toUserApiTokenDTO);\n+        return Response.ok(new Stream2JSONInputStream(sessions)).build();\n+    }\n+\n+    @DELETE\n+    @Path(\"/apitokens/{name}\")\n+    @Operation(summary = \"Revoke a specified API token associated to the authenticated user.\", responses = {\n+            @ApiResponse(responseCode = \"200\", description = \"OK\", content = @Content(schema = @Schema(implementation = UserApiTokenDTO.class))) })\n+    public Response removeApiToken(@Context SecurityContext securityContext, @PathParam(\"name\") String name) {\n+        if (securityContext.getUserPrincipal() == null) {\n+            return JSONResponse.createErrorResponse(Status.UNAUTHORIZED, \"User is not authenticated\");\n+        }\n+\n+        ManagedUser user = (ManagedUser) userRegistry.get(securityContext.getUserPrincipal().getName());\n+        if (user == null) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"User not found\");\n+        }\n+\n+        Optional<UserApiToken> userApiToken = user.getApiTokens().stream()\n+                .filter(apiToken -> apiToken.getName().equals(name)).findAny();\n+        if (userApiToken.isEmpty()) {\n+            return JSONResponse.createErrorResponse(Status.NOT_FOUND, \"No API token found with that name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njc2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        User user = this.get(usernamePasswordCreds.getUsername());\n          \n          \n            \n                        User user = get(usernamePasswordCreds.getUsername());", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786762", "createdAt": "2020-10-21T23:10:44Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NjgzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786838", "createdAt": "2020-10-21T23:10:57Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njg3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786877", "createdAt": "2020-10-21T23:11:05Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NjkyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786921", "createdAt": "2020-10-21T23:11:14Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njk3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509786978", "createdAt": "2020-10-21T23:11:24Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void clearSessions(User user) {\n         if (!(user instanceof ManagedUser)) {\n-            throw new AuthenticationException(\"User is not managed: \" + usernamePasswordCreds.getUsername());\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n \n         ManagedUser managedUser = (ManagedUser) user;\n-        String hashedPassword = hashPassword(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt()).get();\n-        if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n-            throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+        managedUser.getSessions().clear();\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NzAyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509787026", "createdAt": "2020-10-21T23:11:32Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void clearSessions(User user) {\n         if (!(user instanceof ManagedUser)) {\n-            throw new AuthenticationException(\"User is not managed: \" + usernamePasswordCreds.getUsername());\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n \n         ManagedUser managedUser = (ManagedUser) user;\n-        String hashedPassword = hashPassword(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt()).get();\n-        if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n-            throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+        managedUser.getSessions().clear();\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public String addUserApiToken(User user, String name, String scope) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+        if (!name.matches(\"[a-zA-Z0-9]*\")) {\n+            throw new IllegalArgumentException(\"API token name format invalid, alphanumeric characters only\");\n         }\n \n-        Authentication authentication = new Authentication(managedUser.getName());\n-        return authentication;\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String tokenSalt = generateSalt(KEY_LENGTH / 8).get();\n+        byte[] rnd = new byte[64];\n+        RAND.nextBytes(rnd);\n+        String token = APITOKEN_PREFIX + \".\" + name + \".\"\n+                + Base64.getEncoder().encodeToString(rnd).replaceAll(\"(\\\\+|/|=)\", \"\");\n+        String tokenHash = hash(token, tokenSalt, APITOKEN_ITERATIONS).get();\n+\n+        UserApiToken userApiToken = new UserApiToken(name, tokenHash + \":\" + tokenSalt, scope);\n+\n+        managedUser.getApiTokens().add(userApiToken);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NzExMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.update(user);\n          \n          \n            \n                    update(user);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r509787112", "createdAt": "2020-10-21T23:11:45Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = this.get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public void clearSessions(User user) {\n         if (!(user instanceof ManagedUser)) {\n-            throw new AuthenticationException(\"User is not managed: \" + usernamePasswordCreds.getUsername());\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n \n         ManagedUser managedUser = (ManagedUser) user;\n-        String hashedPassword = hashPassword(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt()).get();\n-        if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n-            throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+        managedUser.getSessions().clear();\n+        this.update(user);\n+    }\n+\n+    @Override\n+    public String addUserApiToken(User user, String name, String scope) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+        if (!name.matches(\"[a-zA-Z0-9]*\")) {\n+            throw new IllegalArgumentException(\"API token name format invalid, alphanumeric characters only\");\n         }\n \n-        Authentication authentication = new Authentication(managedUser.getName());\n-        return authentication;\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String tokenSalt = generateSalt(KEY_LENGTH / 8).get();\n+        byte[] rnd = new byte[64];\n+        RAND.nextBytes(rnd);\n+        String token = APITOKEN_PREFIX + \".\" + name + \".\"\n+                + Base64.getEncoder().encodeToString(rnd).replaceAll(\"(\\\\+|/|=)\", \"\");\n+        String tokenHash = hash(token, tokenSalt, APITOKEN_ITERATIONS).get();\n+\n+        UserApiToken userApiToken = new UserApiToken(name, tokenHash + \":\" + tokenSalt, scope);\n+\n+        managedUser.getApiTokens().add(userApiToken);\n+        this.update(user);\n+\n+        return token;\n+    }\n+\n+    @Override\n+    public void removeUserApiToken(User user, UserApiToken userApiToken) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getApiTokens().remove(userApiToken);\n+        this.update(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9cbf96e22be1b7bbe4884f2477c119158fe6be"}, "originalPosition": 194}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea523afb6804cd8674fd1a31805ab4939698db3a", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/ea523afb6804cd8674fd1a31805ab4939698db3a", "committedDate": "2020-10-22T15:26:11Z", "message": "Address review comments\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62c4e6f4278093449966c9b5d13d733d4a30824e", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/62c4e6f4278093449966c9b5d13d733d4a30824e", "committedDate": "2020-10-22T15:34:33Z", "message": "Missing closing paren\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/f051da17a1892a50746392ce911944bfaab3ac27", "committedDate": "2020-10-22T15:36:51Z", "message": "Fix error message when token name doesn't match pattern\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTUyMjQ2", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515152246", "createdAt": "2020-10-22T22:03:17Z", "commit": {"oid": "ea523afb6804cd8674fd1a31805ab4939698db3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowMzoxOFrOHm1ehQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowMzoxOFrOHm1ehQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NDEwMQ==", "bodyText": "These checks can be removed now.", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510484101", "createdAt": "2020-10-22T22:03:18Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/ChangePasswordPageServlet.java", "diffHunk": "@@ -57,43 +56,41 @@ public ChangePasswordPageServlet(BundleContext bundleContext, @Reference HttpSer\n         try {\n             httpService.registerServlet(\"/changePassword\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n-            logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n+            logger.error(\"Error during change password page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message, false));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n-            }\n+        try {\n+            String message = \"\";\n+\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n         if (req != null && resp != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea523afb6804cd8674fd1a31805ab4939698db3a"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTU0Njcw", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515154670", "createdAt": "2020-10-22T22:08:37Z", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowODozN1rOHm1mlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowODozN1rOHm1mlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjE2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (!(\"code\".equals(responseType))) {\n          \n          \n            \n                        if (!\"code\".equals(responseType)) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486165", "createdAt": "2020-10-22T22:08:37Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTU0OTI4", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515154928", "createdAt": "2020-10-22T22:09:10Z", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOToxMFrOHm1ncg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOToxMFrOHm1ncg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjM4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n          \n          \n            \n                            String codeChallenge = params.containsKey(\"code_challenge\") ? params.get(\"code_challenge\")[0] : null;", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486386", "createdAt": "2020-10-22T22:09:10Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 289}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTU1MDUx", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515155051", "createdAt": "2020-10-22T22:09:25Z", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOToyNVrOHm1n3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOToyNVrOHm1n3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjQ5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n          \n          \n            \n                            String codeChallengeMethod = params.containsKey(\"code_challenge_method\")", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486492", "createdAt": "2020-10-22T22:09:25Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 290}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTU1MjM5", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515155239", "createdAt": "2020-10-22T22:09:53Z", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOTo1M1rOHm1ofg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjowOTo1M1rOHm1ofg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjY1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";\n          \n          \n            \n                    String repeatPasswordFieldType = isSignupMode() ? \"password\" : \"hidden\";", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486654", "createdAt": "2020-10-22T22:09:53Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                        ? params.get(\"code_challenge_method\")[0]\n+                        : null;\n+                ManagedUser managedUser = (ManagedUser) user;\n+                PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                        codeChallenge, codeChallengeMethod);\n+                managedUser.setPendingToken(pendingToken);\n+                userRegistry.update(managedUser);\n+            }\n+\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+            resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n+        } catch (AuthenticationException e) {\n+            processFailedLogin(resp, params, e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            @Nullable\n+            String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n+            @Nullable\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            if (baseRedirectUri != null) {\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n                 resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-            } catch (AuthenticationException e) {\n-                lastAuthenticationFailure = Instant.now();\n-                authenticationFailureCount += 1;\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                logger.warn(\"Authentication failed: {}\", e.getMessage());\n-                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n\n+            } else {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n                 resp.getWriter().close();\n-            } catch (IllegalArgumentException e) {\n-                @Nullable\n-                String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n-                @Nullable\n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                if (baseRedirectUri != null) {\n-                    resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n-                    resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-                } else {\n-                    resp.setContentType(\"text/plain;charset=UTF-8\");\n-                    resp.getWriter().append(e.getMessage());\n-                    resp.getWriter().close();\n-                }\n             }\n         }\n     }\n \n-    private String getPageBody(Map<String, String[]> params, String message) {\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n         String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n         String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 344}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTU1NDA1", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515155405", "createdAt": "2020-10-22T22:10:15Z", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMDoxNVrOHm1pFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMDoxNVrOHm1pFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4NjgwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String buttonLabel = (isSignupMode()) ? \"Create Account\" : \"Sign In\"; // TODO: i18n\n          \n          \n            \n                    String buttonLabel = isSignupMode() ? \"Create Account\" : \"Sign In\"; // TODO: i18n", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486807", "createdAt": "2020-10-22T22:10:15Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                        ? params.get(\"code_challenge_method\")[0]\n+                        : null;\n+                ManagedUser managedUser = (ManagedUser) user;\n+                PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                        codeChallenge, codeChallengeMethod);\n+                managedUser.setPendingToken(pendingToken);\n+                userRegistry.update(managedUser);\n+            }\n+\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+            resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n+        } catch (AuthenticationException e) {\n+            processFailedLogin(resp, params, e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            @Nullable\n+            String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n+            @Nullable\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            if (baseRedirectUri != null) {\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n                 resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-            } catch (AuthenticationException e) {\n-                lastAuthenticationFailure = Instant.now();\n-                authenticationFailureCount += 1;\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                logger.warn(\"Authentication failed: {}\", e.getMessage());\n-                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n\n+            } else {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n                 resp.getWriter().close();\n-            } catch (IllegalArgumentException e) {\n-                @Nullable\n-                String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n-                @Nullable\n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                if (baseRedirectUri != null) {\n-                    resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n-                    resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-                } else {\n-                    resp.setContentType(\"text/plain;charset=UTF-8\");\n-                    resp.getWriter().append(e.getMessage());\n-                    resp.getWriter().close();\n-                }\n             }\n         }\n     }\n \n-    private String getPageBody(Map<String, String[]> params, String message) {\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n         String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n         String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";\n         String buttonLabel = (isSignupMode()) ? \"Create Account\" : \"Sign In\"; // TODO: i18n", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 345}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTU1NTUz", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515155553", "createdAt": "2020-10-22T22:10:32Z", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMDozM1rOHm1pow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMDozM1rOHm1pow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4Njk0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!params.containsKey((\"redirect_uri\"))) {\n          \n          \n            \n                    if (!params.containsKey(\"redirect_uri\")) {", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510486947", "createdAt": "2020-10-22T22:10:33Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.http.auth/src/main/java/org/openhab/core/io/http/auth/internal/AuthorizePageServlet.java", "diffHunk": "@@ -64,210 +55,172 @@\n  */\n @NonNullByDefault\n @Component(immediate = true)\n-public class AuthorizePageServlet extends HttpServlet {\n+public class AuthorizePageServlet extends AbstractAuthPageServlet {\n \n     private static final long serialVersionUID = 5340598701104679843L;\n \n     private final Logger logger = LoggerFactory.getLogger(AuthorizePageServlet.class);\n \n-    private HashMap<String, Instant> csrfTokens = new HashMap<>();\n-\n-    private HttpService httpService;\n-    private UserRegistry userRegistry;\n-    private AuthenticationProvider authProvider;\n-    @Nullable\n-    private Instant lastAuthenticationFailure;\n-    private int authenticationFailureCount = 0;\n-\n-    private String pageTemplate;\n-\n     @Activate\n     public AuthorizePageServlet(BundleContext bundleContext, @Reference HttpService httpService,\n             @Reference UserRegistry userRegistry, @Reference AuthenticationProvider authProvider) {\n-        this.httpService = httpService;\n-        this.userRegistry = userRegistry;\n-        this.authProvider = authProvider;\n-\n-        pageTemplate = \"\";\n+        super(bundleContext, httpService, userRegistry, authProvider);\n         try {\n-            URL resource = bundleContext.getBundle().getResource(\"pages/authorize.html\");\n-            if (resource != null) {\n-                try {\n-                    pageTemplate = new String(resource.openStream().readAllBytes(), StandardCharsets.UTF_8);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-                httpService.registerServlet(\"/auth\", this, null, null);\n-            }\n+            httpService.registerServlet(\"/auth\", this, null, null);\n         } catch (NamespaceException | ServletException e) {\n             logger.error(\"Error during authorization page registration: {}\", e.getMessage());\n         }\n     }\n \n     @Override\n-    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doGet(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n+        Map<String, String[]> params = req.getParameterMap();\n \n-            try {\n-                String message = \"\";\n-                String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n-                String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n+        try {\n+            String message = \"\";\n+            String scope = (params.containsKey(\"scope\")) ? params.get(\"scope\")[0] : \"\";\n+            String clientId = (params.containsKey(\"client_id\")) ? params.get(\"client_id\")[0] : \"\";\n \n-                // Basic sanity check\n-                if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n+            // Basic sanity check\n+            if (scope.contains(\"<\") || clientId.contains(\"<\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n \n-                // TODO: i18n\n-                if (isSignupMode()) {\n-                    message = \"Create a first administrator account to continue.\";\n-                } else {\n-                    message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n-                }\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                resp.getWriter().append(getPageBody(params, message));\n-                resp.getWriter().close();\n-            } catch (Exception e) {\n-                resp.setContentType(\"text/plain;charset=UTF-8\");\n-                resp.getWriter().append(e.getMessage());\n-                resp.getWriter().close();\n+            // TODO: i18n\n+            if (isSignupMode()) {\n+                message = \"Create a first administrator account to continue.\";\n+            } else {\n+                message = String.format(\"Sign in to grant <b>%s</b> access to <b>%s</b>:\", scope, clientId);\n             }\n+            resp.setContentType(\"text/html;charset=UTF-8\");\n+            resp.getWriter().append(getPageBody(params, message, false));\n+            resp.getWriter().close();\n+        } catch (Exception e) {\n+            resp.setContentType(\"text/plain;charset=UTF-8\");\n+            resp.getWriter().append(e.getMessage());\n+            resp.getWriter().close();\n         }\n     }\n \n     @Override\n-    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+    protected void doPost(@NonNullByDefault({}) HttpServletRequest req, @NonNullByDefault({}) HttpServletResponse resp)\n             throws ServletException, IOException {\n-        if (req != null && resp != null) {\n-            Map<String, String[]> params = req.getParameterMap();\n-            try {\n-                if (!params.containsKey((\"username\"))) {\n-                    throw new AuthenticationException(\"no username\");\n-                }\n-                if (!params.containsKey((\"password\"))) {\n-                    throw new AuthenticationException(\"no password\");\n-                }\n-                if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n-                    throw new AuthenticationException(\"CSRF check failed\");\n-                }\n-                if (!params.containsKey((\"redirect_uri\"))) {\n-                    throw new IllegalArgumentException(\"invalid_request\");\n-                }\n-                if (!params.containsKey((\"response_type\"))) {\n-                    throw new IllegalArgumentException(\"unsupported_response_type\");\n-                }\n-                if (!params.containsKey((\"client_id\"))) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n-                if (!params.containsKey((\"scope\"))) {\n-                    throw new IllegalArgumentException(\"invalid_scope\");\n-                }\n+        Map<String, String[]> params = req.getParameterMap();\n+        try {\n+            if (!params.containsKey(\"username\")) {\n+                throw new AuthenticationException(\"no username\");\n+            }\n+            if (!params.containsKey(\"password\")) {\n+                throw new AuthenticationException(\"no password\");\n+            }\n+            if (!params.containsKey(\"csrf_token\") || !csrfTokens.containsKey(params.get(\"csrf_token\")[0])) {\n+                throw new AuthenticationException(\"CSRF check failed\");\n+            }\n+            if (!params.containsKey(\"redirect_uri\")) {\n+                throw new IllegalArgumentException(\"invalid_request\");\n+            }\n+            if (!params.containsKey(\"response_type\")) {\n+                throw new IllegalArgumentException(\"unsupported_response_type\");\n+            }\n+            if (!params.containsKey(\"client_id\")) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n+            if (!params.containsKey(\"scope\")) {\n+                throw new IllegalArgumentException(\"invalid_scope\");\n+            }\n \n-                csrfTokens.remove(params.get(\"csrf_token\")[0]);\n+            removeCsrfToken(params.get(\"csrf_token\")[0]);\n \n-                String baseRedirectUri = params.get(\"redirect_uri\")[0];\n-                String responseType = params.get(\"response_type\")[0];\n-                String clientId = params.get(\"redirect_uri\")[0];\n-                String scope = params.get(\"scope\")[0];\n+            String baseRedirectUri = params.get(\"redirect_uri\")[0];\n+            String responseType = params.get(\"response_type\")[0];\n+            String clientId = params.get(\"redirect_uri\")[0];\n+            String scope = params.get(\"scope\")[0];\n \n-                if (!(\"code\".equals(responseType))) {\n-                    throw new AuthenticationException(\"unsupported_response_type\");\n-                }\n+            if (!(\"code\".equals(responseType))) {\n+                throw new AuthenticationException(\"unsupported_response_type\");\n+            }\n \n-                if (!clientId.equals(baseRedirectUri)) {\n-                    throw new IllegalArgumentException(\"unauthorized_client\");\n-                }\n+            if (!clientId.equals(baseRedirectUri)) {\n+                throw new IllegalArgumentException(\"unauthorized_client\");\n+            }\n \n-                String username = params.get(\"username\")[0];\n-                String password = params.get(\"password\")[0];\n-\n-                User user;\n-                if (isSignupMode()) {\n-                    // Create a first administrator account with the supplied credentials\n-\n-                    // first verify the password confirmation and bail out if necessary\n-                    if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n-                        resp.setContentType(\"text/html;charset=UTF-8\");\n-                        // TODO: i18n\n-                        resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\"));\n-                        resp.getWriter().close();\n-                        return;\n-                    }\n-\n-                    user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n-                    logger.info(\"First user account created: {}\", username);\n-                } else {\n-                    // Enforce a dynamic cooldown period after a failed authentication attempt: the number of\n-                    // consecutive failures in seconds\n-                    if (lastAuthenticationFailure != null && lastAuthenticationFailure\n-                            .isAfter(Instant.now().minus(Duration.ofSeconds(authenticationFailureCount)))) {\n-                        throw new AuthenticationException(\"Too many consecutive login attempts\");\n-                    }\n-\n-                    // Authenticate the user with the supplied credentials\n-                    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);\n-                    Authentication auth = authProvider.authenticate(credentials);\n-                    logger.debug(\"Login successful: {}\", auth.getUsername());\n-                    lastAuthenticationFailure = null;\n-                    authenticationFailureCount = 0;\n-                    user = userRegistry.get(auth.getUsername());\n-                }\n+            String username = params.get(\"username\")[0];\n+            String password = params.get(\"password\")[0];\n+\n+            User user;\n+            if (isSignupMode()) {\n+                // Create a first administrator account with the supplied credentials\n \n-                String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n-\n-                if (user instanceof ManagedUser) {\n-                    String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0]\n-                            : null;\n-                    String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n-                            ? params.get(\"code_challenge_method\")[0]\n-                            : null;\n-                    ManagedUser managedUser = (ManagedUser) user;\n-                    PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n-                            codeChallenge, codeChallengeMethod);\n-                    managedUser.setPendingToken(pendingToken);\n-                    userRegistry.update(managedUser);\n+                // first verify the password confirmation and bail out if necessary\n+                if (!params.containsKey(\"password_repeat\") || !password.equals(params.get(\"password_repeat\")[0])) {\n+                    resp.setContentType(\"text/html;charset=UTF-8\");\n+                    // TODO: i18n\n+                    resp.getWriter().append(getPageBody(params, \"Passwords don't match, please try again.\", false));\n+                    resp.getWriter().close();\n+                    return;\n                 }\n \n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+                user = userRegistry.register(username, password, Set.of(Role.ADMIN));\n+                logger.info(\"First user account created: {}\", username);\n+            } else {\n+                user = login(username, password);\n+            }\n+\n+            String authorizationCode = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+            if (user instanceof ManagedUser) {\n+                String codeChallenge = (params.containsKey(\"code_challenge\")) ? params.get(\"code_challenge\")[0] : null;\n+                String codeChallengeMethod = (params.containsKey(\"code_challenge_method\"))\n+                        ? params.get(\"code_challenge_method\")[0]\n+                        : null;\n+                ManagedUser managedUser = (ManagedUser) user;\n+                PendingToken pendingToken = new PendingToken(authorizationCode, clientId, baseRedirectUri, scope,\n+                        codeChallenge, codeChallengeMethod);\n+                managedUser.setPendingToken(pendingToken);\n+                userRegistry.update(managedUser);\n+            }\n+\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, authorizationCode, null, state));\n+            resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n+        } catch (AuthenticationException e) {\n+            processFailedLogin(resp, params, e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            @Nullable\n+            String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n+            @Nullable\n+            String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n+            if (baseRedirectUri != null) {\n+                resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n                 resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-            } catch (AuthenticationException e) {\n-                lastAuthenticationFailure = Instant.now();\n-                authenticationFailureCount += 1;\n-                resp.setContentType(\"text/html;charset=UTF-8\");\n-                logger.warn(\"Authentication failed: {}\", e.getMessage());\n-                resp.getWriter().append(getPageBody(params, \"Please try again.\")); // TODO: i18n\n+            } else {\n+                resp.setContentType(\"text/plain;charset=UTF-8\");\n+                resp.getWriter().append(e.getMessage());\n                 resp.getWriter().close();\n-            } catch (IllegalArgumentException e) {\n-                @Nullable\n-                String baseRedirectUri = params.containsKey(\"redirect_uri\") ? params.get(\"redirect_uri\")[0] : null;\n-                @Nullable\n-                String state = params.containsKey(\"state\") ? params.get(\"state\")[0] : null;\n-                if (baseRedirectUri != null) {\n-                    resp.addHeader(HttpHeaders.LOCATION, getRedirectUri(baseRedirectUri, null, e.getMessage(), state));\n-                    resp.setStatus(HttpStatus.MOVED_TEMPORARILY_302);\n-                } else {\n-                    resp.setContentType(\"text/plain;charset=UTF-8\");\n-                    resp.getWriter().append(e.getMessage());\n-                    resp.getWriter().close();\n-                }\n             }\n         }\n     }\n \n-    private String getPageBody(Map<String, String[]> params, String message) {\n+    @Override\n+    protected String getPageBody(Map<String, String[]> params, String message, boolean hideForm) {\n         String responseBody = pageTemplate.replace(\"{form_fields}\", getFormFields(params));\n         String repeatPasswordFieldType = (isSignupMode()) ? \"password\" : \"hidden\";\n         String buttonLabel = (isSignupMode()) ? \"Create Account\" : \"Sign In\"; // TODO: i18n\n         responseBody = responseBody.replace(\"{message}\", message);\n+        responseBody = responseBody.replace(\"{formAction}\", \"/auth\");\n+        responseBody = responseBody.replace(\"{formClass}\", \"show\");\n         responseBody = responseBody.replace(\"{repeatPasswordFieldType}\", repeatPasswordFieldType);\n+        responseBody = responseBody.replace(\"{newPasswordFieldType}\", \"hidden\");\n+        responseBody = responseBody.replace(\"{tokenNameFieldType}\", \"hidden\");\n+        responseBody = responseBody.replace(\"{tokenScopeFieldType}\", \"hidden\");\n         responseBody = responseBody.replace(\"{buttonLabel}\", buttonLabel);\n+        responseBody = responseBody.replace(\"{resultClass}\", \"\");\n         return responseBody;\n     }\n \n-    private String getFormFields(Map<String, String[]> params) {\n+    @Override\n+    protected String getFormFields(Map<String, String[]> params) {\n         String hiddenFormFields = \"\";\n \n         if (!params.containsKey((\"redirect_uri\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 363}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTU2NzAy", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515156702", "createdAt": "2020-10-22T22:13:05Z", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMzowNVrOHm1tPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxMzowNVrOHm1tPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4Nzg3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Authentication auth = new Authentication(username, roles.toArray(new String[roles.size()]), scope);\n          \n          \n            \n                        return auth;\n          \n          \n            \n                        return new Authentication(username, roles.toArray(new String[roles.size()]), scope);", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510487870", "createdAt": "2020-10-22T22:13:05Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core.io.rest.auth/src/main/java/org/openhab/core/io/rest/auth/internal/JwtHelper.java", "diffHunk": "@@ -150,7 +149,8 @@ public Authentication verifyAndParseJwtAccessToken(String jwt) throws Authentica\n             JwtClaims jwtClaims = jwtConsumer.processToClaims(jwt);\n             String username = jwtClaims.getSubject();\n             List<String> roles = jwtClaims.getStringListClaimValue(\"role\");\n-            Authentication auth = new Authentication(username, roles.toArray(new String[roles.size()]));\n+            String scope = jwtClaims.getStringClaimValue(\"scope\");\n+            Authentication auth = new Authentication(username, roles.toArray(new String[roles.size()]), scope);\n             return auth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTU3NjIy", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515157622", "createdAt": "2020-10-22T22:14:55Z", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxNDo1NlrOHm1wDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxNDo1NlrOHm1wDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4ODU4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param the new password hash\n          \n          \n            \n                 * @param passwordHash the new password hash", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510488588", "createdAt": "2020-10-22T22:14:56Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/auth/ManagedUser.java", "diffHunk": "@@ -59,6 +59,24 @@ public String getPasswordHash() {\n         return passwordHash;\n     }\n \n+    /**\n+     * Alters the password salt.\n+     *\n+     * @param passwordSalt the new password salt\n+     */\n+    public void setPasswordSalt(String passwordSalt) {\n+        this.passwordSalt = passwordSalt;\n+    }\n+\n+    /**\n+     * Alters the password hash.\n+     *\n+     * @param the new password hash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTU4MDQ2", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515158046", "createdAt": "2020-10-22T22:15:54Z", "commit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxNTo1NFrOHm1xmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMjoxNTo1NFrOHm1xmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ4ODk4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param password the new password\n          \n          \n            \n                 * @param newPassword the new password", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r510488985", "createdAt": "2020-10-22T22:15:54Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/auth/UserRegistry.java", "diffHunk": "@@ -38,4 +38,55 @@\n      * @return the new registered {@link User} instance\n      */\n     public User register(String username, String password, Set<String> roles);\n+\n+    /**\n+     * Change the password for an {@link User} in this registry. The implementation receives the new password and is\n+     * responsible for their secure storage (for instance by hashing the password).\n+     *\n+     * @param username the username of the existing user\n+     * @param password the new password", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f051da17a1892a50746392ce911944bfaab3ac27"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b", "committedDate": "2020-10-23T00:51:09Z", "message": "Address more review comments\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTQ4ODE1", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-515948815", "createdAt": "2020-10-23T19:28:47Z", "commit": {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOToyODo0OFrOHnbfSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOToyODo0OFrOHnbfSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwNjg4OA==", "bodyText": "That's probably because I am not very careful :) \ud83d\ude44", "url": "https://github.com/openhab/openhab-core/pull/1735#discussion_r511106888", "createdAt": "2020-10-23T19:28:48Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/auth/UserRegistryImpl.java", "diffHunk": "@@ -128,23 +133,132 @@ public User register(String username, String password, Set<String> roles) {\n \n     @Override\n     public Authentication authenticate(Credentials credentials) throws AuthenticationException {\n-        UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n-        User user = this.get(usernamePasswordCreds.getUsername());\n-        if (user == null) {\n-            throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+        if (credentials instanceof UsernamePasswordCredentials) {\n+            UsernamePasswordCredentials usernamePasswordCreds = (UsernamePasswordCredentials) credentials;\n+            User user = get(usernamePasswordCreds.getUsername());\n+            if (user == null) {\n+                throw new AuthenticationException(\"User not found: \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            ManagedUser managedUser = (ManagedUser) user;\n+            String hashedPassword = hash(usernamePasswordCreds.getPassword(), managedUser.getPasswordSalt(),\n+                    PASSWORD_ITERATIONS).get();\n+            if (!hashedPassword.equals(managedUser.getPasswordHash())) {\n+                throw new AuthenticationException(\"Wrong password for user \" + usernamePasswordCreds.getUsername());\n+            }\n+\n+            return new Authentication(managedUser.getName(), managedUser.getRoles().stream().toArray(String[]::new));\n+        } else if (credentials instanceof UserApiTokenCredentials) {\n+            UserApiTokenCredentials apiTokenCreds = (UserApiTokenCredentials) credentials;\n+            String[] apiTokenParts = apiTokenCreds.getApiToken().split(\"\\\\.\");\n+            if (apiTokenParts.length != 3 || !APITOKEN_PREFIX.equals(apiTokenParts[0])) {\n+                throw new AuthenticationException(\"Invalid API token format\");\n+            }\n+            for (User user : getAll()) {\n+                ManagedUser managedUser = (ManagedUser) user;\n+                for (UserApiToken userApiToken : managedUser.getApiTokens()) {\n+                    // only check if the name in the token matches\n+                    if (!userApiToken.getName().equals(apiTokenParts[1])) {\n+                        continue;\n+                    }\n+                    String[] existingTokenHashAndSalt = userApiToken.getApiToken().split(\":\");\n+                    String incomingTokenHash = hash(apiTokenCreds.getApiToken(), existingTokenHashAndSalt[1],\n+                            APITOKEN_ITERATIONS).get();\n+\n+                    if (incomingTokenHash.equals(existingTokenHashAndSalt[0])) {\n+                        return new Authentication(managedUser.getName(),\n+                                managedUser.getRoles().stream().toArray(String[]::new), userApiToken.getScope());\n+                    }\n+                }\n+            }\n+\n+            throw new AuthenticationException(\"Unknown API token\");\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid credential type\");\n+    }\n+\n+    @Override\n+    public void changePassword(User user, String newPassword) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        String passwordSalt = generateSalt(KEY_LENGTH / 8).get();\n+        String passwordHash = hash(newPassword, passwordSalt, PASSWORD_ITERATIONS).get();\n+        managedUser.setPasswordSalt(passwordSalt);\n+        managedUser.setPasswordHash(passwordHash);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void addUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n+        }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);\n+        update(user);\n+    }\n+\n+    @Override\n+    public void removeUserSession(User user, UserSession session) {\n+        if (!(user instanceof ManagedUser)) {\n+            throw new IllegalArgumentException(\"User is not managed: \" + user.getName());\n         }\n+\n+        ManagedUser managedUser = (ManagedUser) user;\n+        managedUser.getSessions().add(session);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bbaa29c7a5ec6d0969eec95901376d62ad9ea7b"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5bf4a4eb4954709e9d373500e1d1631c8b0a142", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/d5bf4a4eb4954709e9d373500e1d1631c8b0a142", "committedDate": "2020-10-23T19:30:24Z", "message": "Fix removeUserSession in UserRegistryImpl\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e486af4c668f1015b47170bebad0a6018b1a17d2", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/e486af4c668f1015b47170bebad0a6018b1a17d2", "committedDate": "2020-10-23T21:36:11Z", "message": "Add UserRegistryImplTest\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef5f4a75bec594e654861d7596b7a56164074038", "author": {"user": {"login": "ghys", "name": "Yannick Schaus"}}, "url": "https://github.com/openhab/openhab-core/commit/ef5f4a75bec594e654861d7596b7a56164074038", "committedDate": "2020-10-25T09:51:33Z", "message": "Fix null annotations warnings in TokenResource\n\nSigned-off-by: Yannick Schaus <github@schaus.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MzQ1NzU4", "url": "https://github.com/openhab/openhab-core/pull/1735#pullrequestreview-516345758", "createdAt": "2020-10-25T10:46:49Z", "commit": {"oid": "ef5f4a75bec594e654861d7596b7a56164074038"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4647, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}