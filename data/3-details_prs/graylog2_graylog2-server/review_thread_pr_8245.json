{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MTgyODc0", "number": 8245, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzozMzowNFrOECCRAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwODowMjoxOVrOECC3sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTY5NzI5OnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/main/java/org/graylog2/indexer/messages/Messages.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzozMzowNFrOGePkfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDozNToxMFrOGeWA4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2NTU2Ng==", "bodyText": "I did not understand what the method is supposed to do before reading its body. Maybe we should rename it to waitBeforeRetrying or something along these lines?", "url": "https://github.com/Graylog2/graylog2-server/pull/8245#discussion_r434365566", "createdAt": "2020-06-03T07:33:04Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/main/java/org/graylog2/indexer/messages/Messages.java", "diffHunk": "@@ -218,21 +228,85 @@ public ResultMessage get(String messageId, String index) throws DocumentNotFound\n             if (LOG.isDebugEnabled()) {\n                 String chunkInfo = \"\";\n                 if (chunkSize != messageList.size()) {\n-                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", partitionCount,\n-                            (int) Math.ceil((double)messageList.size() / chunkSize), offset);\n+                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", chunkCount,\n+                            (int) Math.ceil((double) messageList.size() / chunkSize), offset);\n                 }\n                 LOG.debug(\"Index: Bulk indexed {} messages{}, failures: {}\",\n                         result.getItems().size(), chunkInfo, failedItems.size());\n             }\n-            if (!result.getFailedItems().isEmpty()) {\n+            if (!remainingFailures.isEmpty()) {\n                 LOG.error(\"Failed to index [{}] messages. Please check the index error log in your web interface for the reason. Error: {}\",\n-                        result.getFailedItems().size(), result.getErrorMessage());\n+                        remainingFailures.size(), result.getErrorMessage());\n             }\n-            partitionCount++;\n+            chunkCount++;\n         }\n         return failedItems;\n     }\n \n+    private BulkResult bulkIndexChunk(List<Map.Entry<IndexSet, Message>> chunk) {\n+        Bulk.Builder bulk = new Bulk.Builder();\n+\n+        for (Map.Entry<IndexSet, Message> entry : chunk) {\n+            final Message message = entry.getValue();\n+\n+            bulk.addAction(new Index.Builder(message.toElasticSearchObject(invalidTimestampMeter))\n+                    .index(entry.getKey().getWriteIndexAlias())\n+                    .type(IndexMapping.TYPE_MESSAGE)\n+                    .id(message.getId())\n+                    .build());\n+        }\n+\n+        return runBulkRequest(bulk.build(), chunk.size());\n+    }\n+\n+    private Set<BulkResult.BulkResultItem> retryOnlyIndexBlockItemsForever(List<Map.Entry<IndexSet, Message>> chunk, List<BulkResult.BulkResultItem> allFailedItems) {\n+        Set<BulkResult.BulkResultItem> indexBlocks = indexBlocksFrom(allFailedItems);\n+        Set<BulkResult.BulkResultItem> otherFailures = new HashSet<>(Sets.difference(new HashSet<>(allFailedItems), indexBlocks));\n+        List<Map.Entry<IndexSet, Message>> blockedMessages = messagesForResultItems(chunk, indexBlocks);\n+\n+        long attempt = 1;\n+\n+        while (!indexBlocks.isEmpty()) {\n+            blockExecutionForAttempt(attempt++);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7164c35c97bce1a3011e7e61fcdbc7cc63f3c"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MTEzOA==", "bodyText": "\ud83d\udc4d\nwaitBeforeRetrying is a better name indeed.", "url": "https://github.com/Graylog2/graylog2-server/pull/8245#discussion_r434471138", "createdAt": "2020-06-03T10:35:10Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/main/java/org/graylog2/indexer/messages/Messages.java", "diffHunk": "@@ -218,21 +228,85 @@ public ResultMessage get(String messageId, String index) throws DocumentNotFound\n             if (LOG.isDebugEnabled()) {\n                 String chunkInfo = \"\";\n                 if (chunkSize != messageList.size()) {\n-                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", partitionCount,\n-                            (int) Math.ceil((double)messageList.size() / chunkSize), offset);\n+                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", chunkCount,\n+                            (int) Math.ceil((double) messageList.size() / chunkSize), offset);\n                 }\n                 LOG.debug(\"Index: Bulk indexed {} messages{}, failures: {}\",\n                         result.getItems().size(), chunkInfo, failedItems.size());\n             }\n-            if (!result.getFailedItems().isEmpty()) {\n+            if (!remainingFailures.isEmpty()) {\n                 LOG.error(\"Failed to index [{}] messages. Please check the index error log in your web interface for the reason. Error: {}\",\n-                        result.getFailedItems().size(), result.getErrorMessage());\n+                        remainingFailures.size(), result.getErrorMessage());\n             }\n-            partitionCount++;\n+            chunkCount++;\n         }\n         return failedItems;\n     }\n \n+    private BulkResult bulkIndexChunk(List<Map.Entry<IndexSet, Message>> chunk) {\n+        Bulk.Builder bulk = new Bulk.Builder();\n+\n+        for (Map.Entry<IndexSet, Message> entry : chunk) {\n+            final Message message = entry.getValue();\n+\n+            bulk.addAction(new Index.Builder(message.toElasticSearchObject(invalidTimestampMeter))\n+                    .index(entry.getKey().getWriteIndexAlias())\n+                    .type(IndexMapping.TYPE_MESSAGE)\n+                    .id(message.getId())\n+                    .build());\n+        }\n+\n+        return runBulkRequest(bulk.build(), chunk.size());\n+    }\n+\n+    private Set<BulkResult.BulkResultItem> retryOnlyIndexBlockItemsForever(List<Map.Entry<IndexSet, Message>> chunk, List<BulkResult.BulkResultItem> allFailedItems) {\n+        Set<BulkResult.BulkResultItem> indexBlocks = indexBlocksFrom(allFailedItems);\n+        Set<BulkResult.BulkResultItem> otherFailures = new HashSet<>(Sets.difference(new HashSet<>(allFailedItems), indexBlocks));\n+        List<Map.Entry<IndexSet, Message>> blockedMessages = messagesForResultItems(chunk, indexBlocks);\n+\n+        long attempt = 1;\n+\n+        while (!indexBlocks.isEmpty()) {\n+            blockExecutionForAttempt(attempt++);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2NTU2Ng=="}, "originalCommit": {"oid": "f4a7164c35c97bce1a3011e7e61fcdbc7cc63f3c"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTcwNzE1OnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/test/java/org/graylog2/indexer/messages/MockedMessagesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzozNjowN1rOGePquA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDozNTo0MFrOGeWCSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2NzE2MA==", "bodyText": "This should be javax.validation.constraints.NotNull instead.", "url": "https://github.com/Graylog2/graylog2-server/pull/8245#discussion_r434367160", "createdAt": "2020-06-03T07:36:07Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/messages/MockedMessagesTest.java", "diffHunk": "@@ -24,6 +24,7 @@\n import org.graylog2.indexer.IndexSet;\n import org.graylog2.plugin.Message;\n import org.graylog2.system.processing.InMemoryProcessingStatusRecorder;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7164c35c97bce1a3011e7e61fcdbc7cc63f3c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MTQ5OA==", "bodyText": "I removed the annotations completely, because I think we don't use them consistently anyway.", "url": "https://github.com/Graylog2/graylog2-server/pull/8245#discussion_r434471498", "createdAt": "2020-06-03T10:35:40Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/messages/MockedMessagesTest.java", "diffHunk": "@@ -24,6 +24,7 @@\n import org.graylog2.indexer.IndexSet;\n import org.graylog2.plugin.Message;\n import org.graylog2.system.processing.InMemoryProcessingStatusRecorder;\n+import org.jetbrains.annotations.NotNull;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2NzE2MA=="}, "originalCommit": {"oid": "f4a7164c35c97bce1a3011e7e61fcdbc7cc63f3c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTc0MTg4OnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/main/java/org/graylog2/indexer/messages/Messages.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0NjozOFrOGeQAzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDozNjo0M1rOGeWEeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3MjgxMw==", "bodyText": "This should have a better message, something like sleeping for ... ms before retrying bulk indexing (attempt #n).", "url": "https://github.com/Graylog2/graylog2-server/pull/8245#discussion_r434372813", "createdAt": "2020-06-03T07:46:38Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/main/java/org/graylog2/indexer/messages/Messages.java", "diffHunk": "@@ -218,21 +228,85 @@ public ResultMessage get(String messageId, String index) throws DocumentNotFound\n             if (LOG.isDebugEnabled()) {\n                 String chunkInfo = \"\";\n                 if (chunkSize != messageList.size()) {\n-                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", partitionCount,\n-                            (int) Math.ceil((double)messageList.size() / chunkSize), offset);\n+                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", chunkCount,\n+                            (int) Math.ceil((double) messageList.size() / chunkSize), offset);\n                 }\n                 LOG.debug(\"Index: Bulk indexed {} messages{}, failures: {}\",\n                         result.getItems().size(), chunkInfo, failedItems.size());\n             }\n-            if (!result.getFailedItems().isEmpty()) {\n+            if (!remainingFailures.isEmpty()) {\n                 LOG.error(\"Failed to index [{}] messages. Please check the index error log in your web interface for the reason. Error: {}\",\n-                        result.getFailedItems().size(), result.getErrorMessage());\n+                        remainingFailures.size(), result.getErrorMessage());\n             }\n-            partitionCount++;\n+            chunkCount++;\n         }\n         return failedItems;\n     }\n \n+    private BulkResult bulkIndexChunk(List<Map.Entry<IndexSet, Message>> chunk) {\n+        Bulk.Builder bulk = new Bulk.Builder();\n+\n+        for (Map.Entry<IndexSet, Message> entry : chunk) {\n+            final Message message = entry.getValue();\n+\n+            bulk.addAction(new Index.Builder(message.toElasticSearchObject(invalidTimestampMeter))\n+                    .index(entry.getKey().getWriteIndexAlias())\n+                    .type(IndexMapping.TYPE_MESSAGE)\n+                    .id(message.getId())\n+                    .build());\n+        }\n+\n+        return runBulkRequest(bulk.build(), chunk.size());\n+    }\n+\n+    private Set<BulkResult.BulkResultItem> retryOnlyIndexBlockItemsForever(List<Map.Entry<IndexSet, Message>> chunk, List<BulkResult.BulkResultItem> allFailedItems) {\n+        Set<BulkResult.BulkResultItem> indexBlocks = indexBlocksFrom(allFailedItems);\n+        Set<BulkResult.BulkResultItem> otherFailures = new HashSet<>(Sets.difference(new HashSet<>(allFailedItems), indexBlocks));\n+        List<Map.Entry<IndexSet, Message>> blockedMessages = messagesForResultItems(chunk, indexBlocks);\n+\n+        long attempt = 1;\n+\n+        while (!indexBlocks.isEmpty()) {\n+            blockExecutionForAttempt(attempt++);\n+\n+            BulkResult bulkResult = bulkIndexChunk(blockedMessages);\n+\n+            List<BulkResult.BulkResultItem> failedItems = bulkResult.getFailedItems();\n+\n+            indexBlocks = indexBlocksFrom(failedItems);\n+            blockedMessages = messagesForResultItems(blockedMessages, indexBlocks);\n+\n+            Set<BulkResult.BulkResultItem> newOtherFailures = Sets.difference(new HashSet<>(failedItems), indexBlocks);\n+            otherFailures.addAll(newOtherFailures);\n+        }\n+\n+        return otherFailures;\n+    }\n+\n+    private void blockExecutionForAttempt(long attempt) {\n+        try {\n+            long sleepTime = exponentialWaitSeconds.computeSleepTime(new IndexBlockRetryAttempt(attempt));\n+            LOG.info(\"sleeping \" + sleepTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7164c35c97bce1a3011e7e61fcdbc7cc63f3c"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MjA1OA==", "bodyText": "Leaving this in was an oversight. I only meant to log the time for debugging purposes. Removed it.", "url": "https://github.com/Graylog2/graylog2-server/pull/8245#discussion_r434472058", "createdAt": "2020-06-03T10:36:43Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/main/java/org/graylog2/indexer/messages/Messages.java", "diffHunk": "@@ -218,21 +228,85 @@ public ResultMessage get(String messageId, String index) throws DocumentNotFound\n             if (LOG.isDebugEnabled()) {\n                 String chunkInfo = \"\";\n                 if (chunkSize != messageList.size()) {\n-                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", partitionCount,\n-                            (int) Math.ceil((double)messageList.size() / chunkSize), offset);\n+                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", chunkCount,\n+                            (int) Math.ceil((double) messageList.size() / chunkSize), offset);\n                 }\n                 LOG.debug(\"Index: Bulk indexed {} messages{}, failures: {}\",\n                         result.getItems().size(), chunkInfo, failedItems.size());\n             }\n-            if (!result.getFailedItems().isEmpty()) {\n+            if (!remainingFailures.isEmpty()) {\n                 LOG.error(\"Failed to index [{}] messages. Please check the index error log in your web interface for the reason. Error: {}\",\n-                        result.getFailedItems().size(), result.getErrorMessage());\n+                        remainingFailures.size(), result.getErrorMessage());\n             }\n-            partitionCount++;\n+            chunkCount++;\n         }\n         return failedItems;\n     }\n \n+    private BulkResult bulkIndexChunk(List<Map.Entry<IndexSet, Message>> chunk) {\n+        Bulk.Builder bulk = new Bulk.Builder();\n+\n+        for (Map.Entry<IndexSet, Message> entry : chunk) {\n+            final Message message = entry.getValue();\n+\n+            bulk.addAction(new Index.Builder(message.toElasticSearchObject(invalidTimestampMeter))\n+                    .index(entry.getKey().getWriteIndexAlias())\n+                    .type(IndexMapping.TYPE_MESSAGE)\n+                    .id(message.getId())\n+                    .build());\n+        }\n+\n+        return runBulkRequest(bulk.build(), chunk.size());\n+    }\n+\n+    private Set<BulkResult.BulkResultItem> retryOnlyIndexBlockItemsForever(List<Map.Entry<IndexSet, Message>> chunk, List<BulkResult.BulkResultItem> allFailedItems) {\n+        Set<BulkResult.BulkResultItem> indexBlocks = indexBlocksFrom(allFailedItems);\n+        Set<BulkResult.BulkResultItem> otherFailures = new HashSet<>(Sets.difference(new HashSet<>(allFailedItems), indexBlocks));\n+        List<Map.Entry<IndexSet, Message>> blockedMessages = messagesForResultItems(chunk, indexBlocks);\n+\n+        long attempt = 1;\n+\n+        while (!indexBlocks.isEmpty()) {\n+            blockExecutionForAttempt(attempt++);\n+\n+            BulkResult bulkResult = bulkIndexChunk(blockedMessages);\n+\n+            List<BulkResult.BulkResultItem> failedItems = bulkResult.getFailedItems();\n+\n+            indexBlocks = indexBlocksFrom(failedItems);\n+            blockedMessages = messagesForResultItems(blockedMessages, indexBlocks);\n+\n+            Set<BulkResult.BulkResultItem> newOtherFailures = Sets.difference(new HashSet<>(failedItems), indexBlocks);\n+            otherFailures.addAll(newOtherFailures);\n+        }\n+\n+        return otherFailures;\n+    }\n+\n+    private void blockExecutionForAttempt(long attempt) {\n+        try {\n+            long sleepTime = exponentialWaitSeconds.computeSleepTime(new IndexBlockRetryAttempt(attempt));\n+            LOG.info(\"sleeping \" + sleepTime);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3MjgxMw=="}, "originalCommit": {"oid": "f4a7164c35c97bce1a3011e7e61fcdbc7cc63f3c"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTc5NjMzOnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/main/java/org/graylog2/indexer/messages/Messages.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwODowMjoxOVrOGeQjUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDozNzowM1rOGeWFCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MTY1MA==", "bodyText": "It would be good to have some logging here indicating that the index blocks have been resolved.", "url": "https://github.com/Graylog2/graylog2-server/pull/8245#discussion_r434381650", "createdAt": "2020-06-03T08:02:19Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/main/java/org/graylog2/indexer/messages/Messages.java", "diffHunk": "@@ -218,21 +228,85 @@ public ResultMessage get(String messageId, String index) throws DocumentNotFound\n             if (LOG.isDebugEnabled()) {\n                 String chunkInfo = \"\";\n                 if (chunkSize != messageList.size()) {\n-                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", partitionCount,\n-                            (int) Math.ceil((double)messageList.size() / chunkSize), offset);\n+                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", chunkCount,\n+                            (int) Math.ceil((double) messageList.size() / chunkSize), offset);\n                 }\n                 LOG.debug(\"Index: Bulk indexed {} messages{}, failures: {}\",\n                         result.getItems().size(), chunkInfo, failedItems.size());\n             }\n-            if (!result.getFailedItems().isEmpty()) {\n+            if (!remainingFailures.isEmpty()) {\n                 LOG.error(\"Failed to index [{}] messages. Please check the index error log in your web interface for the reason. Error: {}\",\n-                        result.getFailedItems().size(), result.getErrorMessage());\n+                        remainingFailures.size(), result.getErrorMessage());\n             }\n-            partitionCount++;\n+            chunkCount++;\n         }\n         return failedItems;\n     }\n \n+    private BulkResult bulkIndexChunk(List<Map.Entry<IndexSet, Message>> chunk) {\n+        Bulk.Builder bulk = new Bulk.Builder();\n+\n+        for (Map.Entry<IndexSet, Message> entry : chunk) {\n+            final Message message = entry.getValue();\n+\n+            bulk.addAction(new Index.Builder(message.toElasticSearchObject(invalidTimestampMeter))\n+                    .index(entry.getKey().getWriteIndexAlias())\n+                    .type(IndexMapping.TYPE_MESSAGE)\n+                    .id(message.getId())\n+                    .build());\n+        }\n+\n+        return runBulkRequest(bulk.build(), chunk.size());\n+    }\n+\n+    private Set<BulkResult.BulkResultItem> retryOnlyIndexBlockItemsForever(List<Map.Entry<IndexSet, Message>> chunk, List<BulkResult.BulkResultItem> allFailedItems) {\n+        Set<BulkResult.BulkResultItem> indexBlocks = indexBlocksFrom(allFailedItems);\n+        Set<BulkResult.BulkResultItem> otherFailures = new HashSet<>(Sets.difference(new HashSet<>(allFailedItems), indexBlocks));\n+        List<Map.Entry<IndexSet, Message>> blockedMessages = messagesForResultItems(chunk, indexBlocks);\n+\n+        long attempt = 1;\n+\n+        while (!indexBlocks.isEmpty()) {\n+            blockExecutionForAttempt(attempt++);\n+\n+            BulkResult bulkResult = bulkIndexChunk(blockedMessages);\n+\n+            List<BulkResult.BulkResultItem> failedItems = bulkResult.getFailedItems();\n+\n+            indexBlocks = indexBlocksFrom(failedItems);\n+            blockedMessages = messagesForResultItems(blockedMessages, indexBlocks);\n+\n+            Set<BulkResult.BulkResultItem> newOtherFailures = Sets.difference(new HashSet<>(failedItems), indexBlocks);\n+            otherFailures.addAll(newOtherFailures);\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7164c35c97bce1a3011e7e61fcdbc7cc63f3c"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MjIwMQ==", "bodyText": "\ud83d\udc4d Agreed. I added some.", "url": "https://github.com/Graylog2/graylog2-server/pull/8245#discussion_r434472201", "createdAt": "2020-06-03T10:37:03Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/main/java/org/graylog2/indexer/messages/Messages.java", "diffHunk": "@@ -218,21 +228,85 @@ public ResultMessage get(String messageId, String index) throws DocumentNotFound\n             if (LOG.isDebugEnabled()) {\n                 String chunkInfo = \"\";\n                 if (chunkSize != messageList.size()) {\n-                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", partitionCount,\n-                            (int) Math.ceil((double)messageList.size() / chunkSize), offset);\n+                    chunkInfo = String.format(Locale.ROOT, \" (chunk %d/%d offset %d)\", chunkCount,\n+                            (int) Math.ceil((double) messageList.size() / chunkSize), offset);\n                 }\n                 LOG.debug(\"Index: Bulk indexed {} messages{}, failures: {}\",\n                         result.getItems().size(), chunkInfo, failedItems.size());\n             }\n-            if (!result.getFailedItems().isEmpty()) {\n+            if (!remainingFailures.isEmpty()) {\n                 LOG.error(\"Failed to index [{}] messages. Please check the index error log in your web interface for the reason. Error: {}\",\n-                        result.getFailedItems().size(), result.getErrorMessage());\n+                        remainingFailures.size(), result.getErrorMessage());\n             }\n-            partitionCount++;\n+            chunkCount++;\n         }\n         return failedItems;\n     }\n \n+    private BulkResult bulkIndexChunk(List<Map.Entry<IndexSet, Message>> chunk) {\n+        Bulk.Builder bulk = new Bulk.Builder();\n+\n+        for (Map.Entry<IndexSet, Message> entry : chunk) {\n+            final Message message = entry.getValue();\n+\n+            bulk.addAction(new Index.Builder(message.toElasticSearchObject(invalidTimestampMeter))\n+                    .index(entry.getKey().getWriteIndexAlias())\n+                    .type(IndexMapping.TYPE_MESSAGE)\n+                    .id(message.getId())\n+                    .build());\n+        }\n+\n+        return runBulkRequest(bulk.build(), chunk.size());\n+    }\n+\n+    private Set<BulkResult.BulkResultItem> retryOnlyIndexBlockItemsForever(List<Map.Entry<IndexSet, Message>> chunk, List<BulkResult.BulkResultItem> allFailedItems) {\n+        Set<BulkResult.BulkResultItem> indexBlocks = indexBlocksFrom(allFailedItems);\n+        Set<BulkResult.BulkResultItem> otherFailures = new HashSet<>(Sets.difference(new HashSet<>(allFailedItems), indexBlocks));\n+        List<Map.Entry<IndexSet, Message>> blockedMessages = messagesForResultItems(chunk, indexBlocks);\n+\n+        long attempt = 1;\n+\n+        while (!indexBlocks.isEmpty()) {\n+            blockExecutionForAttempt(attempt++);\n+\n+            BulkResult bulkResult = bulkIndexChunk(blockedMessages);\n+\n+            List<BulkResult.BulkResultItem> failedItems = bulkResult.getFailedItems();\n+\n+            indexBlocks = indexBlocksFrom(failedItems);\n+            blockedMessages = messagesForResultItems(blockedMessages, indexBlocks);\n+\n+            Set<BulkResult.BulkResultItem> newOtherFailures = Sets.difference(new HashSet<>(failedItems), indexBlocks);\n+            otherFailures.addAll(newOtherFailures);\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MTY1MA=="}, "originalCommit": {"oid": "f4a7164c35c97bce1a3011e7e61fcdbc7cc63f3c"}, "originalPosition": 214}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4240, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}