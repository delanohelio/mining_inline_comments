{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNjk4MTk5", "number": 8459, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToyNjo1N1rOEM0Mfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNjoyMDowN1rOEM9z6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODczNTM1OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch6/src/main/java/org/graylog/storage/elasticsearch6/ClusterAdapterES6.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOToyNjo1N1rOGvJIow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDozNjoyNFrOGvUFnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NTkyMw==", "bodyText": "I think we can get rid of this method entirely and just call ClusterAdapter#health from Cluster#deflectorHealth", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452085923", "createdAt": "2020-07-09T09:26:57Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch6/src/main/java/org/graylog/storage/elasticsearch6/ClusterAdapterES6.java", "diffHunk": "@@ -74,8 +73,7 @@ private HealthStatus extractHealthStatus(JsonNode node) {\n \n     @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI2NTM3Mg==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452265372", "createdAt": "2020-07-09T14:36:24Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch6/src/main/java/org/graylog/storage/elasticsearch6/ClusterAdapterES6.java", "diffHunk": "@@ -74,8 +73,7 @@ private HealthStatus extractHealthStatus(JsonNode node) {\n \n     @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NTkyMw=="}, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODc1NzQ0OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch6/src/main/java/org/graylog/storage/elasticsearch6/ClusterAdapterES6.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozMjo0OVrOGvJWEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDozNzoyOFrOGvUIfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4OTM2Mw==", "bodyText": "We can reuse HealthStatus#fromString in ClusterAdapterES6#extractHealthStatus.", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452089363", "createdAt": "2020-07-09T09:32:49Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch6/src/main/java/org/graylog/storage/elasticsearch6/ClusterAdapterES6.java", "diffHunk": "@@ -74,8 +73,7 @@ private HealthStatus extractHealthStatus(JsonNode node) {\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI2NjExMQ==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452266111", "createdAt": "2020-07-09T14:37:28Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch6/src/main/java/org/graylog/storage/elasticsearch6/ClusterAdapterES6.java", "diffHunk": "@@ -74,8 +73,7 @@ private HealthStatus extractHealthStatus(JsonNode node) {\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4OTM2Mw=="}, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODgxMDkxOnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/main/java/org/graylog2/system/stats/ClusterStatsService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTo0Njo1MlrOGvJ2cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDo0ODo0MlrOGvUqGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5NzY1MQ==", "bodyText": "Wouldn't it make sense to delegate to Cluster here? We could exchange the two dependencies on ClusterAdapter and IndexSetRegistry with one on Cluster. Cluster also already has a dependency on IndexSetRegistry .", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452097651", "createdAt": "2020-07-09T09:46:52Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/main/java/org/graylog2/system/stats/ClusterStatsService.java", "diffHunk": "@@ -110,7 +113,25 @@ private long countDashboards() {\n \n     public ElasticsearchStats elasticsearchStats() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3NDcxMg==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452274712", "createdAt": "2020-07-09T14:48:42Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/main/java/org/graylog2/system/stats/ClusterStatsService.java", "diffHunk": "@@ -110,7 +113,25 @@ private long countDashboards() {\n \n     public ElasticsearchStats elasticsearchStats() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5NzY1MQ=="}, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODg3NzY3OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch6/src/test/java/org/graylog/storage/elasticsearch6/ClusterES6IT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMDowNTowOVrOGvKfyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDo0NDoxMlrOGvUcGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwODIzNQ==", "bodyText": "I think we can get rid of this comment and rather rename the test to indicate that defaults are expected.", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452108235", "createdAt": "2020-07-09T10:05:09Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch6/src/test/java/org/graylog/storage/elasticsearch6/ClusterES6IT.java", "diffHunk": "@@ -18,6 +21,18 @@\n     @Rule\n     public final ElasticsearchInstance elasticsearch = ElasticsearchInstanceES6.create();\n \n+    @Test\n+    public void getClusterAllocationDiskSettings() {\n+        final ClusterAllocationDiskSettings clusterAllocationDiskSettings = cluster.getClusterAllocationDiskSettings();\n+\n+        //Default Elasticsearch settings in Elasticsearch 5.6", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3MTEyOQ==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452271129", "createdAt": "2020-07-09T14:44:12Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch6/src/test/java/org/graylog/storage/elasticsearch6/ClusterES6IT.java", "diffHunk": "@@ -18,6 +21,18 @@\n     @Rule\n     public final ElasticsearchInstance elasticsearch = ElasticsearchInstanceES6.create();\n \n+    @Test\n+    public void getClusterAllocationDiskSettings() {\n+        final ClusterAllocationDiskSettings clusterAllocationDiskSettings = cluster.getClusterAllocationDiskSettings();\n+\n+        //Default Elasticsearch settings in Elasticsearch 5.6", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwODIzNQ=="}, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODg4NDQ5OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch6/src/test/java/org/graylog/storage/elasticsearch6/ClusterES6IT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMDowNzowNlrOGvKkAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDo0NDoyMlrOGvUcgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwOTMxMg==", "bodyText": "Shouldn't this be 95% for 6.8?", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452109312", "createdAt": "2020-07-09T10:07:06Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch6/src/test/java/org/graylog/storage/elasticsearch6/ClusterES6IT.java", "diffHunk": "@@ -18,6 +21,18 @@\n     @Rule\n     public final ElasticsearchInstance elasticsearch = ElasticsearchInstanceES6.create();\n \n+    @Test\n+    public void getClusterAllocationDiskSettings() {\n+        final ClusterAllocationDiskSettings clusterAllocationDiskSettings = cluster.getClusterAllocationDiskSettings();\n+\n+        //Default Elasticsearch settings in Elasticsearch 5.6\n+        assertThat(clusterAllocationDiskSettings.ThresholdEnabled()).isTrue();\n+        assertThat(clusterAllocationDiskSettings.watermarkSettings().type()).isEqualTo(WatermarkSettings.SettingsType.PERCENTAGE);\n+        assertThat(clusterAllocationDiskSettings.watermarkSettings().low()).isEqualTo(85D);\n+        assertThat(clusterAllocationDiskSettings.watermarkSettings().high()).isEqualTo(90D);\n+        assertThat(clusterAllocationDiskSettings.watermarkSettings().floodStage()).isNull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3MTIzMg==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452271232", "createdAt": "2020-07-09T14:44:22Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch6/src/test/java/org/graylog/storage/elasticsearch6/ClusterES6IT.java", "diffHunk": "@@ -18,6 +21,18 @@\n     @Rule\n     public final ElasticsearchInstance elasticsearch = ElasticsearchInstanceES6.create();\n \n+    @Test\n+    public void getClusterAllocationDiskSettings() {\n+        final ClusterAllocationDiskSettings clusterAllocationDiskSettings = cluster.getClusterAllocationDiskSettings();\n+\n+        //Default Elasticsearch settings in Elasticsearch 5.6\n+        assertThat(clusterAllocationDiskSettings.ThresholdEnabled()).isTrue();\n+        assertThat(clusterAllocationDiskSettings.watermarkSettings().type()).isEqualTo(WatermarkSettings.SettingsType.PERCENTAGE);\n+        assertThat(clusterAllocationDiskSettings.watermarkSettings().low()).isEqualTo(85D);\n+        assertThat(clusterAllocationDiskSettings.watermarkSettings().high()).isEqualTo(90D);\n+        assertThat(clusterAllocationDiskSettings.watermarkSettings().floodStage()).isNull();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwOTMxMg=="}, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODkyMDk0OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/ClusterAdapterES7.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMDoxODoxMFrOGvK6qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDo0NTowMVrOGvUecA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExNTExNQ==", "bodyText": "Should be Collection<String>", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452115115", "createdAt": "2020-07-09T10:18:10Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/ClusterAdapterES7.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.JsonNodeType;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Lists;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.settings.ClusterGetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.settings.ClusterGetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.GetIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.common.unit.TimeValue;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cat.NodeResponse;\n+import org.graylog2.indexer.ElasticsearchException;\n+import org.graylog2.indexer.cluster.ClusterAdapter;\n+import org.graylog2.indexer.cluster.PendingTasksStats;\n+import org.graylog2.indexer.cluster.health.ClusterAllocationDiskSettings;\n+import org.graylog2.indexer.cluster.health.ClusterAllocationDiskSettingsFactory;\n+import org.graylog2.indexer.cluster.health.NodeDiskUsageStats;\n+import org.graylog2.indexer.cluster.health.NodeFileDescriptorStats;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.rest.models.system.indexer.responses.ClusterHealth;\n+import org.graylog2.system.stats.elasticsearch.ClusterStats;\n+import org.graylog2.system.stats.elasticsearch.IndicesStats;\n+import org.graylog2.system.stats.elasticsearch.NodesStats;\n+import org.graylog2.system.stats.elasticsearch.ShardStats;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class ClusterAdapterES7 implements ClusterAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(ClusterAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final Duration requestTimeout;\n+    private final CatApi catApi;\n+    private final PlainJsonApi jsonApi;\n+\n+    @Inject\n+    public ClusterAdapterES7(ElasticsearchClient client,\n+                             @Named(\"elasticsearch_socket_timeout\") Duration requestTimeout,\n+                             CatApi catApi,\n+                             PlainJsonApi jsonApi) {\n+        this.client = client;\n+        this.requestTimeout = requestTimeout;\n+        this.catApi = catApi;\n+        this.jsonApi = jsonApi;\n+    }\n+\n+    @Override\n+    public Optional<HealthStatus> health(Collection<String> indices) {\n+        return clusterHealth(indices).map(response -> healthStatusFrom(response.getStatus()));\n+    }\n+\n+    private HealthStatus healthStatusFrom(ClusterHealthStatus status) {\n+        switch (status) {\n+            case RED:\n+                return HealthStatus.Red;\n+            case YELLOW:\n+                return HealthStatus.Yellow;\n+            case GREEN:\n+                return HealthStatus.Green;\n+        }\n+\n+        throw new IllegalStateException(\"Invalid health status received: \" + status);\n+    }\n+\n+    @Override\n+    public Optional<HealthStatus> deflectorHealth(Collection<String> indices) {\n+        return health(indices);\n+    }\n+\n+    @Override\n+    public Set<NodeFileDescriptorStats> fileDescriptorStats() {\n+        final List<NodeResponse> result = nodes();\n+        return result.stream()\n+                .map(node -> NodeFileDescriptorStats.create(node.name(), node.ip(), node.host(), node.fileDescriptorMax()))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private List<NodeResponse> nodes() {\n+        return client.execute(catApi::nodes);\n+    }\n+\n+    @Override\n+    public Set<NodeDiskUsageStats> diskUsageStats() {\n+        final List<NodeResponse> result = nodes();\n+        return result.stream()\n+                .map(node -> NodeDiskUsageStats.create(node.name(), node.ip(), node.host(), node.diskUsed(), node.diskTotal(), node.diskUsedPercent()))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public ClusterAllocationDiskSettings clusterAllocationDiskSettings() {\n+        final ClusterGetSettingsRequest request = new ClusterGetSettingsRequest();\n+        request.includeDefaults(true);\n+\n+        final ClusterGetSettingsResponse response = client.execute((c, requestOptions) -> c.cluster().getSettings(request, requestOptions));\n+        return ClusterAllocationDiskSettingsFactory.create(\n+                Boolean.parseBoolean(response.getSetting(\"cluster.routing.allocation.disk.threshold_enabled\")),\n+                response.getSetting(\"cluster.routing.allocation.disk.watermark.low\"),\n+                response.getSetting(\"cluster.routing.allocation.disk.watermark.high\"),\n+                response.getSetting(\"cluster.routing.allocation.disk.watermark.flood_stage\")\n+        );\n+    }\n+\n+    @Override\n+    public Optional<String> nodeIdToName(String nodeId) {\n+        return nodeById(nodeId)\n+                .map(jsonNode -> jsonNode.get(\"name\").asText());\n+    }\n+\n+    @Override\n+    public Optional<String> nodeIdToHostName(String nodeId) {\n+        return nodeById(nodeId)\n+                .map(jsonNode -> jsonNode.get(\"host\").asText());\n+    }\n+\n+    private Optional<JsonNode> nodeById(String nodeId) {\n+        if (Strings.isNullOrEmpty(nodeId)) {\n+            return Optional.empty();\n+        }\n+        final Request request = new Request(\"GET\", \"/_nodes/\" + nodeId);\n+        return Optional.of(client.execute((c, requestOptions) -> jsonApi.perform(c, request, requestOptions)))\n+                .map(jsonNode -> jsonNode.path(\"nodes\").path(nodeId))\n+                .filter(node -> !node.isMissingNode());\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        final ClusterHealthRequest request = new ClusterHealthRequest()\n+                .timeout(new TimeValue(requestTimeout.getQuantity(), requestTimeout.getUnit()))\n+                .local(true);\n+        try {\n+            final ClusterHealthResponse result = client.execute((c, requestOptions) -> c.cluster().health(request, requestOptions));\n+            return result.getNumberOfDataNodes() > 0;\n+        } catch (ElasticsearchException e) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.error(e.getMessage(), e);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public Optional<String> clusterName(Collection<String> indices) {\n+        return clusterHealth(indices).map(ClusterHealthResponse::getClusterName);\n+    }\n+\n+    @Override\n+    public Optional<ClusterHealth> clusterHealthStats(Collection<String> indices) {\n+        return clusterHealth(indices)\n+                .map(this::clusterHealthFrom);\n+    }\n+\n+    private ClusterHealth clusterHealthFrom(ClusterHealthResponse response) {\n+        return ClusterHealth.create(response.getStatus().toString(),\n+                ClusterHealth.ShardStatus.create(\n+                        response.getActiveShards(),\n+                        response.getInitializingShards(),\n+                        response.getRelocatingShards(),\n+                        response.getUnassignedShards()\n+                )\n+        );\n+    }\n+\n+    @Override\n+    public PendingTasksStats pendingTasks() {\n+        final Request request = new Request(\"GET\", \"/_cluster/pending_tasks\");\n+\n+        final JsonNode response = client.execute((c, requestOptions) -> jsonApi.perform(c, request, requestOptions),\n+                \"Couldn't read Elasticsearch pending cluster tasks\");\n+\n+        final JsonNode pendingClusterTasks = response.path(\"tasks\");\n+        final int pendingTasksSize = pendingClusterTasks.size();\n+        final List<Long> pendingTasksTimeInQueue = Lists.newArrayListWithCapacity(pendingTasksSize);\n+        for (JsonNode jsonElement : pendingClusterTasks) {\n+            if (jsonElement.has(\"time_in_queue_millis\")) {\n+                pendingTasksTimeInQueue.add(jsonElement.get(\"time_in_queue_millis\").asLong());\n+            }\n+        }\n+\n+        return PendingTasksStats.create(pendingTasksSize, pendingTasksTimeInQueue);\n+    }\n+\n+    @Override\n+    public ClusterStats clusterStats() {\n+        final Request request = new Request(\"GET\", \"/_cluster/stats/nodes\");\n+\n+        final JsonNode clusterStatsResponseJson = client.execute((c, requestOptions) -> jsonApi.perform(c, request, requestOptions),\n+        \"Couldn't read Elasticsearch cluster stats\");\n+        final String clusterName = clusterStatsResponseJson.path(\"cluster_name\").asText();\n+\n+        String clusterVersion = null;\n+        if (clusterStatsResponseJson.path(\"nodes\").path(\"versions\").isArray()) {\n+            final ArrayNode versions = (ArrayNode) clusterStatsResponseJson.path(\"nodes\").path(\"versions\");\n+            // We just use the first version in the \"versions\" array. This is not correct if there are different\n+            // versions running in the cluster, but that is not recommended anyway.\n+            final JsonNode versionNode = versions.path(0);\n+            if (versionNode.getNodeType() != JsonNodeType.MISSING) {\n+                clusterVersion = versionNode.asText();\n+            }\n+        }\n+\n+        final JsonNode countStats = clusterStatsResponseJson.path(\"nodes\").path(\"count\");\n+\n+        final NodesStats nodesStats = NodesStats.create(\n+                countStats.path(\"total\").asInt(-1),\n+                countStats.path(\"master_only\").asInt(-1),\n+                countStats.path(\"data_only\").asInt(-1),\n+                countStats.path(\"master_data\").asInt(-1),\n+                countStats.path(\"client\").asInt(-1)\n+        );\n+\n+        final JsonNode clusterIndicesStats = clusterStatsResponseJson.path(\"indices\");\n+        final IndicesStats indicesStats = IndicesStats.create(\n+                clusterIndicesStats.path(\"count\").asInt(-1),\n+                clusterIndicesStats.path(\"store\").path(\"size_in_bytes\").asLong(-1L),\n+                clusterIndicesStats.path(\"fielddata\").path(\"memory_size_in_bytes\").asLong(-1L)\n+        );\n+\n+        return ClusterStats.create(clusterName, clusterVersion, nodesStats, indicesStats);\n+    }\n+\n+    @Override\n+    public ShardStats shardStats(Collection<String> indices) {\n+        return clusterHealth(indices)\n+                .map(response -> ShardStats.create(\n+                        response.getNumberOfNodes(),\n+                        response.getNumberOfDataNodes(),\n+                        response.getActiveShards(),\n+                        response.getRelocatingShards(),\n+                        response.getActivePrimaryShards(),\n+                        response.getInitializingShards(),\n+                        response.getUnassignedShards(),\n+                        response.isTimedOut()\n+                ))\n+                .orElseThrow(() -> new ElasticsearchException(\"Unable to retrieve shard stats.\"));\n+    }\n+\n+    private Optional<ClusterHealthResponse> clusterHealth(Collection<? extends String> indices) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3MTcyOA==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452271728", "createdAt": "2020-07-09T14:45:01Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/ClusterAdapterES7.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.JsonNodeType;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Lists;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.settings.ClusterGetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.settings.ClusterGetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.GetIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.common.unit.TimeValue;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cat.NodeResponse;\n+import org.graylog2.indexer.ElasticsearchException;\n+import org.graylog2.indexer.cluster.ClusterAdapter;\n+import org.graylog2.indexer.cluster.PendingTasksStats;\n+import org.graylog2.indexer.cluster.health.ClusterAllocationDiskSettings;\n+import org.graylog2.indexer.cluster.health.ClusterAllocationDiskSettingsFactory;\n+import org.graylog2.indexer.cluster.health.NodeDiskUsageStats;\n+import org.graylog2.indexer.cluster.health.NodeFileDescriptorStats;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.rest.models.system.indexer.responses.ClusterHealth;\n+import org.graylog2.system.stats.elasticsearch.ClusterStats;\n+import org.graylog2.system.stats.elasticsearch.IndicesStats;\n+import org.graylog2.system.stats.elasticsearch.NodesStats;\n+import org.graylog2.system.stats.elasticsearch.ShardStats;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class ClusterAdapterES7 implements ClusterAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(ClusterAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final Duration requestTimeout;\n+    private final CatApi catApi;\n+    private final PlainJsonApi jsonApi;\n+\n+    @Inject\n+    public ClusterAdapterES7(ElasticsearchClient client,\n+                             @Named(\"elasticsearch_socket_timeout\") Duration requestTimeout,\n+                             CatApi catApi,\n+                             PlainJsonApi jsonApi) {\n+        this.client = client;\n+        this.requestTimeout = requestTimeout;\n+        this.catApi = catApi;\n+        this.jsonApi = jsonApi;\n+    }\n+\n+    @Override\n+    public Optional<HealthStatus> health(Collection<String> indices) {\n+        return clusterHealth(indices).map(response -> healthStatusFrom(response.getStatus()));\n+    }\n+\n+    private HealthStatus healthStatusFrom(ClusterHealthStatus status) {\n+        switch (status) {\n+            case RED:\n+                return HealthStatus.Red;\n+            case YELLOW:\n+                return HealthStatus.Yellow;\n+            case GREEN:\n+                return HealthStatus.Green;\n+        }\n+\n+        throw new IllegalStateException(\"Invalid health status received: \" + status);\n+    }\n+\n+    @Override\n+    public Optional<HealthStatus> deflectorHealth(Collection<String> indices) {\n+        return health(indices);\n+    }\n+\n+    @Override\n+    public Set<NodeFileDescriptorStats> fileDescriptorStats() {\n+        final List<NodeResponse> result = nodes();\n+        return result.stream()\n+                .map(node -> NodeFileDescriptorStats.create(node.name(), node.ip(), node.host(), node.fileDescriptorMax()))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private List<NodeResponse> nodes() {\n+        return client.execute(catApi::nodes);\n+    }\n+\n+    @Override\n+    public Set<NodeDiskUsageStats> diskUsageStats() {\n+        final List<NodeResponse> result = nodes();\n+        return result.stream()\n+                .map(node -> NodeDiskUsageStats.create(node.name(), node.ip(), node.host(), node.diskUsed(), node.diskTotal(), node.diskUsedPercent()))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public ClusterAllocationDiskSettings clusterAllocationDiskSettings() {\n+        final ClusterGetSettingsRequest request = new ClusterGetSettingsRequest();\n+        request.includeDefaults(true);\n+\n+        final ClusterGetSettingsResponse response = client.execute((c, requestOptions) -> c.cluster().getSettings(request, requestOptions));\n+        return ClusterAllocationDiskSettingsFactory.create(\n+                Boolean.parseBoolean(response.getSetting(\"cluster.routing.allocation.disk.threshold_enabled\")),\n+                response.getSetting(\"cluster.routing.allocation.disk.watermark.low\"),\n+                response.getSetting(\"cluster.routing.allocation.disk.watermark.high\"),\n+                response.getSetting(\"cluster.routing.allocation.disk.watermark.flood_stage\")\n+        );\n+    }\n+\n+    @Override\n+    public Optional<String> nodeIdToName(String nodeId) {\n+        return nodeById(nodeId)\n+                .map(jsonNode -> jsonNode.get(\"name\").asText());\n+    }\n+\n+    @Override\n+    public Optional<String> nodeIdToHostName(String nodeId) {\n+        return nodeById(nodeId)\n+                .map(jsonNode -> jsonNode.get(\"host\").asText());\n+    }\n+\n+    private Optional<JsonNode> nodeById(String nodeId) {\n+        if (Strings.isNullOrEmpty(nodeId)) {\n+            return Optional.empty();\n+        }\n+        final Request request = new Request(\"GET\", \"/_nodes/\" + nodeId);\n+        return Optional.of(client.execute((c, requestOptions) -> jsonApi.perform(c, request, requestOptions)))\n+                .map(jsonNode -> jsonNode.path(\"nodes\").path(nodeId))\n+                .filter(node -> !node.isMissingNode());\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        final ClusterHealthRequest request = new ClusterHealthRequest()\n+                .timeout(new TimeValue(requestTimeout.getQuantity(), requestTimeout.getUnit()))\n+                .local(true);\n+        try {\n+            final ClusterHealthResponse result = client.execute((c, requestOptions) -> c.cluster().health(request, requestOptions));\n+            return result.getNumberOfDataNodes() > 0;\n+        } catch (ElasticsearchException e) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.error(e.getMessage(), e);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public Optional<String> clusterName(Collection<String> indices) {\n+        return clusterHealth(indices).map(ClusterHealthResponse::getClusterName);\n+    }\n+\n+    @Override\n+    public Optional<ClusterHealth> clusterHealthStats(Collection<String> indices) {\n+        return clusterHealth(indices)\n+                .map(this::clusterHealthFrom);\n+    }\n+\n+    private ClusterHealth clusterHealthFrom(ClusterHealthResponse response) {\n+        return ClusterHealth.create(response.getStatus().toString(),\n+                ClusterHealth.ShardStatus.create(\n+                        response.getActiveShards(),\n+                        response.getInitializingShards(),\n+                        response.getRelocatingShards(),\n+                        response.getUnassignedShards()\n+                )\n+        );\n+    }\n+\n+    @Override\n+    public PendingTasksStats pendingTasks() {\n+        final Request request = new Request(\"GET\", \"/_cluster/pending_tasks\");\n+\n+        final JsonNode response = client.execute((c, requestOptions) -> jsonApi.perform(c, request, requestOptions),\n+                \"Couldn't read Elasticsearch pending cluster tasks\");\n+\n+        final JsonNode pendingClusterTasks = response.path(\"tasks\");\n+        final int pendingTasksSize = pendingClusterTasks.size();\n+        final List<Long> pendingTasksTimeInQueue = Lists.newArrayListWithCapacity(pendingTasksSize);\n+        for (JsonNode jsonElement : pendingClusterTasks) {\n+            if (jsonElement.has(\"time_in_queue_millis\")) {\n+                pendingTasksTimeInQueue.add(jsonElement.get(\"time_in_queue_millis\").asLong());\n+            }\n+        }\n+\n+        return PendingTasksStats.create(pendingTasksSize, pendingTasksTimeInQueue);\n+    }\n+\n+    @Override\n+    public ClusterStats clusterStats() {\n+        final Request request = new Request(\"GET\", \"/_cluster/stats/nodes\");\n+\n+        final JsonNode clusterStatsResponseJson = client.execute((c, requestOptions) -> jsonApi.perform(c, request, requestOptions),\n+        \"Couldn't read Elasticsearch cluster stats\");\n+        final String clusterName = clusterStatsResponseJson.path(\"cluster_name\").asText();\n+\n+        String clusterVersion = null;\n+        if (clusterStatsResponseJson.path(\"nodes\").path(\"versions\").isArray()) {\n+            final ArrayNode versions = (ArrayNode) clusterStatsResponseJson.path(\"nodes\").path(\"versions\");\n+            // We just use the first version in the \"versions\" array. This is not correct if there are different\n+            // versions running in the cluster, but that is not recommended anyway.\n+            final JsonNode versionNode = versions.path(0);\n+            if (versionNode.getNodeType() != JsonNodeType.MISSING) {\n+                clusterVersion = versionNode.asText();\n+            }\n+        }\n+\n+        final JsonNode countStats = clusterStatsResponseJson.path(\"nodes\").path(\"count\");\n+\n+        final NodesStats nodesStats = NodesStats.create(\n+                countStats.path(\"total\").asInt(-1),\n+                countStats.path(\"master_only\").asInt(-1),\n+                countStats.path(\"data_only\").asInt(-1),\n+                countStats.path(\"master_data\").asInt(-1),\n+                countStats.path(\"client\").asInt(-1)\n+        );\n+\n+        final JsonNode clusterIndicesStats = clusterStatsResponseJson.path(\"indices\");\n+        final IndicesStats indicesStats = IndicesStats.create(\n+                clusterIndicesStats.path(\"count\").asInt(-1),\n+                clusterIndicesStats.path(\"store\").path(\"size_in_bytes\").asLong(-1L),\n+                clusterIndicesStats.path(\"fielddata\").path(\"memory_size_in_bytes\").asLong(-1L)\n+        );\n+\n+        return ClusterStats.create(clusterName, clusterVersion, nodesStats, indicesStats);\n+    }\n+\n+    @Override\n+    public ShardStats shardStats(Collection<String> indices) {\n+        return clusterHealth(indices)\n+                .map(response -> ShardStats.create(\n+                        response.getNumberOfNodes(),\n+                        response.getNumberOfDataNodes(),\n+                        response.getActiveShards(),\n+                        response.getRelocatingShards(),\n+                        response.getActivePrimaryShards(),\n+                        response.getInitializingShards(),\n+                        response.getUnassignedShards(),\n+                        response.isTimedOut()\n+                ))\n+                .orElseThrow(() -> new ElasticsearchException(\"Unable to retrieve shard stats.\"));\n+    }\n+\n+    private Optional<ClusterHealthResponse> clusterHealth(Collection<? extends String> indices) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExNTExNQ=="}, "originalCommit": {"oid": "8a92f4ed3fe33c8ea2b8d5ee626be449697c75cd"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxOTI0MTI0OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/test/java/org/graylog/storage/elasticsearch7/ClusterES7IT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjowMToxNlrOGvN_0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjowMToxNlrOGvN_0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2NTU4Ng==", "bodyText": "cough", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452165586", "createdAt": "2020-07-09T12:01:16Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/test/java/org/graylog/storage/elasticsearch7/ClusterES7IT.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.github.joschi.jadconfig.util.Duration;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.core.MainResponse;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cat.NodeResponse;\n+import org.graylog.storage.elasticsearch7.testing.ElasticsearchInstanceES7;\n+import org.graylog.testing.elasticsearch.ElasticsearchInstance;\n+import org.graylog2.indexer.cluster.ClusterAdapter;\n+import org.graylog2.indexer.cluster.ClusterIT;\n+import org.graylog2.indexer.cluster.health.ClusterAllocationDiskSettings;\n+import org.graylog2.indexer.cluster.health.WatermarkSettings;\n+import org.graylog2.shared.bindings.providers.ObjectMapperProvider;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ClusterES7IT extends ClusterIT {\n+    @Rule\n+    public final ElasticsearchInstanceES7 elasticsearch = ElasticsearchInstanceES7.create();\n+\n+    @Test\n+    public void getClusterAllocationDiskSettings() {\n+        final ClusterAllocationDiskSettings clusterAllocationDiskSettings = cluster.getClusterAllocationDiskSettings();\n+\n+        //Default Elasticsearch settings in Elasticsearch 5.6", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc4b9fd082d9f197e80880d2f6bf3d7b46d4bb4d"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDMxMDgwOnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/main/java/org/graylog2/system/stats/ClusterStatsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNjoyMDowN1rOGvYeiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzoyMTo1OFrOGwoRIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMzNzI4OQ==", "bodyText": "After extracting elasticsearchStats to Cluster we can now get rid of IndexSetRegistry here.", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r452337289", "createdAt": "2020-07-09T16:20:07Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/main/java/org/graylog2/system/stats/ClusterStatsService.java", "diffHunk": "@@ -53,8 +51,8 @@\n     private final AlertService alertService;\n     private final AlarmCallbackConfigurationService alarmCallbackConfigurationService;\n     private final DashboardService dashboardService;\n+    private final Cluster cluster;\n     private final IndexSetRegistry indexSetRegistry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e09875337f18e8ef3313d7653d42ed42e4e716ea"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY0NDU3Nw==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8459#discussion_r453644577", "createdAt": "2020-07-13T13:21:58Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/main/java/org/graylog2/system/stats/ClusterStatsService.java", "diffHunk": "@@ -53,8 +51,8 @@\n     private final AlertService alertService;\n     private final AlarmCallbackConfigurationService alarmCallbackConfigurationService;\n     private final DashboardService dashboardService;\n+    private final Cluster cluster;\n     private final IndexSetRegistry indexSetRegistry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMzNzI4OQ=="}, "originalCommit": {"oid": "e09875337f18e8ef3313d7653d42ed42e4e716ea"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4222, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}