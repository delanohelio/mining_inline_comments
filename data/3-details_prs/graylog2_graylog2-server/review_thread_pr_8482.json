{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MDY3NTI4", "number": 8482, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjoxOToyMlrOENyt1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzoyNjozNVrOEOQeUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODk3ODc2OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cat/CatApi.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjoxOToyMlrOGwmDlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDoxOToxMlrOGxNd5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwODM0Mw==", "bodyText": "This can be extracted to a private method and reused in indexState.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r453608343", "createdAt": "2020-07-13T12:19:22Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cat/CatApi.java", "diffHunk": "@@ -28,6 +35,40 @@ public CatApi(ObjectMapper objectMapper,\n         return perform(request, new TypeReference<List<NodeResponse>>() {}, \"Unable to retrieve nodes list\");\n     }\n \n+    public Set<String> indices(String index, Collection<String> status, String errorMessage) {\n+        return indices(Collections.singleton(index), status, errorMessage);\n+    }\n+\n+    public Set<String> indices(Collection<String> indices, Collection<String> status, String errorMessage) {\n+        final String joinedIndices = String.join(\",\", indices);\n+        final Request request = request(\"GET\", \"indices/\" + joinedIndices);\n+        request.addParameter(\"h\", \"index,status\");\n+        request.addParameter(\"expand_wildcards\", \"all\");\n+        request.addParameter(\"s\", \"index,status\");\n+\n+        final JsonNode jsonResponse = perform(request, new TypeReference<JsonNode>() {}, errorMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1NDA1NA==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454254054", "createdAt": "2020-07-14T10:19:12Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cat/CatApi.java", "diffHunk": "@@ -28,6 +35,40 @@ public CatApi(ObjectMapper objectMapper,\n         return perform(request, new TypeReference<List<NodeResponse>>() {}, \"Unable to retrieve nodes list\");\n     }\n \n+    public Set<String> indices(String index, Collection<String> status, String errorMessage) {\n+        return indices(Collections.singleton(index), status, errorMessage);\n+    }\n+\n+    public Set<String> indices(Collection<String> indices, Collection<String> status, String errorMessage) {\n+        final String joinedIndices = String.join(\",\", indices);\n+        final Request request = request(\"GET\", \"indices/\" + joinedIndices);\n+        request.addParameter(\"h\", \"index,status\");\n+        request.addParameter(\"expand_wildcards\", \"all\");\n+        request.addParameter(\"s\", \"index,status\");\n+\n+        final JsonNode jsonResponse = perform(request, new TypeReference<JsonNode>() {}, errorMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwODM0Mw=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTY1NDQ5OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDo1Nzo1N1rOGwsZnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDoxOTo0OVrOGxNfGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMjI4Nw==", "bodyText": "The throws declaration is redundant for these two methods.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r453712287", "createdAt": "2020-07-13T14:57:57Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.flush.FlushRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.open.OpenIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.template.delete.DeleteIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchType;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.GetAliasesResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CloseIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CreateIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.DeleteAliasRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.PutIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.query.QueryBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.BulkByScrollResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.ReindexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.Filter;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Max;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Min;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cluster.ClusterStateApi;\n+import org.graylog.storage.elasticsearch7.stats.StatsApi;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class IndicesAdapterES7 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final StatsApi statsApi;\n+    private final CatApi catApi;\n+    private final ClusterStateApi clusterStateApi;\n+\n+    @Inject\n+    public IndicesAdapterES7(ElasticsearchClient client,\n+                             StatsApi statsApi,\n+                             CatApi catApi,\n+                             ClusterStateApi clusterStateApi) {\n+        this.client = client;\n+        this.statsApi = statsApi;\n+        this.catApi = catApi;\n+        this.clusterStateApi = clusterStateApi;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        final ReindexRequest request = new ReindexRequest();\n+        request.setSourceIndices(source);\n+        request.setDestIndex(target);\n+\n+        final BulkByScrollResponse result = client.execute((c, requestOptions) -> c.reindex(request, requestOptions));\n+\n+        final IndexMoveResult indexMoveResult = IndexMoveResult.create(\n+                Math.toIntExact(result.getTotal()),\n+                result.getTook().millis(),\n+                !result.getBulkFailures().isEmpty()\n+        );\n+        resultCallback.accept(indexMoveResult);\n+    }\n+\n+    @Override\n+    public void delete(String index) {\n+        final DeleteIndexRequest request = new DeleteIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().delete(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .aliases(alias);\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions));\n+\n+        return result.getAliases().keySet();\n+    }\n+\n+    @Override\n+    public void create(String index, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndexRequest request = new CreateIndexRequest(index)\n+                .settings(settings);\n+\n+        client.execute((c, requestOptions) -> c.indices().create(request, requestOptions),\n+                \"Unable to create index \" + index);\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName)\n+                .source(template);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().putTemplate(request, requestOptions),\n+                \"Unable to create index template \" + templateName);\n+\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettingsRequest request = new GetSettingsRequest()\n+                .indices(index)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, false));\n+\n+        final GetSettingsResponse result = client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Couldn't read settings of index \" + index);\n+\n+        final Optional<String> creationDate = Optional.ofNullable(result.getIndexToSettings().get(index))\n+                .map(indexSettings -> indexSettings.get(\"index.creation_date\"));\n+\n+        return creationDate\n+                .map(Long::valueOf)\n+                .map(DateTime::new);\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        final OpenIndexRequest request = new OpenIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().open(request, requestOptions),\n+                \"Unable to open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/7.8/indices-update-settings.html\n+        final Map<String, Object> settings = ImmutableMap.of(\n+                \"index\", ImmutableMap.of(\"blocks\",\n+                        ImmutableMap.of(\n+                                \"write\", true, // Block writing.\n+                                \"read\", false, // Allow reading.\n+                                \"metadata\", false) // Allow getting metadata.\n+                )\n+        );\n+\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(index)\n+                .settings(settings);\n+        client.execute((c, requestOptions) -> c.indices().putSettings(request, requestOptions),\n+                \"Couldn't set index \" + index + \" to read-only\");\n+    }\n+\n+    @Override\n+    public void flush(String index) {\n+        final FlushRequest request = new FlushRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().flush(request, requestOptions),\n+                \"Unable to flush index \" + index);\n+    }\n+\n+    @Override\n+    public String markIndexReopened(String index) {\n+        final String aliasName = index + Indices.REOPENED_ALIAS_SUFFIX;\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(index)\n+                .alias(aliasName);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't create reopened alias for index \" + index);\n+\n+        return aliasName;\n+    }\n+\n+    @Override\n+    public void removeAlias(String index, String alias) {\n+        final DeleteAliasRequest request = new DeleteAliasRequest(index, alias);\n+\n+        client.execute((c, requestOptions) -> c.indices().deleteAlias(request, requestOptions),\n+                \"Unable to remove alias \" + alias + \", pointing to \" + index);\n+    }\n+\n+    @Override\n+    public void close(String index) {\n+        final CloseIndexRequest request = new CloseIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().close(request, requestOptions),\n+                \"Unable to close index \" + index);\n+    }\n+\n+    @Override\n+    public long numberOfMessages(String index) {\n+        final JsonNode result = client.execute((c, requestOptions) -> statsApi.indexStats(c, index),\n+                \"Unable to retrieve index stats for \" + index);\n+        return result.path(\"primaries\").path(\"docs\").path(\"count\").asLong();\n+    }\n+\n+    private GetSettingsResponse settingsFor(String indexOrAlias) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexOrAlias)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, true));\n+        return client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Unable to retrieve settings for index/alias \" + indexOrAlias);\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> aliases(String indexPattern) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .indices(indexPattern)\n+                .indicesOptions(IndicesOptions.fromOptions(false, false, true, false));\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions),\n+                \"Couldn't collect aliases for index pattern \" + indexPattern);\n+        return result.getAliases()\n+                .entrySet()\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        Map.Entry::getKey,\n+                        entry -> entry.getValue().stream().map(AliasMetaData::alias).collect(Collectors.toSet())\n+                ));\n+    }\n+\n+    @Override\n+    public boolean deleteIndexTemplate(String templateName) {\n+        final DeleteIndexTemplateRequest request = new DeleteIndexTemplateRequest(templateName);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().deleteTemplate(request, requestOptions),\n+                \"Unable to delete index template \" + templateName);\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> fieldsInIndices(String[] writeIndexWildcards) {\n+        final List<String> indexWildCards = Arrays.asList(writeIndexWildcards);\n+        return client.execute((c, requestOptions) -> clusterStateApi.fields(c, requestOptions, indexWildCards),\n+                \"Unable to retrieve fields from indices: \" + indexWildCards);\n+    }\n+\n+    @Override\n+    public Set<String> closedIndices(Collection<String> indices) {\n+        return catApi.indices(indices, Collections.singleton(\"close\"),\n+                \"Unable to retrieve list of closed indices for \" + indices);\n+    }\n+\n+    @Override\n+    public Set<IndexStatistics> indicesStats(Collection<String> indices) {\n+        final ImmutableSet.Builder<IndexStatistics> result = ImmutableSet.builder();\n+\n+        final JsonNode allWithShardLevel = client.execute((c, requestOptions) -> statsApi.indexStatsWithShardLevel(c, indices),\n+                \"Unable to retrieve index stats for \" + indices);\n+        final Iterator<Map.Entry<String, JsonNode>> fields = allWithShardLevel.fields();\n+        while (fields.hasNext()) {\n+            final Map.Entry<String, JsonNode> entry = fields.next();\n+            final String index = entry.getKey();\n+            final JsonNode indexStats = entry.getValue();\n+            if (indexStats.isObject()) {\n+                result.add(IndexStatistics.create(index, indexStats));\n+            }\n+        }\n+\n+        return result.build();\n+    }\n+\n+    @Override\n+    public Optional<IndexStatistics> getIndexStats(String index) {\n+        final JsonNode indexStats = client.execute((c, requestOptions) -> statsApi.indexStatsWithShardLevel(c, index),\n+                \"Unable to retrieve index stats for \" + index);\n+        return indexStats.isMissingNode()\n+                ? Optional.empty()\n+                : Optional.of(IndexStatistics.create(index, indexStats));\n+    }\n+\n+    @Override\n+    public JsonNode getIndexStats(Collection<String> indices) {\n+        final JsonNode result = client.execute((c, requestOptions) -> statsApi.indexStatsWithDocsAndStore(c, indices),\n+                \"Couldn't check stats of indices \" + indices);\n+\n+        return result.path(\"indices\");\n+    }\n+\n+    @Override\n+    public boolean exists(String index) throws IOException {\n+        final GetSettingsResponse result = settingsFor(index);\n+        return result.getIndexToSettings().size() == 1 && result.getIndexToSettings().containsKey(index);\n+    }\n+\n+    @Override\n+    public boolean aliasExists(String alias) throws IOException {\n+        final GetAliasesRequest request = new GetAliasesRequest(alias);\n+        return client.execute((c, requestOptions) -> c.indices().existsAlias(request, requestOptions));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1NDM2MA==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454254360", "createdAt": "2020-07-14T10:19:49Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.flush.FlushRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.open.OpenIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.template.delete.DeleteIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchType;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.GetAliasesResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CloseIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CreateIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.DeleteAliasRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.PutIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.query.QueryBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.BulkByScrollResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.ReindexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.Filter;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Max;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Min;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cluster.ClusterStateApi;\n+import org.graylog.storage.elasticsearch7.stats.StatsApi;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class IndicesAdapterES7 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final StatsApi statsApi;\n+    private final CatApi catApi;\n+    private final ClusterStateApi clusterStateApi;\n+\n+    @Inject\n+    public IndicesAdapterES7(ElasticsearchClient client,\n+                             StatsApi statsApi,\n+                             CatApi catApi,\n+                             ClusterStateApi clusterStateApi) {\n+        this.client = client;\n+        this.statsApi = statsApi;\n+        this.catApi = catApi;\n+        this.clusterStateApi = clusterStateApi;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        final ReindexRequest request = new ReindexRequest();\n+        request.setSourceIndices(source);\n+        request.setDestIndex(target);\n+\n+        final BulkByScrollResponse result = client.execute((c, requestOptions) -> c.reindex(request, requestOptions));\n+\n+        final IndexMoveResult indexMoveResult = IndexMoveResult.create(\n+                Math.toIntExact(result.getTotal()),\n+                result.getTook().millis(),\n+                !result.getBulkFailures().isEmpty()\n+        );\n+        resultCallback.accept(indexMoveResult);\n+    }\n+\n+    @Override\n+    public void delete(String index) {\n+        final DeleteIndexRequest request = new DeleteIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().delete(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .aliases(alias);\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions));\n+\n+        return result.getAliases().keySet();\n+    }\n+\n+    @Override\n+    public void create(String index, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndexRequest request = new CreateIndexRequest(index)\n+                .settings(settings);\n+\n+        client.execute((c, requestOptions) -> c.indices().create(request, requestOptions),\n+                \"Unable to create index \" + index);\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName)\n+                .source(template);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().putTemplate(request, requestOptions),\n+                \"Unable to create index template \" + templateName);\n+\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettingsRequest request = new GetSettingsRequest()\n+                .indices(index)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, false));\n+\n+        final GetSettingsResponse result = client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Couldn't read settings of index \" + index);\n+\n+        final Optional<String> creationDate = Optional.ofNullable(result.getIndexToSettings().get(index))\n+                .map(indexSettings -> indexSettings.get(\"index.creation_date\"));\n+\n+        return creationDate\n+                .map(Long::valueOf)\n+                .map(DateTime::new);\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        final OpenIndexRequest request = new OpenIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().open(request, requestOptions),\n+                \"Unable to open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/7.8/indices-update-settings.html\n+        final Map<String, Object> settings = ImmutableMap.of(\n+                \"index\", ImmutableMap.of(\"blocks\",\n+                        ImmutableMap.of(\n+                                \"write\", true, // Block writing.\n+                                \"read\", false, // Allow reading.\n+                                \"metadata\", false) // Allow getting metadata.\n+                )\n+        );\n+\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(index)\n+                .settings(settings);\n+        client.execute((c, requestOptions) -> c.indices().putSettings(request, requestOptions),\n+                \"Couldn't set index \" + index + \" to read-only\");\n+    }\n+\n+    @Override\n+    public void flush(String index) {\n+        final FlushRequest request = new FlushRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().flush(request, requestOptions),\n+                \"Unable to flush index \" + index);\n+    }\n+\n+    @Override\n+    public String markIndexReopened(String index) {\n+        final String aliasName = index + Indices.REOPENED_ALIAS_SUFFIX;\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(index)\n+                .alias(aliasName);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't create reopened alias for index \" + index);\n+\n+        return aliasName;\n+    }\n+\n+    @Override\n+    public void removeAlias(String index, String alias) {\n+        final DeleteAliasRequest request = new DeleteAliasRequest(index, alias);\n+\n+        client.execute((c, requestOptions) -> c.indices().deleteAlias(request, requestOptions),\n+                \"Unable to remove alias \" + alias + \", pointing to \" + index);\n+    }\n+\n+    @Override\n+    public void close(String index) {\n+        final CloseIndexRequest request = new CloseIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().close(request, requestOptions),\n+                \"Unable to close index \" + index);\n+    }\n+\n+    @Override\n+    public long numberOfMessages(String index) {\n+        final JsonNode result = client.execute((c, requestOptions) -> statsApi.indexStats(c, index),\n+                \"Unable to retrieve index stats for \" + index);\n+        return result.path(\"primaries\").path(\"docs\").path(\"count\").asLong();\n+    }\n+\n+    private GetSettingsResponse settingsFor(String indexOrAlias) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexOrAlias)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, true));\n+        return client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Unable to retrieve settings for index/alias \" + indexOrAlias);\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> aliases(String indexPattern) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .indices(indexPattern)\n+                .indicesOptions(IndicesOptions.fromOptions(false, false, true, false));\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions),\n+                \"Couldn't collect aliases for index pattern \" + indexPattern);\n+        return result.getAliases()\n+                .entrySet()\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        Map.Entry::getKey,\n+                        entry -> entry.getValue().stream().map(AliasMetaData::alias).collect(Collectors.toSet())\n+                ));\n+    }\n+\n+    @Override\n+    public boolean deleteIndexTemplate(String templateName) {\n+        final DeleteIndexTemplateRequest request = new DeleteIndexTemplateRequest(templateName);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().deleteTemplate(request, requestOptions),\n+                \"Unable to delete index template \" + templateName);\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> fieldsInIndices(String[] writeIndexWildcards) {\n+        final List<String> indexWildCards = Arrays.asList(writeIndexWildcards);\n+        return client.execute((c, requestOptions) -> clusterStateApi.fields(c, requestOptions, indexWildCards),\n+                \"Unable to retrieve fields from indices: \" + indexWildCards);\n+    }\n+\n+    @Override\n+    public Set<String> closedIndices(Collection<String> indices) {\n+        return catApi.indices(indices, Collections.singleton(\"close\"),\n+                \"Unable to retrieve list of closed indices for \" + indices);\n+    }\n+\n+    @Override\n+    public Set<IndexStatistics> indicesStats(Collection<String> indices) {\n+        final ImmutableSet.Builder<IndexStatistics> result = ImmutableSet.builder();\n+\n+        final JsonNode allWithShardLevel = client.execute((c, requestOptions) -> statsApi.indexStatsWithShardLevel(c, indices),\n+                \"Unable to retrieve index stats for \" + indices);\n+        final Iterator<Map.Entry<String, JsonNode>> fields = allWithShardLevel.fields();\n+        while (fields.hasNext()) {\n+            final Map.Entry<String, JsonNode> entry = fields.next();\n+            final String index = entry.getKey();\n+            final JsonNode indexStats = entry.getValue();\n+            if (indexStats.isObject()) {\n+                result.add(IndexStatistics.create(index, indexStats));\n+            }\n+        }\n+\n+        return result.build();\n+    }\n+\n+    @Override\n+    public Optional<IndexStatistics> getIndexStats(String index) {\n+        final JsonNode indexStats = client.execute((c, requestOptions) -> statsApi.indexStatsWithShardLevel(c, index),\n+                \"Unable to retrieve index stats for \" + index);\n+        return indexStats.isMissingNode()\n+                ? Optional.empty()\n+                : Optional.of(IndexStatistics.create(index, indexStats));\n+    }\n+\n+    @Override\n+    public JsonNode getIndexStats(Collection<String> indices) {\n+        final JsonNode result = client.execute((c, requestOptions) -> statsApi.indexStatsWithDocsAndStore(c, indices),\n+                \"Couldn't check stats of indices \" + indices);\n+\n+        return result.path(\"indices\");\n+    }\n+\n+    @Override\n+    public boolean exists(String index) throws IOException {\n+        final GetSettingsResponse result = settingsFor(index);\n+        return result.getIndexToSettings().size() == 1 && result.getIndexToSettings().containsKey(index);\n+    }\n+\n+    @Override\n+    public boolean aliasExists(String alias) throws IOException {\n+        final GetAliasesRequest request = new GetAliasesRequest(alias);\n+        return client.execute((c, requestOptions) -> c.indices().existsAlias(request, requestOptions));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMjI4Nw=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 329}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTcwMDUwOnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowODowOVrOGws2fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo1MjozN1rOGxOgaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxOTY3Ng==", "bodyText": "The return value of Indices#markIndexReopened is actually never used. This (and the corresponding declarations in the interface and IndicesAdapterES6) could become void methods.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r453719676", "createdAt": "2020-07-13T15:08:09Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.flush.FlushRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.open.OpenIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.template.delete.DeleteIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchType;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.GetAliasesResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CloseIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CreateIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.DeleteAliasRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.PutIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.query.QueryBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.BulkByScrollResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.ReindexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.Filter;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Max;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Min;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cluster.ClusterStateApi;\n+import org.graylog.storage.elasticsearch7.stats.StatsApi;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class IndicesAdapterES7 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final StatsApi statsApi;\n+    private final CatApi catApi;\n+    private final ClusterStateApi clusterStateApi;\n+\n+    @Inject\n+    public IndicesAdapterES7(ElasticsearchClient client,\n+                             StatsApi statsApi,\n+                             CatApi catApi,\n+                             ClusterStateApi clusterStateApi) {\n+        this.client = client;\n+        this.statsApi = statsApi;\n+        this.catApi = catApi;\n+        this.clusterStateApi = clusterStateApi;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        final ReindexRequest request = new ReindexRequest();\n+        request.setSourceIndices(source);\n+        request.setDestIndex(target);\n+\n+        final BulkByScrollResponse result = client.execute((c, requestOptions) -> c.reindex(request, requestOptions));\n+\n+        final IndexMoveResult indexMoveResult = IndexMoveResult.create(\n+                Math.toIntExact(result.getTotal()),\n+                result.getTook().millis(),\n+                !result.getBulkFailures().isEmpty()\n+        );\n+        resultCallback.accept(indexMoveResult);\n+    }\n+\n+    @Override\n+    public void delete(String index) {\n+        final DeleteIndexRequest request = new DeleteIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().delete(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .aliases(alias);\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions));\n+\n+        return result.getAliases().keySet();\n+    }\n+\n+    @Override\n+    public void create(String index, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndexRequest request = new CreateIndexRequest(index)\n+                .settings(settings);\n+\n+        client.execute((c, requestOptions) -> c.indices().create(request, requestOptions),\n+                \"Unable to create index \" + index);\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName)\n+                .source(template);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().putTemplate(request, requestOptions),\n+                \"Unable to create index template \" + templateName);\n+\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettingsRequest request = new GetSettingsRequest()\n+                .indices(index)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, false));\n+\n+        final GetSettingsResponse result = client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Couldn't read settings of index \" + index);\n+\n+        final Optional<String> creationDate = Optional.ofNullable(result.getIndexToSettings().get(index))\n+                .map(indexSettings -> indexSettings.get(\"index.creation_date\"));\n+\n+        return creationDate\n+                .map(Long::valueOf)\n+                .map(DateTime::new);\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        final OpenIndexRequest request = new OpenIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().open(request, requestOptions),\n+                \"Unable to open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/7.8/indices-update-settings.html\n+        final Map<String, Object> settings = ImmutableMap.of(\n+                \"index\", ImmutableMap.of(\"blocks\",\n+                        ImmutableMap.of(\n+                                \"write\", true, // Block writing.\n+                                \"read\", false, // Allow reading.\n+                                \"metadata\", false) // Allow getting metadata.\n+                )\n+        );\n+\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(index)\n+                .settings(settings);\n+        client.execute((c, requestOptions) -> c.indices().putSettings(request, requestOptions),\n+                \"Couldn't set index \" + index + \" to read-only\");\n+    }\n+\n+    @Override\n+    public void flush(String index) {\n+        final FlushRequest request = new FlushRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().flush(request, requestOptions),\n+                \"Unable to flush index \" + index);\n+    }\n+\n+    @Override\n+    public String markIndexReopened(String index) {\n+        final String aliasName = index + Indices.REOPENED_ALIAS_SUFFIX;\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(index)\n+                .alias(aliasName);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't create reopened alias for index \" + index);\n+\n+        return aliasName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI3MTA4Mw==", "bodyText": "Makes sense, I would like to do that later though, as it requires a corresponding change in the enterprise plugin.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454271083", "createdAt": "2020-07-14T10:52:37Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.flush.FlushRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.open.OpenIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.template.delete.DeleteIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchType;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.GetAliasesResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CloseIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CreateIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.DeleteAliasRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.PutIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.query.QueryBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.BulkByScrollResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.ReindexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.Filter;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Max;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Min;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cluster.ClusterStateApi;\n+import org.graylog.storage.elasticsearch7.stats.StatsApi;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class IndicesAdapterES7 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final StatsApi statsApi;\n+    private final CatApi catApi;\n+    private final ClusterStateApi clusterStateApi;\n+\n+    @Inject\n+    public IndicesAdapterES7(ElasticsearchClient client,\n+                             StatsApi statsApi,\n+                             CatApi catApi,\n+                             ClusterStateApi clusterStateApi) {\n+        this.client = client;\n+        this.statsApi = statsApi;\n+        this.catApi = catApi;\n+        this.clusterStateApi = clusterStateApi;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        final ReindexRequest request = new ReindexRequest();\n+        request.setSourceIndices(source);\n+        request.setDestIndex(target);\n+\n+        final BulkByScrollResponse result = client.execute((c, requestOptions) -> c.reindex(request, requestOptions));\n+\n+        final IndexMoveResult indexMoveResult = IndexMoveResult.create(\n+                Math.toIntExact(result.getTotal()),\n+                result.getTook().millis(),\n+                !result.getBulkFailures().isEmpty()\n+        );\n+        resultCallback.accept(indexMoveResult);\n+    }\n+\n+    @Override\n+    public void delete(String index) {\n+        final DeleteIndexRequest request = new DeleteIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().delete(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .aliases(alias);\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions));\n+\n+        return result.getAliases().keySet();\n+    }\n+\n+    @Override\n+    public void create(String index, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndexRequest request = new CreateIndexRequest(index)\n+                .settings(settings);\n+\n+        client.execute((c, requestOptions) -> c.indices().create(request, requestOptions),\n+                \"Unable to create index \" + index);\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName)\n+                .source(template);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().putTemplate(request, requestOptions),\n+                \"Unable to create index template \" + templateName);\n+\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettingsRequest request = new GetSettingsRequest()\n+                .indices(index)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, false));\n+\n+        final GetSettingsResponse result = client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Couldn't read settings of index \" + index);\n+\n+        final Optional<String> creationDate = Optional.ofNullable(result.getIndexToSettings().get(index))\n+                .map(indexSettings -> indexSettings.get(\"index.creation_date\"));\n+\n+        return creationDate\n+                .map(Long::valueOf)\n+                .map(DateTime::new);\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        final OpenIndexRequest request = new OpenIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().open(request, requestOptions),\n+                \"Unable to open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/7.8/indices-update-settings.html\n+        final Map<String, Object> settings = ImmutableMap.of(\n+                \"index\", ImmutableMap.of(\"blocks\",\n+                        ImmutableMap.of(\n+                                \"write\", true, // Block writing.\n+                                \"read\", false, // Allow reading.\n+                                \"metadata\", false) // Allow getting metadata.\n+                )\n+        );\n+\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(index)\n+                .settings(settings);\n+        client.execute((c, requestOptions) -> c.indices().putSettings(request, requestOptions),\n+                \"Couldn't set index \" + index + \" to read-only\");\n+    }\n+\n+    @Override\n+    public void flush(String index) {\n+        final FlushRequest request = new FlushRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().flush(request, requestOptions),\n+                \"Unable to flush index \" + index);\n+    }\n+\n+    @Override\n+    public String markIndexReopened(String index) {\n+        final String aliasName = index + Indices.REOPENED_ALIAS_SUFFIX;\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(index)\n+                .alias(aliasName);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't create reopened alias for index \" + index);\n+\n+        return aliasName;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxOTY3Ng=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTczNjg0OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cat/CatApi.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNToxNjoxMlrOGwtNIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDoyMToxNFrOGxNiAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNTQ3Mg==", "bodyText": "Needs a //noinspection UnstableApiUsage comment", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r453725472", "createdAt": "2020-07-13T15:16:12Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cat/CatApi.java", "diffHunk": "@@ -28,6 +35,40 @@ public CatApi(ObjectMapper objectMapper,\n         return perform(request, new TypeReference<List<NodeResponse>>() {}, \"Unable to retrieve nodes list\");\n     }\n \n+    public Set<String> indices(String index, Collection<String> status, String errorMessage) {\n+        return indices(Collections.singleton(index), status, errorMessage);\n+    }\n+\n+    public Set<String> indices(Collection<String> indices, Collection<String> status, String errorMessage) {\n+        final String joinedIndices = String.join(\",\", indices);\n+        final Request request = request(\"GET\", \"indices/\" + joinedIndices);\n+        request.addParameter(\"h\", \"index,status\");\n+        request.addParameter(\"expand_wildcards\", \"all\");\n+        request.addParameter(\"s\", \"index,status\");\n+\n+        final JsonNode jsonResponse = perform(request, new TypeReference<JsonNode>() {}, errorMessage);\n+\n+        //noinspection UnstableApiUsage\n+        return Streams.stream(jsonResponse.elements())\n+                .filter(index -> status.isEmpty() || status.contains(index.path(\"status\").asText()))\n+                .map(index -> index.path(\"index\").asText())\n+                .collect(Collectors.toSet());\n+    }\n+\n+    public Optional<String> indexState(String indexName, String errorMessage) {\n+        final Request request = request(\"GET\", \"indices/\" + indexName);\n+        request.addParameter(\"h\", \"index,status\");\n+        request.addParameter(\"expand_wildcards\", \"all\");\n+        request.addParameter(\"s\", \"index,status\");\n+\n+        final JsonNode jsonResponse = perform(request, new TypeReference<JsonNode>() {}, errorMessage);\n+\n+        return Streams.stream(jsonResponse.elements())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1NTEwNw==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454255107", "createdAt": "2020-07-14T10:21:14Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cat/CatApi.java", "diffHunk": "@@ -28,6 +35,40 @@ public CatApi(ObjectMapper objectMapper,\n         return perform(request, new TypeReference<List<NodeResponse>>() {}, \"Unable to retrieve nodes list\");\n     }\n \n+    public Set<String> indices(String index, Collection<String> status, String errorMessage) {\n+        return indices(Collections.singleton(index), status, errorMessage);\n+    }\n+\n+    public Set<String> indices(Collection<String> indices, Collection<String> status, String errorMessage) {\n+        final String joinedIndices = String.join(\",\", indices);\n+        final Request request = request(\"GET\", \"indices/\" + joinedIndices);\n+        request.addParameter(\"h\", \"index,status\");\n+        request.addParameter(\"expand_wildcards\", \"all\");\n+        request.addParameter(\"s\", \"index,status\");\n+\n+        final JsonNode jsonResponse = perform(request, new TypeReference<JsonNode>() {}, errorMessage);\n+\n+        //noinspection UnstableApiUsage\n+        return Streams.stream(jsonResponse.elements())\n+                .filter(index -> status.isEmpty() || status.contains(index.path(\"status\").asText()))\n+                .map(index -> index.path(\"index\").asText())\n+                .collect(Collectors.toSet());\n+    }\n+\n+    public Optional<String> indexState(String indexName, String errorMessage) {\n+        final Request request = request(\"GET\", \"indices/\" + indexName);\n+        request.addParameter(\"h\", \"index,status\");\n+        request.addParameter(\"expand_wildcards\", \"all\");\n+        request.addParameter(\"s\", \"index,status\");\n+\n+        final JsonNode jsonResponse = perform(request, new TypeReference<JsonNode>() {}, errorMessage);\n+\n+        return Streams.stream(jsonResponse.elements())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNTQ3Mg=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTc1Mzk3OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cluster/ClusterStateApi.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNToxOTo0MFrOGwtXXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDoyODoyM1rOGxNw-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyODA5NA==", "bodyText": "RestHighLevelClient should become a constructor parameter to be consistent with the changes we made to CatApi and PlainJsonApi.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r453728094", "createdAt": "2020-07-13T15:19:40Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cluster/ClusterStateApi.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.graylog.storage.elasticsearch7.cluster;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.Streams;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RequestOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+\n+public class ClusterStateApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public ClusterStateApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public Map<String, Set<String>> fields(RestHighLevelClient client, RequestOptions requestOptions, Collection<String> indices) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1ODkzOQ==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454258939", "createdAt": "2020-07-14T10:28:23Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cluster/ClusterStateApi.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.graylog.storage.elasticsearch7.cluster;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.Streams;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RequestOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+\n+public class ClusterStateApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public ClusterStateApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public Map<String, Set<String>> fields(RestHighLevelClient client, RequestOptions requestOptions, Collection<String> indices) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyODA5NA=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTc3MDAzOnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cluster/ClusterStateApi.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNToyMzowOVrOGwthbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDoyODozN1rOGxNxhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMDY3MA==", "bodyText": "requestOptions is unused and can be removed.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r453730670", "createdAt": "2020-07-13T15:23:09Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cluster/ClusterStateApi.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.graylog.storage.elasticsearch7.cluster;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.Streams;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RequestOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+\n+public class ClusterStateApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public ClusterStateApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public Map<String, Set<String>> fields(RestHighLevelClient client, RequestOptions requestOptions, Collection<String> indices) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1OTA3Ng==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454259076", "createdAt": "2020-07-14T10:28:37Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cluster/ClusterStateApi.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.graylog.storage.elasticsearch7.cluster;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.Streams;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RequestOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+\n+public class ClusterStateApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public ClusterStateApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public Map<String, Set<String>> fields(RestHighLevelClient client, RequestOptions requestOptions, Collection<String> indices) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMDY3MA=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTgxMzI0OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cluster/ClusterStateApi.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTozMjo1N1rOGwt7-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo1Nzo1MVrOGxOrBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNzQ2NA==", "bodyText": "Unless we already have a known use case for other metrics than metadata, I'd just hard code it here and get rid of the parameter.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r453737464", "createdAt": "2020-07-13T15:32:57Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cluster/ClusterStateApi.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.graylog.storage.elasticsearch7.cluster;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.Streams;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RequestOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+\n+public class ClusterStateApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public ClusterStateApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public Map<String, Set<String>> fields(RestHighLevelClient client, RequestOptions requestOptions, Collection<String> indices) throws IOException {\n+        final Request request = request(Collections.singleton(\"metadata\"), indices);\n+\n+        final Response response = client.getLowLevelClient().performRequest(request);\n+\n+        final JsonNode jsonResponse = objectMapper.readTree(response.getEntity().getContent());\n+\n+        return Streams.stream(jsonResponse.path(\"metadata\").path(\"indices\").fields())\n+                .flatMap(index -> allFieldsFromIndex(index.getKey(), index.getValue()))\n+                .collect(groupingBy(Map.Entry::getKey, mapping(Map.Entry::getValue, Collectors.toSet())));\n+    }\n+\n+    private Stream<Map.Entry<String, String>> allFieldsFromIndex(String indexName, JsonNode indexMapping) {\n+        return Streams.stream(indexMapping.path(\"mappings\").fields())\n+                .flatMap(documentType -> allFieldsFromDocumentType(indexName, documentType.getValue()));\n+    }\n+\n+    private Stream<? extends Map.Entry<String, String>> allFieldsFromDocumentType(String indexName, JsonNode documentType) {\n+        return Streams.stream(documentType.path(\"properties\").fields())\n+                .map(field -> new AbstractMap.SimpleEntry<>(indexName, field.getKey()));\n+    }\n+\n+    private Request request(Collection<String> metrics, Collection<String> indices) {\n+        checkArgument(!metrics.isEmpty(), \"At least one metric must be provided.\");\n+        final String joinedMetrics = String.join(\",\", metrics);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI3Mzc5Ng==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454273796", "createdAt": "2020-07-14T10:57:51Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/cluster/ClusterStateApi.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.graylog.storage.elasticsearch7.cluster;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.Streams;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RequestOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+\n+public class ClusterStateApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public ClusterStateApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public Map<String, Set<String>> fields(RestHighLevelClient client, RequestOptions requestOptions, Collection<String> indices) throws IOException {\n+        final Request request = request(Collections.singleton(\"metadata\"), indices);\n+\n+        final Response response = client.getLowLevelClient().performRequest(request);\n+\n+        final JsonNode jsonResponse = objectMapper.readTree(response.getEntity().getContent());\n+\n+        return Streams.stream(jsonResponse.path(\"metadata\").path(\"indices\").fields())\n+                .flatMap(index -> allFieldsFromIndex(index.getKey(), index.getValue()))\n+                .collect(groupingBy(Map.Entry::getKey, mapping(Map.Entry::getValue, Collectors.toSet())));\n+    }\n+\n+    private Stream<Map.Entry<String, String>> allFieldsFromIndex(String indexName, JsonNode indexMapping) {\n+        return Streams.stream(indexMapping.path(\"mappings\").fields())\n+                .flatMap(documentType -> allFieldsFromDocumentType(indexName, documentType.getValue()));\n+    }\n+\n+    private Stream<? extends Map.Entry<String, String>> allFieldsFromDocumentType(String indexName, JsonNode documentType) {\n+        return Streams.stream(documentType.path(\"properties\").fields())\n+                .map(field -> new AbstractMap.SimpleEntry<>(indexName, field.getKey()));\n+    }\n+\n+    private Request request(Collection<String> metrics, Collection<String> indices) {\n+        checkArgument(!metrics.isEmpty(), \"At least one metric must be provided.\");\n+        final String joinedMetrics = String.join(\",\", metrics);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNzQ2NA=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjc3MjM3OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/stats/StatsApi.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODoxNzo1OVrOGxJQ-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDozNzowMFrOGxOB7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE4NTIxMA==", "bodyText": "RestHighLevelClient should become a constructor parameter to be consistent with the changes we made to CatApi and PlainJsonApi.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454185210", "createdAt": "2020-07-14T08:17:59Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/stats/StatsApi.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package org.graylog.storage.elasticsearch7.stats;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class StatsApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public StatsApi(ObjectMapper objectMapper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2MzI3Nw==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454263277", "createdAt": "2020-07-14T10:37:00Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/stats/StatsApi.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package org.graylog.storage.elasticsearch7.stats;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class StatsApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public StatsApi(ObjectMapper objectMapper) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE4NTIxMA=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjc3OTU3OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/stats/StatsApi.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODoyMDowNFrOGxJVkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDozNzowOVrOGxOCKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE4NjM4NA==", "bodyText": "Misaligned curly brace.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454186384", "createdAt": "2020-07-14T08:20:04Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/stats/StatsApi.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package org.graylog.storage.elasticsearch7.stats;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class StatsApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public StatsApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public JsonNode indexStats(RestHighLevelClient client, String index) throws IOException {\n+        return stats(client, index);\n+    }\n+\n+    public JsonNode indexStatsWithShardLevel(RestHighLevelClient client, String index) throws IOException {\n+        return indexStatsWithShardLevel(client, Collections.singleton(index)).path(index);\n+    }\n+\n+    public JsonNode indexStatsWithShardLevel(RestHighLevelClient client, Collection<String> indices) throws IOException {\n+        final JsonNode stats = stats(client, indices, request -> {\n+            request.addParameter(\"level\", \"shards\");\n+            request.addParameter(\"ignore_unavailable\", \"true\");\n+        });\n+\n+        return stats.path(\"indices\");\n+    }\n+\n+    public JsonNode indexStatsWithDocsAndStore(RestHighLevelClient client, Collection<String> indices) throws IOException {\n+        final JsonNode stats = stats(client, indices, ImmutableSet.of(\"store\", \"docs\"));\n+\n+        return stats.path(\"indices\");\n+    }\n+\n+    public Optional<Long> storeSizes(RestHighLevelClient client, String index) throws IOException {\n+        final JsonNode stats = stats(client, Collections.singleton(index), Collections.singleton(\"store\"));\n+        final JsonNode sizeInBytes = stats.path(\"indices\")\n+                .path(index)\n+                .path(\"primaries\")\n+                .path(\"store\")\n+                .path(\"size_in_bytes\");\n+        return Optional.of(sizeInBytes).filter(JsonNode::isNumber).map(JsonNode::asLong);\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client, String index) throws IOException {\n+        return stats(client, Collections.singleton(index), Collections.emptySet(), (request) -> {});\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Collection<String> metrics) throws IOException {\n+        return stats(client, indices, metrics, (request) -> {});\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Consumer<Request> fn) throws IOException {\n+        return stats(client, indices, Collections.emptySet(), fn);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2MzMzNg==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454263336", "createdAt": "2020-07-14T10:37:09Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/stats/StatsApi.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package org.graylog.storage.elasticsearch7.stats;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class StatsApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public StatsApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public JsonNode indexStats(RestHighLevelClient client, String index) throws IOException {\n+        return stats(client, index);\n+    }\n+\n+    public JsonNode indexStatsWithShardLevel(RestHighLevelClient client, String index) throws IOException {\n+        return indexStatsWithShardLevel(client, Collections.singleton(index)).path(index);\n+    }\n+\n+    public JsonNode indexStatsWithShardLevel(RestHighLevelClient client, Collection<String> indices) throws IOException {\n+        final JsonNode stats = stats(client, indices, request -> {\n+            request.addParameter(\"level\", \"shards\");\n+            request.addParameter(\"ignore_unavailable\", \"true\");\n+        });\n+\n+        return stats.path(\"indices\");\n+    }\n+\n+    public JsonNode indexStatsWithDocsAndStore(RestHighLevelClient client, Collection<String> indices) throws IOException {\n+        final JsonNode stats = stats(client, indices, ImmutableSet.of(\"store\", \"docs\"));\n+\n+        return stats.path(\"indices\");\n+    }\n+\n+    public Optional<Long> storeSizes(RestHighLevelClient client, String index) throws IOException {\n+        final JsonNode stats = stats(client, Collections.singleton(index), Collections.singleton(\"store\"));\n+        final JsonNode sizeInBytes = stats.path(\"indices\")\n+                .path(index)\n+                .path(\"primaries\")\n+                .path(\"store\")\n+                .path(\"size_in_bytes\");\n+        return Optional.of(sizeInBytes).filter(JsonNode::isNumber).map(JsonNode::asLong);\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client, String index) throws IOException {\n+        return stats(client, Collections.singleton(index), Collections.emptySet(), (request) -> {});\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Collection<String> metrics) throws IOException {\n+        return stats(client, indices, metrics, (request) -> {});\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Consumer<Request> fn) throws IOException {\n+        return stats(client, indices, Collections.emptySet(), fn);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE4NjM4NA=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjc5ODY1OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODoyNToyMFrOGxJhaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo1MTo0MlrOGxOedA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE4OTQxOQ==", "bodyText": "You mean because it's using the cluster API? Since this is specifically checking the status of an index I think it's fine in here.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454189419", "createdAt": "2020-07-14T08:25:20Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.flush.FlushRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.open.OpenIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.template.delete.DeleteIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchType;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.GetAliasesResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CloseIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CreateIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.DeleteAliasRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.PutIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.query.QueryBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.BulkByScrollResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.ReindexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.Filter;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Max;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Min;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cluster.ClusterStateApi;\n+import org.graylog.storage.elasticsearch7.stats.StatsApi;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class IndicesAdapterES7 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final StatsApi statsApi;\n+    private final CatApi catApi;\n+    private final ClusterStateApi clusterStateApi;\n+\n+    @Inject\n+    public IndicesAdapterES7(ElasticsearchClient client,\n+                             StatsApi statsApi,\n+                             CatApi catApi,\n+                             ClusterStateApi clusterStateApi) {\n+        this.client = client;\n+        this.statsApi = statsApi;\n+        this.catApi = catApi;\n+        this.clusterStateApi = clusterStateApi;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        final ReindexRequest request = new ReindexRequest();\n+        request.setSourceIndices(source);\n+        request.setDestIndex(target);\n+\n+        final BulkByScrollResponse result = client.execute((c, requestOptions) -> c.reindex(request, requestOptions));\n+\n+        final IndexMoveResult indexMoveResult = IndexMoveResult.create(\n+                Math.toIntExact(result.getTotal()),\n+                result.getTook().millis(),\n+                !result.getBulkFailures().isEmpty()\n+        );\n+        resultCallback.accept(indexMoveResult);\n+    }\n+\n+    @Override\n+    public void delete(String index) {\n+        final DeleteIndexRequest request = new DeleteIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().delete(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .aliases(alias);\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions));\n+\n+        return result.getAliases().keySet();\n+    }\n+\n+    @Override\n+    public void create(String index, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndexRequest request = new CreateIndexRequest(index)\n+                .settings(settings);\n+\n+        client.execute((c, requestOptions) -> c.indices().create(request, requestOptions),\n+                \"Unable to create index \" + index);\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName)\n+                .source(template);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().putTemplate(request, requestOptions),\n+                \"Unable to create index template \" + templateName);\n+\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettingsRequest request = new GetSettingsRequest()\n+                .indices(index)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, false));\n+\n+        final GetSettingsResponse result = client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Couldn't read settings of index \" + index);\n+\n+        final Optional<String> creationDate = Optional.ofNullable(result.getIndexToSettings().get(index))\n+                .map(indexSettings -> indexSettings.get(\"index.creation_date\"));\n+\n+        return creationDate\n+                .map(Long::valueOf)\n+                .map(DateTime::new);\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        final OpenIndexRequest request = new OpenIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().open(request, requestOptions),\n+                \"Unable to open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/7.8/indices-update-settings.html\n+        final Map<String, Object> settings = ImmutableMap.of(\n+                \"index\", ImmutableMap.of(\"blocks\",\n+                        ImmutableMap.of(\n+                                \"write\", true, // Block writing.\n+                                \"read\", false, // Allow reading.\n+                                \"metadata\", false) // Allow getting metadata.\n+                )\n+        );\n+\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(index)\n+                .settings(settings);\n+        client.execute((c, requestOptions) -> c.indices().putSettings(request, requestOptions),\n+                \"Couldn't set index \" + index + \" to read-only\");\n+    }\n+\n+    @Override\n+    public void flush(String index) {\n+        final FlushRequest request = new FlushRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().flush(request, requestOptions),\n+                \"Unable to flush index \" + index);\n+    }\n+\n+    @Override\n+    public String markIndexReopened(String index) {\n+        final String aliasName = index + Indices.REOPENED_ALIAS_SUFFIX;\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(index)\n+                .alias(aliasName);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't create reopened alias for index \" + index);\n+\n+        return aliasName;\n+    }\n+\n+    @Override\n+    public void removeAlias(String index, String alias) {\n+        final DeleteAliasRequest request = new DeleteAliasRequest(index, alias);\n+\n+        client.execute((c, requestOptions) -> c.indices().deleteAlias(request, requestOptions),\n+                \"Unable to remove alias \" + alias + \", pointing to \" + index);\n+    }\n+\n+    @Override\n+    public void close(String index) {\n+        final CloseIndexRequest request = new CloseIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().close(request, requestOptions),\n+                \"Unable to close index \" + index);\n+    }\n+\n+    @Override\n+    public long numberOfMessages(String index) {\n+        final JsonNode result = client.execute((c, requestOptions) -> statsApi.indexStats(c, index),\n+                \"Unable to retrieve index stats for \" + index);\n+        return result.path(\"primaries\").path(\"docs\").path(\"count\").asLong();\n+    }\n+\n+    private GetSettingsResponse settingsFor(String indexOrAlias) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexOrAlias)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, true));\n+        return client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Unable to retrieve settings for index/alias \" + indexOrAlias);\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> aliases(String indexPattern) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .indices(indexPattern)\n+                .indicesOptions(IndicesOptions.fromOptions(false, false, true, false));\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions),\n+                \"Couldn't collect aliases for index pattern \" + indexPattern);\n+        return result.getAliases()\n+                .entrySet()\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        Map.Entry::getKey,\n+                        entry -> entry.getValue().stream().map(AliasMetaData::alias).collect(Collectors.toSet())\n+                ));\n+    }\n+\n+    @Override\n+    public boolean deleteIndexTemplate(String templateName) {\n+        final DeleteIndexTemplateRequest request = new DeleteIndexTemplateRequest(templateName);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().deleteTemplate(request, requestOptions),\n+                \"Unable to delete index template \" + templateName);\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> fieldsInIndices(String[] writeIndexWildcards) {\n+        final List<String> indexWildCards = Arrays.asList(writeIndexWildcards);\n+        return client.execute((c, requestOptions) -> clusterStateApi.fields(c, requestOptions, indexWildCards),\n+                \"Unable to retrieve fields from indices: \" + indexWildCards);\n+    }\n+\n+    @Override\n+    public Set<String> closedIndices(Collection<String> indices) {\n+        return catApi.indices(indices, Collections.singleton(\"close\"),\n+                \"Unable to retrieve list of closed indices for \" + indices);\n+    }\n+\n+    @Override\n+    public Set<IndexStatistics> indicesStats(Collection<String> indices) {\n+        final ImmutableSet.Builder<IndexStatistics> result = ImmutableSet.builder();\n+\n+        final JsonNode allWithShardLevel = client.execute((c, requestOptions) -> statsApi.indexStatsWithShardLevel(c, indices),\n+                \"Unable to retrieve index stats for \" + indices);\n+        final Iterator<Map.Entry<String, JsonNode>> fields = allWithShardLevel.fields();\n+        while (fields.hasNext()) {\n+            final Map.Entry<String, JsonNode> entry = fields.next();\n+            final String index = entry.getKey();\n+            final JsonNode indexStats = entry.getValue();\n+            if (indexStats.isObject()) {\n+                result.add(IndexStatistics.create(index, indexStats));\n+            }\n+        }\n+\n+        return result.build();\n+    }\n+\n+    @Override\n+    public Optional<IndexStatistics> getIndexStats(String index) {\n+        final JsonNode indexStats = client.execute((c, requestOptions) -> statsApi.indexStatsWithShardLevel(c, index),\n+                \"Unable to retrieve index stats for \" + index);\n+        return indexStats.isMissingNode()\n+                ? Optional.empty()\n+                : Optional.of(IndexStatistics.create(index, indexStats));\n+    }\n+\n+    @Override\n+    public JsonNode getIndexStats(Collection<String> indices) {\n+        final JsonNode result = client.execute((c, requestOptions) -> statsApi.indexStatsWithDocsAndStore(c, indices),\n+                \"Couldn't check stats of indices \" + indices);\n+\n+        return result.path(\"indices\");\n+    }\n+\n+    @Override\n+    public boolean exists(String index) throws IOException {\n+        final GetSettingsResponse result = settingsFor(index);\n+        return result.getIndexToSettings().size() == 1 && result.getIndexToSettings().containsKey(index);\n+    }\n+\n+    @Override\n+    public boolean aliasExists(String alias) throws IOException {\n+        final GetAliasesRequest request = new GetAliasesRequest(alias);\n+        return client.execute((c, requestOptions) -> c.indices().existsAlias(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> indices(String indexWildcard, List<String> status, String indexSetId) {\n+        return catApi.indices(indexWildcard, status, \"Couldn't get index list for index set <\" + indexSetId + \">\");\n+    }\n+\n+    @Override\n+    public Optional<Long> storeSizeInBytes(String index) {\n+        return client.execute((c, options) -> statsApi.storeSizes(c, index),\n+                \"Unable to retrieve store size for \" + index);\n+    }\n+\n+    @Override\n+    public void cycleAlias(String aliasName, String targetIndex) {\n+        final IndicesAliasesRequest.AliasActions addAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(targetIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest()\n+                .addAliasAction(addAlias);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't point alias \" + aliasName + \" to index \" + targetIndex);\n+    }\n+\n+    @Override\n+    public void cycleAlias(String aliasName, String targetIndex, String oldIndex) {\n+        final IndicesAliasesRequest.AliasActions addAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(targetIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest.AliasActions removeAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.REMOVE_INDEX)\n+                .index(oldIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest()\n+                .addAliasAction(removeAlias)\n+                .addAliasAction(addAlias);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't switch alias \" + aliasName + \" from index \" + oldIndex + \" to index \" + targetIndex);\n+    }\n+\n+    @Override\n+    public void removeAliases(Set<String> indices, String alias) {\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.REMOVE_INDEX)\n+                .indices(indices.toArray(new String[0]))\n+                .alias(alias);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't remove alias \" + alias + \" from indices \" + indices);\n+    }\n+\n+    @Override\n+    public void optimizeIndex(String index, int maxNumSegments, Duration timeout) {\n+        final ForceMergeRequest request = new ForceMergeRequest()\n+                .indices(index)\n+                .maxNumSegments(maxNumSegments)\n+                .flush(true)\n+                .onlyExpungeDeletes(true);\n+\n+        client.execute((c, requestOptions) -> c.indices().forcemerge(request, requestOptions));\n+    }\n+\n+    @Override\n+    public IndexRangeStats indexRangeStatsOfIndex(String index) {\n+        final FilterAggregationBuilder builder = AggregationBuilders.filter(\"agg\", QueryBuilders.existsQuery(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.min(\"ts_min\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.max(\"ts_max\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.terms(\"streams\").size(Integer.MAX_VALUE).field(Message.FIELD_STREAMS));\n+        final SearchSourceBuilder query = SearchSourceBuilder.searchSource()\n+                .aggregation(builder)\n+                .size(0);\n+\n+        final SearchRequest request = new SearchRequest()\n+                .source(query)\n+                .indices(index)\n+                .searchType(SearchType.DFS_QUERY_THEN_FETCH)\n+                .indicesOptions(IndicesOptions.lenientExpandOpen());\n+\n+        final SearchResponse result = client.execute((c, requestOptions) -> c.search(request, requestOptions),\n+                \"Couldn't build index range of index \" + index);\n+\n+        if (result.getTotalShards() == 0 || result.getAggregations() == null) {\n+            throw new IndexNotFoundException(\"Couldn't build index range of index \" + index + \" because it doesn't exist.\");\n+        }\n+        final Filter f = result.getAggregations().get(\"agg\");\n+        if (f == null) {\n+            throw new IndexNotFoundException(\"Couldn't build index range of index \" + index + \" because it doesn't exist.\");\n+        } else if (f.getDocCount() == 0L) {\n+            LOG.debug(\"No documents with attribute \\\"timestamp\\\" found in index <{}>\", index);\n+            return IndexRangeStats.EMPTY;\n+        }\n+\n+        final Min minAgg = f.getAggregations().get(\"ts_min\");\n+        final long minUnixTime = new Double(minAgg.getValue()).longValue();\n+        final DateTime min = new DateTime(minUnixTime, DateTimeZone.UTC);\n+        final Max maxAgg = f.getAggregations().get(\"ts_max\");\n+        final long maxUnixTime = new Double(maxAgg.getValue()).longValue();\n+        final DateTime max = new DateTime(maxUnixTime, DateTimeZone.UTC);\n+        // make sure we return an empty list, so we can differentiate between old indices that don't have this information\n+        // and newer ones that simply have no streams.\n+        final Terms streams = f.getAggregations().get(\"streams\");\n+        final List<String> streamIds = streams.getBuckets().stream()\n+                .map(MultiBucketsAggregation.Bucket::getKeyAsString)\n+                .collect(toList());\n+\n+        return IndexRangeStats.create(min, max, streamIds);\n+    }\n+\n+    @Override\n+    // TODO: Should this be moved to ClusterAdapter?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 440}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI3MDU4MA==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454270580", "createdAt": "2020-07-14T10:51:42Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.flush.FlushRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.open.OpenIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.template.delete.DeleteIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchType;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.GetAliasesResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CloseIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CreateIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.DeleteAliasRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.PutIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.query.QueryBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.BulkByScrollResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.ReindexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.Filter;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Max;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Min;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cluster.ClusterStateApi;\n+import org.graylog.storage.elasticsearch7.stats.StatsApi;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class IndicesAdapterES7 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final StatsApi statsApi;\n+    private final CatApi catApi;\n+    private final ClusterStateApi clusterStateApi;\n+\n+    @Inject\n+    public IndicesAdapterES7(ElasticsearchClient client,\n+                             StatsApi statsApi,\n+                             CatApi catApi,\n+                             ClusterStateApi clusterStateApi) {\n+        this.client = client;\n+        this.statsApi = statsApi;\n+        this.catApi = catApi;\n+        this.clusterStateApi = clusterStateApi;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        final ReindexRequest request = new ReindexRequest();\n+        request.setSourceIndices(source);\n+        request.setDestIndex(target);\n+\n+        final BulkByScrollResponse result = client.execute((c, requestOptions) -> c.reindex(request, requestOptions));\n+\n+        final IndexMoveResult indexMoveResult = IndexMoveResult.create(\n+                Math.toIntExact(result.getTotal()),\n+                result.getTook().millis(),\n+                !result.getBulkFailures().isEmpty()\n+        );\n+        resultCallback.accept(indexMoveResult);\n+    }\n+\n+    @Override\n+    public void delete(String index) {\n+        final DeleteIndexRequest request = new DeleteIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().delete(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .aliases(alias);\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions));\n+\n+        return result.getAliases().keySet();\n+    }\n+\n+    @Override\n+    public void create(String index, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndexRequest request = new CreateIndexRequest(index)\n+                .settings(settings);\n+\n+        client.execute((c, requestOptions) -> c.indices().create(request, requestOptions),\n+                \"Unable to create index \" + index);\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName)\n+                .source(template);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().putTemplate(request, requestOptions),\n+                \"Unable to create index template \" + templateName);\n+\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettingsRequest request = new GetSettingsRequest()\n+                .indices(index)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, false));\n+\n+        final GetSettingsResponse result = client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Couldn't read settings of index \" + index);\n+\n+        final Optional<String> creationDate = Optional.ofNullable(result.getIndexToSettings().get(index))\n+                .map(indexSettings -> indexSettings.get(\"index.creation_date\"));\n+\n+        return creationDate\n+                .map(Long::valueOf)\n+                .map(DateTime::new);\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        final OpenIndexRequest request = new OpenIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().open(request, requestOptions),\n+                \"Unable to open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/7.8/indices-update-settings.html\n+        final Map<String, Object> settings = ImmutableMap.of(\n+                \"index\", ImmutableMap.of(\"blocks\",\n+                        ImmutableMap.of(\n+                                \"write\", true, // Block writing.\n+                                \"read\", false, // Allow reading.\n+                                \"metadata\", false) // Allow getting metadata.\n+                )\n+        );\n+\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(index)\n+                .settings(settings);\n+        client.execute((c, requestOptions) -> c.indices().putSettings(request, requestOptions),\n+                \"Couldn't set index \" + index + \" to read-only\");\n+    }\n+\n+    @Override\n+    public void flush(String index) {\n+        final FlushRequest request = new FlushRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().flush(request, requestOptions),\n+                \"Unable to flush index \" + index);\n+    }\n+\n+    @Override\n+    public String markIndexReopened(String index) {\n+        final String aliasName = index + Indices.REOPENED_ALIAS_SUFFIX;\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(index)\n+                .alias(aliasName);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't create reopened alias for index \" + index);\n+\n+        return aliasName;\n+    }\n+\n+    @Override\n+    public void removeAlias(String index, String alias) {\n+        final DeleteAliasRequest request = new DeleteAliasRequest(index, alias);\n+\n+        client.execute((c, requestOptions) -> c.indices().deleteAlias(request, requestOptions),\n+                \"Unable to remove alias \" + alias + \", pointing to \" + index);\n+    }\n+\n+    @Override\n+    public void close(String index) {\n+        final CloseIndexRequest request = new CloseIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().close(request, requestOptions),\n+                \"Unable to close index \" + index);\n+    }\n+\n+    @Override\n+    public long numberOfMessages(String index) {\n+        final JsonNode result = client.execute((c, requestOptions) -> statsApi.indexStats(c, index),\n+                \"Unable to retrieve index stats for \" + index);\n+        return result.path(\"primaries\").path(\"docs\").path(\"count\").asLong();\n+    }\n+\n+    private GetSettingsResponse settingsFor(String indexOrAlias) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexOrAlias)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, true));\n+        return client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Unable to retrieve settings for index/alias \" + indexOrAlias);\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> aliases(String indexPattern) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .indices(indexPattern)\n+                .indicesOptions(IndicesOptions.fromOptions(false, false, true, false));\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions),\n+                \"Couldn't collect aliases for index pattern \" + indexPattern);\n+        return result.getAliases()\n+                .entrySet()\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        Map.Entry::getKey,\n+                        entry -> entry.getValue().stream().map(AliasMetaData::alias).collect(Collectors.toSet())\n+                ));\n+    }\n+\n+    @Override\n+    public boolean deleteIndexTemplate(String templateName) {\n+        final DeleteIndexTemplateRequest request = new DeleteIndexTemplateRequest(templateName);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().deleteTemplate(request, requestOptions),\n+                \"Unable to delete index template \" + templateName);\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> fieldsInIndices(String[] writeIndexWildcards) {\n+        final List<String> indexWildCards = Arrays.asList(writeIndexWildcards);\n+        return client.execute((c, requestOptions) -> clusterStateApi.fields(c, requestOptions, indexWildCards),\n+                \"Unable to retrieve fields from indices: \" + indexWildCards);\n+    }\n+\n+    @Override\n+    public Set<String> closedIndices(Collection<String> indices) {\n+        return catApi.indices(indices, Collections.singleton(\"close\"),\n+                \"Unable to retrieve list of closed indices for \" + indices);\n+    }\n+\n+    @Override\n+    public Set<IndexStatistics> indicesStats(Collection<String> indices) {\n+        final ImmutableSet.Builder<IndexStatistics> result = ImmutableSet.builder();\n+\n+        final JsonNode allWithShardLevel = client.execute((c, requestOptions) -> statsApi.indexStatsWithShardLevel(c, indices),\n+                \"Unable to retrieve index stats for \" + indices);\n+        final Iterator<Map.Entry<String, JsonNode>> fields = allWithShardLevel.fields();\n+        while (fields.hasNext()) {\n+            final Map.Entry<String, JsonNode> entry = fields.next();\n+            final String index = entry.getKey();\n+            final JsonNode indexStats = entry.getValue();\n+            if (indexStats.isObject()) {\n+                result.add(IndexStatistics.create(index, indexStats));\n+            }\n+        }\n+\n+        return result.build();\n+    }\n+\n+    @Override\n+    public Optional<IndexStatistics> getIndexStats(String index) {\n+        final JsonNode indexStats = client.execute((c, requestOptions) -> statsApi.indexStatsWithShardLevel(c, index),\n+                \"Unable to retrieve index stats for \" + index);\n+        return indexStats.isMissingNode()\n+                ? Optional.empty()\n+                : Optional.of(IndexStatistics.create(index, indexStats));\n+    }\n+\n+    @Override\n+    public JsonNode getIndexStats(Collection<String> indices) {\n+        final JsonNode result = client.execute((c, requestOptions) -> statsApi.indexStatsWithDocsAndStore(c, indices),\n+                \"Couldn't check stats of indices \" + indices);\n+\n+        return result.path(\"indices\");\n+    }\n+\n+    @Override\n+    public boolean exists(String index) throws IOException {\n+        final GetSettingsResponse result = settingsFor(index);\n+        return result.getIndexToSettings().size() == 1 && result.getIndexToSettings().containsKey(index);\n+    }\n+\n+    @Override\n+    public boolean aliasExists(String alias) throws IOException {\n+        final GetAliasesRequest request = new GetAliasesRequest(alias);\n+        return client.execute((c, requestOptions) -> c.indices().existsAlias(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> indices(String indexWildcard, List<String> status, String indexSetId) {\n+        return catApi.indices(indexWildcard, status, \"Couldn't get index list for index set <\" + indexSetId + \">\");\n+    }\n+\n+    @Override\n+    public Optional<Long> storeSizeInBytes(String index) {\n+        return client.execute((c, options) -> statsApi.storeSizes(c, index),\n+                \"Unable to retrieve store size for \" + index);\n+    }\n+\n+    @Override\n+    public void cycleAlias(String aliasName, String targetIndex) {\n+        final IndicesAliasesRequest.AliasActions addAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(targetIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest()\n+                .addAliasAction(addAlias);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't point alias \" + aliasName + \" to index \" + targetIndex);\n+    }\n+\n+    @Override\n+    public void cycleAlias(String aliasName, String targetIndex, String oldIndex) {\n+        final IndicesAliasesRequest.AliasActions addAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(targetIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest.AliasActions removeAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.REMOVE_INDEX)\n+                .index(oldIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest()\n+                .addAliasAction(removeAlias)\n+                .addAliasAction(addAlias);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't switch alias \" + aliasName + \" from index \" + oldIndex + \" to index \" + targetIndex);\n+    }\n+\n+    @Override\n+    public void removeAliases(Set<String> indices, String alias) {\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.REMOVE_INDEX)\n+                .indices(indices.toArray(new String[0]))\n+                .alias(alias);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't remove alias \" + alias + \" from indices \" + indices);\n+    }\n+\n+    @Override\n+    public void optimizeIndex(String index, int maxNumSegments, Duration timeout) {\n+        final ForceMergeRequest request = new ForceMergeRequest()\n+                .indices(index)\n+                .maxNumSegments(maxNumSegments)\n+                .flush(true)\n+                .onlyExpungeDeletes(true);\n+\n+        client.execute((c, requestOptions) -> c.indices().forcemerge(request, requestOptions));\n+    }\n+\n+    @Override\n+    public IndexRangeStats indexRangeStatsOfIndex(String index) {\n+        final FilterAggregationBuilder builder = AggregationBuilders.filter(\"agg\", QueryBuilders.existsQuery(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.min(\"ts_min\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.max(\"ts_max\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.terms(\"streams\").size(Integer.MAX_VALUE).field(Message.FIELD_STREAMS));\n+        final SearchSourceBuilder query = SearchSourceBuilder.searchSource()\n+                .aggregation(builder)\n+                .size(0);\n+\n+        final SearchRequest request = new SearchRequest()\n+                .source(query)\n+                .indices(index)\n+                .searchType(SearchType.DFS_QUERY_THEN_FETCH)\n+                .indicesOptions(IndicesOptions.lenientExpandOpen());\n+\n+        final SearchResponse result = client.execute((c, requestOptions) -> c.search(request, requestOptions),\n+                \"Couldn't build index range of index \" + index);\n+\n+        if (result.getTotalShards() == 0 || result.getAggregations() == null) {\n+            throw new IndexNotFoundException(\"Couldn't build index range of index \" + index + \" because it doesn't exist.\");\n+        }\n+        final Filter f = result.getAggregations().get(\"agg\");\n+        if (f == null) {\n+            throw new IndexNotFoundException(\"Couldn't build index range of index \" + index + \" because it doesn't exist.\");\n+        } else if (f.getDocCount() == 0L) {\n+            LOG.debug(\"No documents with attribute \\\"timestamp\\\" found in index <{}>\", index);\n+            return IndexRangeStats.EMPTY;\n+        }\n+\n+        final Min minAgg = f.getAggregations().get(\"ts_min\");\n+        final long minUnixTime = new Double(minAgg.getValue()).longValue();\n+        final DateTime min = new DateTime(minUnixTime, DateTimeZone.UTC);\n+        final Max maxAgg = f.getAggregations().get(\"ts_max\");\n+        final long maxUnixTime = new Double(maxAgg.getValue()).longValue();\n+        final DateTime max = new DateTime(maxUnixTime, DateTimeZone.UTC);\n+        // make sure we return an empty list, so we can differentiate between old indices that don't have this information\n+        // and newer ones that simply have no streams.\n+        final Terms streams = f.getAggregations().get(\"streams\");\n+        final List<String> streamIds = streams.getBuckets().stream()\n+                .map(MultiBucketsAggregation.Bucket::getKeyAsString)\n+                .collect(toList());\n+\n+        return IndexRangeStats.create(min, max, streamIds);\n+    }\n+\n+    @Override\n+    // TODO: Should this be moved to ClusterAdapter?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE4OTQxOQ=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 440}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjgxOTUxOnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/stats/StatsApi.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODozMDo1OFrOGxJuKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo0MjozNlrOGxOMsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE5MjY4Mw==", "bodyText": "I'd suggest giving the fn parameter a name that communicates its intention, maybe requestModification? It would also make sense to add an overload without the parameter.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454192683", "createdAt": "2020-07-14T08:30:58Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/stats/StatsApi.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package org.graylog.storage.elasticsearch7.stats;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class StatsApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public StatsApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public JsonNode indexStats(RestHighLevelClient client, String index) throws IOException {\n+        return stats(client, index);\n+    }\n+\n+    public JsonNode indexStatsWithShardLevel(RestHighLevelClient client, String index) throws IOException {\n+        return indexStatsWithShardLevel(client, Collections.singleton(index)).path(index);\n+    }\n+\n+    public JsonNode indexStatsWithShardLevel(RestHighLevelClient client, Collection<String> indices) throws IOException {\n+        final JsonNode stats = stats(client, indices, request -> {\n+            request.addParameter(\"level\", \"shards\");\n+            request.addParameter(\"ignore_unavailable\", \"true\");\n+        });\n+\n+        return stats.path(\"indices\");\n+    }\n+\n+    public JsonNode indexStatsWithDocsAndStore(RestHighLevelClient client, Collection<String> indices) throws IOException {\n+        final JsonNode stats = stats(client, indices, ImmutableSet.of(\"store\", \"docs\"));\n+\n+        return stats.path(\"indices\");\n+    }\n+\n+    public Optional<Long> storeSizes(RestHighLevelClient client, String index) throws IOException {\n+        final JsonNode stats = stats(client, Collections.singleton(index), Collections.singleton(\"store\"));\n+        final JsonNode sizeInBytes = stats.path(\"indices\")\n+                .path(index)\n+                .path(\"primaries\")\n+                .path(\"store\")\n+                .path(\"size_in_bytes\");\n+        return Optional.of(sizeInBytes).filter(JsonNode::isNumber).map(JsonNode::asLong);\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client, String index) throws IOException {\n+        return stats(client, Collections.singleton(index), Collections.emptySet(), (request) -> {});\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Collection<String> metrics) throws IOException {\n+        return stats(client, indices, metrics, (request) -> {});\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Consumer<Request> fn) throws IOException {\n+        return stats(client, indices, Collections.emptySet(), fn);\n+            }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Collection<String> metrics,\n+                           Consumer<Request> fn) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2NjAzNA==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454266034", "createdAt": "2020-07-14T10:42:36Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/stats/StatsApi.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package org.graylog.storage.elasticsearch7.stats;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Request;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.Response;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.inject.Inject;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class StatsApi {\n+    private final ObjectMapper objectMapper;\n+\n+    @Inject\n+    public StatsApi(ObjectMapper objectMapper) {\n+        this.objectMapper = objectMapper;\n+    }\n+\n+    public JsonNode indexStats(RestHighLevelClient client, String index) throws IOException {\n+        return stats(client, index);\n+    }\n+\n+    public JsonNode indexStatsWithShardLevel(RestHighLevelClient client, String index) throws IOException {\n+        return indexStatsWithShardLevel(client, Collections.singleton(index)).path(index);\n+    }\n+\n+    public JsonNode indexStatsWithShardLevel(RestHighLevelClient client, Collection<String> indices) throws IOException {\n+        final JsonNode stats = stats(client, indices, request -> {\n+            request.addParameter(\"level\", \"shards\");\n+            request.addParameter(\"ignore_unavailable\", \"true\");\n+        });\n+\n+        return stats.path(\"indices\");\n+    }\n+\n+    public JsonNode indexStatsWithDocsAndStore(RestHighLevelClient client, Collection<String> indices) throws IOException {\n+        final JsonNode stats = stats(client, indices, ImmutableSet.of(\"store\", \"docs\"));\n+\n+        return stats.path(\"indices\");\n+    }\n+\n+    public Optional<Long> storeSizes(RestHighLevelClient client, String index) throws IOException {\n+        final JsonNode stats = stats(client, Collections.singleton(index), Collections.singleton(\"store\"));\n+        final JsonNode sizeInBytes = stats.path(\"indices\")\n+                .path(index)\n+                .path(\"primaries\")\n+                .path(\"store\")\n+                .path(\"size_in_bytes\");\n+        return Optional.of(sizeInBytes).filter(JsonNode::isNumber).map(JsonNode::asLong);\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client, String index) throws IOException {\n+        return stats(client, Collections.singleton(index), Collections.emptySet(), (request) -> {});\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Collection<String> metrics) throws IOException {\n+        return stats(client, indices, metrics, (request) -> {});\n+    }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Consumer<Request> fn) throws IOException {\n+        return stats(client, indices, Collections.emptySet(), fn);\n+            }\n+\n+    private JsonNode stats(RestHighLevelClient client,\n+                           Collection<String> indices,\n+                           Collection<String> metrics,\n+                           Consumer<Request> fn) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE5MjY4Mw=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjkyMjQ3OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/test/java/org/graylog/storage/elasticsearch7/testing/ClientES7.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODo1OToxNlrOGxKubw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo0MTowNFrOGxOJvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIwOTEzNQ==", "bodyText": "This block is repeated three times throughout this class. I t can be extracted to a private method, something like contentFrom(Response response).", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454209135", "createdAt": "2020-07-14T08:59:16Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/test/java/org/graylog/storage/elasticsearch7/testing/ClientES7.java", "diffHunk": "@@ -164,10 +205,26 @@ public void cleanUp() {\n     }\n \n     private String[] existingIndices() {\n-        final GetIndexRequest getIndexRequest = new GetIndexRequest(\"*\");\n-        getIndexRequest.indicesOptions(IndicesOptions.lenientExpandOpen());\n-        final GetIndexResponse result = client.execute((c, requestOptions) -> c.indices().get(getIndexRequest, requestOptions));\n-        return result.getIndices();\n+        final Request request = new Request(\"GET\", \"/_cat/indices\");\n+        request.addParameter(\"format\", \"json\");\n+        request.addParameter(\"h\", \"index\");\n+\n+        final Response response = client.execute((c, requestOptions) -> {\n+            request.setOptions(requestOptions);\n+            return c.getLowLevelClient().performRequest(request);\n+        });\n+\n+        final JsonNode jsonResponse;\n+        try {\n+            jsonResponse = objectMapper.readTree(response.getEntity().getContent());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2NTI3Nw==", "bodyText": "\u2714\ufe0f I handled it by including it in the client.execute() lambda, which is already going through IOException handling.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454265277", "createdAt": "2020-07-14T10:41:04Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/test/java/org/graylog/storage/elasticsearch7/testing/ClientES7.java", "diffHunk": "@@ -164,10 +205,26 @@ public void cleanUp() {\n     }\n \n     private String[] existingIndices() {\n-        final GetIndexRequest getIndexRequest = new GetIndexRequest(\"*\");\n-        getIndexRequest.indicesOptions(IndicesOptions.lenientExpandOpen());\n-        final GetIndexResponse result = client.execute((c, requestOptions) -> c.indices().get(getIndexRequest, requestOptions));\n-        return result.getIndices();\n+        final Request request = new Request(\"GET\", \"/_cat/indices\");\n+        request.addParameter(\"format\", \"json\");\n+        request.addParameter(\"h\", \"index\");\n+\n+        final Response response = client.execute((c, requestOptions) -> {\n+            request.setOptions(requestOptions);\n+            return c.getLowLevelClient().performRequest(request);\n+        });\n+\n+        final JsonNode jsonResponse;\n+        try {\n+            jsonResponse = objectMapper.readTree(response.getEntity().getContent());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIwOTEzNQ=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjk0OTk5OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/test/java/org/graylog/storage/elasticsearch7/testing/ClientES7.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOTowNjozN1rOGxK_OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzoxMDo1MVrOGxS-XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxMzQzMg==", "bodyText": "I'd suggest extracting a private variable here. (I spotted the closing bracket for Streams#stream on line 130 by accident and it just bugged me...)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Streams.stream(response.path(index)\n          \n          \n            \n                            .path(\"mappings\")\n          \n          \n            \n                            .path(\"properties\")\n          \n          \n            \n                            .fields())\n          \n          \n            \n                            .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().path(\"type\").asText()));\n          \n          \n            \n                    final Iterator<Map.Entry<String, JsonNode>> fields = response.path(index)\n          \n          \n            \n                            .path(\"mappings\")\n          \n          \n            \n                            .path(\"properties\")\n          \n          \n            \n                            .fields();\n          \n          \n            \n                    //noinspection UnstableApiUsage\n          \n          \n            \n                    return Streams.stream(fields)\n          \n          \n            \n                            .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().path(\"type\").asText()));", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454213432", "createdAt": "2020-07-14T09:06:37Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/test/java/org/graylog/storage/elasticsearch7/testing/ClientES7.java", "diffHunk": "@@ -90,22 +96,55 @@ public void addAliasMapping(String indexName, String alias) {\n                 .alias(alias);\n         indicesAliasesRequest.addAliasAction(aliasAction);\n \n-        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions));\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"failed to add alias \" + alias + \" for index \" + indexName);\n     }\n \n     @Override\n-    public JsonNode getMapping(String... indices) {\n-        return null;\n+    public boolean isSourceEnabled(String testIndexName) {\n+        // TODO: implement\n+        return true;\n     }\n \n     @Override\n-    public JsonNode getTemplate(String templateName) {\n-        return null;\n+    public String fieldType(String testIndexName, String field) {\n+        return getMapping(testIndexName).get(field);\n+    }\n+\n+    private Map<String, String> getMapping(String index) {\n+        final Request request = new Request(\"GET\", \"/\" + index + \"/_mapping\");\n+        final Response result = client.execute((c, requestOptions) -> {\n+            request.setOptions(requestOptions);\n+            return c.getLowLevelClient().performRequest(request);\n+        });\n+\n+        final JsonNode response;\n+        try {\n+            response = objectMapper.readTree(result.getEntity().getContent());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return Streams.stream(response.path(index)\n+                .path(\"mappings\")\n+                .path(\"properties\")\n+                .fields())\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().path(\"type\").asText()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2NjkzNQ==", "bodyText": "\u2714\ufe0f I extracted a helper method for it.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454266935", "createdAt": "2020-07-14T10:44:24Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/test/java/org/graylog/storage/elasticsearch7/testing/ClientES7.java", "diffHunk": "@@ -90,22 +96,55 @@ public void addAliasMapping(String indexName, String alias) {\n                 .alias(alias);\n         indicesAliasesRequest.addAliasAction(aliasAction);\n \n-        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions));\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"failed to add alias \" + alias + \" for index \" + indexName);\n     }\n \n     @Override\n-    public JsonNode getMapping(String... indices) {\n-        return null;\n+    public boolean isSourceEnabled(String testIndexName) {\n+        // TODO: implement\n+        return true;\n     }\n \n     @Override\n-    public JsonNode getTemplate(String templateName) {\n-        return null;\n+    public String fieldType(String testIndexName, String field) {\n+        return getMapping(testIndexName).get(field);\n+    }\n+\n+    private Map<String, String> getMapping(String index) {\n+        final Request request = new Request(\"GET\", \"/\" + index + \"/_mapping\");\n+        final Response result = client.execute((c, requestOptions) -> {\n+            request.setOptions(requestOptions);\n+            return c.getLowLevelClient().performRequest(request);\n+        });\n+\n+        final JsonNode response;\n+        try {\n+            response = objectMapper.readTree(result.getEntity().getContent());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return Streams.stream(response.path(index)\n+                .path(\"mappings\")\n+                .path(\"properties\")\n+                .fields())\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().path(\"type\").asText()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxMzQzMg=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM0NDI4NQ==", "bodyText": "Even better!", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454344285", "createdAt": "2020-07-14T13:10:51Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/test/java/org/graylog/storage/elasticsearch7/testing/ClientES7.java", "diffHunk": "@@ -90,22 +96,55 @@ public void addAliasMapping(String indexName, String alias) {\n                 .alias(alias);\n         indicesAliasesRequest.addAliasAction(aliasAction);\n \n-        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions));\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"failed to add alias \" + alias + \" for index \" + indexName);\n     }\n \n     @Override\n-    public JsonNode getMapping(String... indices) {\n-        return null;\n+    public boolean isSourceEnabled(String testIndexName) {\n+        // TODO: implement\n+        return true;\n     }\n \n     @Override\n-    public JsonNode getTemplate(String templateName) {\n-        return null;\n+    public String fieldType(String testIndexName, String field) {\n+        return getMapping(testIndexName).get(field);\n+    }\n+\n+    private Map<String, String> getMapping(String index) {\n+        final Request request = new Request(\"GET\", \"/\" + index + \"/_mapping\");\n+        final Response result = client.execute((c, requestOptions) -> {\n+            request.setOptions(requestOptions);\n+            return c.getLowLevelClient().performRequest(request);\n+        });\n+\n+        final JsonNode response;\n+        try {\n+            response = objectMapper.readTree(result.getEntity().getContent());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return Streams.stream(response.path(index)\n+                .path(\"mappings\")\n+                .path(\"properties\")\n+                .fields())\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().path(\"type\").asText()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxMzQzMg=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjk5NjExOnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOToxOToyN1rOGxLbqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo0NDo1NlrOGxORQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIyMDcxMg==", "bodyText": "One is enough!\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * This file is part of Graylog.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Graylog is free software: you can redistribute it and/or modify\n          \n          \n            \n             * it under the terms of the GNU General Public License as published by\n          \n          \n            \n             * the Free Software Foundation, either version 3 of the License, or\n          \n          \n            \n             * (at your option) any later version.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Graylog is distributed in the hope that it will be useful,\n          \n          \n            \n             * but WITHOUT ANY WARRANTY; without even the implied warranty of\n          \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n          \n          \n            \n             * GNU General Public License for more details.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * You should have received a copy of the GNU General Public License\n          \n          \n            \n             * along with Graylog.  If not, see <http://www.gnu.org/licenses/>.\n          \n          \n            \n             */", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454220712", "createdAt": "2020-07-14T09:19:27Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -14,18 +14,31 @@\n  * You should have received a copy of the GNU General Public License\n  * along with Graylog.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+/**\n+ * This file is part of Graylog.\n+ * <p>\n+ * Graylog is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ * <p>\n+ * Graylog is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ * <p>\n+ * You should have received a copy of the GNU General Public License\n+ * along with Graylog.  If not, see <http://www.gnu.org/licenses/>.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2NzIwMQ==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454267201", "createdAt": "2020-07-14T10:44:56Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -14,18 +14,31 @@\n  * You should have received a copy of the GNU General Public License\n  * along with Graylog.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+/**\n+ * This file is part of Graylog.\n+ * <p>\n+ * Graylog is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ * <p>\n+ * Graylog is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ * <p>\n+ * You should have received a copy of the GNU General Public License\n+ * along with Graylog.  If not, see <http://www.gnu.org/licenses/>.\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIyMDcxMg=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzAwODMyOnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOToyMjo0MVrOGxLjKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo0NTozNFrOGxOSkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIyMjYzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Optional<DateTime> storeSizeInBytes = indices.indexCreationDate(index);\n          \n          \n            \n            \n          \n          \n            \n                    assertThat(storeSizeInBytes).isNotEmpty();\n          \n          \n            \n                    final Optional<DateTime> creationTime = indices.indexCreationDate(index);\n          \n          \n            \n            \n          \n          \n            \n                    assertThat(creationTime).isNotEmpty();", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454222635", "createdAt": "2020-07-14T09:22:41Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -406,4 +366,51 @@ public void getIndices() {\n         assertThat(indices.getIndices(indexSet, \"close\"))\n                 .containsOnly(index2);\n     }\n+\n+    @Test\n+    public void storeSizeInBytesReturnsValue() {\n+        final String index = client().createRandomIndex(\"foo\");\n+\n+        final Optional<Long> storeSizeInBytes = indices.getStoreSizeInBytes(index);\n+\n+        assertThat(storeSizeInBytes).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void retrievesCreationTimeOfIndex() {\n+        final String index = client().createRandomIndex(\"foo\");\n+\n+        final Optional<DateTime> storeSizeInBytes = indices.indexCreationDate(index);\n+\n+        assertThat(storeSizeInBytes).isNotEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI2NzUzNw==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454267537", "createdAt": "2020-07-14T10:45:34Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -406,4 +366,51 @@ public void getIndices() {\n         assertThat(indices.getIndices(indexSet, \"close\"))\n                 .containsOnly(index2);\n     }\n+\n+    @Test\n+    public void storeSizeInBytesReturnsValue() {\n+        final String index = client().createRandomIndex(\"foo\");\n+\n+        final Optional<Long> storeSizeInBytes = indices.getStoreSizeInBytes(index);\n+\n+        assertThat(storeSizeInBytes).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void retrievesCreationTimeOfIndex() {\n+        final String index = client().createRandomIndex(\"foo\");\n+\n+        final Optional<DateTime> storeSizeInBytes = indices.indexCreationDate(index);\n+\n+        assertThat(storeSizeInBytes).isNotEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIyMjYzNQ=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzEwNjU0OnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOTo0OTo0NlrOGxMf-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo1MToyMlrOGxOd1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODIwMA==", "bodyText": "I would suggest to rename this to findsClosedIndices and also create a third index and not close it to verify that only closed indices are found.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454238200", "createdAt": "2020-07-14T09:49:46Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -132,6 +148,18 @@ public void testClose() {\n         //assertThat(getIndexState(index)).isEqualTo(\"close\");\n     }\n \n+    @Test\n+    public void testClosedIndices() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI3MDQyMQ==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454270421", "createdAt": "2020-07-14T10:51:22Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -132,6 +148,18 @@ public void testClose() {\n         //assertThat(getIndexState(index)).isEqualTo(\"close\");\n     }\n \n+    @Test\n+    public void testClosedIndices() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODIwMA=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzEyMDI4OnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOTo1MzoyOFrOGxMoIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDo1MToyNlrOGxOd8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0MDI4OQ==", "bodyText": "Actually I think it would be worth to rename all the tests in here whose names start with test to something more meaningful.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454240289", "createdAt": "2020-07-14T09:53:28Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -132,6 +148,18 @@ public void testClose() {\n         //assertThat(getIndexState(index)).isEqualTo(\"close\");\n     }\n \n+    @Test\n+    public void testClosedIndices() {\n+        final String index1 = client().createRandomIndex(\"indices_it_\");\n+        client().closeIndex(index1);\n+        final String index2 = client().createRandomIndex(\"otherindices_it_\");\n+        client().closeIndex(index2);\n+\n+        final Set<String> closedIndices = indices.getClosedIndices(Collections.singleton(\"*\"));\n+\n+        assertThat(closedIndices).containsExactlyInAnyOrder(index1, index2);\n+    }\n+\n     @Test\n     public void testAliasExists() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI3MDQ0OQ==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454270449", "createdAt": "2020-07-14T10:51:26Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -132,6 +148,18 @@ public void testClose() {\n         //assertThat(getIndexState(index)).isEqualTo(\"close\");\n     }\n \n+    @Test\n+    public void testClosedIndices() {\n+        final String index1 = client().createRandomIndex(\"indices_it_\");\n+        client().closeIndex(index1);\n+        final String index2 = client().createRandomIndex(\"otherindices_it_\");\n+        client().closeIndex(index2);\n+\n+        final Set<String> closedIndices = indices.getClosedIndices(Collections.singleton(\"*\"));\n+\n+        assertThat(closedIndices).containsExactlyInAnyOrder(index1, index2);\n+    }\n+\n     @Test\n     public void testAliasExists() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0MDI4OQ=="}, "originalCommit": {"oid": "0c7d8a11ea24b030193ae62cd35985b9d78209c4"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzgxODU2OnYy", "diffSide": "RIGHT", "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzoxODowM1rOGxTQMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzo0Mjo0M1rOGxUQdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM0ODg0OA==", "bodyText": "We should extract another private method here that gets State a parameter to remove the duplication with isClosed. Something like indexHasState(String index, State state)", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454348848", "createdAt": "2020-07-14T13:18:03Z", "author": {"login": "alex-konn"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.flush.FlushRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.open.OpenIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.template.delete.DeleteIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchType;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.GetAliasesResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CloseIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CreateIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.DeleteAliasRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.PutIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.query.QueryBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.BulkByScrollResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.ReindexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.Filter;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Max;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Min;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cluster.ClusterStateApi;\n+import org.graylog.storage.elasticsearch7.stats.StatsApi;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class IndicesAdapterES7 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final StatsApi statsApi;\n+    private final CatApi catApi;\n+    private final ClusterStateApi clusterStateApi;\n+\n+    @Inject\n+    public IndicesAdapterES7(ElasticsearchClient client,\n+                             StatsApi statsApi,\n+                             CatApi catApi,\n+                             ClusterStateApi clusterStateApi) {\n+        this.client = client;\n+        this.statsApi = statsApi;\n+        this.catApi = catApi;\n+        this.clusterStateApi = clusterStateApi;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        final ReindexRequest request = new ReindexRequest();\n+        request.setSourceIndices(source);\n+        request.setDestIndex(target);\n+\n+        final BulkByScrollResponse result = client.execute((c, requestOptions) -> c.reindex(request, requestOptions));\n+\n+        final IndexMoveResult indexMoveResult = IndexMoveResult.create(\n+                Math.toIntExact(result.getTotal()),\n+                result.getTook().millis(),\n+                !result.getBulkFailures().isEmpty()\n+        );\n+        resultCallback.accept(indexMoveResult);\n+    }\n+\n+    @Override\n+    public void delete(String index) {\n+        final DeleteIndexRequest request = new DeleteIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().delete(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .aliases(alias);\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions));\n+\n+        return result.getAliases().keySet();\n+    }\n+\n+    @Override\n+    public void create(String index, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndexRequest request = new CreateIndexRequest(index)\n+                .settings(settings);\n+\n+        client.execute((c, requestOptions) -> c.indices().create(request, requestOptions),\n+                \"Unable to create index \" + index);\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName)\n+                .source(template);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().putTemplate(request, requestOptions),\n+                \"Unable to create index template \" + templateName);\n+\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettingsRequest request = new GetSettingsRequest()\n+                .indices(index)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, false));\n+\n+        final GetSettingsResponse result = client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Couldn't read settings of index \" + index);\n+\n+        final Optional<String> creationDate = Optional.ofNullable(result.getIndexToSettings().get(index))\n+                .map(indexSettings -> indexSettings.get(\"index.creation_date\"));\n+\n+        return creationDate\n+                .map(Long::valueOf)\n+                .map(DateTime::new);\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        final OpenIndexRequest request = new OpenIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().open(request, requestOptions),\n+                \"Unable to open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/7.8/indices-update-settings.html\n+        final Map<String, Object> settings = ImmutableMap.of(\n+                \"index\", ImmutableMap.of(\"blocks\",\n+                        ImmutableMap.of(\n+                                \"write\", true, // Block writing.\n+                                \"read\", false, // Allow reading.\n+                                \"metadata\", false) // Allow getting metadata.\n+                )\n+        );\n+\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(index)\n+                .settings(settings);\n+        client.execute((c, requestOptions) -> c.indices().putSettings(request, requestOptions),\n+                \"Couldn't set index \" + index + \" to read-only\");\n+    }\n+\n+    @Override\n+    public void flush(String index) {\n+        final FlushRequest request = new FlushRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().flush(request, requestOptions),\n+                \"Unable to flush index \" + index);\n+    }\n+\n+    @Override\n+    public String markIndexReopened(String index) {\n+        final String aliasName = index + Indices.REOPENED_ALIAS_SUFFIX;\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(index)\n+                .alias(aliasName);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't create reopened alias for index \" + index);\n+\n+        return aliasName;\n+    }\n+\n+    @Override\n+    public void removeAlias(String index, String alias) {\n+        final DeleteAliasRequest request = new DeleteAliasRequest(index, alias);\n+\n+        client.execute((c, requestOptions) -> c.indices().deleteAlias(request, requestOptions),\n+                \"Unable to remove alias \" + alias + \", pointing to \" + index);\n+    }\n+\n+    @Override\n+    public void close(String index) {\n+        final CloseIndexRequest request = new CloseIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().close(request, requestOptions),\n+                \"Unable to close index \" + index);\n+    }\n+\n+    @Override\n+    public long numberOfMessages(String index) {\n+        final JsonNode result = statsApi.indexStats(index);\n+        return result.path(\"primaries\").path(\"docs\").path(\"count\").asLong();\n+    }\n+\n+    private GetSettingsResponse settingsFor(String indexOrAlias) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexOrAlias)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, true));\n+        return client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Unable to retrieve settings for index/alias \" + indexOrAlias);\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> aliases(String indexPattern) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .indices(indexPattern)\n+                .indicesOptions(IndicesOptions.fromOptions(false, false, true, false));\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions),\n+                \"Couldn't collect aliases for index pattern \" + indexPattern);\n+        return result.getAliases()\n+                .entrySet()\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        Map.Entry::getKey,\n+                        entry -> entry.getValue().stream().map(AliasMetaData::alias).collect(Collectors.toSet())\n+                ));\n+    }\n+\n+    @Override\n+    public boolean deleteIndexTemplate(String templateName) {\n+        final DeleteIndexTemplateRequest request = new DeleteIndexTemplateRequest(templateName);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().deleteTemplate(request, requestOptions),\n+                \"Unable to delete index template \" + templateName);\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> fieldsInIndices(String[] writeIndexWildcards) {\n+        final List<String> indexWildCards = Arrays.asList(writeIndexWildcards);\n+        return clusterStateApi.fields(indexWildCards);\n+    }\n+\n+    @Override\n+    public Set<String> closedIndices(Collection<String> indices) {\n+        return catApi.indices(indices, Collections.singleton(\"close\"),\n+                \"Unable to retrieve list of closed indices for \" + indices);\n+    }\n+\n+    @Override\n+    public Set<IndexStatistics> indicesStats(Collection<String> indices) {\n+        final ImmutableSet.Builder<IndexStatistics> result = ImmutableSet.builder();\n+\n+        final JsonNode allWithShardLevel = statsApi.indexStatsWithShardLevel(indices);\n+        final Iterator<Map.Entry<String, JsonNode>> fields = allWithShardLevel.fields();\n+        while (fields.hasNext()) {\n+            final Map.Entry<String, JsonNode> entry = fields.next();\n+            final String index = entry.getKey();\n+            final JsonNode indexStats = entry.getValue();\n+            if (indexStats.isObject()) {\n+                result.add(IndexStatistics.create(index, indexStats));\n+            }\n+        }\n+\n+        return result.build();\n+    }\n+\n+    @Override\n+    public Optional<IndexStatistics> getIndexStats(String index) {\n+        final JsonNode indexStats = statsApi.indexStatsWithShardLevel(index);\n+        return indexStats.isMissingNode()\n+                ? Optional.empty()\n+                : Optional.of(IndexStatistics.create(index, indexStats));\n+    }\n+\n+    @Override\n+    public JsonNode getIndexStats(Collection<String> indices) {\n+        final JsonNode result = statsApi.indexStatsWithDocsAndStore(indices);\n+\n+        return result.path(\"indices\");\n+    }\n+\n+    @Override\n+    public boolean exists(String index) {\n+        final GetSettingsResponse result = settingsFor(index);\n+        return result.getIndexToSettings().size() == 1 && result.getIndexToSettings().containsKey(index);\n+    }\n+\n+    @Override\n+    public boolean aliasExists(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest(alias);\n+        return client.execute((c, requestOptions) -> c.indices().existsAlias(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> indices(String indexWildcard, List<String> status, String indexSetId) {\n+        return catApi.indices(indexWildcard, status, \"Couldn't get index list for index set <\" + indexSetId + \">\");\n+    }\n+\n+    @Override\n+    public Optional<Long> storeSizeInBytes(String index) {\n+        return statsApi.storeSizes(index);\n+    }\n+\n+    @Override\n+    public void cycleAlias(String aliasName, String targetIndex) {\n+        final IndicesAliasesRequest.AliasActions addAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(targetIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest()\n+                .addAliasAction(addAlias);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't point alias \" + aliasName + \" to index \" + targetIndex);\n+    }\n+\n+    @Override\n+    public void cycleAlias(String aliasName, String targetIndex, String oldIndex) {\n+        final IndicesAliasesRequest.AliasActions addAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(targetIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest.AliasActions removeAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.REMOVE_INDEX)\n+                .index(oldIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest()\n+                .addAliasAction(removeAlias)\n+                .addAliasAction(addAlias);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't switch alias \" + aliasName + \" from index \" + oldIndex + \" to index \" + targetIndex);\n+    }\n+\n+    @Override\n+    public void removeAliases(Set<String> indices, String alias) {\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.REMOVE_INDEX)\n+                .indices(indices.toArray(new String[0]))\n+                .alias(alias);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't remove alias \" + alias + \" from indices \" + indices);\n+    }\n+\n+    @Override\n+    public void optimizeIndex(String index, int maxNumSegments, Duration timeout) {\n+        final ForceMergeRequest request = new ForceMergeRequest()\n+                .indices(index)\n+                .maxNumSegments(maxNumSegments)\n+                .flush(true)\n+                .onlyExpungeDeletes(true);\n+\n+        client.execute((c, requestOptions) -> c.indices().forcemerge(request, requestOptions));\n+    }\n+\n+    @Override\n+    public IndexRangeStats indexRangeStatsOfIndex(String index) {\n+        final FilterAggregationBuilder builder = AggregationBuilders.filter(\"agg\", QueryBuilders.existsQuery(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.min(\"ts_min\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.max(\"ts_max\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.terms(\"streams\").size(Integer.MAX_VALUE).field(Message.FIELD_STREAMS));\n+        final SearchSourceBuilder query = SearchSourceBuilder.searchSource()\n+                .aggregation(builder)\n+                .size(0);\n+\n+        final SearchRequest request = new SearchRequest()\n+                .source(query)\n+                .indices(index)\n+                .searchType(SearchType.DFS_QUERY_THEN_FETCH)\n+                .indicesOptions(IndicesOptions.lenientExpandOpen());\n+\n+        final SearchResponse result = client.execute((c, requestOptions) -> c.search(request, requestOptions),\n+                \"Couldn't build index range of index \" + index);\n+\n+        if (result.getTotalShards() == 0 || result.getAggregations() == null) {\n+            throw new IndexNotFoundException(\"Couldn't build index range of index \" + index + \" because it doesn't exist.\");\n+        }\n+        final Filter f = result.getAggregations().get(\"agg\");\n+        if (f == null) {\n+            throw new IndexNotFoundException(\"Couldn't build index range of index \" + index + \" because it doesn't exist.\");\n+        } else if (f.getDocCount() == 0L) {\n+            LOG.debug(\"No documents with attribute \\\"timestamp\\\" found in index <{}>\", index);\n+            return IndexRangeStats.EMPTY;\n+        }\n+\n+        final Min minAgg = f.getAggregations().get(\"ts_min\");\n+        final long minUnixTime = new Double(minAgg.getValue()).longValue();\n+        final DateTime min = new DateTime(minUnixTime, DateTimeZone.UTC);\n+        final Max maxAgg = f.getAggregations().get(\"ts_max\");\n+        final long maxUnixTime = new Double(maxAgg.getValue()).longValue();\n+        final DateTime max = new DateTime(maxUnixTime, DateTimeZone.UTC);\n+        // make sure we return an empty list, so we can differentiate between old indices that don't have this information\n+        // and newer ones that simply have no streams.\n+        final Terms streams = f.getAggregations().get(\"streams\");\n+        final List<String> streamIds = streams.getBuckets().stream()\n+                .map(MultiBucketsAggregation.Bucket::getKeyAsString)\n+                .collect(toList());\n+\n+        return IndexRangeStats.create(min, max, streamIds);\n+    }\n+\n+    @Override\n+    public HealthStatus waitForRecovery(String index) {\n+        final ClusterHealthRequest clusterHealthRequest = new ClusterHealthRequest(index);\n+        clusterHealthRequest.waitForGreenStatus();\n+\n+        final ClusterHealthResponse result = client.execute((c, requestOptions) -> c.cluster().health(clusterHealthRequest, requestOptions));\n+        return HealthStatus.fromString(result.getStatus().toString());\n+    }\n+\n+    @Override\n+    public boolean isOpen(String index) {\n+        return indexState(index)\n+                .map(state -> state.equals(State.Open))\n+                .orElseThrow(() -> new IndexNotFoundException(\"Unable to determine state for absent index \" + index));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40190e73fc58a850b865ee2654f085828b458169"}, "originalPosition": 445}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM2NTMwMQ==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454365301", "createdAt": "2020-07-14T13:42:43Z", "author": {"login": "dennisoelkers"}, "path": "graylog-storage-elasticsearch7/src/main/java/org/graylog/storage/elasticsearch7/IndicesAdapterES7.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.graylog.storage.elasticsearch7;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.github.joschi.jadconfig.util.Duration;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.flush.FlushRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.open.OpenIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.admin.indices.template.delete.DeleteIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.search.SearchType;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.IndicesOptions;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.GetAliasesResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CloseIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.CreateIndexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.DeleteAliasRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.client.indices.PutIndexTemplateRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.query.QueryBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.BulkByScrollResponse;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.index.reindex.ReindexRequest;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.Filter;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Max;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.aggregations.metrics.Min;\n+import org.graylog.shaded.elasticsearch7.org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.graylog.storage.elasticsearch7.cat.CatApi;\n+import org.graylog.storage.elasticsearch7.cluster.ClusterStateApi;\n+import org.graylog.storage.elasticsearch7.stats.StatsApi;\n+import org.graylog2.indexer.IndexNotFoundException;\n+import org.graylog2.indexer.indices.HealthStatus;\n+import org.graylog2.indexer.indices.IndexMoveResult;\n+import org.graylog2.indexer.indices.IndexSettings;\n+import org.graylog2.indexer.indices.Indices;\n+import org.graylog2.indexer.indices.IndicesAdapter;\n+import org.graylog2.indexer.indices.stats.IndexStatistics;\n+import org.graylog2.indexer.searches.IndexRangeStats;\n+import org.graylog2.plugin.Message;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class IndicesAdapterES7 implements IndicesAdapter {\n+    private static final Logger LOG = LoggerFactory.getLogger(IndicesAdapterES7.class);\n+    private final ElasticsearchClient client;\n+    private final StatsApi statsApi;\n+    private final CatApi catApi;\n+    private final ClusterStateApi clusterStateApi;\n+\n+    @Inject\n+    public IndicesAdapterES7(ElasticsearchClient client,\n+                             StatsApi statsApi,\n+                             CatApi catApi,\n+                             ClusterStateApi clusterStateApi) {\n+        this.client = client;\n+        this.statsApi = statsApi;\n+        this.catApi = catApi;\n+        this.clusterStateApi = clusterStateApi;\n+    }\n+\n+    @Override\n+    public void move(String source, String target, Consumer<IndexMoveResult> resultCallback) {\n+        final ReindexRequest request = new ReindexRequest();\n+        request.setSourceIndices(source);\n+        request.setDestIndex(target);\n+\n+        final BulkByScrollResponse result = client.execute((c, requestOptions) -> c.reindex(request, requestOptions));\n+\n+        final IndexMoveResult indexMoveResult = IndexMoveResult.create(\n+                Math.toIntExact(result.getTotal()),\n+                result.getTook().millis(),\n+                !result.getBulkFailures().isEmpty()\n+        );\n+        resultCallback.accept(indexMoveResult);\n+    }\n+\n+    @Override\n+    public void delete(String index) {\n+        final DeleteIndexRequest request = new DeleteIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().delete(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> resolveAlias(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .aliases(alias);\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions));\n+\n+        return result.getAliases().keySet();\n+    }\n+\n+    @Override\n+    public void create(String index, IndexSettings indexSettings, String templateName, Map<String, Object> template) {\n+        final Map<String, Object> settings = new HashMap<>();\n+        settings.put(\"number_of_shards\", indexSettings.shards());\n+        settings.put(\"number_of_replicas\", indexSettings.replicas());\n+\n+        final CreateIndexRequest request = new CreateIndexRequest(index)\n+                .settings(settings);\n+\n+        client.execute((c, requestOptions) -> c.indices().create(request, requestOptions),\n+                \"Unable to create index \" + index);\n+    }\n+\n+    @Override\n+    public boolean ensureIndexTemplate(String templateName, Map<String, Object> template) {\n+        final PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName)\n+                .source(template);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().putTemplate(request, requestOptions),\n+                \"Unable to create index template \" + templateName);\n+\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Optional<DateTime> indexCreationDate(String index) {\n+        final GetSettingsRequest request = new GetSettingsRequest()\n+                .indices(index)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, false));\n+\n+        final GetSettingsResponse result = client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Couldn't read settings of index \" + index);\n+\n+        final Optional<String> creationDate = Optional.ofNullable(result.getIndexToSettings().get(index))\n+                .map(indexSettings -> indexSettings.get(\"index.creation_date\"));\n+\n+        return creationDate\n+                .map(Long::valueOf)\n+                .map(DateTime::new);\n+    }\n+\n+    @Override\n+    public void openIndex(String index) {\n+        final OpenIndexRequest request = new OpenIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().open(request, requestOptions),\n+                \"Unable to open index \" + index);\n+    }\n+\n+    @Override\n+    public void setReadOnly(String index) {\n+        // https://www.elastic.co/guide/en/elasticsearch/reference/7.8/indices-update-settings.html\n+        final Map<String, Object> settings = ImmutableMap.of(\n+                \"index\", ImmutableMap.of(\"blocks\",\n+                        ImmutableMap.of(\n+                                \"write\", true, // Block writing.\n+                                \"read\", false, // Allow reading.\n+                                \"metadata\", false) // Allow getting metadata.\n+                )\n+        );\n+\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(index)\n+                .settings(settings);\n+        client.execute((c, requestOptions) -> c.indices().putSettings(request, requestOptions),\n+                \"Couldn't set index \" + index + \" to read-only\");\n+    }\n+\n+    @Override\n+    public void flush(String index) {\n+        final FlushRequest request = new FlushRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().flush(request, requestOptions),\n+                \"Unable to flush index \" + index);\n+    }\n+\n+    @Override\n+    public String markIndexReopened(String index) {\n+        final String aliasName = index + Indices.REOPENED_ALIAS_SUFFIX;\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(index)\n+                .alias(aliasName);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't create reopened alias for index \" + index);\n+\n+        return aliasName;\n+    }\n+\n+    @Override\n+    public void removeAlias(String index, String alias) {\n+        final DeleteAliasRequest request = new DeleteAliasRequest(index, alias);\n+\n+        client.execute((c, requestOptions) -> c.indices().deleteAlias(request, requestOptions),\n+                \"Unable to remove alias \" + alias + \", pointing to \" + index);\n+    }\n+\n+    @Override\n+    public void close(String index) {\n+        final CloseIndexRequest request = new CloseIndexRequest(index);\n+\n+        client.execute((c, requestOptions) -> c.indices().close(request, requestOptions),\n+                \"Unable to close index \" + index);\n+    }\n+\n+    @Override\n+    public long numberOfMessages(String index) {\n+        final JsonNode result = statsApi.indexStats(index);\n+        return result.path(\"primaries\").path(\"docs\").path(\"count\").asLong();\n+    }\n+\n+    private GetSettingsResponse settingsFor(String indexOrAlias) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexOrAlias)\n+                .indicesOptions(IndicesOptions.fromOptions(true, true, true, true));\n+        return client.execute((c, requestOptions) -> c.indices().getSettings(request, requestOptions),\n+                \"Unable to retrieve settings for index/alias \" + indexOrAlias);\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> aliases(String indexPattern) {\n+        final GetAliasesRequest request = new GetAliasesRequest()\n+                .indices(indexPattern)\n+                .indicesOptions(IndicesOptions.fromOptions(false, false, true, false));\n+        final GetAliasesResponse result = client.execute((c, requestOptions) -> c.indices().getAlias(request, requestOptions),\n+                \"Couldn't collect aliases for index pattern \" + indexPattern);\n+        return result.getAliases()\n+                .entrySet()\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        Map.Entry::getKey,\n+                        entry -> entry.getValue().stream().map(AliasMetaData::alias).collect(Collectors.toSet())\n+                ));\n+    }\n+\n+    @Override\n+    public boolean deleteIndexTemplate(String templateName) {\n+        final DeleteIndexTemplateRequest request = new DeleteIndexTemplateRequest(templateName);\n+\n+        final AcknowledgedResponse result = client.execute((c, requestOptions) -> c.indices().deleteTemplate(request, requestOptions),\n+                \"Unable to delete index template \" + templateName);\n+        return result.isAcknowledged();\n+    }\n+\n+    @Override\n+    public Map<String, Set<String>> fieldsInIndices(String[] writeIndexWildcards) {\n+        final List<String> indexWildCards = Arrays.asList(writeIndexWildcards);\n+        return clusterStateApi.fields(indexWildCards);\n+    }\n+\n+    @Override\n+    public Set<String> closedIndices(Collection<String> indices) {\n+        return catApi.indices(indices, Collections.singleton(\"close\"),\n+                \"Unable to retrieve list of closed indices for \" + indices);\n+    }\n+\n+    @Override\n+    public Set<IndexStatistics> indicesStats(Collection<String> indices) {\n+        final ImmutableSet.Builder<IndexStatistics> result = ImmutableSet.builder();\n+\n+        final JsonNode allWithShardLevel = statsApi.indexStatsWithShardLevel(indices);\n+        final Iterator<Map.Entry<String, JsonNode>> fields = allWithShardLevel.fields();\n+        while (fields.hasNext()) {\n+            final Map.Entry<String, JsonNode> entry = fields.next();\n+            final String index = entry.getKey();\n+            final JsonNode indexStats = entry.getValue();\n+            if (indexStats.isObject()) {\n+                result.add(IndexStatistics.create(index, indexStats));\n+            }\n+        }\n+\n+        return result.build();\n+    }\n+\n+    @Override\n+    public Optional<IndexStatistics> getIndexStats(String index) {\n+        final JsonNode indexStats = statsApi.indexStatsWithShardLevel(index);\n+        return indexStats.isMissingNode()\n+                ? Optional.empty()\n+                : Optional.of(IndexStatistics.create(index, indexStats));\n+    }\n+\n+    @Override\n+    public JsonNode getIndexStats(Collection<String> indices) {\n+        final JsonNode result = statsApi.indexStatsWithDocsAndStore(indices);\n+\n+        return result.path(\"indices\");\n+    }\n+\n+    @Override\n+    public boolean exists(String index) {\n+        final GetSettingsResponse result = settingsFor(index);\n+        return result.getIndexToSettings().size() == 1 && result.getIndexToSettings().containsKey(index);\n+    }\n+\n+    @Override\n+    public boolean aliasExists(String alias) {\n+        final GetAliasesRequest request = new GetAliasesRequest(alias);\n+        return client.execute((c, requestOptions) -> c.indices().existsAlias(request, requestOptions));\n+    }\n+\n+    @Override\n+    public Set<String> indices(String indexWildcard, List<String> status, String indexSetId) {\n+        return catApi.indices(indexWildcard, status, \"Couldn't get index list for index set <\" + indexSetId + \">\");\n+    }\n+\n+    @Override\n+    public Optional<Long> storeSizeInBytes(String index) {\n+        return statsApi.storeSizes(index);\n+    }\n+\n+    @Override\n+    public void cycleAlias(String aliasName, String targetIndex) {\n+        final IndicesAliasesRequest.AliasActions addAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(targetIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest()\n+                .addAliasAction(addAlias);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't point alias \" + aliasName + \" to index \" + targetIndex);\n+    }\n+\n+    @Override\n+    public void cycleAlias(String aliasName, String targetIndex, String oldIndex) {\n+        final IndicesAliasesRequest.AliasActions addAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.ADD)\n+                .index(targetIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest.AliasActions removeAlias = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.REMOVE_INDEX)\n+                .index(oldIndex)\n+                .alias(aliasName);\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest()\n+                .addAliasAction(removeAlias)\n+                .addAliasAction(addAlias);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't switch alias \" + aliasName + \" from index \" + oldIndex + \" to index \" + targetIndex);\n+    }\n+\n+    @Override\n+    public void removeAliases(Set<String> indices, String alias) {\n+        final IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest();\n+        final IndicesAliasesRequest.AliasActions aliasAction = new IndicesAliasesRequest.AliasActions(IndicesAliasesRequest.AliasActions.Type.REMOVE_INDEX)\n+                .indices(indices.toArray(new String[0]))\n+                .alias(alias);\n+        indicesAliasesRequest.addAliasAction(aliasAction);\n+\n+        client.execute((c, requestOptions) -> c.indices().updateAliases(indicesAliasesRequest, requestOptions),\n+                \"Couldn't remove alias \" + alias + \" from indices \" + indices);\n+    }\n+\n+    @Override\n+    public void optimizeIndex(String index, int maxNumSegments, Duration timeout) {\n+        final ForceMergeRequest request = new ForceMergeRequest()\n+                .indices(index)\n+                .maxNumSegments(maxNumSegments)\n+                .flush(true)\n+                .onlyExpungeDeletes(true);\n+\n+        client.execute((c, requestOptions) -> c.indices().forcemerge(request, requestOptions));\n+    }\n+\n+    @Override\n+    public IndexRangeStats indexRangeStatsOfIndex(String index) {\n+        final FilterAggregationBuilder builder = AggregationBuilders.filter(\"agg\", QueryBuilders.existsQuery(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.min(\"ts_min\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.max(\"ts_max\").field(Message.FIELD_TIMESTAMP))\n+                .subAggregation(AggregationBuilders.terms(\"streams\").size(Integer.MAX_VALUE).field(Message.FIELD_STREAMS));\n+        final SearchSourceBuilder query = SearchSourceBuilder.searchSource()\n+                .aggregation(builder)\n+                .size(0);\n+\n+        final SearchRequest request = new SearchRequest()\n+                .source(query)\n+                .indices(index)\n+                .searchType(SearchType.DFS_QUERY_THEN_FETCH)\n+                .indicesOptions(IndicesOptions.lenientExpandOpen());\n+\n+        final SearchResponse result = client.execute((c, requestOptions) -> c.search(request, requestOptions),\n+                \"Couldn't build index range of index \" + index);\n+\n+        if (result.getTotalShards() == 0 || result.getAggregations() == null) {\n+            throw new IndexNotFoundException(\"Couldn't build index range of index \" + index + \" because it doesn't exist.\");\n+        }\n+        final Filter f = result.getAggregations().get(\"agg\");\n+        if (f == null) {\n+            throw new IndexNotFoundException(\"Couldn't build index range of index \" + index + \" because it doesn't exist.\");\n+        } else if (f.getDocCount() == 0L) {\n+            LOG.debug(\"No documents with attribute \\\"timestamp\\\" found in index <{}>\", index);\n+            return IndexRangeStats.EMPTY;\n+        }\n+\n+        final Min minAgg = f.getAggregations().get(\"ts_min\");\n+        final long minUnixTime = new Double(minAgg.getValue()).longValue();\n+        final DateTime min = new DateTime(minUnixTime, DateTimeZone.UTC);\n+        final Max maxAgg = f.getAggregations().get(\"ts_max\");\n+        final long maxUnixTime = new Double(maxAgg.getValue()).longValue();\n+        final DateTime max = new DateTime(maxUnixTime, DateTimeZone.UTC);\n+        // make sure we return an empty list, so we can differentiate between old indices that don't have this information\n+        // and newer ones that simply have no streams.\n+        final Terms streams = f.getAggregations().get(\"streams\");\n+        final List<String> streamIds = streams.getBuckets().stream()\n+                .map(MultiBucketsAggregation.Bucket::getKeyAsString)\n+                .collect(toList());\n+\n+        return IndexRangeStats.create(min, max, streamIds);\n+    }\n+\n+    @Override\n+    public HealthStatus waitForRecovery(String index) {\n+        final ClusterHealthRequest clusterHealthRequest = new ClusterHealthRequest(index);\n+        clusterHealthRequest.waitForGreenStatus();\n+\n+        final ClusterHealthResponse result = client.execute((c, requestOptions) -> c.cluster().health(clusterHealthRequest, requestOptions));\n+        return HealthStatus.fromString(result.getStatus().toString());\n+    }\n+\n+    @Override\n+    public boolean isOpen(String index) {\n+        return indexState(index)\n+                .map(state -> state.equals(State.Open))\n+                .orElseThrow(() -> new IndexNotFoundException(\"Unable to determine state for absent index \" + index));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM0ODg0OA=="}, "originalCommit": {"oid": "40190e73fc58a850b865ee2654f085828b458169"}, "originalPosition": 445}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzg1NDI3OnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzoyNjozNVrOGxTl3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzo0Mjo0N1rOGxUQng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM1NDM5OQ==", "bodyText": "The variable for index3 is not needed. If you want to keep it in here to make it more obvious that it shouldn't be contained in the result, the \"unused\" warning should be suppressed.", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454354399", "createdAt": "2020-07-14T13:26:35Z", "author": {"login": "alex-konn"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -126,16 +119,28 @@ public void testDelete() {\n     public void testClose() {\n         final String index = client().createRandomIndex(\"indices_it_\");\n \n-        assertThat(indicesAdapter.isOpen(index)).isTrue();\n+        assertThat(indices.isOpen(index)).isTrue();\n \n         indices.close(index);\n \n-        assertThat(indicesAdapter.isClosed(index)).isTrue();\n-        //assertThat(getIndexState(index)).isEqualTo(\"close\");\n+        assertThat(indices.isClosed(index)).isTrue();\n     }\n \n     @Test\n-    public void testAliasExists() {\n+    public void findClosedIndices() {\n+        final String index1 = client().createRandomIndex(\"indices_it_\");\n+        client().closeIndex(index1);\n+        final String index2 = client().createRandomIndex(\"otherindices_it_\");\n+        client().closeIndex(index2);\n+        final String index3 = client().createRandomIndex(\"evenmoreindices_it_\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40190e73fc58a850b865ee2654f085828b458169"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM2NTM0Mg==", "bodyText": "\u2714\ufe0f", "url": "https://github.com/Graylog2/graylog2-server/pull/8482#discussion_r454365342", "createdAt": "2020-07-14T13:42:47Z", "author": {"login": "dennisoelkers"}, "path": "graylog2-server/src/test/java/org/graylog2/indexer/indices/IndicesIT.java", "diffHunk": "@@ -126,16 +119,28 @@ public void testDelete() {\n     public void testClose() {\n         final String index = client().createRandomIndex(\"indices_it_\");\n \n-        assertThat(indicesAdapter.isOpen(index)).isTrue();\n+        assertThat(indices.isOpen(index)).isTrue();\n \n         indices.close(index);\n \n-        assertThat(indicesAdapter.isClosed(index)).isTrue();\n-        //assertThat(getIndexState(index)).isEqualTo(\"close\");\n+        assertThat(indices.isClosed(index)).isTrue();\n     }\n \n     @Test\n-    public void testAliasExists() {\n+    public void findClosedIndices() {\n+        final String index1 = client().createRandomIndex(\"indices_it_\");\n+        client().closeIndex(index1);\n+        final String index2 = client().createRandomIndex(\"otherindices_it_\");\n+        client().closeIndex(index2);\n+        final String index3 = client().createRandomIndex(\"evenmoreindices_it_\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM1NDM5OQ=="}, "originalCommit": {"oid": "40190e73fc58a850b865ee2654f085828b458169"}, "originalPosition": 103}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4107, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}