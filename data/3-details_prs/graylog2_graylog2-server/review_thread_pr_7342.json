{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5NTYzMzcz", "number": 7342, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo0NDowM1rODcOZfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzoyNzoxNVrODcPBzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTIyNjIzOnYy", "diffSide": "RIGHT", "path": "graylog2-web-interface/src/views/components/dashboard/BigDisplayModeHeader.jsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo0NDowM1rOFkKSIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo0NDowM1rOFkKSIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MTUzNg==", "bodyText": "This throwed a PropType error. I removed the isRequired and added undefined as a default props, because it's the state, before the store got connected.", "url": "https://github.com/Graylog2/graylog2-server/pull/7342#discussion_r373461536", "createdAt": "2020-01-31T12:44:03Z", "author": {"login": "linuspahl"}, "path": "graylog2-web-interface/src/views/components/dashboard/BigDisplayModeHeader.jsx", "diffHunk": "@@ -36,8 +36,14 @@ const BigDisplayModeHeader = ({ view: { activeQuery, view } = {} }: Props) => {\n \n BigDisplayModeHeader.propTypes = {\n   view: PropTypes.shape({\n-    title: PropTypes.string.isRequired,\n-  }).isRequired,\n+    view: PropTypes.shape({\n+      title: PropTypes.string.isRequired,\n+    }),\n+  }),\n+};\n+\n+BigDisplayModeHeader.defaultProps = {\n+  view: undefined,\n };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b45a5564e4232f0f404aa43166c5ce900fe737"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTIyODE0OnYy", "diffSide": "RIGHT", "path": "graylog2-web-interface/src/views/pages/NewDashboardPage.jsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo0NTowM1rOFkKTXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo0NTowM1rOFkKTXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MTg1Mg==", "bodyText": "When I go it right processHooks expects the query object instead of the full location.", "url": "https://github.com/Graylog2/graylog2-server/pull/7342#discussion_r373461852", "createdAt": "2020-01-31T12:45:03Z", "author": {"login": "linuspahl"}, "path": "graylog2-web-interface/src/views/pages/NewDashboardPage.jsx", "diffHunk": "@@ -31,7 +32,7 @@ const NewDashboardPage = ({ route, location, loadingViewHooks, executingViewHook\n     const { state = {} } = location;\n     const { view: searchView } = state;\n     if (searchView && searchView.search) {\n-      const query = location;\n+      const { query } = location;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b45a5564e4232f0f404aa43166c5ce900fe737"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTI1ODk2OnYy", "diffSide": "RIGHT", "path": "graylog2-web-interface/src/views/pages/ShowDashboardInBigDisplayMode.test.jsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo1Nzo0NVrOFkKl_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjo1Nzo0NVrOFkKl_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NjYyMQ==", "bodyText": "Question: At first I was not aware of the connect mock we are using for several other tests. The above tests are working without the connect mock, but at some point I needed to add the cleanup method in afterEach.\nImplementing the cleanup method without the conntect mock throws the following error: TypeError: desub is not a function\nBut with the connect mock, the view returned from ViewStore.getInitialState is no longer available in e.g. the BigDisplayModeHeader\nMy question is, how to deal with this scenario?", "url": "https://github.com/Graylog2/graylog2-server/pull/7342#discussion_r373466621", "createdAt": "2020-01-31T12:57:45Z", "author": {"login": "linuspahl"}, "path": "graylog2-web-interface/src/views/pages/ShowDashboardInBigDisplayMode.test.jsx", "diffHunk": "@@ -0,0 +1,98 @@\n+// @flow strict\n+import * as React from 'react';\n+import { render, cleanup, wait } from '@testing-library/react';\n+\n+import { StoreMock as MockStore } from 'helpers/mocking';\n+import MockQuery from 'views/logic/queries/Query';\n+import { RefreshActions } from 'views/stores/RefreshStore';\n+import View from 'views/logic/views/View';\n+\n+import ShowDashboardInBigDisplayMode from 'views/pages/ShowDashboardInBigDisplayMode';\n+\n+const mockView = View.builder()\n+  .type(View.Type.Dashboard)\n+  .id('view-id')\n+  .title('view title')\n+  .build();\n+\n+jest.mock('stores/connect', () => x => x);\n+jest.mock('react-router', () => ({ withRouter: x => x }));\n+jest.mock('views/stores/RefreshStore', () => ({\n+  RefreshActions: {\n+    setInterval: jest.fn(),\n+    enable: jest.fn(),\n+    disable: jest.fn(),\n+  },\n+}));\n+jest.mock('views/stores/ViewStore', () => ({\n+  ViewStore: MockStore(\n+    'listen',\n+    ['getInitialState', () => ({ activeQuery: 'somequery', view: mockView })],\n+  ),\n+}));\n+jest.mock('views/stores/SearchExecutionStateStore', () => ({\n+  SearchExecutionStateStore: { listen: jest.fn() },\n+}));\n+jest.mock('views/stores/CurrentQueryStore', () => ({\n+  CurrentQueryStore: MockStore(['getInitialState', () => MockQuery.builder().build()], 'listen'),\n+}));\n+\n+describe('ShowDashboardInBigDisplayMode', () => {\n+  const mockLocation = {\n+    query: {\n+      interval: '30', refresh: '10',\n+    },\n+  };\n+\n+  afterEach(() => {\n+    cleanup();\n+    jest.clearAllMocks();\n+  });\n+\n+  it('sets refresh interval correctly based on location query', async () => {\n+    render(<ShowDashboardInBigDisplayMode route={{}}\n+                                          params={{ viewId: mockView.id }}\n+                                          location={mockLocation} />);\n+    await wait(() => expect(RefreshActions.setInterval).toHaveBeenCalledTimes(1));\n+    await wait(() => expect(RefreshActions.setInterval).toHaveBeenCalledWith(10000));\n+  });\n+\n+  it('should enable refresh actions', async () => {\n+    render(<ShowDashboardInBigDisplayMode route={{}}\n+                                          params={{ viewId: mockView.id }}\n+                                          location={mockLocation} />);\n+    await wait(() => expect(RefreshActions.enable).toHaveBeenCalledTimes(1));\n+  });\n+\n+  it('should set new refresh interval when location query refresh param changes', async () => {\n+    const { rerender } = render(<ShowDashboardInBigDisplayMode route={{}}\n+                                                               params={{ viewId: mockView.id }}\n+                                                               location={mockLocation} />);\n+    rerender(<ShowDashboardInBigDisplayMode route={{}}\n+                                            params={{ viewId: mockView.id }}\n+                                            location={{ query: { ...mockLocation.query, refresh: '20' } }} />);\n+\n+    await wait(() => expect(RefreshActions.setInterval).toHaveBeenCalledTimes(2));\n+    await wait(() => expect(RefreshActions.setInterval).toHaveBeenCalledWith(20000));\n+  });\n+\n+  it('should not change RefreshActions when query refresh param did not changes', async () => {\n+    const { rerender } = render(<ShowDashboardInBigDisplayMode route={{}}\n+                                                               params={{ viewId: mockView.id }}\n+                                                               location={mockLocation} />);\n+    rerender(<ShowDashboardInBigDisplayMode route={{}}\n+                                            params={{ viewId: mockView.id }}\n+                                            location={mockLocation} />);\n+\n+    await wait(() => expect(RefreshActions.setInterval).toHaveBeenCalledTimes(1));\n+    await wait(() => expect(RefreshActions.enable).toHaveBeenCalledTimes(1));\n+  });\n+\n+  // it('should display view title', async () => {\n+  //   const { getByText } = render(<ShowDashboardInBigDisplayMode route={{}}\n+  //                                                               params={{ viewId: mockView.id }}\n+  //                                                               location={mockLocation} />);\n+\n+  //   await waitForElement(() => getByText('view title'));\n+  // });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b45a5564e4232f0f404aa43166c5ce900fe737"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTI5MjMzOnYy", "diffSide": "RIGHT", "path": "graylog2-web-interface/src/views/pages/NewSearchPage.test.jsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzoxMTo1OFrOFkK6rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzoxMTo1OFrOFkK6rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MTkxNg==", "bodyText": "Question: So far we are not using requireActual. it looked like the best solution for me, in the context of the following case:\nThis is the related import import ViewLoader, { processHooks } from 'views/logic/views/ViewLoader';\nWe need to mock processHooks, to test if it got called correctly. But I don't want to mock the ViewLoader, because I need to trigger e.g. the onError function we are passing to the ViewLoader. This is the main reason for the above implementation.\nHaving a look at e.g. the the ShowViewPage, I saw a different usage of the ViewLoader regarding the import. The ViewLoader and processHooks are getting imported the same way, but we are not using the ViewLoader directly. We are defining it as a default prop.\nMy question is, should we unify the usage of the ViewLoader for NewDashboardPage, NewSearchPage, ShowViewPage and StreamSearchPage?\nThe Implementation with the default prop would simplify the described test case.", "url": "https://github.com/Graylog2/graylog2-server/pull/7342#discussion_r373471916", "createdAt": "2020-01-31T13:11:58Z", "author": {"login": "linuspahl"}, "path": "graylog2-web-interface/src/views/pages/NewSearchPage.test.jsx", "diffHunk": "@@ -0,0 +1,194 @@\n+// @flow strict\n+import * as React from 'react';\n+import { render, cleanup, wait, waitForElement, fireEvent } from 'wrappedTestingLibrary';\n+\n+import { StoreMock as MockStore } from 'helpers/mocking';\n+import asMock from 'helpers/mocking/AsMock';\n+\n+import { processHooks } from 'views/logic/views/ViewLoader';\n+import { syncWithQueryParameters } from 'views/hooks/SyncWithQueryParameters';\n+import { ViewActions } from 'views/stores/ViewStore';\n+import { ViewManagementActions } from 'views/stores/ViewManagementStore';\n+import NewViewLoaderContext from 'views/logic/NewViewLoaderContext';\n+import Search from 'views/logic/search/Search';\n+import View from 'views/logic/views/View';\n+import ViewLoaderContext from 'views/logic/ViewLoaderContext';\n+\n+import NewSearchPage from './NewSearchPage';\n+\n+const mockExtendedSearchPage = jest.fn(() => <div>Extended search page</div>);\n+const mockView = View.create()\n+  .toBuilder()\n+  .type(View.Type.Search)\n+  .search(Search.builder().build())\n+  .build();\n+\n+jest.mock('react-router', () => ({ withRouter: x => x }));\n+jest.mock('./ExtendedSearchPage', () => mockExtendedSearchPage);\n+jest.mock('views/stores/SearchStore', () => MockStore());\n+jest.mock('views/stores/ViewStore', () => ({\n+  ViewActions: { create: jest.fn(() => Promise.resolve({ view: mockView })) },\n+}));\n+jest.mock('views/hooks/SyncWithQueryParameters', () => ({\n+  syncWithQueryParameters: jest.fn(),\n+}));\n+jest.mock('views/stores/ViewManagementStore', () => ({\n+  ViewManagementActions: {\n+    get: jest.fn(() => Promise.resolve()),\n+  },\n+}));\n+jest.mock('views/logic/views/ViewLoader', () => {\n+  const originalModule = jest.requireActual('views/logic/views/ViewLoader');\n+  return {\n+    __esModule: true,\n+    ...originalModule,\n+    processHooks: jest.fn((promise, loadHooks, executeHooks, query, onSuccess) => Promise.resolve().then(onSuccess)),\n+  };\n+});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b45a5564e4232f0f404aa43166c5ce900fe737"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTMyNDc4OnYy", "diffSide": "RIGHT", "path": "graylog2-web-interface/src/views/pages/NewSearchPage.test.jsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzoyNToyMVrOFkLOoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzoyNToyMVrOFkLOoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NzAyNQ==", "bodyText": "Question: Having a look at the implementation of processHooks, I realized we should unify the usage, especially in the context of the error case. Sometimes we are catching the error and creating a UserNotification:\n return processHooks(\n      ...\n ).catch(\n     error => UserNotification.error(`Executing search failed with error: ${error}`, 'Could not execute search'),\n);\n\nsometimes we are using the processHooks onError argument, to set the hookComponent state\nreturn viewLoader(\n      ...\n      (e) => {\n        if (e instanceof Error) {\n          throw e;\n        }\n        this.setState({ hookComponent: e });\n      },\n\nand sometimes we are doing the same, but without checking the error instance.\nMy main question is related to the hookComponent. It looks like we are defining a hookComponent when processHooks errors. When the hookComponent is defined we'll display it instead of the ExtendedSearchPage. I want to test tis case, but looking at the code I don't understand when the hookComponent (e.g. in the last code snippet) gets defined. because when it is an error, setState will not get called. When it is not an error, the onError function passed to processHooks will not getCalled.", "url": "https://github.com/Graylog2/graylog2-server/pull/7342#discussion_r373477025", "createdAt": "2020-01-31T13:25:21Z", "author": {"login": "linuspahl"}, "path": "graylog2-web-interface/src/views/pages/NewSearchPage.test.jsx", "diffHunk": "@@ -0,0 +1,194 @@\n+// @flow strict\n+import * as React from 'react';\n+import { render, cleanup, wait, waitForElement, fireEvent } from 'wrappedTestingLibrary';\n+\n+import { StoreMock as MockStore } from 'helpers/mocking';\n+import asMock from 'helpers/mocking/AsMock';\n+\n+import { processHooks } from 'views/logic/views/ViewLoader';\n+import { syncWithQueryParameters } from 'views/hooks/SyncWithQueryParameters';\n+import { ViewActions } from 'views/stores/ViewStore';\n+import { ViewManagementActions } from 'views/stores/ViewManagementStore';\n+import NewViewLoaderContext from 'views/logic/NewViewLoaderContext';\n+import Search from 'views/logic/search/Search';\n+import View from 'views/logic/views/View';\n+import ViewLoaderContext from 'views/logic/ViewLoaderContext';\n+\n+import NewSearchPage from './NewSearchPage';\n+\n+const mockExtendedSearchPage = jest.fn(() => <div>Extended search page</div>);\n+const mockView = View.create()\n+  .toBuilder()\n+  .type(View.Type.Search)\n+  .search(Search.builder().build())\n+  .build();\n+\n+jest.mock('react-router', () => ({ withRouter: x => x }));\n+jest.mock('./ExtendedSearchPage', () => mockExtendedSearchPage);\n+jest.mock('views/stores/SearchStore', () => MockStore());\n+jest.mock('views/stores/ViewStore', () => ({\n+  ViewActions: { create: jest.fn(() => Promise.resolve({ view: mockView })) },\n+}));\n+jest.mock('views/hooks/SyncWithQueryParameters', () => ({\n+  syncWithQueryParameters: jest.fn(),\n+}));\n+jest.mock('views/stores/ViewManagementStore', () => ({\n+  ViewManagementActions: {\n+    get: jest.fn(() => Promise.resolve()),\n+  },\n+}));\n+jest.mock('views/logic/views/ViewLoader', () => {\n+  const originalModule = jest.requireActual('views/logic/views/ViewLoader');\n+  return {\n+    __esModule: true,\n+    ...originalModule,\n+    processHooks: jest.fn((promise, loadHooks, executeHooks, query, onSuccess) => Promise.resolve().then(onSuccess)),\n+  };\n+});\n+\n+describe('NewSearchPage', () => {\n+  const mockRouter = {\n+    getCurrentLocation: jest.fn(() => ({ pathname: '/search', search: '?q=&rangetype=relative&relative=300' })),\n+  };\n+  const mockLocation = {\n+    pathname: '/search',\n+    query: {\n+      q: '',\n+      rangetype: 'relative',\n+      relative: '300',\n+    },\n+  };\n+  afterEach(() => {\n+    cleanup();\n+    jest.clearAllMocks();\n+  });\n+\n+  it('should render minimal', async () => {\n+    const { getByText } = render(<NewSearchPage route={{}} router={mockRouter} location={{}} />);\n+    await waitForElement(() => getByText('Extended search page'));\n+  });\n+\n+  it('should show spinner while loading view', () => {\n+    const { getByText } = render(<NewSearchPage route={{}} router={mockRouter} location={{}} />);\n+    expect(getByText('Loading...')).not.toBeNull();\n+  });\n+\n+  describe('mounting', () => {\n+    it('should create new view with type search', async () => {\n+      const createViewAction = asMock(ViewActions.create);\n+\n+      render(<NewSearchPage route={{}}\n+                            router={mockRouter}\n+                            location={{}} />);\n+\n+      await wait(() => expect(createViewAction).toBeCalledTimes(1));\n+      await wait(() => expect(createViewAction).toHaveBeenCalledWith(View.Type.Search));\n+    });\n+\n+    it('should process hooks with provided location query', async () => {\n+      const processHooksAction = asMock(processHooks);\n+\n+      render(<NewSearchPage route={{}}\n+                            router={mockRouter}\n+                            location={mockLocation} />);\n+\n+      await wait(() => expect(processHooksAction).toBeCalledTimes(1));\n+      await wait(() => expect(processHooksAction.mock.calls[0][3]).toStrictEqual({ q: '', rangetype: 'relative', relative: '300' }));\n+    });\n+  });\n+\n+  describe('loading another view', () => {\n+    it('should be possible with specific view id', async () => {\n+      mockExtendedSearchPage.mockImplementation(() => (\n+        <ViewLoaderContext.Consumer>\n+          {loadView => <button type=\"button\" onClick={() => loadView && loadView('special-view-id')}>Load view</button>}\n+        </ViewLoaderContext.Consumer>\n+      ));\n+      const viewGetAction = asMock(ViewManagementActions.get);\n+\n+      const { getByText } = render(<NewSearchPage route={{}}\n+                                                  router={mockRouter}\n+                                                  location={{}} />);\n+      const viewLoadButton = await waitForElement(() => getByText('Load view'));\n+      fireEvent.click(viewLoadButton);\n+\n+      await wait(() => expect(viewGetAction).toHaveBeenCalledTimes(1));\n+      await wait(() => expect(viewGetAction).toHaveBeenCalledWith('special-view-id'));\n+    });\n+\n+    // it('should show error message when loading fails', async () => {\n+    //   const hookComponent = <div>The hook component</div>;\n+    //   ViewManagementActions.get = mockAction(jest.fn(() => Promise.reject(hookComponent)));\n+    //   mockExtendedSearchPage.mockImplementation(() => (\n+    //     <ViewLoaderContext.Consumer>\n+    //       {loadView => loadView && <button type=\"button\" onClick={() => loadView('special-view-id')}>Load view</button>}\n+    //     </ViewLoaderContext.Consumer>\n+    //   ));\n+\n+    //   const { getByText } = render(<NewSearchPage route={{}}\n+    //                                               router={mockRouter}\n+    //                                               location={{}} />);\n+    //   const viewLoadButton = await waitForElement(() => getByText('Load view'));\n+    //   fireEvent.click(viewLoadButton);\n+\n+    //   await waitForElement(() => getByText('The hook component'));\n+    // });\n+  });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b45a5564e4232f0f404aa43166c5ce900fe737"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTMyOTQyOnYy", "diffSide": "LEFT", "path": "graylog2-web-interface/src/views/pages/ShowDashboardInBigDisplayMode.jsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzoyNzoxNVrOFkLRjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzoyNzoxNVrOFkLRjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3Nzc3NA==", "bodyText": "I removed  the ViewMetadataStore and CurrentQueryStore  usage, because it looks like we are not using viewMetadata and query.", "url": "https://github.com/Graylog2/graylog2-server/pull/7342#discussion_r373477774", "createdAt": "2020-01-31T13:27:15Z", "author": {"login": "linuspahl"}, "path": "graylog2-web-interface/src/views/pages/ShowDashboardInBigDisplayMode.jsx", "diffHunk": "@@ -64,4 +62,4 @@ const ShowDashboardInBigDisplayMode = ({ location, params, route, view: { view,\n   );\n };\n \n-export default withRouter(connect(ShowDashboardInBigDisplayMode, { view: ViewStore, viewMetadata: ViewMetadataStore, query: CurrentQueryStore }));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b45a5564e4232f0f404aa43166c5ce900fe737"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3961, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}