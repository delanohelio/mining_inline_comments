{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMTIzOTI4", "number": 9278, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowNzoyOFrOE1RBMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowNzoyOFrOE1RBMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Mjg4ODE3OnYy", "diffSide": "RIGHT", "path": "graylog2-server/src/main/java/org/graylog2/security/realm/HTTPHeaderAuthenticationRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowNzoyOFrOHtcVWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowNzoyOFrOHtcVWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxMjE4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOG.warn(\"Request with trusted HTTP header <{}={}> received from <{}> which is not in the trusted subnets: {}\",\n          \n          \n            \n                        LOG.warn(\"Request with trusted HTTP header <{}={}> received from <{}> which is not in the trusted proxies: <{}>\",", "url": "https://github.com/Graylog2/graylog2-server/pull/9278#discussion_r517412187", "createdAt": "2020-11-04T15:07:28Z", "author": {"login": "mpfz0r"}, "path": "graylog2-server/src/main/java/org/graylog2/security/realm/HTTPHeaderAuthenticationRealm.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * This file is part of Graylog.\n+ *\n+ * Graylog is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * Graylog is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with Graylog.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package org.graylog2.security.realm;\n+\n+import com.google.common.base.Joiner;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationInfo;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.SimpleAccount;\n+import org.apache.shiro.authc.credential.AllowAllCredentialsMatcher;\n+import org.apache.shiro.realm.AuthenticatingRealm;\n+import org.graylog.security.authservice.AuthServiceAuthenticator;\n+import org.graylog.security.authservice.AuthServiceCredentials;\n+import org.graylog.security.authservice.AuthServiceException;\n+import org.graylog.security.authservice.AuthServiceResult;\n+import org.graylog2.plugin.cluster.ClusterConfigService;\n+import org.graylog2.security.headerauth.HTTPHeaderAuthConfig;\n+import org.graylog2.shared.security.HttpHeadersToken;\n+import org.graylog2.utilities.IpSubnet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.net.UnknownHostException;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+public class HTTPHeaderAuthenticationRealm extends AuthenticatingRealm {\n+    private static final Logger LOG = LoggerFactory.getLogger(HTTPHeaderAuthenticationRealm.class);\n+    private static final Joiner JOINER = Joiner.on(\", \");\n+\n+    public static final String NAME = \"http-header-authentication\";\n+\n+    private final ClusterConfigService clusterConfigService;\n+    private final AuthServiceAuthenticator authServiceAuthenticator;\n+    private final Set<IpSubnet> trustedProxies;\n+\n+    @Inject\n+    public HTTPHeaderAuthenticationRealm(ClusterConfigService clusterConfigService,\n+                                         AuthServiceAuthenticator authServiceAuthenticator,\n+                                         @Named(\"trusted_proxies\") Set<IpSubnet> trustedProxies) {\n+        this.clusterConfigService = clusterConfigService;\n+        this.authServiceAuthenticator = authServiceAuthenticator;\n+        this.trustedProxies = trustedProxies;\n+\n+        setAuthenticationTokenClass(HttpHeadersToken.class);\n+        setCachingEnabled(false);\n+        // Credentials will be matched via the authentication service itself so we don't need Shiro to do it\n+        setCredentialsMatcher(new AllowAllCredentialsMatcher());\n+    }\n+\n+    @Override\n+    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+        final HttpHeadersToken headersToken = (HttpHeadersToken) token;\n+        final HTTPHeaderAuthConfig config = loadConfig();\n+\n+        if (!config.enabled()) {\n+            LOG.debug(\"Skipping disabled HTTP header authentication\");\n+            return null;\n+        }\n+\n+        final MultivaluedMap<String, String> headers = headersToken.getHeaders();\n+        final Optional<String> optionalUsername = headerValue(headers, config.usernameHeader());\n+\n+        if (optionalUsername.isPresent()) {\n+            final String username = optionalUsername.get().trim();\n+\n+            if (isBlank(username)) {\n+                LOG.warn(\"Skipping request with trusted HTTP header <{}> and blank value\", config.usernameHeader());\n+                return null;\n+            }\n+\n+            if (inTrustedSubnets(headersToken.getRemoteAddr())) {\n+                return doAuthenticate(username);\n+            }\n+\n+            LOG.warn(\"Request with trusted HTTP header <{}={}> received from <{}> which is not in the trusted subnets: {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "929e2145bc1895c575db85bfdee6bc97e3c1aced"}, "originalPosition": 97}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4448, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}