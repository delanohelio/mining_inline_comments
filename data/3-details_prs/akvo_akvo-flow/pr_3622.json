{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNzE1NTM2", "number": 3622, "title": "[#3620] - scroll to the current edited survey question", "bodyText": "Before the PR (what is the issue or what needed to be done)\nThe solution\nUsing Jquery, scroll to the position of the currently edited question when the save button is clicked.\nScreenshots (if appropriate)\nReviewer Checklist\n\n Added an explanation about the work done\n Connected the PR and the issue on Zenhub\n Added a test plan to the issue\n Updated the copyright header (when relevant)\n Formatted the code\n Added a documentation (if relevant)\n Added some unit tests (if relevant)", "createdAt": "2020-08-04T11:48:53Z", "url": "https://github.com/akvo/akvo-flow/pull/3622", "merged": true, "mergeCommit": {"oid": "67bdf84e827c7ae72aeafb68af6f9326a425097c"}, "closed": true, "closedAt": "2020-08-04T15:03:26Z", "author": {"login": "marvinkome"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7lFdiAH2gAyNDYyNzE1NTM2OjMxNjVmYmFkNTQwZmIzMGRiOGMxMDA2ZTMwMDgyNjk0MjA5OTJlNTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7m0VPAFqTQ2MDgyMjY4NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3165fbad540fb30db8c1006e3008269420992e59", "author": {"user": null}, "url": "https://github.com/akvo/akvo-flow/commit/3165fbad540fb30db8c1006e3008269420992e59", "committedDate": "2020-08-04T11:40:04Z", "message": "[#3620] - scroll to the current edited survey question"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNzM5MDM1", "url": "https://github.com/akvo/akvo-flow/pull/3622#pullrequestreview-460739035", "createdAt": "2020-08-04T11:49:57Z", "commit": {"oid": "3165fbad540fb30db8c1006e3008269420992e59"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMTo0OTo1N1rOG7c53Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMTo0OTo1N1rOG7c53Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk5MjczMw==", "bodyText": "1", "url": "https://github.com/akvo/akvo-flow/pull/3622#discussion_r464992733", "createdAt": "2020-08-04T11:49:57Z", "author": {"login": "marvinkome"}, "path": "Dashboard/app/js/lib/views/surveys/question-view.js", "diffHunk": "@@ -6,888 +6,1075 @@ function sortByOrder(a, b) {\n   return a.get('order') - b.get('order');\n }\n \n-FLOW.QuestionView = FLOW.View.extend(template('navSurveys/question-view'), observe({\n-  'FLOW.selectedControl.dependentQuestion': 'fillOptionList',\n-  'this.text': 'validateQuestionObserver',\n-  'FLOW.questionOptionsControl.emptyOptions': 'validateQuestionObserver',\n-  'this.tip': 'validateQuestionTooltipObserver',\n-  'this.variableName': 'validateVariableNameObserver',\n-  'this.selectedCaddisflyTestBrand': 'brandsObserver',\n-}), {\n-  content: null,\n-  variableName: null,\n-  text: null,\n-  tip: null,\n-  type: null,\n-  mandatoryFlag: null,\n-  minVal: null,\n-  maxVal: null,\n-  allowSign: null,\n-  allowDecimal: null,\n-  allowMultipleFlag: null,\n-  allowOtherFlag: null,\n-  allowExternalSources: false,\n-  localeNameFlag: false,\n-  localeLocationFlag: false,\n-  geoLocked: null,\n-  requireDoubleEntry: null,\n-  dependentFlag: false,\n-  dependentQuestion: null,\n-  includeInMap: null,\n-  allowPoints: true,\n-  allowLine: true,\n-  allowPolygon: true,\n-  questionValidationFailure: false,\n-  questionTooltipValidationFailure: false,\n-  caddisflyResourceUuid: null,\n-  personalData: null,\n-\n-  showCaddisflyTests: Ember.computed(() => FLOW.router.caddisflyResourceController.get('testsFileLoaded')).property('FLOW.router.caddisflyResourceController.testsFileLoaded'),\n-\n-  showMetaConfig: Ember.computed(() => FLOW.Env.showMonitoringFeature).property('FLOW.Env.showMonitoringFeature'),\n-\n-  amOpenQuestion: Ember.computed(function () {\n-    const selected = FLOW.selectedControl.get('selectedQuestion');\n-    if (selected && this.get('content')) {\n-      const isOpen = (this.content.get('keyId') == FLOW.selectedControl.selectedQuestion.get('keyId'));\n-      return isOpen;\n-    }\n-    return false;\n-  }).property('FLOW.selectedControl.selectedQuestion', 'content.keyId').cacheable(),\n-\n-  amTextType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'FREE_TEXT';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amOptionType: Ember.computed(function () {\n-    return this.type && this.type.get('value') === 'OPTION';\n-  }).property('this.type'),\n-\n-  amNumberType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'NUMBER';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amBarcodeType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') === 'SCAN';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amFreeTextType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'FREE_TEXT';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amGeoType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'GEO';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amCascadeType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'CASCADE';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  hasExtraSettings: Ember.computed(function () {\n-    if (!Ember.none(this.type)) {\n-      const val = this.type.get('value');\n-      return val === 'GEOSHAPE' || val === 'CASCADE' || val === 'NUMBER' || val === 'GEO'\n-      || val === 'FREE_TEXT' || val === 'SCAN' || val === 'OPTION' || val === 'CADDISFLY';\n-    }\n-  }).property('this.type').cacheable(),\n-\n-  amGeoshapeType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'GEOSHAPE';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amDateType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'DATE';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amSignatureType: Ember.computed(function () {\n-    return (this.content && this.content.get('type') === 'SIGNATURE')\n-            || (this.type && this.type.get('value') === 'SIGNATURE');\n-  }).property('this.type'),\n-\n-  amCaddisflyType: Ember.computed(function () {\n-    return this.type && this.type.get('value') == 'CADDISFLY';\n-  }).property('this.type').cacheable(),\n-\n-  showLocaleName: Ember.computed(function () {\n-    if (!this.type) {\n+function getOffset(el) {\n+  // el.offsetTop only returns the top value relative to the closest el with position relative.\n+  // to get the value relative to body (or the document), we need to recursively add all the\n+  // offsets from each parents.\n+  if (!el) return 0;\n+\n+  return getOffset(el.offsetParent) + el.offsetTop;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3165fbad540fb30db8c1006e3008269420992e59"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNzM5NTQ2", "url": "https://github.com/akvo/akvo-flow/pull/3622#pullrequestreview-460739546", "createdAt": "2020-08-04T11:50:44Z", "commit": {"oid": "3165fbad540fb30db8c1006e3008269420992e59"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMTo1MDo0NFrOG7c7hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMTo1MDo0NFrOG7c7hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk5MzE1Ng==", "bodyText": "2", "url": "https://github.com/akvo/akvo-flow/pull/3622#discussion_r464993156", "createdAt": "2020-08-04T11:50:44Z", "author": {"login": "marvinkome"}, "path": "Dashboard/app/js/lib/views/surveys/question-view.js", "diffHunk": "@@ -6,888 +6,1075 @@ function sortByOrder(a, b) {\n   return a.get('order') - b.get('order');\n }\n \n-FLOW.QuestionView = FLOW.View.extend(template('navSurveys/question-view'), observe({\n-  'FLOW.selectedControl.dependentQuestion': 'fillOptionList',\n-  'this.text': 'validateQuestionObserver',\n-  'FLOW.questionOptionsControl.emptyOptions': 'validateQuestionObserver',\n-  'this.tip': 'validateQuestionTooltipObserver',\n-  'this.variableName': 'validateVariableNameObserver',\n-  'this.selectedCaddisflyTestBrand': 'brandsObserver',\n-}), {\n-  content: null,\n-  variableName: null,\n-  text: null,\n-  tip: null,\n-  type: null,\n-  mandatoryFlag: null,\n-  minVal: null,\n-  maxVal: null,\n-  allowSign: null,\n-  allowDecimal: null,\n-  allowMultipleFlag: null,\n-  allowOtherFlag: null,\n-  allowExternalSources: false,\n-  localeNameFlag: false,\n-  localeLocationFlag: false,\n-  geoLocked: null,\n-  requireDoubleEntry: null,\n-  dependentFlag: false,\n-  dependentQuestion: null,\n-  includeInMap: null,\n-  allowPoints: true,\n-  allowLine: true,\n-  allowPolygon: true,\n-  questionValidationFailure: false,\n-  questionTooltipValidationFailure: false,\n-  caddisflyResourceUuid: null,\n-  personalData: null,\n-\n-  showCaddisflyTests: Ember.computed(() => FLOW.router.caddisflyResourceController.get('testsFileLoaded')).property('FLOW.router.caddisflyResourceController.testsFileLoaded'),\n-\n-  showMetaConfig: Ember.computed(() => FLOW.Env.showMonitoringFeature).property('FLOW.Env.showMonitoringFeature'),\n-\n-  amOpenQuestion: Ember.computed(function () {\n-    const selected = FLOW.selectedControl.get('selectedQuestion');\n-    if (selected && this.get('content')) {\n-      const isOpen = (this.content.get('keyId') == FLOW.selectedControl.selectedQuestion.get('keyId'));\n-      return isOpen;\n-    }\n-    return false;\n-  }).property('FLOW.selectedControl.selectedQuestion', 'content.keyId').cacheable(),\n-\n-  amTextType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'FREE_TEXT';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amOptionType: Ember.computed(function () {\n-    return this.type && this.type.get('value') === 'OPTION';\n-  }).property('this.type'),\n-\n-  amNumberType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'NUMBER';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amBarcodeType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') === 'SCAN';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amFreeTextType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'FREE_TEXT';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amGeoType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'GEO';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amCascadeType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'CASCADE';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  hasExtraSettings: Ember.computed(function () {\n-    if (!Ember.none(this.type)) {\n-      const val = this.type.get('value');\n-      return val === 'GEOSHAPE' || val === 'CASCADE' || val === 'NUMBER' || val === 'GEO'\n-      || val === 'FREE_TEXT' || val === 'SCAN' || val === 'OPTION' || val === 'CADDISFLY';\n-    }\n-  }).property('this.type').cacheable(),\n-\n-  amGeoshapeType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'GEOSHAPE';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amDateType: Ember.computed(function () {\n-    if (this.type) {\n-      return this.type.get('value') == 'DATE';\n-    }\n-    return false;\n-  }).property('this.type').cacheable(),\n-\n-  amSignatureType: Ember.computed(function () {\n-    return (this.content && this.content.get('type') === 'SIGNATURE')\n-            || (this.type && this.type.get('value') === 'SIGNATURE');\n-  }).property('this.type'),\n-\n-  amCaddisflyType: Ember.computed(function () {\n-    return this.type && this.type.get('value') == 'CADDISFLY';\n-  }).property('this.type').cacheable(),\n-\n-  showLocaleName: Ember.computed(function () {\n-    if (!this.type) {\n+function getOffset(el) {\n+  // el.offsetTop only returns the top value relative to the closest el with position relative.\n+  // to get the value relative to body (or the document), we need to recursively add all the\n+  // offsets from each parents.\n+  if (!el) return 0;\n+\n+  return getOffset(el.offsetParent) + el.offsetTop;\n+}\n+\n+FLOW.QuestionView = FLOW.View.extend(\n+  template('navSurveys/question-view'),\n+  observe({\n+    'FLOW.selectedControl.dependentQuestion': 'fillOptionList',\n+    'this.text': 'validateQuestionObserver',\n+    'FLOW.questionOptionsControl.emptyOptions': 'validateQuestionObserver',\n+    'this.tip': 'validateQuestionTooltipObserver',\n+    'this.variableName': 'validateVariableNameObserver',\n+    'this.selectedCaddisflyTestBrand': 'brandsObserver',\n+  }),\n+  {\n+    content: null,\n+    variableName: null,\n+    text: null,\n+    tip: null,\n+    type: null,\n+    mandatoryFlag: null,\n+    minVal: null,\n+    maxVal: null,\n+    allowSign: null,\n+    allowDecimal: null,\n+    allowMultipleFlag: null,\n+    allowOtherFlag: null,\n+    allowExternalSources: false,\n+    localeNameFlag: false,\n+    localeLocationFlag: false,\n+    geoLocked: null,\n+    requireDoubleEntry: null,\n+    dependentFlag: false,\n+    dependentQuestion: null,\n+    includeInMap: null,\n+    allowPoints: true,\n+    allowLine: true,\n+    allowPolygon: true,\n+    questionValidationFailure: false,\n+    questionTooltipValidationFailure: false,\n+    caddisflyResourceUuid: null,\n+    personalData: null,\n+\n+    showCaddisflyTests: Ember.computed(() =>\n+      FLOW.router.caddisflyResourceController.get('testsFileLoaded')\n+    ).property('FLOW.router.caddisflyResourceController.testsFileLoaded'),\n+\n+    showMetaConfig: Ember.computed(() => FLOW.Env.showMonitoringFeature).property(\n+      'FLOW.Env.showMonitoringFeature'\n+    ),\n+\n+    amOpenQuestion: Ember.computed(function() {\n+      const selected = FLOW.selectedControl.get('selectedQuestion');\n+      if (selected && this.get('content')) {\n+        const isOpen =\n+          this.content.get('keyId') == FLOW.selectedControl.selectedQuestion.get('keyId');\n+        return isOpen;\n+      }\n       return false;\n-    }\n-    return this.type.get('value') == 'FREE_TEXT'\n-        || this.type.get('value') == 'NUMBER'\n-        || this.type.get('value') == 'OPTION'\n-        || this.type.get('value') == 'SCAN'\n-        || this.type.get('value') == 'CASCADE';\n-  }).property('this.type').cacheable(),\n-\n-  // TODO dependencies\n-  // TODO options\n-  doQuestionEdit() {\n-    if (this.content && (this.content.get('isDirty') || this.content.get('isSaving'))) {\n-      this.showMessageDialog(Ember.String.loc('_question_is_being_saved'),\n-        Ember.String.loc('_question_is_being_saved_text'));\n-      return;\n-    }\n-\n-    this.loadQuestionOptions();\n-\n-    FLOW.selectedControl.set('selectedQuestion', this.get('content'));\n-    this.set('variableName', FLOW.selectedControl.selectedQuestion.get('variableName'));\n-    this.set('text', FLOW.selectedControl.selectedQuestion.get('text'));\n-    this.set('tip', FLOW.selectedControl.selectedQuestion.get('tip'));\n-    this.set('mandatoryFlag', FLOW.selectedControl.selectedQuestion.get('mandatoryFlag'));\n-    this.set('minVal', FLOW.selectedControl.selectedQuestion.get('minVal'));\n-    this.set('maxVal', FLOW.selectedControl.selectedQuestion.get('maxVal'));\n-    this.set('allowSign', FLOW.selectedControl.selectedQuestion.get('allowSign'));\n-    this.set('allowDecimal', FLOW.selectedControl.selectedQuestion.get('allowDecimal'));\n-    this.set('allowMultipleFlag', FLOW.selectedControl.selectedQuestion.get('allowMultipleFlag'));\n-    this.set('allowOtherFlag', FLOW.selectedControl.selectedQuestion.get('allowOtherFlag'));\n-    this.set('allowExternalSources', FLOW.selectedControl.selectedQuestion.get('allowExternalSources'));\n-    this.set('localeNameFlag', FLOW.selectedControl.selectedQuestion.get('localeNameFlag'));\n-    this.set('localeLocationFlag', FLOW.selectedControl.selectedQuestion.get('localeLocationFlag'));\n-    this.set('geoLocked', FLOW.selectedControl.selectedQuestion.get('geoLocked'));\n-    this.set('requireDoubleEntry', FLOW.selectedControl.selectedQuestion.get('requireDoubleEntry'));\n-    this.set('includeInMap', FLOW.selectedControl.selectedQuestion.get('includeInMap'));\n-    this.set('dependentFlag', FLOW.selectedControl.selectedQuestion.get('dependentFlag'));\n-    this.set('allowPoints', FLOW.selectedControl.selectedQuestion.get('allowPoints'));\n-    this.set('allowLine', FLOW.selectedControl.selectedQuestion.get('allowLine'));\n-    this.set('allowPolygon', FLOW.selectedControl.selectedQuestion.get('allowPolygon'));\n-    this.set('cascadeResourceId', FLOW.selectedControl.selectedQuestion.get('cascadeResourceId'));\n-    this.set('caddisflyResourceUuid', FLOW.selectedControl.selectedQuestion.get('caddisflyResourceUuid'));\n-    this.set('personalData', FLOW.selectedControl.selectedQuestion.get('personalData'));\n-\n-    FLOW.optionListControl.set('content', []);\n-\n-    // if the cascadeResourceId is not null, get the resource\n-    if (!Ember.empty(FLOW.selectedControl.selectedQuestion.get('cascadeResourceId'))) {\n-      const cascadeResource = FLOW.store.find(FLOW.CascadeResource, FLOW.selectedControl.selectedQuestion.get('cascadeResourceId'));\n-      FLOW.selectedControl.set('selectedCascadeResource', cascadeResource);\n-    }\n-\n-    // reset selected caddisfly resource\n-    FLOW.selectedControl.set('selectedCaddisflyResource', null);\n-    // if the caddisflyResourceUuid is not null, get the resource\n-    if (!Ember.empty(FLOW.selectedControl.selectedQuestion.get('caddisflyResourceUuid'))) {\n-      const caddResource = FLOW.router.caddisflyResourceController.content.findProperty('uuid', FLOW.selectedControl.selectedQuestion.get('caddisflyResourceUuid'));\n-      if (!Ember.empty(caddResource)) {\n-        this.set('selectedCaddisflyTestSample', this.get('caddisflyTestSamples').findProperty('sample', caddResource.get('sample')));\n-        this.set('selectedCaddisflyTestName', this.get('caddisflyTestNames').findProperty('name', caddResource.get('name')));\n-        this.set('selectedCaddisflyTestBrand', this.get('caddisflyTestBrands').find(item => item.brand === caddResource.get('brand') && item.model === caddResource.get('model') && item.device === caddResource.get('device')));\n-        FLOW.selectedControl.set('selectedCaddisflyResource', caddResource);\n-      }\n-    }\n-    // if the dependentQuestionId is not null, get the question\n-    if (!Ember.empty(FLOW.selectedControl.selectedQuestion.get('dependentQuestionId'))) {\n-      const dependentQuestion = FLOW.store.find(FLOW.Question, FLOW.selectedControl.selectedQuestion.get('dependentQuestionId'));\n-      const dependentAnswer = FLOW.selectedControl.selectedQuestion.get('dependentQuestionAnswer');\n-\n-      // if we have found the question, fill the options\n-      if (dependentQuestion.get('id') !== '0') {\n-        FLOW.selectedControl.set('dependentQuestion', dependentQuestion);\n-        this.fillOptionList();\n-\n-        const dependentAnswerArray = dependentAnswer.split('|');\n-        // find the answer already set and set it to true in the optionlist\n-        FLOW.optionListControl.get('content').forEach((item) => {\n-          if (dependentAnswerArray.indexOf(item.get('value')) > -1) {\n-            item.set('isSelected', true);\n-          }\n-        });\n+    })\n+      .property('FLOW.selectedControl.selectedQuestion', 'content.keyId')\n+      .cacheable(),\n+\n+    amTextType: Ember.computed(function() {\n+      if (this.type) {\n+        return this.type.get('value') == 'FREE_TEXT';\n+      }\n+      return false;\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    amOptionType: Ember.computed(function() {\n+      return this.type && this.type.get('value') === 'OPTION';\n+    }).property('this.type'),\n+\n+    amNumberType: Ember.computed(function() {\n+      if (this.type) {\n+        return this.type.get('value') == 'NUMBER';\n+      }\n+      return false;\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    amBarcodeType: Ember.computed(function() {\n+      if (this.type) {\n+        return this.type.get('value') === 'SCAN';\n+      }\n+      return false;\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    amFreeTextType: Ember.computed(function() {\n+      if (this.type) {\n+        return this.type.get('value') == 'FREE_TEXT';\n+      }\n+      return false;\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    amGeoType: Ember.computed(function() {\n+      if (this.type) {\n+        return this.type.get('value') == 'GEO';\n+      }\n+      return false;\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    amCascadeType: Ember.computed(function() {\n+      if (this.type) {\n+        return this.type.get('value') == 'CASCADE';\n+      }\n+      return false;\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    hasExtraSettings: Ember.computed(function() {\n+      if (!Ember.none(this.type)) {\n+        const val = this.type.get('value');\n+        return (\n+          val === 'GEOSHAPE' ||\n+          val === 'CASCADE' ||\n+          val === 'NUMBER' ||\n+          val === 'GEO' ||\n+          val === 'FREE_TEXT' ||\n+          val === 'SCAN' ||\n+          val === 'OPTION' ||\n+          val === 'CADDISFLY'\n+        );\n       }\n-    }\n-\n-    let questionType = null;\n-    // set the type to the original choice\n-    FLOW.questionTypeControl.get('content').forEach((item) => {\n-      if (item.get('value') == FLOW.selectedControl.selectedQuestion.get('type')) {\n-        questionType = item;\n-      }\n-    });\n-    this.set('type', questionType);\n-  },\n-\n-  /*\n-   *  Load the question options for question editing\n-   */\n-  loadQuestionOptions() {\n-    const c = this.content;\n-    FLOW.questionOptionsControl.set('content', []);\n-    FLOW.questionOptionsControl.set('questionId', c.get('keyId'));\n-\n-    const options = FLOW.store.filter(FLOW.QuestionOption, optionItem => optionItem.get('questionId') === c.get('keyId'));\n-\n-    if (options.get('length')) {\n-      const optionArray = Ember.A(options.toArray().sort(sortByOrder));\n-      FLOW.questionOptionsControl.set('content', optionArray);\n-    } else {\n-      FLOW.questionOptionsControl.loadDefaultOptions();\n-    }\n-  },\n-\n-  fillOptionList() {\n-    if (FLOW.selectedControl.get('dependentQuestion')) {\n-      const dependentQuestion = FLOW.selectedControl.get('dependentQuestion');\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    amGeoshapeType: Ember.computed(function() {\n+      if (this.type) {\n+        return this.type.get('value') == 'GEOSHAPE';\n+      }\n+      return false;\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    amDateType: Ember.computed(function() {\n+      if (this.type) {\n+        return this.type.get('value') == 'DATE';\n+      }\n+      return false;\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    amSignatureType: Ember.computed(function() {\n+      return (\n+        (this.content && this.content.get('type') === 'SIGNATURE') ||\n+        (this.type && this.type.get('value') === 'SIGNATURE')\n+      );\n+    }).property('this.type'),\n+\n+    amCaddisflyType: Ember.computed(function() {\n+      return this.type && this.type.get('value') == 'CADDISFLY';\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    showLocaleName: Ember.computed(function() {\n+      if (!this.type) {\n+        return false;\n+      }\n+      return (\n+        this.type.get('value') == 'FREE_TEXT' ||\n+        this.type.get('value') == 'NUMBER' ||\n+        this.type.get('value') == 'OPTION' ||\n+        this.type.get('value') == 'SCAN' ||\n+        this.type.get('value') == 'CASCADE'\n+      );\n+    })\n+      .property('this.type')\n+      .cacheable(),\n+\n+    // TODO dependencies\n+    // TODO options\n+    doQuestionEdit() {\n+      if (this.content && (this.content.get('isDirty') || this.content.get('isSaving'))) {\n+        this.showMessageDialog(\n+          Ember.String.loc('_question_is_being_saved'),\n+          Ember.String.loc('_question_is_being_saved_text')\n+        );\n+        return;\n+      }\n+\n+      this.loadQuestionOptions();\n+\n+      FLOW.selectedControl.set('selectedQuestion', this.get('content'));\n+      this.set('variableName', FLOW.selectedControl.selectedQuestion.get('variableName'));\n+      this.set('text', FLOW.selectedControl.selectedQuestion.get('text'));\n+      this.set('tip', FLOW.selectedControl.selectedQuestion.get('tip'));\n+      this.set('mandatoryFlag', FLOW.selectedControl.selectedQuestion.get('mandatoryFlag'));\n+      this.set('minVal', FLOW.selectedControl.selectedQuestion.get('minVal'));\n+      this.set('maxVal', FLOW.selectedControl.selectedQuestion.get('maxVal'));\n+      this.set('allowSign', FLOW.selectedControl.selectedQuestion.get('allowSign'));\n+      this.set('allowDecimal', FLOW.selectedControl.selectedQuestion.get('allowDecimal'));\n+      this.set('allowMultipleFlag', FLOW.selectedControl.selectedQuestion.get('allowMultipleFlag'));\n+      this.set('allowOtherFlag', FLOW.selectedControl.selectedQuestion.get('allowOtherFlag'));\n+      this.set(\n+        'allowExternalSources',\n+        FLOW.selectedControl.selectedQuestion.get('allowExternalSources')\n+      );\n+      this.set('localeNameFlag', FLOW.selectedControl.selectedQuestion.get('localeNameFlag'));\n+      this.set(\n+        'localeLocationFlag',\n+        FLOW.selectedControl.selectedQuestion.get('localeLocationFlag')\n+      );\n+      this.set('geoLocked', FLOW.selectedControl.selectedQuestion.get('geoLocked'));\n+      this.set(\n+        'requireDoubleEntry',\n+        FLOW.selectedControl.selectedQuestion.get('requireDoubleEntry')\n+      );\n+      this.set('includeInMap', FLOW.selectedControl.selectedQuestion.get('includeInMap'));\n+      this.set('dependentFlag', FLOW.selectedControl.selectedQuestion.get('dependentFlag'));\n+      this.set('allowPoints', FLOW.selectedControl.selectedQuestion.get('allowPoints'));\n+      this.set('allowLine', FLOW.selectedControl.selectedQuestion.get('allowLine'));\n+      this.set('allowPolygon', FLOW.selectedControl.selectedQuestion.get('allowPolygon'));\n+      this.set('cascadeResourceId', FLOW.selectedControl.selectedQuestion.get('cascadeResourceId'));\n+      this.set(\n+        'caddisflyResourceUuid',\n+        FLOW.selectedControl.selectedQuestion.get('caddisflyResourceUuid')\n+      );\n+      this.set('personalData', FLOW.selectedControl.selectedQuestion.get('personalData'));\n+\n       FLOW.optionListControl.set('content', []);\n-      FLOW.optionListControl.set('currentActive', null);\n \n-      const options = FLOW.store.filter(FLOW.QuestionOption, (item) => {\n-        if (!Ember.none(FLOW.selectedControl.selectedQuestion)) {\n-          return item.get('questionId') == dependentQuestion.get('keyId');\n+      // if the cascadeResourceId is not null, get the resource\n+      if (!Ember.empty(FLOW.selectedControl.selectedQuestion.get('cascadeResourceId'))) {\n+        const cascadeResource = FLOW.store.find(\n+          FLOW.CascadeResource,\n+          FLOW.selectedControl.selectedQuestion.get('cascadeResourceId')\n+        );\n+        FLOW.selectedControl.set('selectedCascadeResource', cascadeResource);\n+      }\n+\n+      // reset selected caddisfly resource\n+      FLOW.selectedControl.set('selectedCaddisflyResource', null);\n+      // if the caddisflyResourceUuid is not null, get the resource\n+      if (!Ember.empty(FLOW.selectedControl.selectedQuestion.get('caddisflyResourceUuid'))) {\n+        const caddResource = FLOW.router.caddisflyResourceController.content.findProperty(\n+          'uuid',\n+          FLOW.selectedControl.selectedQuestion.get('caddisflyResourceUuid')\n+        );\n+        if (!Ember.empty(caddResource)) {\n+          this.set(\n+            'selectedCaddisflyTestSample',\n+            this.get('caddisflyTestSamples').findProperty('sample', caddResource.get('sample'))\n+          );\n+          this.set(\n+            'selectedCaddisflyTestName',\n+            this.get('caddisflyTestNames').findProperty('name', caddResource.get('name'))\n+          );\n+          this.set(\n+            'selectedCaddisflyTestBrand',\n+            this.get('caddisflyTestBrands').find(\n+              item =>\n+                item.brand === caddResource.get('brand') &&\n+                item.model === caddResource.get('model') &&\n+                item.device === caddResource.get('device')\n+            )\n+          );\n+          FLOW.selectedControl.set('selectedCaddisflyResource', caddResource);\n+        }\n+      }\n+      // if the dependentQuestionId is not null, get the question\n+      if (!Ember.empty(FLOW.selectedControl.selectedQuestion.get('dependentQuestionId'))) {\n+        const dependentQuestion = FLOW.store.find(\n+          FLOW.Question,\n+          FLOW.selectedControl.selectedQuestion.get('dependentQuestionId')\n+        );\n+        const dependentAnswer = FLOW.selectedControl.selectedQuestion.get(\n+          'dependentQuestionAnswer'\n+        );\n+\n+        // if we have found the question, fill the options\n+        if (dependentQuestion.get('id') !== '0') {\n+          FLOW.selectedControl.set('dependentQuestion', dependentQuestion);\n+          this.fillOptionList();\n+\n+          const dependentAnswerArray = dependentAnswer.split('|');\n+          // find the answer already set and set it to true in the optionlist\n+          FLOW.optionListControl.get('content').forEach(item => {\n+            if (dependentAnswerArray.indexOf(item.get('value')) > -1) {\n+              item.set('isSelected', true);\n+            }\n+          });\n+        }\n+      }\n+\n+      let questionType = null;\n+      // set the type to the original choice\n+      FLOW.questionTypeControl.get('content').forEach(item => {\n+        if (item.get('value') == FLOW.selectedControl.selectedQuestion.get('type')) {\n+          questionType = item;\n         }\n-        return false;\n       });\n+      this.set('type', questionType);\n+    },\n+\n+    /*\n+     *  Load the question options for question editing\n+     */\n+    loadQuestionOptions() {\n+      const c = this.content;\n+      FLOW.questionOptionsControl.set('content', []);\n+      FLOW.questionOptionsControl.set('questionId', c.get('keyId'));\n+\n+      const options = FLOW.store.filter(\n+        FLOW.QuestionOption,\n+        optionItem => optionItem.get('questionId') === c.get('keyId')\n+      );\n+\n+      if (options.get('length')) {\n+        const optionArray = Ember.A(options.toArray().sort(sortByOrder));\n+        FLOW.questionOptionsControl.set('content', optionArray);\n+      } else {\n+        FLOW.questionOptionsControl.loadDefaultOptions();\n+      }\n+    },\n+\n+    fillOptionList() {\n+      if (FLOW.selectedControl.get('dependentQuestion')) {\n+        const dependentQuestion = FLOW.selectedControl.get('dependentQuestion');\n+        FLOW.optionListControl.set('content', []);\n+        FLOW.optionListControl.set('currentActive', null);\n+\n+        const options = FLOW.store.filter(FLOW.QuestionOption, item => {\n+          if (!Ember.none(FLOW.selectedControl.selectedQuestion)) {\n+            return item.get('questionId') == dependentQuestion.get('keyId');\n+          }\n+          return false;\n+        });\n+\n+        const optionArray = options.toArray();\n+        optionArray.sort((a, b) => a.get('order') - b.get('order'));\n+\n+        optionArray.forEach(item => {\n+          FLOW.optionListControl.get('content').push(\n+            Ember.Object.create({\n+              isSelected: false,\n+              value: item.get('text'),\n+            })\n+          );\n+        });\n+      }\n+    },\n+\n+    doCancelEditQuestion() {\n+      FLOW.selectedControl.set('selectedQuestion', null);\n+    },\n+\n+    doSaveEditQuestion() {\n+      if (this.variableNameValidationFailure) {\n+        this.showMessageDialog(\n+          Ember.String.loc('_variable_name_must_be_valid_and_unique'),\n+          this.variableNameValidationFailureReason\n+        );\n+        return;\n+      }\n+\n+      if (this.questionValidationFailure) {\n+        this.showMessageDialog(\n+          Ember.String.loc('_question_over_500_chars_header'),\n+          Ember.String.loc('_question_over_500_chars_text')\n+        );\n+        return;\n+      }\n+\n+      if (this.questionTooltipValidationFailure) {\n+        this.showMessageDialog(\n+          Ember.String.loc('_tooltip_over_500_chars_header'),\n+          Ember.String.loc('_tooltip_over_500_chars_text')\n+        );\n+        return;\n+      }\n+\n+      if (this.get('amOptionType')) {\n+        // save options to the datastore\n+        FLOW.questionOptionsControl.persistOptions();\n+      }\n+\n+      if (\n+        this.type.get('value') === 'GEOSHAPE' &&\n+        this.get('allowPoints') === false &&\n+        this.get('allowLine') === false &&\n+        this.get('allowPolygon') === false\n+      ) {\n+        this.showMessageDialog(\n+          Ember.String.loc('_no_geoshape_types_header'),\n+          Ember.String.loc('_no_geoshape_types_text')\n+        );\n+        return;\n+      }\n \n-      const optionArray = options.toArray();\n-      optionArray.sort((a, b) => a.get('order') - b.get('order'));\n+      if (\n+        this.type.get('value') === 'CASCADE' &&\n+        Ember.empty(FLOW.selectedControl.get('selectedCascadeResource'))\n+      ) {\n+        FLOW.dialogControl.set('activeAction', 'ignore');\n+        FLOW.dialogControl.set('header', Ember.String.loc('_cascade_resources'));\n+        FLOW.dialogControl.set('message', Ember.String.loc('_cascade_select_resource'));\n+        FLOW.dialogControl.set('showCANCEL', false);\n+        FLOW.dialogControl.set('showDialog', true);\n+        return false;\n+      }\n+\n+      if (this.type.get('value') !== 'NUMBER') {\n+        this.set('minVal', null);\n+        this.set('maxVal', null);\n+        this.set('allowSign', false);\n+        this.set('allowDecimal', false);\n+      }\n+      if (\n+        this.type.get('value') !== 'GEO' &&\n+        this.type.get('value') !== 'GEOSHAPE' &&\n+        this.type.get('value') !== 'SCAN'\n+      ) {\n+        this.set('geoLocked', false);\n+      }\n \n-      optionArray.forEach((item) => {\n-        FLOW.optionListControl.get('content').push(Ember.Object.create({\n-          isSelected: false,\n-          value: item.get('text'),\n-        }));\n+      if (!(this.type.get('value') == 'NUMBER' || this.type.get('value') == 'FREE_TEXT')) {\n+        this.set('requireDoubleEntry', false);\n+      }\n+\n+      if (!(this.type.get('value') == 'CASCADE')) {\n+        this.set('cascadeResourceId', null);\n+      }\n+\n+      if (!(this.type.get('value') == 'CADDISFLY')) {\n+        this.set('caddisflyResourceUuid', null);\n+      }\n+\n+      const path = `${FLOW.selectedControl.selectedSurveyGroup.get(\n+        'code'\n+      )}/${FLOW.selectedControl.selectedSurvey.get(\n+        'name'\n+      )}/${FLOW.selectedControl.selectedQuestionGroup.get('code')}`;\n+      FLOW.selectedControl.selectedQuestion.set('variableName', this.get('variableName'));\n+      FLOW.selectedControl.selectedQuestion.set('text', this.get('text'));\n+      FLOW.selectedControl.selectedQuestion.set('tip', this.get('tip'));\n+      FLOW.selectedControl.selectedQuestion.set('mandatoryFlag', this.get('mandatoryFlag'));\n+      FLOW.selectedControl.selectedQuestion.set('personalData', this.get('personalData'));\n+\n+      const minVal = Ember.empty(this.get('minVal')) ? null : this.get('minVal');\n+      const maxVal = Ember.empty(this.get('maxVal')) ? null : this.get('maxVal');\n+      FLOW.selectedControl.selectedQuestion.set('minVal', minVal);\n+      FLOW.selectedControl.selectedQuestion.set('maxVal', maxVal);\n+\n+      FLOW.selectedControl.selectedQuestion.set('path', path);\n+      FLOW.selectedControl.selectedQuestion.set('allowSign', this.get('allowSign'));\n+      FLOW.selectedControl.selectedQuestion.set('allowDecimal', this.get('allowDecimal'));\n+      FLOW.selectedControl.selectedQuestion.set('allowMultipleFlag', this.get('allowMultipleFlag'));\n+      FLOW.selectedControl.selectedQuestion.set('allowOtherFlag', this.get('allowOtherFlag'));\n+      FLOW.selectedControl.selectedQuestion.set(\n+        'localeNameFlag',\n+        this.get('showLocaleName') && this.get('localeNameFlag')\n+      );\n+      FLOW.selectedControl.selectedQuestion.set(\n+        'localeLocationFlag',\n+        this.get('amGeoType') && this.get('localeLocationFlag')\n+      );\n+      FLOW.selectedControl.selectedQuestion.set('geoLocked', this.get('geoLocked'));\n+      FLOW.selectedControl.selectedQuestion.set(\n+        'requireDoubleEntry',\n+        this.get('requireDoubleEntry')\n+      );\n+      FLOW.selectedControl.selectedQuestion.set('includeInMap', this.get('includeInMap'));\n+      FLOW.selectedControl.selectedQuestion.set('allowPoints', this.get('allowPoints'));\n+      FLOW.selectedControl.selectedQuestion.set('allowLine', this.get('allowLine'));\n+      FLOW.selectedControl.selectedQuestion.set('allowPolygon', this.get('allowPolygon'));\n+\n+      const allowExternalSources =\n+        this.type.get('value') !== 'FREE_TEXT' ? false : this.get('allowExternalSources');\n+      FLOW.selectedControl.selectedQuestion.set('allowExternalSources', allowExternalSources);\n+\n+      let dependentQuestionAnswer = '';\n+      let first = true;\n+\n+      FLOW.optionListControl.get('content').forEach(item => {\n+        if (item.isSelected) {\n+          if (!first) {\n+            dependentQuestionAnswer += '|';\n+          }\n+          first = false;\n+          dependentQuestionAnswer += item.value;\n+        }\n       });\n-    }\n-  },\n-\n-  doCancelEditQuestion() {\n-    FLOW.selectedControl.set('selectedQuestion', null);\n-  },\n-\n-\n-  doSaveEditQuestion() {\n-    if (this.variableNameValidationFailure) {\n-      this.showMessageDialog(Ember.String.loc('_variable_name_must_be_valid_and_unique'), this.variableNameValidationFailureReason);\n-      return;\n-    }\n-\n-    if (this.questionValidationFailure) {\n-      this.showMessageDialog(Ember.String.loc('_question_over_500_chars_header'), Ember.String.loc('_question_over_500_chars_text'));\n-      return;\n-    }\n-\n-    if (this.questionTooltipValidationFailure) {\n-      this.showMessageDialog(Ember.String.loc('_tooltip_over_500_chars_header'), Ember.String.loc('_tooltip_over_500_chars_text'));\n-      return;\n-    }\n-\n-    if (this.get('amOptionType')) {\n-      // save options to the datastore\n-      FLOW.questionOptionsControl.persistOptions();\n-    }\n-\n-    if (this.type.get('value') === 'GEOSHAPE'\n-      && this.get('allowPoints') === false\n-      && this.get('allowLine') === false\n-      && this.get('allowPolygon') === false) {\n-      this.showMessageDialog(Ember.String.loc('_no_geoshape_types_header'), Ember.String.loc('_no_geoshape_types_text'));\n-      return;\n-    }\n-\n-    if (this.type.get('value') === 'CASCADE' && Ember.empty(FLOW.selectedControl.get('selectedCascadeResource'))) {\n-      FLOW.dialogControl.set('activeAction', 'ignore');\n-      FLOW.dialogControl.set('header', Ember.String.loc('_cascade_resources'));\n-      FLOW.dialogControl.set('message', Ember.String.loc('_cascade_select_resource'));\n-      FLOW.dialogControl.set('showCANCEL', false);\n-      FLOW.dialogControl.set('showDialog', true);\n-      return false;\n-    }\n-\n-    if (this.type.get('value') !== 'NUMBER') {\n-      this.set('minVal', null);\n-      this.set('maxVal', null);\n-      this.set('allowSign', false);\n-      this.set('allowDecimal', false);\n-    }\n-    if (this.type.get('value') !== 'GEO' && this.type.get('value') !== 'GEOSHAPE' && this.type.get('value') !== 'SCAN') {\n-      this.set('geoLocked', false);\n-    }\n-\n-    if (!(this.type.get('value') == 'NUMBER' || this.type.get('value') == 'FREE_TEXT')) {\n-      this.set('requireDoubleEntry', false);\n-    }\n-\n-    if (!(this.type.get('value') == 'CASCADE')) {\n-      this.set('cascadeResourceId', null);\n-    }\n-\n-    if (!(this.type.get('value') == 'CADDISFLY')) {\n-      this.set('caddisflyResourceUuid', null);\n-    }\n-\n-    const path = `${FLOW.selectedControl.selectedSurveyGroup.get('code')}/${FLOW.selectedControl.selectedSurvey.get('name')}/${FLOW.selectedControl.selectedQuestionGroup.get('code')}`;\n-    FLOW.selectedControl.selectedQuestion.set('variableName', this.get('variableName'));\n-    FLOW.selectedControl.selectedQuestion.set('text', this.get('text'));\n-    FLOW.selectedControl.selectedQuestion.set('tip', this.get('tip'));\n-    FLOW.selectedControl.selectedQuestion.set('mandatoryFlag', this.get('mandatoryFlag'));\n-    FLOW.selectedControl.selectedQuestion.set('personalData', this.get('personalData'));\n-\n-    const minVal = (Ember.empty(this.get('minVal'))) ? null : this.get('minVal');\n-    const maxVal = (Ember.empty(this.get('maxVal'))) ? null : this.get('maxVal');\n-    FLOW.selectedControl.selectedQuestion.set('minVal', minVal);\n-    FLOW.selectedControl.selectedQuestion.set('maxVal', maxVal);\n-\n-    FLOW.selectedControl.selectedQuestion.set('path', path);\n-    FLOW.selectedControl.selectedQuestion.set('allowSign', this.get('allowSign'));\n-    FLOW.selectedControl.selectedQuestion.set('allowDecimal', this.get('allowDecimal'));\n-    FLOW.selectedControl.selectedQuestion.set('allowMultipleFlag', this.get('allowMultipleFlag'));\n-    FLOW.selectedControl.selectedQuestion.set('allowOtherFlag', this.get('allowOtherFlag'));\n-    FLOW.selectedControl.selectedQuestion.set('localeNameFlag', this.get('showLocaleName') && this.get('localeNameFlag'));\n-    FLOW.selectedControl.selectedQuestion.set('localeLocationFlag', this.get('amGeoType') && this.get('localeLocationFlag'));\n-    FLOW.selectedControl.selectedQuestion.set('geoLocked', this.get('geoLocked'));\n-    FLOW.selectedControl.selectedQuestion.set('requireDoubleEntry', this.get('requireDoubleEntry'));\n-    FLOW.selectedControl.selectedQuestion.set('includeInMap', this.get('includeInMap'));\n-    FLOW.selectedControl.selectedQuestion.set('allowPoints', this.get('allowPoints'));\n-    FLOW.selectedControl.selectedQuestion.set('allowLine', this.get('allowLine'));\n-    FLOW.selectedControl.selectedQuestion.set('allowPolygon', this.get('allowPolygon'));\n-\n-    const allowExternalSources = (this.type.get('value') !== 'FREE_TEXT') ? false : this.get('allowExternalSources');\n-    FLOW.selectedControl.selectedQuestion.set('allowExternalSources', allowExternalSources);\n-\n-    let dependentQuestionAnswer = '';\n-    let first = true;\n-\n-    FLOW.optionListControl.get('content').forEach((item) => {\n-      if (item.isSelected) {\n-        if (!first) {\n-          dependentQuestionAnswer += '|';\n+\n+      if (this.get('dependentFlag') && dependentQuestionAnswer !== '') {\n+        FLOW.selectedControl.selectedQuestion.set('dependentFlag', this.get('dependentFlag'));\n+        FLOW.selectedControl.selectedQuestion.set(\n+          'dependentQuestionId',\n+          FLOW.selectedControl.dependentQuestion.get('keyId')\n+        );\n+        FLOW.selectedControl.selectedQuestion.set(\n+          'dependentQuestionAnswer',\n+          dependentQuestionAnswer\n+        );\n+      } else {\n+        FLOW.selectedControl.selectedQuestion.set('dependentFlag', false);\n+        FLOW.selectedControl.selectedQuestion.set('dependentQuestionId', null);\n+        FLOW.selectedControl.selectedQuestion.set('dependentQuestionAnswer', null);\n+      }\n+\n+      if (this.get('type')) {\n+        FLOW.selectedControl.selectedQuestion.set('type', this.type.get('value'));\n+      }\n+\n+      // deal with cascadeResource\n+      if (this.type.get('value') == 'CASCADE') {\n+        if (!Ember.empty(FLOW.selectedControl.get('selectedCascadeResource'))) {\n+          FLOW.selectedControl.selectedQuestion.set(\n+            'cascadeResourceId',\n+            FLOW.selectedControl.selectedCascadeResource.get('keyId')\n+          );\n         }\n-        first = false;\n-        dependentQuestionAnswer += item.value;\n-      }\n-    });\n-\n-    if (this.get('dependentFlag') && dependentQuestionAnswer !== '') {\n-      FLOW.selectedControl.selectedQuestion.set('dependentFlag', this.get('dependentFlag'));\n-      FLOW.selectedControl.selectedQuestion.set('dependentQuestionId', FLOW.selectedControl.dependentQuestion.get('keyId'));\n-      FLOW.selectedControl.selectedQuestion.set('dependentQuestionAnswer', dependentQuestionAnswer);\n-    } else {\n-      FLOW.selectedControl.selectedQuestion.set('dependentFlag', false);\n-      FLOW.selectedControl.selectedQuestion.set('dependentQuestionId', null);\n-      FLOW.selectedControl.selectedQuestion.set('dependentQuestionAnswer', null);\n-    }\n-\n-    if (this.get('type')) {\n-      FLOW.selectedControl.selectedQuestion.set('type', this.type.get('value'));\n-    }\n-\n-    // deal with cascadeResource\n-    if (this.type.get('value') == 'CASCADE') {\n-      if (!Ember.empty(FLOW.selectedControl.get('selectedCascadeResource'))) {\n-        FLOW.selectedControl.selectedQuestion.set('cascadeResourceId',\n-          FLOW.selectedControl.selectedCascadeResource.get('keyId'));\n-      }\n-    }\n-\n-    // deal with caddisflyResource\n-    if (this.type.get('value') == 'CADDISFLY') {\n-      if (!Ember.empty(FLOW.selectedControl.get('selectedCaddisflyResource'))) {\n-        FLOW.selectedControl.selectedQuestion.set('caddisflyResourceUuid',\n-          FLOW.selectedControl.selectedCaddisflyResource.get('uuid'));\n-      }\n-    }\n-\n-    FLOW.selectedControl.selectedSurvey.set('status', 'NOT_PUBLISHED');\n-    FLOW.store.commit();\n-    FLOW.selectedControl.set('selectedQuestion', null);\n-    FLOW.selectedControl.set('dependentQuestion', null);\n-    FLOW.selectedControl.set('selectedCascadeResource', null);\n-  },\n-\n-  isPartOfMonitoringGroup(questionKeyId) {\n-    const surveyId = FLOW.store.findById(FLOW.Question, questionKeyId).get('surveyId');\n-    const surveyGroupId = FLOW.store.findById(FLOW.Survey, surveyId).get('surveyGroupId');\n-    return FLOW.store.findById(FLOW.SurveyGroup, surveyGroupId).get('monitoringGroup');\n-  },\n-\n-  /**\n-   * Variable name validation\n-   *\n-   * A valid variable name must match /^[A-Za-z0-9_\\-]*$/. Uniqueness\n-   * constraints depends on wether the question is part of a\n-   * monitoring group or not. If the question is part of a\n-   * monitoring group, uniqueness validation _must_ happen on the\n-   * server and cover all questions which are part of that group. If\n-   * not, the uniqueness constraint only covers the survey and can\n-   * be checked on the client.\n-   */\n-  throttleTimer: null,\n-\n-  validateVariableName(args) {\n-    const self = this;\n-    const { selectedQuestion } = FLOW.selectedControl;\n-    const questionKeyId = selectedQuestion.get('keyId');\n-    const variableName = this.get('variableName') || '';\n-    if (FLOW.Env.mandatoryQuestionID && variableName.match(/^\\s*$/)) {\n-      args.failure(Ember.String.loc('_variable_name_mandatory'));\n-    } else if (!variableName.match(/^[A-Za-z0-9_-]*$/)) {\n-      args.failure(Ember.String.loc('_variable_name_only_alphanumeric'));\n-    } else {\n-      const monitoring = this.isPartOfMonitoringGroup(questionKeyId);\n-      if (monitoring) {\n-        clearTimeout(this.throttleTimer);\n-        this.throttleTimer = setTimeout(() => {\n-          $.ajax({\n-            url: `/rest/questions/${questionKeyId}/validate?variableName=${variableName}`,\n-            type: 'POST',\n-            success(data) {\n-              if (data.success) {\n-                // check for special characters once more\n-                if (!self.get('variableName').match(/^[A-Za-z0-9_-]*$/)) {\n-                  args.failure(Ember.String.loc('_variable_name_only_alphanumeric'));\n+      }\n+\n+      // deal with caddisflyResource\n+      if (this.type.get('value') == 'CADDISFLY') {\n+        if (!Ember.empty(FLOW.selectedControl.get('selectedCaddisflyResource'))) {\n+          FLOW.selectedControl.selectedQuestion.set(\n+            'caddisflyResourceUuid',\n+            FLOW.selectedControl.selectedCaddisflyResource.get('uuid')\n+          );\n+        }\n+      }\n+\n+      FLOW.selectedControl.selectedSurvey.set('status', 'NOT_PUBLISHED');\n+      FLOW.store.commit();\n+\n+      FLOW.selectedControl.set('selectedQuestion', null);\n+      FLOW.selectedControl.set('dependentQuestion', null);\n+      FLOW.selectedControl.set('selectedCascadeResource', null);\n+\n+      // scroll to position\n+      const el = document.querySelector(`[data-id=\"${this.get('content').get('keyId')}\"]`);\n+      // removing the offset of the fixed topbar (-150px)\n+      $('body').animate({ scrollTop: getOffset(el) - 150 }, 500);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3165fbad540fb30db8c1006e3008269420992e59"}, "originalPosition": 999}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwODIyNjg1", "url": "https://github.com/akvo/akvo-flow/pull/3622#pullrequestreview-460822685", "createdAt": "2020-08-04T13:41:10Z", "commit": {"oid": "3165fbad540fb30db8c1006e3008269420992e59"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4536, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}