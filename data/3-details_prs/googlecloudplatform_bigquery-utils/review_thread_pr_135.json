{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMDk0MDI5", "number": 135, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowMToyMVrOEVoOOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMToxOTo0NFrOEVoajg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTE0NTU1OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/entity/FixOption.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowMToyMVrOG8flyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMTo0OTo1OFrOG9Fa_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTMyMA==", "bodyText": "nit: stylewise we usually don't use paragraph for field comment.\nJust use \"//...\" for short comment.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/135#discussion_r466085320", "createdAt": "2020-08-06T01:01:21Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/entity/FixOption.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.google.cloud.bigquery.utils.queryfixer.entity;\n+\n+import lombok.Value;\n+\n+@Value(staticConstructor = \"of\")\n+public class FixOption {\n+  /**\n+   * A short description about this fixing option. Usually, if an identifier is to be modified, this\n+   * field will be the new identifier to replace. For example, if a table is to be replaced, this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572992edaae8f993873cf9bbaca9fcbbc65dff4c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNTE1MA==", "bodyText": "Done", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/135#discussion_r466705150", "createdAt": "2020-08-06T21:49:58Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/entity/FixOption.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.google.cloud.bigquery.utils.queryfixer.entity;\n+\n+import lombok.Value;\n+\n+@Value(staticConstructor = \"of\")\n+public class FixOption {\n+  /**\n+   * A short description about this fixing option. Usually, if an identifier is to be modified, this\n+   * field will be the new identifier to replace. For example, if a table is to be replaced, this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTMyMA=="}, "originalCommit": {"oid": "572992edaae8f993873cf9bbaca9fcbbc65dff4c"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTE1NjI0OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/fixer/TableNotFoundFixer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowODowM1rOG8fsJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMTo0OToxNFrOG9FZvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4Njk0OQ==", "bodyText": "maybe add a TODO to make this user configurable.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/135#discussion_r466086949", "createdAt": "2020-08-06T01:08:03Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/fixer/TableNotFoundFixer.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.google.cloud.bigquery.utils.queryfixer.fixer;\n+\n+import com.google.cloud.bigquery.TableId;\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixOption;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixResult;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import com.google.cloud.bigquery.utils.queryfixer.errors.TableNotFoundError;\n+import com.google.cloud.bigquery.utils.queryfixer.service.BigQueryService;\n+import com.google.cloud.bigquery.utils.queryfixer.util.PatternMatcher;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The fixer class responsible for \"table not found\" error. It fixes the error by (1) find the\n+ * similar table under the same project and dataset as the incorrect one, and (2) replace the\n+ * incorrect one with the most similar table.\n+ *\n+ * <p>If no similar tables are found in the dataset, the fixer will directly return the error\n+ * without providing any fix options.\n+ */\n+public class TableNotFoundFixer implements IFixer {\n+\n+  /** This regex is able to parse both project:dataset.table and dataset.table. */\n+  private static final String tableIdRegex = \"^((.*?):)?(.*?)\\\\.(.*?)$\";\n+\n+  private final String query;\n+  private final TableNotFoundError err;\n+  private final BigQueryService bigQueryService;\n+  private final QueryPositionConverter queryPositionConverter;\n+\n+  public TableNotFoundFixer(String query, TableNotFoundError err, BigQueryService bigQueryService) {\n+    this.query = query;\n+    this.err = err;\n+    this.bigQueryService = bigQueryService;\n+    this.queryPositionConverter = new QueryPositionConverter(query);\n+  }\n+\n+  @Override\n+  public FixResult fix() {\n+    TableId fullTableId = constructTableId(err.getTableName());\n+    List<String> tableNames =\n+        bigQueryService.listTableNames(fullTableId.getProject(), fullTableId.getDataset());\n+\n+    StringUtil.SimilarStrings similarTables =\n+        StringUtil.findSimilarWords(tableNames, fullTableId.getTable());\n+\n+    // this is an arbitrary standard. It requires the candidate table should share at least 50%\n+    // similarity as\n+    // the incorrect table typo.\n+    int editDistanceThreshold = (fullTableId.getTable().length() + 1) / 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572992edaae8f993873cf9bbaca9fcbbc65dff4c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNDgyOQ==", "bodyText": "Done", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/135#discussion_r466704829", "createdAt": "2020-08-06T21:49:14Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/fixer/TableNotFoundFixer.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.google.cloud.bigquery.utils.queryfixer.fixer;\n+\n+import com.google.cloud.bigquery.TableId;\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixOption;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixResult;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import com.google.cloud.bigquery.utils.queryfixer.errors.TableNotFoundError;\n+import com.google.cloud.bigquery.utils.queryfixer.service.BigQueryService;\n+import com.google.cloud.bigquery.utils.queryfixer.util.PatternMatcher;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The fixer class responsible for \"table not found\" error. It fixes the error by (1) find the\n+ * similar table under the same project and dataset as the incorrect one, and (2) replace the\n+ * incorrect one with the most similar table.\n+ *\n+ * <p>If no similar tables are found in the dataset, the fixer will directly return the error\n+ * without providing any fix options.\n+ */\n+public class TableNotFoundFixer implements IFixer {\n+\n+  /** This regex is able to parse both project:dataset.table and dataset.table. */\n+  private static final String tableIdRegex = \"^((.*?):)?(.*?)\\\\.(.*?)$\";\n+\n+  private final String query;\n+  private final TableNotFoundError err;\n+  private final BigQueryService bigQueryService;\n+  private final QueryPositionConverter queryPositionConverter;\n+\n+  public TableNotFoundFixer(String query, TableNotFoundError err, BigQueryService bigQueryService) {\n+    this.query = query;\n+    this.err = err;\n+    this.bigQueryService = bigQueryService;\n+    this.queryPositionConverter = new QueryPositionConverter(query);\n+  }\n+\n+  @Override\n+  public FixResult fix() {\n+    TableId fullTableId = constructTableId(err.getTableName());\n+    List<String> tableNames =\n+        bigQueryService.listTableNames(fullTableId.getProject(), fullTableId.getDataset());\n+\n+    StringUtil.SimilarStrings similarTables =\n+        StringUtil.findSimilarWords(tableNames, fullTableId.getTable());\n+\n+    // this is an arbitrary standard. It requires the candidate table should share at least 50%\n+    // similarity as\n+    // the incorrect table typo.\n+    int editDistanceThreshold = (fullTableId.getTable().length() + 1) / 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4Njk0OQ=="}, "originalCommit": {"oid": "572992edaae8f993873cf9bbaca9fcbbc65dff4c"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTE1NzI5OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/fixer/TableNotFoundFixer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowODozNFrOG8fsvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMTo0Nzo0MVrOG9FXIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NzEwMA==", "bodyText": "nit: This", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/135#discussion_r466087100", "createdAt": "2020-08-06T01:08:34Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/fixer/TableNotFoundFixer.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.google.cloud.bigquery.utils.queryfixer.fixer;\n+\n+import com.google.cloud.bigquery.TableId;\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixOption;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixResult;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import com.google.cloud.bigquery.utils.queryfixer.errors.TableNotFoundError;\n+import com.google.cloud.bigquery.utils.queryfixer.service.BigQueryService;\n+import com.google.cloud.bigquery.utils.queryfixer.util.PatternMatcher;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The fixer class responsible for \"table not found\" error. It fixes the error by (1) find the\n+ * similar table under the same project and dataset as the incorrect one, and (2) replace the\n+ * incorrect one with the most similar table.\n+ *\n+ * <p>If no similar tables are found in the dataset, the fixer will directly return the error\n+ * without providing any fix options.\n+ */\n+public class TableNotFoundFixer implements IFixer {\n+\n+  /** This regex is able to parse both project:dataset.table and dataset.table. */\n+  private static final String tableIdRegex = \"^((.*?):)?(.*?)\\\\.(.*?)$\";\n+\n+  private final String query;\n+  private final TableNotFoundError err;\n+  private final BigQueryService bigQueryService;\n+  private final QueryPositionConverter queryPositionConverter;\n+\n+  public TableNotFoundFixer(String query, TableNotFoundError err, BigQueryService bigQueryService) {\n+    this.query = query;\n+    this.err = err;\n+    this.bigQueryService = bigQueryService;\n+    this.queryPositionConverter = new QueryPositionConverter(query);\n+  }\n+\n+  @Override\n+  public FixResult fix() {\n+    TableId fullTableId = constructTableId(err.getTableName());\n+    List<String> tableNames =\n+        bigQueryService.listTableNames(fullTableId.getProject(), fullTableId.getDataset());\n+\n+    StringUtil.SimilarStrings similarTables =\n+        StringUtil.findSimilarWords(tableNames, fullTableId.getTable());\n+\n+    // this is an arbitrary standard. It requires the candidate table should share at least 50%\n+    // similarity as\n+    // the incorrect table typo.\n+    int editDistanceThreshold = (fullTableId.getTable().length() + 1) / 2;\n+\n+    if (similarTables.getStrings().isEmpty()\n+        || similarTables.getDistance() > editDistanceThreshold) {\n+      return FixResult.failure(err);\n+    }\n+\n+    // this method only finds the first occurrence of the incorrect table. It is possible that this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572992edaae8f993873cf9bbaca9fcbbc65dff4c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNDE2MA==", "bodyText": "Done", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/135#discussion_r466704160", "createdAt": "2020-08-06T21:47:41Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/fixer/TableNotFoundFixer.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.google.cloud.bigquery.utils.queryfixer.fixer;\n+\n+import com.google.cloud.bigquery.TableId;\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixOption;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixResult;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import com.google.cloud.bigquery.utils.queryfixer.errors.TableNotFoundError;\n+import com.google.cloud.bigquery.utils.queryfixer.service.BigQueryService;\n+import com.google.cloud.bigquery.utils.queryfixer.util.PatternMatcher;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The fixer class responsible for \"table not found\" error. It fixes the error by (1) find the\n+ * similar table under the same project and dataset as the incorrect one, and (2) replace the\n+ * incorrect one with the most similar table.\n+ *\n+ * <p>If no similar tables are found in the dataset, the fixer will directly return the error\n+ * without providing any fix options.\n+ */\n+public class TableNotFoundFixer implements IFixer {\n+\n+  /** This regex is able to parse both project:dataset.table and dataset.table. */\n+  private static final String tableIdRegex = \"^((.*?):)?(.*?)\\\\.(.*?)$\";\n+\n+  private final String query;\n+  private final TableNotFoundError err;\n+  private final BigQueryService bigQueryService;\n+  private final QueryPositionConverter queryPositionConverter;\n+\n+  public TableNotFoundFixer(String query, TableNotFoundError err, BigQueryService bigQueryService) {\n+    this.query = query;\n+    this.err = err;\n+    this.bigQueryService = bigQueryService;\n+    this.queryPositionConverter = new QueryPositionConverter(query);\n+  }\n+\n+  @Override\n+  public FixResult fix() {\n+    TableId fullTableId = constructTableId(err.getTableName());\n+    List<String> tableNames =\n+        bigQueryService.listTableNames(fullTableId.getProject(), fullTableId.getDataset());\n+\n+    StringUtil.SimilarStrings similarTables =\n+        StringUtil.findSimilarWords(tableNames, fullTableId.getTable());\n+\n+    // this is an arbitrary standard. It requires the candidate table should share at least 50%\n+    // similarity as\n+    // the incorrect table typo.\n+    int editDistanceThreshold = (fullTableId.getTable().length() + 1) / 2;\n+\n+    if (similarTables.getStrings().isEmpty()\n+        || similarTables.getDistance() > editDistanceThreshold) {\n+      return FixResult.failure(err);\n+    }\n+\n+    // this method only finds the first occurrence of the incorrect table. It is possible that this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NzEwMA=="}, "originalCommit": {"oid": "572992edaae8f993873cf9bbaca9fcbbc65dff4c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTE3NzEwOnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/fixer/TableNotFoundFixer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMToxOTo0NFrOG8f4WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMTo0NjoyMFrOG9FVAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5MDA3Mw==", "bodyText": "So we rely on the error message to identify if they used legacy sql?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/135#discussion_r466090073", "createdAt": "2020-08-06T01:19:44Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/fixer/TableNotFoundFixer.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.google.cloud.bigquery.utils.queryfixer.fixer;\n+\n+import com.google.cloud.bigquery.TableId;\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixOption;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixResult;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import com.google.cloud.bigquery.utils.queryfixer.errors.TableNotFoundError;\n+import com.google.cloud.bigquery.utils.queryfixer.service.BigQueryService;\n+import com.google.cloud.bigquery.utils.queryfixer.util.PatternMatcher;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The fixer class responsible for \"table not found\" error. It fixes the error by (1) find the\n+ * similar table under the same project and dataset as the incorrect one, and (2) replace the\n+ * incorrect one with the most similar table.\n+ *\n+ * <p>If no similar tables are found in the dataset, the fixer will directly return the error\n+ * without providing any fix options.\n+ */\n+public class TableNotFoundFixer implements IFixer {\n+\n+  /** This regex is able to parse both project:dataset.table and dataset.table. */\n+  private static final String tableIdRegex = \"^((.*?):)?(.*?)\\\\.(.*?)$\";\n+\n+  private final String query;\n+  private final TableNotFoundError err;\n+  private final BigQueryService bigQueryService;\n+  private final QueryPositionConverter queryPositionConverter;\n+\n+  public TableNotFoundFixer(String query, TableNotFoundError err, BigQueryService bigQueryService) {\n+    this.query = query;\n+    this.err = err;\n+    this.bigQueryService = bigQueryService;\n+    this.queryPositionConverter = new QueryPositionConverter(query);\n+  }\n+\n+  @Override\n+  public FixResult fix() {\n+    TableId fullTableId = constructTableId(err.getTableName());\n+    List<String> tableNames =\n+        bigQueryService.listTableNames(fullTableId.getProject(), fullTableId.getDataset());\n+\n+    StringUtil.SimilarStrings similarTables =\n+        StringUtil.findSimilarWords(tableNames, fullTableId.getTable());\n+\n+    // this is an arbitrary standard. It requires the candidate table should share at least 50%\n+    // similarity as\n+    // the incorrect table typo.\n+    int editDistanceThreshold = (fullTableId.getTable().length() + 1) / 2;\n+\n+    if (similarTables.getStrings().isEmpty()\n+        || similarTables.getDistance() > editDistanceThreshold) {\n+      return FixResult.failure(err);\n+    }\n+\n+    // this method only finds the first occurrence of the incorrect table. It is possible that this\n+    // table exists in multiple positions of this query. What is worse, it is possible that the\n+    // table name is also part of a literal, then this auto fixing may have problem. The ultimate\n+    // solution for this issue is to use Parser to find the correct position of this table.\n+    int tableStartIndex = findTheIndexOfIncorrectTable();\n+\n+    List<FixOption> fixOptions =\n+        similarTables.getStrings().stream()\n+            .map(\n+                table -> {\n+                  String fullTableName =\n+                      constructFullTableName(\n+                          fullTableId.getProject(), fullTableId.getDataset(), table);\n+                  String fixedQuery = replaceTable(fullTableName, tableStartIndex);\n+                  return FixOption.of(fullTableName, fixedQuery);\n+                })\n+            .collect(Collectors.toList());\n+\n+    return FixResult.success(/*approach= */ \"Replace the table name.\", fixOptions, err);\n+  }\n+\n+  private TableId constructTableId(String fullTableName) {\n+    List<String> contents = PatternMatcher.extract(fullTableName, tableIdRegex);\n+    String projectId;\n+    // Assume the table name from dry-run message is always correct, so no check is performed for\n+    // matching.\n+    // If contents[0] == null, it means the table looks like dataset.table, so the project ID should\n+    // be fetched from the BigQuery Client.\n+    if (contents.get(0) == null) {\n+      projectId = bigQueryService.getBigQueryOptions().getProjectId();\n+    } else {\n+      projectId = contents.get(1);\n+    }\n+    String datasetId = contents.get(2);\n+    String tableName = contents.get(3);\n+    return TableId.of(projectId, datasetId, tableName);\n+  }\n+\n+  private String constructFullTableName(String projectId, String datasetId, String tableName) {\n+    return String.format(\"%s.%s.%s\", projectId, datasetId, tableName);\n+  }\n+\n+  private int findTheIndexOfIncorrectTable() {\n+    // the table in the error message is presented in the legacySQL mode, but this fixer is used to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572992edaae8f993873cf9bbaca9fcbbc65dff4c"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMzYxOA==", "bodyText": "Here I mean the error message represents the table in legacySQL format, which is project:dataset.table. I guess we could be an issue for BigQuery to update this error message.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/135#discussion_r466703618", "createdAt": "2020-08-06T21:46:20Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/fixer/TableNotFoundFixer.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.google.cloud.bigquery.utils.queryfixer.fixer;\n+\n+import com.google.cloud.bigquery.TableId;\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixOption;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.FixResult;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import com.google.cloud.bigquery.utils.queryfixer.errors.TableNotFoundError;\n+import com.google.cloud.bigquery.utils.queryfixer.service.BigQueryService;\n+import com.google.cloud.bigquery.utils.queryfixer.util.PatternMatcher;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The fixer class responsible for \"table not found\" error. It fixes the error by (1) find the\n+ * similar table under the same project and dataset as the incorrect one, and (2) replace the\n+ * incorrect one with the most similar table.\n+ *\n+ * <p>If no similar tables are found in the dataset, the fixer will directly return the error\n+ * without providing any fix options.\n+ */\n+public class TableNotFoundFixer implements IFixer {\n+\n+  /** This regex is able to parse both project:dataset.table and dataset.table. */\n+  private static final String tableIdRegex = \"^((.*?):)?(.*?)\\\\.(.*?)$\";\n+\n+  private final String query;\n+  private final TableNotFoundError err;\n+  private final BigQueryService bigQueryService;\n+  private final QueryPositionConverter queryPositionConverter;\n+\n+  public TableNotFoundFixer(String query, TableNotFoundError err, BigQueryService bigQueryService) {\n+    this.query = query;\n+    this.err = err;\n+    this.bigQueryService = bigQueryService;\n+    this.queryPositionConverter = new QueryPositionConverter(query);\n+  }\n+\n+  @Override\n+  public FixResult fix() {\n+    TableId fullTableId = constructTableId(err.getTableName());\n+    List<String> tableNames =\n+        bigQueryService.listTableNames(fullTableId.getProject(), fullTableId.getDataset());\n+\n+    StringUtil.SimilarStrings similarTables =\n+        StringUtil.findSimilarWords(tableNames, fullTableId.getTable());\n+\n+    // this is an arbitrary standard. It requires the candidate table should share at least 50%\n+    // similarity as\n+    // the incorrect table typo.\n+    int editDistanceThreshold = (fullTableId.getTable().length() + 1) / 2;\n+\n+    if (similarTables.getStrings().isEmpty()\n+        || similarTables.getDistance() > editDistanceThreshold) {\n+      return FixResult.failure(err);\n+    }\n+\n+    // this method only finds the first occurrence of the incorrect table. It is possible that this\n+    // table exists in multiple positions of this query. What is worse, it is possible that the\n+    // table name is also part of a literal, then this auto fixing may have problem. The ultimate\n+    // solution for this issue is to use Parser to find the correct position of this table.\n+    int tableStartIndex = findTheIndexOfIncorrectTable();\n+\n+    List<FixOption> fixOptions =\n+        similarTables.getStrings().stream()\n+            .map(\n+                table -> {\n+                  String fullTableName =\n+                      constructFullTableName(\n+                          fullTableId.getProject(), fullTableId.getDataset(), table);\n+                  String fixedQuery = replaceTable(fullTableName, tableStartIndex);\n+                  return FixOption.of(fullTableName, fixedQuery);\n+                })\n+            .collect(Collectors.toList());\n+\n+    return FixResult.success(/*approach= */ \"Replace the table name.\", fixOptions, err);\n+  }\n+\n+  private TableId constructTableId(String fullTableName) {\n+    List<String> contents = PatternMatcher.extract(fullTableName, tableIdRegex);\n+    String projectId;\n+    // Assume the table name from dry-run message is always correct, so no check is performed for\n+    // matching.\n+    // If contents[0] == null, it means the table looks like dataset.table, so the project ID should\n+    // be fetched from the BigQuery Client.\n+    if (contents.get(0) == null) {\n+      projectId = bigQueryService.getBigQueryOptions().getProjectId();\n+    } else {\n+      projectId = contents.get(1);\n+    }\n+    String datasetId = contents.get(2);\n+    String tableName = contents.get(3);\n+    return TableId.of(projectId, datasetId, tableName);\n+  }\n+\n+  private String constructFullTableName(String projectId, String datasetId, String tableName) {\n+    return String.format(\"%s.%s.%s\", projectId, datasetId, tableName);\n+  }\n+\n+  private int findTheIndexOfIncorrectTable() {\n+    // the table in the error message is presented in the legacySQL mode, but this fixer is used to", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5MDA3Mw=="}, "originalCommit": {"oid": "572992edaae8f993873cf9bbaca9fcbbc65dff4c"}, "originalPosition": 103}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3085, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}