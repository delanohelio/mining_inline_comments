{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2Mzg2NzM4", "number": 145, "title": "Query Verification: Implemented td verification", "bodyText": "Implemented the TD side of data aware verification.", "createdAt": "2020-08-11T22:22:27Z", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145", "merged": true, "mergeCommit": {"oid": "c7d5ae6a227837c91e228821f13cc968bdd35db0"}, "closed": true, "closedAt": "2020-08-14T22:01:38Z", "author": {"login": "krishsuchdev"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9-XUlgH2gAyNDY2Mzg2NzM4OmY4Y2JiNTVhZjZjOWExNWU1ZjBiMThkNjEyNmEwMmM2ZGRjYTA4NGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-79O0AH2gAyNDY2Mzg2NzM4OjA3ZjlmMzM1ZTg4MDZkODUyMjBiMDVhM2JhOTZiYTA0MWNiNTY5NDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "author": {"user": {"login": "krishsuchdev", "name": "Krish Suchdev"}}, "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "committedDate": "2020-08-11T22:15:03Z", "message": "Implemented td verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDY5NzA3", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#pullrequestreview-465469707", "createdAt": "2020-08-11T22:24:10Z", "commit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNDoxMFrOG_LSFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNjo1MVrOG_LWNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODMyNA==", "bodyText": "Maybe have some comments to explain why not starting with 0", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468898324", "createdAt": "2020-08-11T22:24:10Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODczMw==", "bodyText": "Do we need to close this stream?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468898733", "createdAt": "2020-08-11T22:25:09Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODg5NQ==", "bodyText": "use String.format(...)", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468898895", "createdAt": "2020-08-11T22:25:31Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5OTE2Mw==", "bodyText": "Can just be List", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468899163", "createdAt": "2020-08-11T22:26:13Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";\n+\n+                    statement += tableReference.get(\"datasetId\").getAsString() + \".\" + tableReference.get(\"tableId\").getAsString() + \" (\";\n+\n+                    // Generate column syntax for each field provided in JSON\n+                    ArrayList<String> columns = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5OTI2Mw==", "bodyText": "Use StringBuilder and append?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468899263", "createdAt": "2020-08-11T22:26:32Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";\n+\n+                    statement += tableReference.get(\"datasetId\").getAsString() + \".\" + tableReference.get(\"tableId\").getAsString() + \" (\";\n+\n+                    // Generate column syntax for each field provided in JSON\n+                    ArrayList<String> columns = new ArrayList<String>();\n+                    for (JsonElement fieldElement : schemaObject.getAsJsonArray(\"fields\")) {\n+                        JsonObject field = fieldElement.getAsJsonObject();\n+\n+                        // Assemble column syntax\n+                        String column = field.get(\"name\").getAsString() + \" \" + field.get(\"type\").getAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5OTM4MQ==", "bodyText": "StringBuilder instead?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468899381", "createdAt": "2020-08-11T22:26:51Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 203}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NTE0MDk2", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#pullrequestreview-465514096", "createdAt": "2020-08-12T00:26:09Z", "commit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMDoyNjowOVrOG_NonQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMDoyNjo1NlrOG_NpiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNjg2MQ==", "bodyText": "This isn't going to work if there's semicolons in quotes I think. Can you add a comment noting this?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468936861", "createdAt": "2020-08-12T00:26:09Z", "author": {"login": "Luminarys"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNzA5Nw==", "bodyText": "You can use inferred types here, i.e. new ArrayList<>();", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468937097", "createdAt": "2020-08-12T00:26:56Z", "author": {"login": "Luminarys"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";\n+\n+                    statement += tableReference.get(\"datasetId\").getAsString() + \".\" + tableReference.get(\"tableId\").getAsString() + \" (\";\n+\n+                    // Generate column syntax for each field provided in JSON\n+                    ArrayList<String> columns = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 208}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a875bdafffd454dab3d634ffe14832136f62391", "author": {"user": {"login": "krishsuchdev", "name": "Krish Suchdev"}}, "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/1a875bdafffd454dab3d634ffe14832136f62391", "committedDate": "2020-08-14T14:56:20Z", "message": "Merge branch 'master' into td"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fe279cf4e5210501be8ab8f84403ab70b52c620", "author": {"user": {"login": "krishsuchdev", "name": "Krish Suchdev"}}, "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/2fe279cf4e5210501be8ab8f84403ab70b52c620", "committedDate": "2020-08-14T15:05:54Z", "message": "Fix query job results builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e947cbff25af7f0d1990f71990539afd543f8b9", "author": {"user": {"login": "krishsuchdev", "name": "Krish Suchdev"}}, "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/6e947cbff25af7f0d1990f71990539afd543f8b9", "committedDate": "2020-08-14T15:06:25Z", "message": "Add decimal precision"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62ec042b5f725fef29704fcd257b20e29e63bd68", "author": {"user": {"login": "krishsuchdev", "name": "Krish Suchdev"}}, "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/62ec042b5f725fef29704fcd257b20e29e63bd68", "committedDate": "2020-08-14T16:23:22Z", "message": "Updates on generating ddl statements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NzIyMjU0", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#pullrequestreview-467722254", "createdAt": "2020-08-14T16:46:50Z", "commit": {"oid": "62ec042b5f725fef29704fcd257b20e29e63bd68"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e76263286423970d54468d2e5af6f568d84ebfd", "author": {"user": {"login": "krishsuchdev", "name": "Krish Suchdev"}}, "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/5e76263286423970d54468d2e5af6f568d84ebfd", "committedDate": "2020-08-14T21:57:39Z", "message": "Update tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd5cb35854e089886316aa3e9e83d3a3c66ee239", "author": {"user": {"login": "krishsuchdev", "name": "Krish Suchdev"}}, "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/cd5cb35854e089886316aa3e9e83d3a3c66ee239", "committedDate": "2020-08-14T21:57:58Z", "message": "Update README"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07f9f335e8806d85220b05a3ba96ba041cb56940", "author": {"user": {"login": "krishsuchdev", "name": "Krish Suchdev"}}, "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/07f9f335e8806d85220b05a3ba96ba041cb56940", "committedDate": "2020-08-14T22:00:40Z", "message": "Merge branch 'master' into td"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 736, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}