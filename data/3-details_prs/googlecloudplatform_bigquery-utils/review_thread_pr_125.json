{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5NjYyNDY3", "number": 125, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNjo1MjowMFrOEUfPCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOToyNjoyNFrOEVIv2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5OTE4NzI4OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNjo1MjowMFrOG6uD0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxOTowMzoxOFrOG7FSGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNTIzNA==", "bodyText": "nit: \"Use\" and unwanted new line :)", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464225234", "createdAt": "2020-08-03T06:52:00Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.google.cloud.bigquery.utils.queryfixer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@Getter\n+public class QueryPositionConverter {\n+\n+  /** The query used to convert indices and positions. */\n+  private final String query;\n+\n+  /** The index in the query corresponding to the starting position of each line. */\n+  private List<Integer> startIndices;\n+\n+  public QueryPositionConverter(String query) {\n+    this.query = query;\n+    fillInStartIndices(query);\n+  }\n+\n+  private void fillInStartIndices(String query) {\n+    startIndices = new ArrayList<>();\n+    startIndices.add(0);\n+    for (int i = 0; i < query.length() - 1; i++) {\n+      if (query.charAt(i) == '\\n') {\n+        startIndices.add(i + 1);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Convert row and column number to an index.\n+   *\n+   * @param row row number\n+   * @param col col number\n+   * @return index\n+   */\n+  public int posToIndex(int row, int col) {\n+    if (row > startIndices.size()) {\n+      return -1;\n+    }\n+\n+    // row and col are 1-index, but the String is 0-index\n+    // therefore -1 is needed for conversion.\n+    int index = startIndices.get(row - 1) + col - 1;\n+\n+    int nextLineStartIndex;\n+    if (row == startIndices.size()) {\n+      nextLineStartIndex = query.length();\n+    } else {\n+      nextLineStartIndex = startIndices.get(row);\n+    }\n+    if (index > nextLineStartIndex) {\n+      return -1;\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Convert index to position.\n+   *\n+   * @param index index to be converted\n+   * @return position\n+   */\n+  public Position indexToPos(int index) {\n+    if (index < 0 || index >= query.length()) {\n+      return Position.invalid();\n+    }\n+    int line = findStartLine(index);\n+    return new Position(line, index - startIndices.get(line - 1) + 1);\n+  }\n+\n+  // use the binary search on startIndices to find the greatest start index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNTcyMA==", "bodyText": "Done", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464605720", "createdAt": "2020-08-03T19:03:18Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.google.cloud.bigquery.utils.queryfixer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@Getter\n+public class QueryPositionConverter {\n+\n+  /** The query used to convert indices and positions. */\n+  private final String query;\n+\n+  /** The index in the query corresponding to the starting position of each line. */\n+  private List<Integer> startIndices;\n+\n+  public QueryPositionConverter(String query) {\n+    this.query = query;\n+    fillInStartIndices(query);\n+  }\n+\n+  private void fillInStartIndices(String query) {\n+    startIndices = new ArrayList<>();\n+    startIndices.add(0);\n+    for (int i = 0; i < query.length() - 1; i++) {\n+      if (query.charAt(i) == '\\n') {\n+        startIndices.add(i + 1);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Convert row and column number to an index.\n+   *\n+   * @param row row number\n+   * @param col col number\n+   * @return index\n+   */\n+  public int posToIndex(int row, int col) {\n+    if (row > startIndices.size()) {\n+      return -1;\n+    }\n+\n+    // row and col are 1-index, but the String is 0-index\n+    // therefore -1 is needed for conversion.\n+    int index = startIndices.get(row - 1) + col - 1;\n+\n+    int nextLineStartIndex;\n+    if (row == startIndices.size()) {\n+      nextLineStartIndex = query.length();\n+    } else {\n+      nextLineStartIndex = startIndices.get(row);\n+    }\n+    if (index > nextLineStartIndex) {\n+      return -1;\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Convert index to position.\n+   *\n+   * @param index index to be converted\n+   * @return position\n+   */\n+  public Position indexToPos(int index) {\n+    if (index < 0 || index >= query.length()) {\n+      return Position.invalid();\n+    }\n+    int line = findStartLine(index);\n+    return new Position(line, index - startIndices.get(line - 1) + 1);\n+  }\n+\n+  // use the binary search on startIndices to find the greatest start index", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNTIzNA=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5OTE4OTg0OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNjo1MzowNlrOG6uFSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTowMzozN1rOG7tjVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNTYxMQ==", "bodyText": "why right - left + 1? not right -left", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464225611", "createdAt": "2020-08-03T06:53:06Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.google.cloud.bigquery.utils.queryfixer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@Getter\n+public class QueryPositionConverter {\n+\n+  /** The query used to convert indices and positions. */\n+  private final String query;\n+\n+  /** The index in the query corresponding to the starting position of each line. */\n+  private List<Integer> startIndices;\n+\n+  public QueryPositionConverter(String query) {\n+    this.query = query;\n+    fillInStartIndices(query);\n+  }\n+\n+  private void fillInStartIndices(String query) {\n+    startIndices = new ArrayList<>();\n+    startIndices.add(0);\n+    for (int i = 0; i < query.length() - 1; i++) {\n+      if (query.charAt(i) == '\\n') {\n+        startIndices.add(i + 1);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Convert row and column number to an index.\n+   *\n+   * @param row row number\n+   * @param col col number\n+   * @return index\n+   */\n+  public int posToIndex(int row, int col) {\n+    if (row > startIndices.size()) {\n+      return -1;\n+    }\n+\n+    // row and col are 1-index, but the String is 0-index\n+    // therefore -1 is needed for conversion.\n+    int index = startIndices.get(row - 1) + col - 1;\n+\n+    int nextLineStartIndex;\n+    if (row == startIndices.size()) {\n+      nextLineStartIndex = query.length();\n+    } else {\n+      nextLineStartIndex = startIndices.get(row);\n+    }\n+    if (index > nextLineStartIndex) {\n+      return -1;\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Convert index to position.\n+   *\n+   * @param index index to be converted\n+   * @return position\n+   */\n+  public Position indexToPos(int index) {\n+    if (index < 0 || index >= query.length()) {\n+      return Position.invalid();\n+    }\n+    int line = findStartLine(index);\n+    return new Position(line, index - startIndices.get(line - 1) + 1);\n+  }\n+\n+  // use the binary search on startIndices to find the greatest start index\n+  // that is less or equal index.\n+  // the return line should be 1-index\n+  private int findStartLine(int index) {\n+    int left = 0, right = startIndices.size() - 1;\n+    while (left < right) {\n+      // in case left + right overflow.\n+      int mid = left + (right - left + 1) / 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzQ3MQ==", "bodyText": "It corresponds to the mid - 1 in line 89. When left + 1 == right, then mid = right. Despite the result of startIndices.get(mid) < index, the for loop will be broken given finally left == right. If we don't have the +1, then it will becomes a dead loop if startIndices.get(mid) < index == true.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464607471", "createdAt": "2020-08-03T19:07:04Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.google.cloud.bigquery.utils.queryfixer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@Getter\n+public class QueryPositionConverter {\n+\n+  /** The query used to convert indices and positions. */\n+  private final String query;\n+\n+  /** The index in the query corresponding to the starting position of each line. */\n+  private List<Integer> startIndices;\n+\n+  public QueryPositionConverter(String query) {\n+    this.query = query;\n+    fillInStartIndices(query);\n+  }\n+\n+  private void fillInStartIndices(String query) {\n+    startIndices = new ArrayList<>();\n+    startIndices.add(0);\n+    for (int i = 0; i < query.length() - 1; i++) {\n+      if (query.charAt(i) == '\\n') {\n+        startIndices.add(i + 1);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Convert row and column number to an index.\n+   *\n+   * @param row row number\n+   * @param col col number\n+   * @return index\n+   */\n+  public int posToIndex(int row, int col) {\n+    if (row > startIndices.size()) {\n+      return -1;\n+    }\n+\n+    // row and col are 1-index, but the String is 0-index\n+    // therefore -1 is needed for conversion.\n+    int index = startIndices.get(row - 1) + col - 1;\n+\n+    int nextLineStartIndex;\n+    if (row == startIndices.size()) {\n+      nextLineStartIndex = query.length();\n+    } else {\n+      nextLineStartIndex = startIndices.get(row);\n+    }\n+    if (index > nextLineStartIndex) {\n+      return -1;\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Convert index to position.\n+   *\n+   * @param index index to be converted\n+   * @return position\n+   */\n+  public Position indexToPos(int index) {\n+    if (index < 0 || index >= query.length()) {\n+      return Position.invalid();\n+    }\n+    int line = findStartLine(index);\n+    return new Position(line, index - startIndices.get(line - 1) + 1);\n+  }\n+\n+  // use the binary search on startIndices to find the greatest start index\n+  // that is less or equal index.\n+  // the return line should be 1-index\n+  private int findStartLine(int index) {\n+    int left = 0, right = startIndices.size() - 1;\n+    while (left < right) {\n+      // in case left + right overflow.\n+      int mid = left + (right - left + 1) / 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNTYxMQ=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NTQ5Mw==", "bodyText": "Can you have (right - left + 1) and right = mid instead then?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465265493", "createdAt": "2020-08-04T19:03:37Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.google.cloud.bigquery.utils.queryfixer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@Getter\n+public class QueryPositionConverter {\n+\n+  /** The query used to convert indices and positions. */\n+  private final String query;\n+\n+  /** The index in the query corresponding to the starting position of each line. */\n+  private List<Integer> startIndices;\n+\n+  public QueryPositionConverter(String query) {\n+    this.query = query;\n+    fillInStartIndices(query);\n+  }\n+\n+  private void fillInStartIndices(String query) {\n+    startIndices = new ArrayList<>();\n+    startIndices.add(0);\n+    for (int i = 0; i < query.length() - 1; i++) {\n+      if (query.charAt(i) == '\\n') {\n+        startIndices.add(i + 1);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Convert row and column number to an index.\n+   *\n+   * @param row row number\n+   * @param col col number\n+   * @return index\n+   */\n+  public int posToIndex(int row, int col) {\n+    if (row > startIndices.size()) {\n+      return -1;\n+    }\n+\n+    // row and col are 1-index, but the String is 0-index\n+    // therefore -1 is needed for conversion.\n+    int index = startIndices.get(row - 1) + col - 1;\n+\n+    int nextLineStartIndex;\n+    if (row == startIndices.size()) {\n+      nextLineStartIndex = query.length();\n+    } else {\n+      nextLineStartIndex = startIndices.get(row);\n+    }\n+    if (index > nextLineStartIndex) {\n+      return -1;\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Convert index to position.\n+   *\n+   * @param index index to be converted\n+   * @return position\n+   */\n+  public Position indexToPos(int index) {\n+    if (index < 0 || index >= query.length()) {\n+      return Position.invalid();\n+    }\n+    int line = findStartLine(index);\n+    return new Position(line, index - startIndices.get(line - 1) + 1);\n+  }\n+\n+  // use the binary search on startIndices to find the greatest start index\n+  // that is less or equal index.\n+  // the return line should be 1-index\n+  private int findStartLine(int index) {\n+    int left = 0, right = startIndices.size() - 1;\n+    while (left < right) {\n+      // in case left + right overflow.\n+      int mid = left + (right - left + 1) / 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNTYxMQ=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5OTE5NzQ5OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNjo1NjoyNFrOG6uJ6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODo1MzoxMlrOG7E-tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNjc5Mw==", "bodyText": "if there is only one element, left = right = 0, seems you will return 1?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464226793", "createdAt": "2020-08-03T06:56:24Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.google.cloud.bigquery.utils.queryfixer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@Getter\n+public class QueryPositionConverter {\n+\n+  /** The query used to convert indices and positions. */\n+  private final String query;\n+\n+  /** The index in the query corresponding to the starting position of each line. */\n+  private List<Integer> startIndices;\n+\n+  public QueryPositionConverter(String query) {\n+    this.query = query;\n+    fillInStartIndices(query);\n+  }\n+\n+  private void fillInStartIndices(String query) {\n+    startIndices = new ArrayList<>();\n+    startIndices.add(0);\n+    for (int i = 0; i < query.length() - 1; i++) {\n+      if (query.charAt(i) == '\\n') {\n+        startIndices.add(i + 1);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Convert row and column number to an index.\n+   *\n+   * @param row row number\n+   * @param col col number\n+   * @return index\n+   */\n+  public int posToIndex(int row, int col) {\n+    if (row > startIndices.size()) {\n+      return -1;\n+    }\n+\n+    // row and col are 1-index, but the String is 0-index\n+    // therefore -1 is needed for conversion.\n+    int index = startIndices.get(row - 1) + col - 1;\n+\n+    int nextLineStartIndex;\n+    if (row == startIndices.size()) {\n+      nextLineStartIndex = query.length();\n+    } else {\n+      nextLineStartIndex = startIndices.get(row);\n+    }\n+    if (index > nextLineStartIndex) {\n+      return -1;\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Convert index to position.\n+   *\n+   * @param index index to be converted\n+   * @return position\n+   */\n+  public Position indexToPos(int index) {\n+    if (index < 0 || index >= query.length()) {\n+      return Position.invalid();\n+    }\n+    int line = findStartLine(index);\n+    return new Position(line, index - startIndices.get(line - 1) + 1);\n+  }\n+\n+  // use the binary search on startIndices to find the greatest start index\n+  // that is less or equal index.\n+  // the return line should be 1-index\n+  private int findStartLine(int index) {\n+    int left = 0, right = startIndices.size() - 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwMDc1OA==", "bodyText": "Yes, you are right, because the returned line number should be 1-based index. Thus, +1 is added to the line number.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464600758", "createdAt": "2020-08-03T18:53:12Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.google.cloud.bigquery.utils.queryfixer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@Getter\n+public class QueryPositionConverter {\n+\n+  /** The query used to convert indices and positions. */\n+  private final String query;\n+\n+  /** The index in the query corresponding to the starting position of each line. */\n+  private List<Integer> startIndices;\n+\n+  public QueryPositionConverter(String query) {\n+    this.query = query;\n+    fillInStartIndices(query);\n+  }\n+\n+  private void fillInStartIndices(String query) {\n+    startIndices = new ArrayList<>();\n+    startIndices.add(0);\n+    for (int i = 0; i < query.length() - 1; i++) {\n+      if (query.charAt(i) == '\\n') {\n+        startIndices.add(i + 1);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Convert row and column number to an index.\n+   *\n+   * @param row row number\n+   * @param col col number\n+   * @return index\n+   */\n+  public int posToIndex(int row, int col) {\n+    if (row > startIndices.size()) {\n+      return -1;\n+    }\n+\n+    // row and col are 1-index, but the String is 0-index\n+    // therefore -1 is needed for conversion.\n+    int index = startIndices.get(row - 1) + col - 1;\n+\n+    int nextLineStartIndex;\n+    if (row == startIndices.size()) {\n+      nextLineStartIndex = query.length();\n+    } else {\n+      nextLineStartIndex = startIndices.get(row);\n+    }\n+    if (index > nextLineStartIndex) {\n+      return -1;\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Convert index to position.\n+   *\n+   * @param index index to be converted\n+   * @return position\n+   */\n+  public Position indexToPos(int index) {\n+    if (index < 0 || index >= query.length()) {\n+      return Position.invalid();\n+    }\n+    int line = findStartLine(index);\n+    return new Position(line, index - startIndices.get(line - 1) + 1);\n+  }\n+\n+  // use the binary search on startIndices to find the greatest start index\n+  // that is less or equal index.\n+  // the return line should be 1-index\n+  private int findStartLine(int index) {\n+    int left = 0, right = startIndices.size() - 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNjc5Mw=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5OTIwMDA5OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/tokenizer/QueryTokenProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNjo1NzoyOVrOG6uLew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxOTowNzoxNVrOG7FZSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNzE5NQ==", "bodyText": "nit: The", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464227195", "createdAt": "2020-08-03T06:57:29Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/tokenizer/QueryTokenProcessor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.google.cloud.bigquery.utils.queryfixer.tokenizer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.IToken;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@AllArgsConstructor\n+public class QueryTokenProcessor {\n+\n+  private final Tokenizer tokenizer;\n+\n+  /**\n+   * Return a token which is closed to a specific position at a query.\n+   *\n+   * @param query the input query\n+   * @param row the row of the position.\n+   * @param column the column of the position\n+   * @return the closed token.\n+   */\n+  public IToken getTokenAt(String query, int row, int column) {\n+    for (IToken token : getAllTokens(query)) {\n+      if (token.getEndRow() >= row && token.getEndColumn() >= column) {\n+        return token;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Tokenize a query and return all its tokens.\n+   *\n+   * @param query the query to be tokenized\n+   * @return a list of tokens of the query\n+   */\n+  public List<IToken> getAllTokens(String query) {\n+    return tokenizer.tokenize(query);\n+  }\n+\n+  /**\n+   * Replace a token of a query and return the new query.\n+   *\n+   * @param query the query whose token is to be replaced\n+   * @param token the token to be replaced\n+   * @param identifier the identifier the token is placed to.\n+   * @return the replaced query\n+   */\n+  public String replaceToken(String query, IToken token, String identifier) {\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n+    // the token's row and column number are 1-index,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzU2Mw==", "bodyText": "Done", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464607563", "createdAt": "2020-08-03T19:07:15Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/tokenizer/QueryTokenProcessor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.google.cloud.bigquery.utils.queryfixer.tokenizer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.IToken;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@AllArgsConstructor\n+public class QueryTokenProcessor {\n+\n+  private final Tokenizer tokenizer;\n+\n+  /**\n+   * Return a token which is closed to a specific position at a query.\n+   *\n+   * @param query the input query\n+   * @param row the row of the position.\n+   * @param column the column of the position\n+   * @return the closed token.\n+   */\n+  public IToken getTokenAt(String query, int row, int column) {\n+    for (IToken token : getAllTokens(query)) {\n+      if (token.getEndRow() >= row && token.getEndColumn() >= column) {\n+        return token;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Tokenize a query and return all its tokens.\n+   *\n+   * @param query the query to be tokenized\n+   * @return a list of tokens of the query\n+   */\n+  public List<IToken> getAllTokens(String query) {\n+    return tokenizer.tokenize(query);\n+  }\n+\n+  /**\n+   * Replace a token of a query and return the new query.\n+   *\n+   * @param query the query whose token is to be replaced\n+   * @param token the token to be replaced\n+   * @param identifier the identifier the token is placed to.\n+   * @return the replaced query\n+   */\n+  public String replaceToken(String query, IToken token, String identifier) {\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n+    // the token's row and column number are 1-index,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNzE5NQ=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5OTIwMTA2OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/tokenizer/QueryTokenProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNjo1Nzo1M1rOG6uMDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxOTowNzoyMFrOG7FZbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNzM0Mw==", "bodyText": "nit: Token", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464227343", "createdAt": "2020-08-03T06:57:53Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/tokenizer/QueryTokenProcessor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.google.cloud.bigquery.utils.queryfixer.tokenizer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.IToken;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@AllArgsConstructor\n+public class QueryTokenProcessor {\n+\n+  private final Tokenizer tokenizer;\n+\n+  /**\n+   * Return a token which is closed to a specific position at a query.\n+   *\n+   * @param query the input query\n+   * @param row the row of the position.\n+   * @param column the column of the position\n+   * @return the closed token.\n+   */\n+  public IToken getTokenAt(String query, int row, int column) {\n+    for (IToken token : getAllTokens(query)) {\n+      if (token.getEndRow() >= row && token.getEndColumn() >= column) {\n+        return token;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Tokenize a query and return all its tokens.\n+   *\n+   * @param query the query to be tokenized\n+   * @return a list of tokens of the query\n+   */\n+  public List<IToken> getAllTokens(String query) {\n+    return tokenizer.tokenize(query);\n+  }\n+\n+  /**\n+   * Replace a token of a query and return the new query.\n+   *\n+   * @param query the query whose token is to be replaced\n+   * @param token the token to be replaced\n+   * @param identifier the identifier the token is placed to.\n+   * @return the replaced query\n+   */\n+  public String replaceToken(String query, IToken token, String identifier) {\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n+    // the token's row and column number are 1-index,\n+    // but the array and string index start with 0.\n+    int startIndex = converter.posToIndex(token.getBeginRow(), token.getBeginColumn());\n+    int endIndex = converter.posToIndex(token.getEndRow(), token.getEndColumn());\n+    if (startIndex == -1 || endIndex == -1) {\n+      throw new IllegalArgumentException(\"token position does not fit in the input query\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzU5Ng==", "bodyText": "Done", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464607596", "createdAt": "2020-08-03T19:07:20Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/tokenizer/QueryTokenProcessor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.google.cloud.bigquery.utils.queryfixer.tokenizer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.QueryPositionConverter;\n+import com.google.cloud.bigquery.utils.queryfixer.entity.IToken;\n+import com.google.cloud.bigquery.utils.queryfixer.util.StringUtil;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@AllArgsConstructor\n+public class QueryTokenProcessor {\n+\n+  private final Tokenizer tokenizer;\n+\n+  /**\n+   * Return a token which is closed to a specific position at a query.\n+   *\n+   * @param query the input query\n+   * @param row the row of the position.\n+   * @param column the column of the position\n+   * @return the closed token.\n+   */\n+  public IToken getTokenAt(String query, int row, int column) {\n+    for (IToken token : getAllTokens(query)) {\n+      if (token.getEndRow() >= row && token.getEndColumn() >= column) {\n+        return token;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Tokenize a query and return all its tokens.\n+   *\n+   * @param query the query to be tokenized\n+   * @return a list of tokens of the query\n+   */\n+  public List<IToken> getAllTokens(String query) {\n+    return tokenizer.tokenize(query);\n+  }\n+\n+  /**\n+   * Replace a token of a query and return the new query.\n+   *\n+   * @param query the query whose token is to be replaced\n+   * @param token the token to be replaced\n+   * @param identifier the identifier the token is placed to.\n+   * @return the replaced query\n+   */\n+  public String replaceToken(String query, IToken token, String identifier) {\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n+    // the token's row and column number are 1-index,\n+    // but the array and string index start with 0.\n+    int startIndex = converter.posToIndex(token.getBeginRow(), token.getBeginColumn());\n+    int endIndex = converter.posToIndex(token.getEndRow(), token.getEndColumn());\n+    if (startIndex == -1 || endIndex == -1) {\n+      throw new IllegalArgumentException(\"token position does not fit in the input query\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNzM0Mw=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5OTIwNzQ4OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/util/StringUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNzowMDoyM1rOG6uPuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxOTowNzo0M1rOG7FaCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyODI4MQ==", "bodyText": "I think this is very common algorithm you don't have to comment on this :)", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464228281", "createdAt": "2020-08-03T07:00:23Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/util/StringUtil.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package com.google.cloud.bigquery.utils.queryfixer.util;\n+\n+import lombok.Value;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/** A utility class to provide static helper methods regarding String. */\n+public class StringUtil {\n+\n+  /**\n+   * Find word(s) from a dictionary that are most similar to a target word. The similarity is\n+   * measured by edit distance between two words.\n+   *\n+   * @param dict dictionary of words\n+   * @param target target word\n+   * @return a list of Strings and their edit distance to the target.\n+   */\n+  public static SimilarStrings findSimilarWords(Collection<String> dict, String target) {\n+    List<Pair<Integer, String>> distanceWordPairs =\n+        dict.stream()\n+            .map(word -> Pair.of(editDistance(word, target), word))\n+            .collect(Collectors.toList());\n+\n+    if (distanceWordPairs.isEmpty()) {\n+      return SimilarStrings.empty();\n+    }\n+\n+    Integer minDistance =\n+        distanceWordPairs.stream().min(Comparator.comparingInt(Pair::getLeft)).get().getLeft();\n+\n+    List<String> words =\n+        distanceWordPairs.stream()\n+            .filter(pair -> (pair.getLeft().equals(minDistance)))\n+            .map(Pair::getRight)\n+            .collect(Collectors.toList());\n+    return new SimilarStrings(words, minDistance);\n+  }\n+\n+  // the code was inspired from\n+  // https://www.programcreek.com/2013/12/edit-distance-in-java/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzc1Mw==", "bodyText": "This comment was removed.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r464607753", "createdAt": "2020-08-03T19:07:43Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/util/StringUtil.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package com.google.cloud.bigquery.utils.queryfixer.util;\n+\n+import lombok.Value;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/** A utility class to provide static helper methods regarding String. */\n+public class StringUtil {\n+\n+  /**\n+   * Find word(s) from a dictionary that are most similar to a target word. The similarity is\n+   * measured by edit distance between two words.\n+   *\n+   * @param dict dictionary of words\n+   * @param target target word\n+   * @return a list of Strings and their edit distance to the target.\n+   */\n+  public static SimilarStrings findSimilarWords(Collection<String> dict, String target) {\n+    List<Pair<Integer, String>> distanceWordPairs =\n+        dict.stream()\n+            .map(word -> Pair.of(editDistance(word, target), word))\n+            .collect(Collectors.toList());\n+\n+    if (distanceWordPairs.isEmpty()) {\n+      return SimilarStrings.empty();\n+    }\n+\n+    Integer minDistance =\n+        distanceWordPairs.stream().min(Comparator.comparingInt(Pair::getLeft)).get().getLeft();\n+\n+    List<String> words =\n+        distanceWordPairs.stream()\n+            .filter(pair -> (pair.getLeft().equals(minDistance)))\n+            .map(Pair::getRight)\n+            .collect(Collectors.toList());\n+    return new SimilarStrings(words, minDistance);\n+  }\n+\n+  // the code was inspired from\n+  // https://www.programcreek.com/2013/12/edit-distance-in-java/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyODI4MQ=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTk0Nzc2OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/test/java/com/google/cloud/bigquery/utils/queryfixer/QueryTokenProcessorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOToxNDo0MlrOG7t6jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzozODozN1rOG71EgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTQzOQ==", "bodyText": "merged into one line? String target = \"....\"", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465271439", "createdAt": "2020-08-04T19:14:42Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/test/java/com/google/cloud/bigquery/utils/queryfixer/QueryTokenProcessorTest.java", "diffHunk": "@@ -15,16 +16,47 @@\n \n   @Before\n   public void createService() {\n-    tokenService = new QueryTokenProcessor(new BigQueryParserFactory());\n+    tokenService = new QueryTokenProcessor(new CalciteTokenizer(new BigQueryParserFactory()));\n   }\n \n   @Test\n   public void convertQueryToTokens() {\n-    String sql = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+    String query = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+\n+    List<IToken> tokens = tokenService.getAllTokens(query);\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n \n-    List<IToken> tokens = tokenService.getAllTokens(sql);\n-    assertEquals(10, tokens.size());\n-    assertEquals(\"Select\", tokens.get(0).getImage());\n-    assertEquals(\"'val'\", tokens.get(tokens.size() - 1).getImage());\n+    for (IToken token : tokens) {\n+      int startIndex = converter.posToIndex(token.getBeginRow(), token.getBeginColumn());\n+      int endIndex = converter.posToIndex(token.getEndRow(), token.getEndColumn() + 1);\n+      assertEquals(\n+          token.getImage().toUpperCase(), query.substring(startIndex, endIndex).toUpperCase());\n+    }\n+  }\n+\n+  @Test\n+  public void verifyModifiedQuery() {\n+    String origin = \"Select col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String target;\n+\n+    target = \"Select Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4ODY3Mg==", "bodyText": "Yes, the auto formatter put them in one line with +s, so I deleted the +s since they are in one line.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465388672", "createdAt": "2020-08-04T23:38:37Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/test/java/com/google/cloud/bigquery/utils/queryfixer/QueryTokenProcessorTest.java", "diffHunk": "@@ -15,16 +16,47 @@\n \n   @Before\n   public void createService() {\n-    tokenService = new QueryTokenProcessor(new BigQueryParserFactory());\n+    tokenService = new QueryTokenProcessor(new CalciteTokenizer(new BigQueryParserFactory()));\n   }\n \n   @Test\n   public void convertQueryToTokens() {\n-    String sql = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+    String query = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+\n+    List<IToken> tokens = tokenService.getAllTokens(query);\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n \n-    List<IToken> tokens = tokenService.getAllTokens(sql);\n-    assertEquals(10, tokens.size());\n-    assertEquals(\"Select\", tokens.get(0).getImage());\n-    assertEquals(\"'val'\", tokens.get(tokens.size() - 1).getImage());\n+    for (IToken token : tokens) {\n+      int startIndex = converter.posToIndex(token.getBeginRow(), token.getBeginColumn());\n+      int endIndex = converter.posToIndex(token.getEndRow(), token.getEndColumn() + 1);\n+      assertEquals(\n+          token.getImage().toUpperCase(), query.substring(startIndex, endIndex).toUpperCase());\n+    }\n+  }\n+\n+  @Test\n+  public void verifyModifiedQuery() {\n+    String origin = \"Select col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String target;\n+\n+    target = \"Select Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTQzOQ=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTk1ODUxOnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/test/java/com/google/cloud/bigquery/utils/queryfixer/QueryTokenProcessorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOToxODowNVrOG7uBYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo0MDo1MVrOG71HEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MzE4Nw==", "bodyText": "Is this intended that extra space between \"Select\" and \"Distinct\" ?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465273187", "createdAt": "2020-08-04T19:18:05Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/test/java/com/google/cloud/bigquery/utils/queryfixer/QueryTokenProcessorTest.java", "diffHunk": "@@ -15,16 +16,47 @@\n \n   @Before\n   public void createService() {\n-    tokenService = new QueryTokenProcessor(new BigQueryParserFactory());\n+    tokenService = new QueryTokenProcessor(new CalciteTokenizer(new BigQueryParserFactory()));\n   }\n \n   @Test\n   public void convertQueryToTokens() {\n-    String sql = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+    String query = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+\n+    List<IToken> tokens = tokenService.getAllTokens(query);\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n \n-    List<IToken> tokens = tokenService.getAllTokens(sql);\n-    assertEquals(10, tokens.size());\n-    assertEquals(\"Select\", tokens.get(0).getImage());\n-    assertEquals(\"'val'\", tokens.get(tokens.size() - 1).getImage());\n+    for (IToken token : tokens) {\n+      int startIndex = converter.posToIndex(token.getBeginRow(), token.getBeginColumn());\n+      int endIndex = converter.posToIndex(token.getEndRow(), token.getEndColumn() + 1);\n+      assertEquals(\n+          token.getImage().toUpperCase(), query.substring(startIndex, endIndex).toUpperCase());\n+    }\n+  }\n+\n+  @Test\n+  public void verifyModifiedQuery() {\n+    String origin = \"Select col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String target;\n+\n+    target = \"Select Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String identifier = \"Select Distinct\";\n+    IToken token = tokenService.getTokenAt(origin, 1, 1);\n+    // Replace Select With Select Distinct\n+    String modifiedQuery = tokenService.replaceToken(origin, token, identifier);\n+    assertEquals(target, modifiedQuery);\n+\n+    target = \"Select  Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4OTMyOA==", "bodyText": "Yes, I think so. insertBeforeToken will automatically put a whitespace in case there is no whitespace.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465389328", "createdAt": "2020-08-04T23:40:51Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/test/java/com/google/cloud/bigquery/utils/queryfixer/QueryTokenProcessorTest.java", "diffHunk": "@@ -15,16 +16,47 @@\n \n   @Before\n   public void createService() {\n-    tokenService = new QueryTokenProcessor(new BigQueryParserFactory());\n+    tokenService = new QueryTokenProcessor(new CalciteTokenizer(new BigQueryParserFactory()));\n   }\n \n   @Test\n   public void convertQueryToTokens() {\n-    String sql = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+    String query = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+\n+    List<IToken> tokens = tokenService.getAllTokens(query);\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n \n-    List<IToken> tokens = tokenService.getAllTokens(sql);\n-    assertEquals(10, tokens.size());\n-    assertEquals(\"Select\", tokens.get(0).getImage());\n-    assertEquals(\"'val'\", tokens.get(tokens.size() - 1).getImage());\n+    for (IToken token : tokens) {\n+      int startIndex = converter.posToIndex(token.getBeginRow(), token.getBeginColumn());\n+      int endIndex = converter.posToIndex(token.getEndRow(), token.getEndColumn() + 1);\n+      assertEquals(\n+          token.getImage().toUpperCase(), query.substring(startIndex, endIndex).toUpperCase());\n+    }\n+  }\n+\n+  @Test\n+  public void verifyModifiedQuery() {\n+    String origin = \"Select col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String target;\n+\n+    target = \"Select Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String identifier = \"Select Distinct\";\n+    IToken token = tokenService.getTokenAt(origin, 1, 1);\n+    // Replace Select With Select Distinct\n+    String modifiedQuery = tokenService.replaceToken(origin, token, identifier);\n+    assertEquals(target, modifiedQuery);\n+\n+    target = \"Select  Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MzE4Nw=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTk1OTE0OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/test/java/com/google/cloud/bigquery/utils/queryfixer/QueryTokenProcessorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOToxODoyMFrOG7uB5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo0MTozOFrOG71IBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MzMxNg==", "bodyText": "Is this intended that extra space between \"Select\" and \"from\" ?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465273316", "createdAt": "2020-08-04T19:18:20Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/test/java/com/google/cloud/bigquery/utils/queryfixer/QueryTokenProcessorTest.java", "diffHunk": "@@ -15,16 +16,47 @@\n \n   @Before\n   public void createService() {\n-    tokenService = new QueryTokenProcessor(new BigQueryParserFactory());\n+    tokenService = new QueryTokenProcessor(new CalciteTokenizer(new BigQueryParserFactory()));\n   }\n \n   @Test\n   public void convertQueryToTokens() {\n-    String sql = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+    String query = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+\n+    List<IToken> tokens = tokenService.getAllTokens(query);\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n \n-    List<IToken> tokens = tokenService.getAllTokens(sql);\n-    assertEquals(10, tokens.size());\n-    assertEquals(\"Select\", tokens.get(0).getImage());\n-    assertEquals(\"'val'\", tokens.get(tokens.size() - 1).getImage());\n+    for (IToken token : tokens) {\n+      int startIndex = converter.posToIndex(token.getBeginRow(), token.getBeginColumn());\n+      int endIndex = converter.posToIndex(token.getEndRow(), token.getEndColumn() + 1);\n+      assertEquals(\n+          token.getImage().toUpperCase(), query.substring(startIndex, endIndex).toUpperCase());\n+    }\n+  }\n+\n+  @Test\n+  public void verifyModifiedQuery() {\n+    String origin = \"Select col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String target;\n+\n+    target = \"Select Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String identifier = \"Select Distinct\";\n+    IToken token = tokenService.getTokenAt(origin, 1, 1);\n+    // Replace Select With Select Distinct\n+    String modifiedQuery = tokenService.replaceToken(origin, token, identifier);\n+    assertEquals(target, modifiedQuery);\n+\n+    target = \"Select  Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    identifier = \"Distinct\";\n+    token = tokenService.getTokenAt(origin, 1, 8);\n+    // Insert Distinct before FROM\n+    modifiedQuery = tokenService.insertBeforeToken(origin, token, identifier);\n+    assertEquals(target, modifiedQuery);\n+\n+    target = \"Select  from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4OTU3NQ==", "bodyText": "Yes, the deleteToken can only delete token not the whitespace between it.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465389575", "createdAt": "2020-08-04T23:41:38Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/test/java/com/google/cloud/bigquery/utils/queryfixer/QueryTokenProcessorTest.java", "diffHunk": "@@ -15,16 +16,47 @@\n \n   @Before\n   public void createService() {\n-    tokenService = new QueryTokenProcessor(new BigQueryParserFactory());\n+    tokenService = new QueryTokenProcessor(new CalciteTokenizer(new BigQueryParserFactory()));\n   }\n \n   @Test\n   public void convertQueryToTokens() {\n-    String sql = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+    String query = \"Select col from `d1.t1`\\n\" + \"where t1.col>'val'\";\n+\n+    List<IToken> tokens = tokenService.getAllTokens(query);\n+    QueryPositionConverter converter = new QueryPositionConverter(query);\n \n-    List<IToken> tokens = tokenService.getAllTokens(sql);\n-    assertEquals(10, tokens.size());\n-    assertEquals(\"Select\", tokens.get(0).getImage());\n-    assertEquals(\"'val'\", tokens.get(tokens.size() - 1).getImage());\n+    for (IToken token : tokens) {\n+      int startIndex = converter.posToIndex(token.getBeginRow(), token.getBeginColumn());\n+      int endIndex = converter.posToIndex(token.getEndRow(), token.getEndColumn() + 1);\n+      assertEquals(\n+          token.getImage().toUpperCase(), query.substring(startIndex, endIndex).toUpperCase());\n+    }\n+  }\n+\n+  @Test\n+  public void verifyModifiedQuery() {\n+    String origin = \"Select col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String target;\n+\n+    target = \"Select Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    String identifier = \"Select Distinct\";\n+    IToken token = tokenService.getTokenAt(origin, 1, 1);\n+    // Replace Select With Select Distinct\n+    String modifiedQuery = tokenService.replaceToken(origin, token, identifier);\n+    assertEquals(target, modifiedQuery);\n+\n+    target = \"Select  Distinct col from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";\n+    identifier = \"Distinct\";\n+    token = tokenService.getTokenAt(origin, 1, 8);\n+    // Insert Distinct before FROM\n+    modifiedQuery = tokenService.insertBeforeToken(origin, token, identifier);\n+    assertEquals(target, modifiedQuery);\n+\n+    target = \"Select  from t1 Join\\nt2 on t1.id = t2.id\\nwhere t1.col > 'val'\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MzMxNg=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTk3NzkwOnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOToyNDoyNFrOG7uNjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOToyNDoyNFrOG7uNjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjMwMA==", "bodyText": "nit: always use \"extra space\" \"1 - index\" same with the code style :)", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465276300", "createdAt": "2020-08-04T19:24:24Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/QueryPositionConverter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.google.cloud.bigquery.utils.queryfixer;\n+\n+import com.google.cloud.bigquery.utils.queryfixer.entity.Position;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/** A class used to convert between index and position (row and column) of a query. */\n+@Getter\n+public class QueryPositionConverter {\n+\n+  /** The query used to convert indices and positions. */\n+  private final String query;\n+\n+  /** The index in the query corresponding to the starting position of each line. */\n+  private List<Integer> startIndices;\n+\n+  public QueryPositionConverter(String query) {\n+    this.query = query;\n+    fillInStartIndices(query);\n+  }\n+\n+  private void fillInStartIndices(String query) {\n+    startIndices = new ArrayList<>();\n+    startIndices.add(0);\n+    for (int i = 0; i < query.length() - 1; i++) {\n+      if (query.charAt(i) == '\\n') {\n+        startIndices.add(i + 1);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Convert row and column number to an index.\n+   *\n+   * @param row row number\n+   * @param col col number\n+   * @return index\n+   */\n+  public int posToIndex(int row, int col) {\n+    if (row > startIndices.size()) {\n+      return -1;\n+    }\n+\n+    // row and col are 1-index, but the String is 0-index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTk4ODc1OnYy", "diffSide": "RIGHT", "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/tokenizer/CalciteTokenizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOToyNjoyNFrOG7uTxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo0Mzo1MlrOG71KWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Nzg5Mw==", "bodyText": "is this overridden \"sql\" by mistake ?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465277893", "createdAt": "2020-08-04T19:26:24Z", "author": {"login": "kikkyo"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/tokenizer/CalciteTokenizer.java", "diffHunk": "@@ -1,38 +1,27 @@\n-package com.google.cloud.bigquery.utils.queryfixer;\n-\n-import org.apache.calcite.sql.parser.babel.SqlBabelParserImpl;\n-import org.apache.calcite.sql.parser.babel.Token;\n+package com.google.cloud.bigquery.utils.queryfixer.tokenizer;\n \n+import com.google.cloud.bigquery.utils.queryfixer.BigQueryParserFactory;\n import com.google.cloud.bigquery.utils.queryfixer.entity.IToken;\n import com.google.cloud.bigquery.utils.queryfixer.entity.TokenImpl;\n-import com.google.common.base.Preconditions;\n-\n import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import org.apache.calcite.sql.parser.babel.SqlBabelParserImpl;\n+import org.apache.calcite.sql.parser.babel.Token;\n \n import java.util.ArrayList;\n import java.util.List;\n \n-/**\n- * A processor provides methods for queries and tokens. It can be used to tokenize queries, find tokens based on\n- * positions, and modify a query in token-level.\n- * */\n @AllArgsConstructor\n-public class QueryTokenProcessor {\n+public class CalciteTokenizer implements Tokenizer {\n \n   private final BigQueryParserFactory parserFactory;\n \n-  /**\n-   * Tokenize a query and return all its tokens.\n-   * @param query the query to be tokenized\n-   * @return a list of tokens of the query\n-   */\n-  public List<IToken> getAllTokens(String query) {\n-    Preconditions.checkNotNull(query, \"Input query should not be null.\");\n-\n+  @Override\n+  public List<IToken> tokenize(@NonNull final String sql) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MDE3MQ==", "bodyText": "Ah yes. This code was written long time ago and I forgot to refactor it.", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/125#discussion_r465390171", "createdAt": "2020-08-04T23:43:52Z", "author": {"login": "mingen-pan"}, "path": "tools/automatic_query_fixer/src/main/java/com/google/cloud/bigquery/utils/queryfixer/tokenizer/CalciteTokenizer.java", "diffHunk": "@@ -1,38 +1,27 @@\n-package com.google.cloud.bigquery.utils.queryfixer;\n-\n-import org.apache.calcite.sql.parser.babel.SqlBabelParserImpl;\n-import org.apache.calcite.sql.parser.babel.Token;\n+package com.google.cloud.bigquery.utils.queryfixer.tokenizer;\n \n+import com.google.cloud.bigquery.utils.queryfixer.BigQueryParserFactory;\n import com.google.cloud.bigquery.utils.queryfixer.entity.IToken;\n import com.google.cloud.bigquery.utils.queryfixer.entity.TokenImpl;\n-import com.google.common.base.Preconditions;\n-\n import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import org.apache.calcite.sql.parser.babel.SqlBabelParserImpl;\n+import org.apache.calcite.sql.parser.babel.Token;\n \n import java.util.ArrayList;\n import java.util.List;\n \n-/**\n- * A processor provides methods for queries and tokens. It can be used to tokenize queries, find tokens based on\n- * positions, and modify a query in token-level.\n- * */\n @AllArgsConstructor\n-public class QueryTokenProcessor {\n+public class CalciteTokenizer implements Tokenizer {\n \n   private final BigQueryParserFactory parserFactory;\n \n-  /**\n-   * Tokenize a query and return all its tokens.\n-   * @param query the query to be tokenized\n-   * @return a list of tokens of the query\n-   */\n-  public List<IToken> getAllTokens(String query) {\n-    Preconditions.checkNotNull(query, \"Input query should not be null.\");\n-\n+  @Override\n+  public List<IToken> tokenize(@NonNull final String sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Nzg5Mw=="}, "originalCommit": {"oid": "225248220a13d782a7daaa74eedd46e0207f97d8"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3072, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}