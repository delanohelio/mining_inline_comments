{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2Mzg2NzM4", "number": 145, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNDoxMFrOEXZwOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMDoyNjo1NlrOEXbVYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTc0NjQ5OnYy", "diffSide": "RIGHT", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNDoxMFrOG_LSFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNjoyNzoyMlrOHA69Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODMyNA==", "bodyText": "Maybe have some comments to explain why not starting with 0", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468898324", "createdAt": "2020-08-11T22:24:10Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyODAyMg==", "bodyText": "Updated. The reason was that ResultSet column indexes start at 1 instead of 0", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r470728022", "createdAt": "2020-08-14T16:27:22Z", "author": {"login": "krishsuchdev"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODMyNA=="}, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTc0OTIxOnYy", "diffSide": "RIGHT", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNTowOVrOG_LTrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNTowOVrOG_LTrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODczMw==", "bodyText": "Do we need to close this stream?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468898733", "createdAt": "2020-08-11T22:25:09Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTc1MDM4OnYy", "diffSide": "RIGHT", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNTozMVrOG_LUTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNTozMVrOG_LUTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODg5NQ==", "bodyText": "use String.format(...)", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468898895", "createdAt": "2020-08-11T22:25:31Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTc1MjE5OnYy", "diffSide": "RIGHT", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNjoxM1rOG_LVWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNjoxM1rOG_LVWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5OTE2Mw==", "bodyText": "Can just be List", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468899163", "createdAt": "2020-08-11T22:26:13Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";\n+\n+                    statement += tableReference.get(\"datasetId\").getAsString() + \".\" + tableReference.get(\"tableId\").getAsString() + \" (\";\n+\n+                    // Generate column syntax for each field provided in JSON\n+                    ArrayList<String> columns = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTc1Mjg3OnYy", "diffSide": "RIGHT", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNjozMlrOG_LVvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNjozMlrOG_LVvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5OTI2Mw==", "bodyText": "Use StringBuilder and append?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468899263", "createdAt": "2020-08-11T22:26:32Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";\n+\n+                    statement += tableReference.get(\"datasetId\").getAsString() + \".\" + tableReference.get(\"tableId\").getAsString() + \" (\";\n+\n+                    // Generate column syntax for each field provided in JSON\n+                    ArrayList<String> columns = new ArrayList<String>();\n+                    for (JsonElement fieldElement : schemaObject.getAsJsonArray(\"fields\")) {\n+                        JsonObject field = fieldElement.getAsJsonObject();\n+\n+                        // Assemble column syntax\n+                        String column = field.get(\"name\").getAsString() + \" \" + field.get(\"type\").getAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTc1MzcwOnYy", "diffSide": "RIGHT", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNjo1MVrOG_LWNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyNjo1MVrOG_LWNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5OTM4MQ==", "bodyText": "StringBuilder instead?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468899381", "createdAt": "2020-08-11T22:26:51Z", "author": {"login": "yzhvictor"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDAwMzc3OnYy", "diffSide": "RIGHT", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMDoyNjowOVrOG_NonQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNjoyODo1NlrOHA7ATw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNjg2MQ==", "bodyText": "This isn't going to work if there's semicolons in quotes I think. Can you add a comment noting this?", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468936861", "createdAt": "2020-08-12T00:26:09Z", "author": {"login": "Luminarys"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyODc4Mw==", "bodyText": "That's true, updated", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r470728783", "createdAt": "2020-08-14T16:28:56Z", "author": {"login": "krishsuchdev"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNjg2MQ=="}, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDAwNTQ1OnYy", "diffSide": "RIGHT", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMDoyNjo1NlrOG_NpiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMDoyNjo1NlrOG_NpiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNzA5Nw==", "bodyText": "You can use inferred types here, i.e. new ArrayList<>();", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468937097", "createdAt": "2020-08-12T00:26:56Z", "author": {"login": "Luminarys"}, "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";\n+\n+                    statement += tableReference.get(\"datasetId\").getAsString() + \".\" + tableReference.get(\"tableId\").getAsString() + \" (\";\n+\n+                    // Generate column syntax for each field provided in JSON\n+                    ArrayList<String> columns = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f"}, "originalPosition": 208}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3104, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}