{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NTM3NDMy", "number": 924, "title": "Fix ZkHelixPropertyStore loses Zookeeper notification issue", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #921\nDescription\n\n\n Here are some details about my PR, including screenshots of any UI changes:\nZkHelixPropertyStore loses ZK notification after session expires.\nThe issue was caused by a bug in Share ZkClient code path. More\nspecifically, Share ZkClient would not call fireAllEvent when ZK\nsession expires. Thus, ZkHelixPropertyStore would not install\nwatches for corresponding ZkPath. Thus, lose Zookeeper\nnofiticaition when changes happens.\n\n\nTests\n\n The following tests are written for this issue:\n\ntestSessionExpirationWithSharedZkClient\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\nksun-mn1:helix-core ksun$ mvn test\nFailed tests:\nTestZkConnectionLost.testLostZkConnection \u00bb ThreadTimeout Method org.testng.in...\nTestJobFailureDependence.testWorkflowFailureJobThreshold \u00bb ThreadTimeout Metho...\nTestHelixAdminCli.testInstanceOperations:469 \u00bb ZkClient Failed to delete /Test...\nTests run: 1093, Failures: 3, Errors: 0, Skipped: 4\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:37 h\n[INFO] Finished at: 2020-04-06T18:55:19-07:00\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.18.1:test (default-test) on project helix-core: There are test failures.\n[ERROR]\n[ERROR] Please refer to /Users/ksun/dev_branch_helix/helix/helix-core/target/surefire-reports for the individual test results.\n[ERROR] -> [Help 1]\n[ERROR]\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR]\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\nIndividual test case run will all succeed.\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-03-31T19:07:11Z", "url": "https://github.com/apache/helix/pull/924", "merged": true, "mergeCommit": {"oid": "108dfc6c9b48a89b1c9804f0c2b77c2572d623a8"}, "closed": true, "closedAt": "2020-04-14T21:18:49Z", "author": {"login": "kaisun2000"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTHnFQAH2gAyMzk2NTM3NDMyOjBmMjFjZTdiOTI5ZmZhN2E0MzZiZTM5MTBlNDBmYjk3OTFkYzFjMWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXoiwDAFqTM5MzIwMTk2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/0f21ce7b929ffa7a436be3910e40fb9791dc1c1c", "committedDate": "2020-03-31T18:42:40Z", "message": "WIP: fix ZkHelixPropertyStore loses Zookeeper notification issue\n\nZkHelixPropertyStore loses ZK notification after session expires.\nTHe issue was caused by a bug in Share ZkClient code path. More\nspecifically, Share ZkClient would not call fireAllEvent when ZK\nsession expires. Thus, ZkHelixPropertyStore would not install\nwatches for corresponding ZkPath. Thus, lose Zookeeper\nnofiticaition when changes happens."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDMyOTE5", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385032919", "createdAt": "2020-03-31T19:19:42Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToxOTo0M1rOF-kmaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToyODoxOVrOF-k6Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NTY4OQ==", "bodyText": "sleep() doesn't look solid and makes the test unstable. I suggest using TestHelper.varify() to replace sleep().", "url": "https://github.com/apache/helix/pull/924#discussion_r401155689", "createdAt": "2020-03-31T19:19:43Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+\n+\n+    // kill the session one more time to cover Shared ZkClient resetting flag\n+    // indicating first time synconnect happened.\n+    ZkTestHelper.expireSession(testClient);\n+\n+    listener.reset();\n+    int expectDeleteNodes = 1 + firstLevelNr + firstLevelNr * secondLevelNr;\n+    store.remove(\"/\", 0);\n+    // wait until all callbacks have been received\n+    for (int i = 0; i < 10; i++) {\n+      if (listener._deleteKeys.size() == expectDeleteNodes)\n+        break;\n+      Thread.sleep(500);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1OTQ0Mg==", "bodyText": "This should not be introduced. If getZkClient() is really necessary, you can make _zkClient as protected.", "url": "https://github.com/apache/helix/pull/924#discussion_r401159442", "createdAt": "2020-03-31T19:26:12Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -72,6 +72,11 @@\n \n   private HelixZkClient _zkClient = null;\n \n+  // test only\n+  public HelixZkClient getZkClient() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MDczMQ==", "bodyText": "Comment block format:\n/*\n * comments\n */", "url": "https://github.com/apache/helix/pull/924#discussion_r401160731", "createdAt": "2020-03-31T19:28:19Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for sharedZkClient\n     if (!isManagingZkConnection()) {\n+      /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDUzNzE5", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385053719", "createdAt": "2020-03-31T19:50:24Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MDoyNFrOF-lpfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MDoyNFrOF-lpfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3Mjg2MQ==", "bodyText": "Exposing the internal HelixZkClient is not desirable", "url": "https://github.com/apache/helix/pull/924#discussion_r401172861", "createdAt": "2020-03-31T19:50:24Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/store/zk/ZkHelixPropertyStore.java", "diffHunk": "@@ -47,4 +48,9 @@ public ZkHelixPropertyStore(String zkAddress, ZkSerializer serializer, String ch\n       ZkBaseDataAccessor.ZkClientType zkClientType) {\n     super(zkAddress, serializer, chrootPath, null, null, MONITOR_TYPE, chrootPath, zkClientType);\n   }\n+\n+  // test only\n+  protected HelixZkClient getTestZkClient() {\n+    return getZkClient();\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDU0Mjc3", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385054277", "createdAt": "2020-03-31T19:51:13Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MToxM1rOF-lrQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MToxM1rOF-lrQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzMxMg==", "bodyText": "Possible to avoid print statements?", "url": "https://github.com/apache/helix/pull/924#discussion_r401173312", "createdAt": "2020-03-31T19:51:13Z", "author": {"login": "narendly"}, "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+\n+\n+    // kill the session one more time to cover Shared ZkClient resetting flag\n+    // indicating first time synconnect happened.\n+    ZkTestHelper.expireSession(testClient);\n+\n+    listener.reset();\n+    int expectDeleteNodes = 1 + firstLevelNr + firstLevelNr * secondLevelNr;\n+    store.remove(\"/\", 0);\n+    // wait until all callbacks have been received\n+    for (int i = 0; i < 10; i++) {\n+      if (listener._deleteKeys.size() == expectDeleteNodes)\n+        break;\n+      Thread.sleep(500);\n+    }\n+\n+    System.out.println(\"createKey#:\" + listener._createKeys.size() + \", changeKey#:\"\n+        + listener._changeKeys.size() + \", deleteKey#:\" + listener._deleteKeys.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDU0NTg2", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385054586", "createdAt": "2020-03-31T19:51:38Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MTozOVrOF-lsMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MTozOVrOF-lsMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzU1NQ==", "bodyText": "Can you avoid adding public methods like this that shouldn't otherwise be used in production?", "url": "https://github.com/apache/helix/pull/924#discussion_r401173555", "createdAt": "2020-03-31T19:51:39Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -112,4 +112,9 @@ public String create(final String path, Object datat, final List<ACL> acl,\n   protected boolean isManagingZkConnection() {\n     return false;\n   }\n+\n+  // test only\n+  public HelixZkClient getConnectionManager() {\n+    return _connectionManager;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDU1NjI2", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385055626", "createdAt": "2020-03-31T19:53:13Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MzoxM1rOF-lvoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MzoxM1rOF-lvoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NDQzMg==", "bodyText": "In general, it's not good practice to add subclass-specific logic in its parent class. Can you think of another way to do this?", "url": "https://github.com/apache/helix/pull/924#discussion_r401174432", "createdAt": "2020-03-31T19:53:13Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for sharedZkClient\n     if (!isManagingZkConnection()) {\n+      /*\n+       For SharedZkClient, we will not invoke fireNewSessionEvents and we will invoke fireAllEvents\n+       This keeps the same behavior as original SharedZkClient.\n+       Invoking fireAllEvents is important to make sure HelixPropertyStore working correctly.\n+      */\n+      if ((event.getState() == KeeperState.SyncConnected) && (!_isNewSessionEventFired) && (!\"0\"\n+          .equals(getHexSessionId()))) {\n+        fireAllEvents();\n+        _isNewSessionEventFired = true;\n+      } else if (event.getState() == KeeperState.Expired) {\n+        _isNewSessionEventFired = false;\n+      }\n       return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDU1ODQ4", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385055848", "createdAt": "2020-03-31T19:53:32Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MzozMlrOF-lwWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MzozMlrOF-lwWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NDYxOA==", "bodyText": "parent class shouldn't know about what its sub classes are doing?", "url": "https://github.com/apache/helix/pull/924#discussion_r401174618", "createdAt": "2020-03-31T19:53:32Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for sharedZkClient\n     if (!isManagingZkConnection()) {\n+      /*\n+       For SharedZkClient, we will not invoke fireNewSessionEvents and we will invoke fireAllEvents\n+       This keeps the same behavior as original SharedZkClient.\n+       Invoking fireAllEvents is important to make sure HelixPropertyStore working correctly.\n+      */\n+      if ((event.getState() == KeeperState.SyncConnected) && (!_isNewSessionEventFired) && (!\"0\"\n+          .equals(getHexSessionId()))) {\n+        fireAllEvents();\n+        _isNewSessionEventFired = true;\n+      } else if (event.getState() == KeeperState.Expired) {\n+        _isNewSessionEventFired = false;\n+      }\n       return;\n     }\n \n+    // The following is the case for non sharedZkClient", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDU2NDA5", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385056409", "createdAt": "2020-03-31T19:54:20Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1NDoyMVrOF-lyWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1NDoyMVrOF-lyWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTEyOQ==", "bodyText": "This is not how you would enter JavaDoc in a public method. Could you please review the javadoc best practice guidelines?", "url": "https://github.com/apache/helix/pull/924#discussion_r401175129", "createdAt": "2020-03-31T19:54:21Z", "author": {"login": "narendly"}, "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDU2NTQ1", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385056545", "createdAt": "2020-03-31T19:54:33Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1NDozM1rOF-lyxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1NDozM1rOF-lyxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTIzOA==", "bodyText": "empty line?", "url": "https://github.com/apache/helix/pull/924#discussion_r401175238", "createdAt": "2020-03-31T19:54:33Z", "author": {"login": "narendly"}, "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDQ2NTE3", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385046517", "createdAt": "2020-03-31T19:39:33Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTozOTozM1rOF-lSLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1NjoyOVrOF-l2ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2Njg5NA==", "bodyText": "Remove extra empty line.", "url": "https://github.com/apache/helix/pull/924#discussion_r401166894", "createdAt": "2020-03-31T19:39:33Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NzE2OA==", "bodyText": "Style:\nif () {\n}", "url": "https://github.com/apache/helix/pull/924#discussion_r401167168", "createdAt": "2020-03-31T19:40:02Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();\n+    ZkTestHelper.expireSession(testClient);\n+\n+\n+    // kill the session one more time to cover Shared ZkClient resetting flag\n+    // indicating first time synconnect happened.\n+    ZkTestHelper.expireSession(testClient);\n+\n+    listener.reset();\n+    int expectDeleteNodes = 1 + firstLevelNr + firstLevelNr * secondLevelNr;\n+    store.remove(\"/\", 0);\n+    // wait until all callbacks have been received\n+    for (int i = 0; i < 10; i++) {\n+      if (listener._deleteKeys.size() == expectDeleteNodes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NzU2Ng==", "bodyText": "Extra spaces.", "url": "https://github.com/apache/helix/pull/924#discussion_r401167566", "createdAt": "2020-03-31T19:40:44Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/store/zk/TestZkHelixPropertyStore.java", "diffHunk": "@@ -88,6 +92,57 @@ public void afterClass() {\n     deleteCluster(getShortClassName());\n   }\n \n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    /*\n+    This test is to make sure SharedZkClient would work with\n+    HelixPropertyStore when session expiration happens. More specifically\n+    HelixPropertyStore would register all the callbacks after session\n+    expiration.\n+     */\n+    String subRoot = _root + \"/\" + \"localCallback\";\n+    List<String> subscribedPaths = new ArrayList<>();\n+    subscribedPaths.add(subRoot);\n+\n+    ZkSerializer serializer = new ZNRecordSerializer();\n+    ZkHelixPropertyStore<ZNRecord> store =\n+        new ZkHelixPropertyStore<>(ZK_ADDR, serializer, subRoot, subscribedPaths);\n+\n+    TestListener listener = new TestListener();\n+    store.subscribe(\"/\", listener);\n+\n+    // test dataCreate callbacks\n+    listener.reset();\n+    setNodes(store, 'a', true);\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    // Note, current shared ZkClient does not issue new session. Thus, we need\n+    // kill _zkConnectionManager's session. Otherwise, ZkTestHelper.expireSesson\n+    // would not work.\n+    SharedZkClient sharedClient = (SharedZkClient) store.getTestZkClient();\n+    HelixZkClient  testClient =  sharedClient.getConnectionManager();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjIyNw==", "bodyText": "If we remove  _isNewSessionEventFired = false; in reconnect() and do below code, it seems more concise and easier to maintain. _isNewSessionEventFired is only changed in this code block. What do you think?\n    if (event.getState() == KeeperState.SyncConnected && !_isNewSessionEventFired && !\"0\".equals(getHexSessionId())) {\n      if (isManagingZkConnection()) {\n        /*\n         * Before the new zookeeper instance is connected to the zookeeper service and its session\n         * is established, its session id is 0.\n         * New session event is not fired until the new zookeeper session receives the first\n         * SyncConnected state(the zookeeper session is established).\n         * Now the session id is available and non-zero, and we can fire new session events.\n         */\n        fireNewSessionEvents();\n      }\n      /*\n       * Set it true to avoid firing events again for the same session next time\n       * when SyncConnected events are received.\n       */\n      _isNewSessionEventFired = true;\n\n      /*\n       * With this first SyncConnected state, we just get connected to zookeeper service after\n       * reconnecting when the session expired. Because previous session expired, we also have to\n       * notify all listeners that something might have changed.\n       */\n      fireAllEvents();\n    } else if (event.getState() == KeeperState.Expired) {\n      if (isManagingZkConnection()) {\n        reconnectOnExpiring();\n      }\n       _isNewSessionEventFired = false;\n    }", "url": "https://github.com/apache/helix/pull/924#discussion_r401176227", "createdAt": "2020-03-31T19:56:29Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for sharedZkClient\n     if (!isManagingZkConnection()) {\n+      /*\n+       For SharedZkClient, we will not invoke fireNewSessionEvents and we will invoke fireAllEvents\n+       This keeps the same behavior as original SharedZkClient.\n+       Invoking fireAllEvents is important to make sure HelixPropertyStore working correctly.\n+      */\n+      if ((event.getState() == KeeperState.SyncConnected) && (!_isNewSessionEventFired) && (!\"0\"\n+          .equals(getHexSessionId()))) {\n+        fireAllEvents();\n+        _isNewSessionEventFired = true;\n+      } else if (event.getState() == KeeperState.Expired) {\n+        _isNewSessionEventFired = false;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MTY5MTM4", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385169138", "createdAt": "2020-03-31T23:18:24Z", "commit": {"oid": "0f21ce7b929ffa7a436be3910e40fb9791dc1c1c"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dd05dcae3d88383b038e8ba56ecd755d1d4aff1", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/6dd05dcae3d88383b038e8ba56ecd755d1d4aff1", "committedDate": "2020-04-01T07:10:09Z", "message": "major overhaul base on feedback\n\n1/ move the test from TestZkHelixPropertyStore to TestZkCacheAsyncOpSingleThread\nThis is to use TestHelper.VerifyWithTimeout()\n2/ add expireSession with SharedZkClient featue in ZkTestHelper and remove all\nthe public accessor to get ZkClient for test purpose"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c705916ec73af6ea6677a511ffd1798c1b66c335", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/c705916ec73af6ea6677a511ffd1798c1b66c335", "committedDate": "2020-04-01T07:15:57Z", "message": "restore TestZkHelixPropertyStore.java."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bb700818edbd8f7711d55582046aae94e009a94", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/7bb700818edbd8f7711d55582046aae94e009a94", "committedDate": "2020-04-01T07:38:33Z", "message": "remove one more test only accessor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/c25db42f5f9a524d204d658a5e3858b1c5273d6c", "committedDate": "2020-04-01T07:40:37Z", "message": "remove unused import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1OTU5NTg0", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-385959584", "createdAt": "2020-04-01T21:23:51Z", "commit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToyMzo1MVrOF_TI8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToyMzo1MVrOF_TI8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxODE5NA==", "bodyText": "I guess this wait only check if there is an expiring happened. The original wait is to ensure the session has been re-established. So if you want to achieve the same goal, maybe we need to compare the older session and newer session then end the wait.\nGiven that saying, I guess you can just modify the existing method to include this check. Note that if this not happen, we can directly fail the test by throwing an exception.", "url": "https://github.com/apache/helix/pull/924#discussion_r401918194", "createdAt": "2020-04-01T21:23:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/ZkTestHelper.java", "diffHunk": "@@ -146,6 +146,70 @@ public void process(WatchedEvent event) {\n     LOG.info(\"After expiry. sessionId: \" + Long.toHexString(curZookeeper.getSessionId()));\n   }\n \n+  public static void expireSharedZkClientSession(HelixZkClient client) throws Exception {\n+    final CountDownLatch waitExpireSession = new CountDownLatch(1);\n+    final ZkClient zkClient = (ZkClient) client;\n+\n+    IZkStateListener listener = new IZkStateListener() {\n+      @Override\n+      public void handleStateChanged(KeeperState state) throws Exception {\n+        LOG.info(\"IZkStateListener#handleStateChanged, state: \" + state);\n+        if (state == KeeperState.Expired) {\n+          waitExpireSession.countDown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MDgyOTk2", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-386082996", "createdAt": "2020-04-02T03:16:48Z", "commit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMzoxNjo0OFrOF_Z5qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMzoxNjo0OFrOF_Z5qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyODk2OA==", "bodyText": "This comment is a bit confusing.  You mean \"The following only applies to dedicated ZkClient in which it manages ZkConnection directly\", right?", "url": "https://github.com/apache/helix/pull/924#discussion_r402028968", "createdAt": "2020-04-02T03:16:48Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1073,10 +1073,24 @@ protected void processStateChanged(WatchedEvent event) {\n \n     fireStateChangedEvent(event.getState());\n \n+    // This following is the case for ZkClient no managing connection\n     if (!isManagingZkConnection()) {\n+      /*\n+       * For SharedZkClient, we will not invoke fireNewSessionEvents but will invoke fireAllEvents\n+       * This keeps the same behavior as original SharedZkClient.\n+       * Invoking fireAllEvents is important to make sure HelixPropertyStore working correctly.\n+       */\n+      if ((event.getState() == KeeperState.SyncConnected) && (!_isNewSessionEventFired) && (!\"0\"\n+          .equals(getHexSessionId()))) {\n+        fireAllEvents();\n+        _isNewSessionEventFired = true;\n+      } else if (event.getState() == KeeperState.Expired) {\n+        _isNewSessionEventFired = false;\n+      }\n       return;\n     }\n \n+    // The following is the case for ZkClient managing the connection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MDg0NDg1", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-386084485", "createdAt": "2020-04-02T03:22:22Z", "commit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMzoyMjoyM1rOF_Z-7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMzoyMjoyM1rOF_Z-7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzMDMxNg==", "bodyText": "Can we subscribe to the state change instead of busy loop?", "url": "https://github.com/apache/helix/pull/924#discussion_r402030316", "createdAt": "2020-04-02T03:22:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/ZkTestHelper.java", "diffHunk": "@@ -146,6 +146,70 @@ public void process(WatchedEvent event) {\n     LOG.info(\"After expiry. sessionId: \" + Long.toHexString(curZookeeper.getSessionId()));\n   }\n \n+  public static void expireSharedZkClientSession(HelixZkClient client) throws Exception {\n+    final CountDownLatch waitExpireSession = new CountDownLatch(1);\n+    final ZkClient zkClient = (ZkClient) client;\n+\n+    IZkStateListener listener = new IZkStateListener() {\n+      @Override\n+      public void handleStateChanged(KeeperState state) throws Exception {\n+        LOG.info(\"IZkStateListener#handleStateChanged, state: \" + state);\n+        if (state == KeeperState.Expired) {\n+          waitExpireSession.countDown();\n+        }\n+      }\n+\n+      @Override\n+      public void handleNewSession(final String sessionId) throws Exception {\n+      }\n+\n+      @Override\n+      public void handleSessionEstablishmentError(Throwable var1) throws Exception {\n+      }\n+    };\n+\n+    zkClient.subscribeStateChanges(listener);\n+\n+    ZkConnection connection = ((ZkConnection) zkClient.getConnection());\n+    ZooKeeper curZookeeper = connection.getZookeeper();\n+    String oldSessionId = Long.toHexString(curZookeeper.getSessionId());\n+    LOG.info(\"Before session expiry. sessionId: \" + oldSessionId + \", zk: \" + curZookeeper);\n+\n+    Watcher watcher = new Watcher() {\n+      @Override\n+      public void process(WatchedEvent event) {\n+        LOG.info(\"Watcher#process, event: \" + event);\n+      }\n+    };\n+\n+    final ZooKeeper dupZookeeper =\n+        new ZooKeeper(connection.getServers(), curZookeeper.getSessionTimeout(), watcher,\n+            curZookeeper.getSessionId(), curZookeeper.getSessionPasswd());\n+    // wait until connected, then close\n+    while (dupZookeeper.getState() != States.CONNECTED) {\n+      Thread.sleep(10);\n+    }\n+    Assert.assertEquals(dupZookeeper.getState(), States.CONNECTED,\n+        \"Fail to connect to zk using current session info\");\n+    dupZookeeper.close();\n+\n+    // make sure session expiry really happens\n+    waitExpireSession.await();\n+    zkClient.unsubscribeStateChanges(listener);\n+\n+    connection = (ZkConnection) zkClient.getConnection();\n+    curZookeeper = connection.getZookeeper();\n+\n+    // wait util connected\n+    while (curZookeeper.getState() != States.CONNECTED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjAwNjQw", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-386200640", "createdAt": "2020-04-02T08:17:02Z", "commit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxNzowMlrOF_gLhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo1Mjo1MVrOF_hguQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMTg0NQ==", "bodyText": "If it is just a local var, no need to make it capitalized.", "url": "https://github.com/apache/helix/pull/924#discussion_r402131845", "createdAt": "2020-04-02T08:17:02Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,83 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MjY2OA==", "bodyText": "+1 to get rid of busy sleeping.", "url": "https://github.com/apache/helix/pull/924#discussion_r402142668", "createdAt": "2020-04-02T08:35:24Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/ZkTestHelper.java", "diffHunk": "@@ -146,6 +146,70 @@ public void process(WatchedEvent event) {\n     LOG.info(\"After expiry. sessionId: \" + Long.toHexString(curZookeeper.getSessionId()));\n   }\n \n+  public static void expireSharedZkClientSession(HelixZkClient client) throws Exception {\n+    final CountDownLatch waitExpireSession = new CountDownLatch(1);\n+    final ZkClient zkClient = (ZkClient) client;\n+\n+    IZkStateListener listener = new IZkStateListener() {\n+      @Override\n+      public void handleStateChanged(KeeperState state) throws Exception {\n+        LOG.info(\"IZkStateListener#handleStateChanged, state: \" + state);\n+        if (state == KeeperState.Expired) {\n+          waitExpireSession.countDown();\n+        }\n+      }\n+\n+      @Override\n+      public void handleNewSession(final String sessionId) throws Exception {\n+      }\n+\n+      @Override\n+      public void handleSessionEstablishmentError(Throwable var1) throws Exception {\n+      }\n+    };\n+\n+    zkClient.subscribeStateChanges(listener);\n+\n+    ZkConnection connection = ((ZkConnection) zkClient.getConnection());\n+    ZooKeeper curZookeeper = connection.getZookeeper();\n+    String oldSessionId = Long.toHexString(curZookeeper.getSessionId());\n+    LOG.info(\"Before session expiry. sessionId: \" + oldSessionId + \", zk: \" + curZookeeper);\n+\n+    Watcher watcher = new Watcher() {\n+      @Override\n+      public void process(WatchedEvent event) {\n+        LOG.info(\"Watcher#process, event: \" + event);\n+      }\n+    };\n+\n+    final ZooKeeper dupZookeeper =\n+        new ZooKeeper(connection.getServers(), curZookeeper.getSessionTimeout(), watcher,\n+            curZookeeper.getSessionId(), curZookeeper.getSessionPasswd());\n+    // wait until connected, then close\n+    while (dupZookeeper.getState() != States.CONNECTED) {\n+      Thread.sleep(10);\n+    }\n+    Assert.assertEquals(dupZookeeper.getState(), States.CONNECTED,\n+        \"Fail to connect to zk using current session info\");\n+    dupZookeeper.close();\n+\n+    // make sure session expiry really happens\n+    waitExpireSession.await();\n+    zkClient.unsubscribeStateChanges(listener);\n+\n+    connection = (ZkConnection) zkClient.getConnection();\n+    curZookeeper = connection.getZookeeper();\n+\n+    // wait util connected\n+    while (curZookeeper.getState() != States.CONNECTED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzMDMxNg=="}, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NTMyNA==", "bodyText": "Should assign the result to ret?", "url": "https://github.com/apache/helix/pull/924#discussion_r402145324", "createdAt": "2020-04-02T08:39:41Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,83 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NzA4Mw==", "bodyText": "Naming SharedZkClient doesn\u2019t match the parameter type HelixZkClient.\nFYI, it seems the only difference between expireSession and this is, this does not have handleNewSession implementation logic. Would you consider reducing the duplicate code?", "url": "https://github.com/apache/helix/pull/924#discussion_r402147083", "createdAt": "2020-04-02T08:42:28Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/ZkTestHelper.java", "diffHunk": "@@ -146,6 +146,70 @@ public void process(WatchedEvent event) {\n     LOG.info(\"After expiry. sessionId: \" + Long.toHexString(curZookeeper.getSessionId()));\n   }\n \n+  public static void expireSharedZkClientSession(HelixZkClient client) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MzY1Nw==", "bodyText": "Assert this?", "url": "https://github.com/apache/helix/pull/924#discussion_r402153657", "createdAt": "2020-04-02T08:52:51Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,83 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );\n+\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    ZkTestHelper.expireSharedZkClientSession(dupZkclient);\n+\n+    // kill the session one more time to cover code path ZkClient resetting flag that\n+    // indicates first time synconnect happened.\n+    ZkTestHelper.expireSharedZkClientSession(dupZkclient);\n+\n+    // remove the currentstates\n+    paths.clear();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      paths.add(path);\n+    }\n+    success = extBaseAccessor.remove(paths, 0);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in remove:\" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cc623ce4560b9ba81e3daa97a04ef39dfdc540e", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/2cc623ce4560b9ba81e3daa97a04ef39dfdc540e", "committedDate": "2020-04-02T19:36:58Z", "message": "enhance TestHelper.expireSession.\nuse the concise logic in zkClient."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/c558a80c5d6dc2cd6cf62ca1615f70196fc2adba", "committedDate": "2020-04-07T03:47:43Z", "message": "Make flaky test happy."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjI2MzY4", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-390226368", "createdAt": "2020-04-08T18:28:57Z", "commit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODoyODo1N1rOGC7r9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODoyODo1N1rOGC7r9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyODI0NQ==", "bodyText": "What if reconnect is not done successfully in the following reconnectOnExpiring() call?\nIn that case, if we change this flag to false, will it cause additional fireNewSessionEvents()? For example if we have a stale new session event in the queue.", "url": "https://github.com/apache/helix/pull/924#discussion_r405728245", "createdAt": "2020-04-08T18:28:57Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1101,7 +1104,10 @@ protected void processStateChanged(WatchedEvent event) {\n         fireAllEvents();\n       }\n     } else if (event.getState() == KeeperState.Expired) {\n-      reconnectOnExpiring();\n+      _isNewSessionEventFired = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjQyNjky", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-390242692", "createdAt": "2020-04-08T18:51:34Z", "commit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODo1MTozNFrOGC8gUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODo1MzowNFrOGC8joQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MTY1MQ==", "bodyText": "Discussed wit Kai offline, this should be fine as long as processStateChanged is synchronized called in one thread.", "url": "https://github.com/apache/helix/pull/924#discussion_r405741651", "createdAt": "2020-04-08T18:51:34Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1101,7 +1104,10 @@ protected void processStateChanged(WatchedEvent event) {\n         fireAllEvents();\n       }\n     } else if (event.getState() == KeeperState.Expired) {\n-      reconnectOnExpiring();\n+      _isNewSessionEventFired = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyODI0NQ=="}, "originalCommit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjI1NA==", "bodyText": "As we moved the isManagingZkConnection closer to these methods, it might be cleaner if we just move it inside reconnectOnExpiring() and fireNewSessionEvents(). So we have better protection and the code looks cleaner.", "url": "https://github.com/apache/helix/pull/924#discussion_r405742254", "createdAt": "2020-04-08T18:52:38Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1101,7 +1104,10 @@ protected void processStateChanged(WatchedEvent event) {\n         fireAllEvents();\n       }\n     } else if (event.getState() == KeeperState.Expired) {\n-      reconnectOnExpiring();\n+      _isNewSessionEventFired = false;\n+      if (isManagingZkConnection()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjQ5Nw==", "bodyText": "BTW, please update the comment of _isNewSessionEventFired, it is out of date.", "url": "https://github.com/apache/helix/pull/924#discussion_r405742497", "createdAt": "2020-04-08T18:53:04Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1101,7 +1104,10 @@ protected void processStateChanged(WatchedEvent event) {\n         fireAllEvents();\n       }\n     } else if (event.getState() == KeeperState.Expired) {\n-      reconnectOnExpiring();\n+      _isNewSessionEventFired = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyODI0NQ=="}, "originalCommit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjc0MDU4", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-390274058", "createdAt": "2020-04-08T19:38:52Z", "commit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOTozODo1MlrOGC-EmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOTo0MjoxOFrOGC-Lrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2NzMyMQ==", "bodyText": "I was also thinking about the same concern.  It should be fine as it is protected by the eventLock. And also if reconnecting fails because of IOException, the old/expired zk is kept, but the expired zk could not do anything.", "url": "https://github.com/apache/helix/pull/924#discussion_r405767321", "createdAt": "2020-04-08T19:38:52Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1101,7 +1104,10 @@ protected void processStateChanged(WatchedEvent event) {\n         fireAllEvents();\n       }\n     } else if (event.getState() == KeeperState.Expired) {\n-      reconnectOnExpiring();\n+      _isNewSessionEventFired = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyODI0NQ=="}, "originalCommit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2NzY5Ng==", "bodyText": "Do you think this should be changed, since I've seen you agreement but no change?", "url": "https://github.com/apache/helix/pull/924#discussion_r405767696", "createdAt": "2020-04-08T19:39:39Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,83 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NTMyNA=="}, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2OTEzNQ==", "bodyText": "If you have to use sleep to wait for the sync connected, I do see duplicate code and it could replaced by TestHelper.varify(), which saves you the duplicate code and also offers a timeout option in case it is forever blocked here.", "url": "https://github.com/apache/helix/pull/924#discussion_r405769135", "createdAt": "2020-04-08T19:42:18Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,100 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    while (true) {\n+      long curSessionId = dupZkclient.getSessionId();\n+      if (curSessionId == sessionId || curSessionId == 0) {\n+        Thread.sleep(500);\n+      } else {\n+        sessionId = curSessionId;\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c558a80c5d6dc2cd6cf62ca1615f70196fc2adba"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca", "committedDate": "2020-04-09T00:06:55Z", "message": "address some comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNTA1ODY1", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-390505865", "createdAt": "2020-04-09T05:48:29Z", "commit": {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNTo0ODoyOVrOGDKaeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNTo1NjowOVrOGDKjbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2OTUyOA==", "bodyText": "It could be simplified to return curSessionId != sessionId && curSessionId != 0?", "url": "https://github.com/apache/helix/pull/924#discussion_r405969528", "createdAt": "2020-04-09T05:48:29Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,99 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    final long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(()-> {\n+      long curSessionId = dupZkclient.getSessionId();\n+      if (curSessionId != sessionId && curSessionId != 0) {\n+        return true;\n+      }\n+      return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2OTg3Mw==", "bodyText": "Unnecessary extra space before )", "url": "https://github.com/apache/helix/pull/924#discussion_r405969873", "createdAt": "2020-04-09T05:49:37Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,99 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDQ1Nw==", "bodyText": "I've seen multiple places not formatted. Can you format your changes here?", "url": "https://github.com/apache/helix/pull/924#discussion_r405970457", "createdAt": "2020-04-09T05:51:42Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,99 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n+          \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000,\n+        zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true  );\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    final long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(()-> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDc4OQ==", "bodyText": "Style?", "url": "https://github.com/apache/helix/pull/924#discussion_r405970789", "createdAt": "2020-04-09T05:52:44Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,83 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMTg0NQ=="}, "originalCommit": {"oid": "c25db42f5f9a524d204d658a5e3858b1c5273d6c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MTYxMw==", "bodyText": "Reversed way? Managing connection should fire handle new session events.", "url": "https://github.com/apache/helix/pull/924#discussion_r405971613", "createdAt": "2020-04-09T05:55:26Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1150,6 +1156,10 @@ private void reconnect() {\n   }\n \n   private void fireNewSessionEvents() {\n+    // only managing zkclient fire handleNewSession event\n+    if (isManagingZkConnection()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MTgyMA==", "bodyText": "Reversed.\nAnd please correct the comment.", "url": "https://github.com/apache/helix/pull/924#discussion_r405971820", "createdAt": "2020-04-09T05:56:09Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1101,11 +1103,16 @@ protected void processStateChanged(WatchedEvent event) {\n         fireAllEvents();\n       }\n     } else if (event.getState() == KeeperState.Expired) {\n+      _isNewSessionEventFired = false;\n       reconnectOnExpiring();\n     }\n   }\n \n   private void reconnectOnExpiring() {\n+    // only managing zkclient fire handleNewSession event\n+    if (isManagingZkConnection()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNTQyODg1", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-390542885", "createdAt": "2020-04-09T07:14:11Z", "commit": {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNzoxNDoxMVrOGDMWlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNzoxNDoxMVrOGDMWlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwMTMwMg==", "bodyText": "Thanks for put the check inside the function. But why we need to move it to after _isNewSessionEventFired = true;?\nIs it concerning? Because when _isNewSessionEventFired is set to true, the event is not sent yet.", "url": "https://github.com/apache/helix/pull/924#discussion_r406001302", "createdAt": "2020-04-09T07:14:11Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1080,22 +1080,21 @@ protected void processStateChanged(WatchedEvent event) {\n      */\n     if (event.getState() == KeeperState.SyncConnected) {\n       if (!_isNewSessionEventFired && !\"0\".equals(getHexSessionId())) {\n-        if (isManagingZkConnection()) {\n-          /*\n-           * Before the new zookeeper instance is connected to the zookeeper service and its session\n-           * is established, its session id is 0.\n-           * New session event is not fired until the new zookeeper session receives the first\n-           * SyncConnected state(the zookeeper session is established).\n-           * Now the session id is available and non-zero, and we can fire new session events.\n-           */\n-          fireNewSessionEvents();\n-        }\n         /*\n          * Set it true to avoid firing events again for the same session next time\n          * when SyncConnected events are received.\n          */\n         _isNewSessionEventFired = true;\n \n+        /*\n+         * Before the new zookeeper instance is connected to the zookeeper service and its session\n+         * is established, its session id is 0.\n+         * New session event is not fired until the new zookeeper session receives the first\n+         * SyncConnected state(the zookeeper session is established).\n+         * Now the session id is available and non-zero, and we can fire new session events.\n+         */\n+        fireNewSessionEvents();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1711ab8e4a9712a39b4dbf00f73ae0a947bbbca"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41273d1188a0cd2f91f00681ba37b8b72795edb3", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/41273d1188a0cd2f91f00681ba37b8b72795edb3", "committedDate": "2020-04-09T18:11:21Z", "message": "formatting and address comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMDM0Mzc0", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-391034374", "createdAt": "2020-04-09T18:31:19Z", "commit": {"oid": "41273d1188a0cd2f91f00681ba37b8b72795edb3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTIxNDA0", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-392521404", "createdAt": "2020-04-14T00:15:06Z", "commit": {"oid": "41273d1188a0cd2f91f00681ba37b8b72795edb3"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDoxNTowN1rOGE5oAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMToxNDoyNlrOGE6pjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MTYxNw==", "bodyText": "Nit, just make my point clear: this is kind of redundant, not what I meant. I meant\nreturn curSessionId != sessionId && curSessionId != 0;", "url": "https://github.com/apache/helix/pull/924#discussion_r407791617", "createdAt": "2020-04-14T00:15:07Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,93 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder\n+          .instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000, zkCacheInitPaths, accessor._zkCache._cache,\n+        _gZkClient, true);\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    final long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(() -> {\n+      long curSessionId = dupZkclient.getSessionId();\n+      return curSessionId != sessionId && curSessionId != 0 ? true : false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41273d1188a0cd2f91f00681ba37b8b72795edb3"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MzIxMQ==", "bodyText": "I still think CURSTATECNT should follow the style: it is not a constant variable.", "url": "https://github.com/apache/helix/pull/924#discussion_r407793211", "createdAt": "2020-04-14T00:20:22Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,93 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41273d1188a0cd2f91f00681ba37b8b72795edb3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwODM5Nw==", "bodyText": "@kaisun2000 My understanding is, the current states created by this invalid session \"session_0\" would also be invalid. Can you help me understand if these invalid current states would work for this testing purpose? Thanks.", "url": "https://github.com/apache/helix/pull/924#discussion_r407808397", "createdAt": "2020-04-14T01:14:26Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,93 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder\n+          .instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41273d1188a0cd2f91f00681ba37b8b72795edb3"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68afe66fd7fa041d55ec5b822352a828830a1f3c", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/68afe66fd7fa041d55ec5b822352a828830a1f3c", "committedDate": "2020-04-14T17:56:17Z", "message": "address some minor issue."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjAxOTY3", "url": "https://github.com/apache/helix/pull/924#pullrequestreview-393201967", "createdAt": "2020-04-14T18:47:47Z", "commit": {"oid": "68afe66fd7fa041d55ec5b822352a828830a1f3c"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODo0Nzo0N1rOGFcOxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODo1MDoxMlrOGFcUWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1ODU5Ng==", "bodyText": "This block of clearing current state paths is unnecessary, as the paths list is not changed?", "url": "https://github.com/apache/helix/pull/924#discussion_r408358596", "createdAt": "2020-04-14T18:47:47Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,93 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int curstateCnt = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < curstateCnt; i++) {\n+      String path = PropertyPathBuilder\n+          .instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n+      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n+\n+      paths.add(path);\n+      records.add(record);\n+    }\n+\n+    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n+    for (int i = 0; i < curstateCnt; i++) {\n+      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n+    }\n+\n+    TestHelper.verifyWithTimeout(\"verifyZkCache\", 5000, zkCacheInitPaths, accessor._zkCache._cache,\n+        _gZkClient, true);\n+\n+    // dup shared ZkClient\n+    HelixZkClient dupZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+\n+    // kill the session to make sure shared zkClient re-installs watcher\n+    final long sessionId = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(() -> {\n+      long curSessionId = dupZkclient.getSessionId();\n+      return curSessionId != sessionId && curSessionId != 0;\n+    }, 10000);\n+    Assert.assertTrue(ret, \"kill session timed out!\");\n+\n+    // kill the session one more time to cover code path ZkClient resetting flag that\n+    // indicates first time synconnect happened.\n+    final long sessionId1 = dupZkclient.getSessionId();\n+    ZkTestHelper.asyncExpireSession(dupZkclient);\n+    ret = TestHelper.verify(() -> {\n+      long curSessionId = dupZkclient.getSessionId();\n+      return curSessionId != sessionId1 && curSessionId != 0;\n+    }, 10000);\n+    Assert.assertTrue(ret, \"kill session second time timed out!\");\n+\n+    // remove the currentstates\n+    paths.clear();\n+    for (int i = 0; i < curstateCnt; i++) {\n+      String path = PropertyPathBuilder\n+          .instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n+      paths.add(path);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68afe66fd7fa041d55ec5b822352a828830a1f3c"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2MDAyNQ==", "bodyText": "My point was, I just wanted to understand it is not only reading the current state paths that have a valid session.\nI double checked. It should work as it would read the paths recursively so \"session_0\" would be read.", "url": "https://github.com/apache/helix/pull/924#discussion_r408360025", "createdAt": "2020-04-14T18:50:12Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java", "diffHunk": "@@ -37,6 +38,93 @@\n import org.testng.annotations.Test;\n \n public class TestZkCacheAsyncOpSingleThread extends ZkUnitTestBase {\n+  @Test\n+  public void testSessionExpirationWithSharedZkClient() throws Exception {\n+    int CURSTATECNT = 10;\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+\n+    // init external base data accessor\n+    HelixZkClient sharedZkclient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n+    sharedZkclient.setZkSerializer(new ZNRecordSerializer());\n+    ZkBaseDataAccessor<ZNRecord> sharedBaseAccessor = new ZkBaseDataAccessor<>(sharedZkclient);\n+\n+    // init zkCacheBaseDataAccessor\n+    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n+    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n+\n+    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n+    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n+\n+    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n+    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n+        new ZkCacheBaseDataAccessor<>(sharedBaseAccessor, null, null, zkCacheInitPaths);\n+\n+    boolean ret =\n+        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n+    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n+\n+    // create 10 current states using external base accessor\n+    List<String> paths = new ArrayList<>();\n+    List<ZNRecord> records = new ArrayList<>();\n+    for (int i = 0; i < CURSTATECNT; i++) {\n+      String path = PropertyPathBuilder\n+          .instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwODM5Nw=="}, "originalCommit": {"oid": "41273d1188a0cd2f91f00681ba37b8b72795edb3"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4748, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}