{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNjc3ODAw", "number": 727, "title": "Add MetadataStoreRoutingDataWriter with DistributedLeaderElection", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nResolves #725\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nWe need a separate ZkClient-based writer that could allow users to write routing data to ZK. This diff adds such an interface, an implementation, and a distributed lock implementation that could help users to manipulate the routing data.\nChangelist:\n\nAdd ZkRoutingDataWriter (+ interface)\nAdd ZkDistributedLock (+ interface) to guarantee that there's at most one active writer at a time (where there are multiple Helix REST deployables)\nAdd a test for ZkRoutingDataWriter\nIntegrate ZkRoutingDataWriter with ZkMetadataStoreDirectory\nAdd test methods to TestZkMetadataStoreDirectory\nAdd ZkDistributedElection to replace ZkDistributedLock (and move ZkDistributedLock to a separate PR)\n\nTests\n\n The following tests are written for this issue:\n\nTestZkRoutingDataWriter\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n\nShut down zookeeper at port 2124 in thread main\nShut down zookeeper at port 2124 in thread main\nShut down zookeeper at port 2123 in thread main\n[INFO] Tests run: 117, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 21.253 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 117, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO]\n[INFO] --- maven-surefire-plugin:3.0.0-M3:test (multi-zk) @ helix-rest ---\n[INFO]\n[INFO] -------------------------------------------------------\n...\n\n\nEnd test :testInvalidHelixRestServerInitialization\nShut down zookeeper at port 2123 in thread main\nShut down zookeeper at port 2124 in thread main\nShut down zookeeper at port 2124 in thread main\nShut down zookeeper at port 2125 in thread main\nShut down zookeeper at port 2123 in thread main\n[INFO] Tests run: 117, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 24.038 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 117, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  51.877 s\n[INFO] Finished at: 2020-02-05T21:14:05-08:00\n[INFO] ------------------------------------------------------------------------\n\n\nhelix-rest run:\n\n[INFO] Tests run: 117, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 20.951 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 117, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  47.479 s\n[INFO] Finished at: 2020-02-09T16:28:51-08:00\n[INFO] ----------------------------\n\nNewest run:\n\nShut down zookeeper at port 2124 in thread main\nShut down zookeeper at port 2125 in thread main\nShut down zookeeper at port 2123 in thread main\n[INFO] Tests run: 127, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 20.768 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 127, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  47.168 s\n[INFO] Finished at: 2020-02-10T16:56:16-08:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-06T02:30:52Z", "url": "https://github.com/apache/helix/pull/727", "merged": true, "mergeCommit": {"oid": "c436392db89d2ff9668d41a5433f84d730501f31"}, "closed": true, "closedAt": "2020-02-11T00:57:58Z", "author": {"login": "narendly"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBlbkCAFqTM1NDIzODY3MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDHAa7gBqjMwMjQ5MjE4ODg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjM4Njcw", "url": "https://github.com/apache/helix/pull/727#pullrequestreview-354238670", "createdAt": "2020-02-06T07:16:32Z", "commit": {"oid": "cff9c2ed7eeb861d707f4c019c4ec88fad627182"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwNzoxNjozMlrOFmRJ0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwNzoxNjozMlrOFmRJ0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3MTI0OA==", "bodyText": "Fundamentally, I think this is not an efficient way for purpose of control of centralized work. This may increase the traffic to ZK.\nIt will be better to work as Helix leader controller. One of the REST server become write REST server (acquire the lock once). Write request to read-only server forward the request to write server for write purpose.", "url": "https://github.com/apache/helix/pull/727#discussion_r375671248", "createdAt": "2020-02-06T07:16:32Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.DistributedLock;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLock;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final DistributedLock _routingDataLock;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff9c2ed7eeb861d707f4c019c4ec88fad627182"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NTAxNTg3", "url": "https://github.com/apache/helix/pull/727#pullrequestreview-355501587", "createdAt": "2020-02-07T23:53:12Z", "commit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo1MzoxMlrOFnNgDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo1MzoxMlrOFnNgDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1OTk4Mw==", "bodyText": "Did you mean to get the hostname here instead of using the dummy hostname?", "url": "https://github.com/apache/helix/pull/727#discussion_r376659983", "createdAt": "2020-02-07T23:53:12Z", "author": {"login": "mgao0"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkAddress = zkAddress;\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NTAyMzU0", "url": "https://github.com/apache/helix/pull/727#pullrequestreview-355502354", "createdAt": "2020-02-07T23:56:17Z", "commit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo1NjoxN1rOFnNitQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo1NjoxN1rOFnNitQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MDY2MQ==", "bodyText": "Can you create a variable for the path so you don't need to repeatedly type it out?", "url": "https://github.com/apache/helix/pull/727#discussion_r376660661", "createdAt": "2020-02-07T23:56:17Z", "author": {"login": "mgao0"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkAddress = zkAddress;\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      if (!_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NTA1NDYx", "url": "https://github.com/apache/helix/pull/727#pullrequestreview-355505461", "createdAt": "2020-02-08T00:10:05Z", "commit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoxMDowNVrOFnNtbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoxMDowNVrOFnNtbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MzQwNg==", "bodyText": "try catch so no need to check if the path exists?", "url": "https://github.com/apache/helix/pull/727#discussion_r376663406", "createdAt": "2020-02-08T00:10:05Z", "author": {"login": "mgao0"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkAddress = zkAddress;\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      if (!_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord =\n+            _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      ZNRecord znRecord =\n+          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+      if (znRecord == null || !znRecord\n+          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .contains(shardingKey)) {\n+        // This realm does not exist or shardingKey doesn't exist. Return true!\n+        return true;\n+      }\n+      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .remove(shardingKey);\n+      // Overwrite this ZNRecord with the sharding key removed\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean setRoutingData(Map<String, List<String>> routingData) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      if (routingData == null) {\n+        throw new IllegalArgumentException(\"routingData given is null!\");\n+      }\n+\n+      // Remove existing routing data\n+      for (String zkRealm : _zkClient\n+          .getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+        if (!_zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm)) {\n+          LOG.error(\n+              \"Failed to delete existing routing data in setRoutingData()! Namespace: {}, Realm: {}\",\n+              _namespace, zkRealm);\n+          return false;\n+        }\n+      }\n+\n+      // For each ZkRealm, write the given routing data to ZooKeeper\n+      for (Map.Entry<String, List<String>> routingDataEntry : routingData.entrySet()) {\n+        String zkRealm = routingDataEntry.getKey();\n+        List<String> shardingKeyList = routingDataEntry.getValue();\n+\n+        ZNRecord znRecord = new ZNRecord(zkRealm);\n+        znRecord\n+            .setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeyList);\n+        try {\n+          if (!_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "originalPosition": 210}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NTE4NTIw", "url": "https://github.com/apache/helix/pull/727#pullrequestreview-355518520", "createdAt": "2020-02-08T01:27:30Z", "commit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMToyNzozMFrOFnOaYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMToyNzozMFrOFnOaYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3NDkxMg==", "bodyText": "Nit: can we recursively delete MetadataStoreRoutingConstants.ROUTING_DATA_PATH here?", "url": "https://github.com/apache/helix/pull/727#discussion_r376674912", "createdAt": "2020-02-08T01:27:30Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.ZkLockException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final String _zkAddress;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkAddress = zkAddress;\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      if (!_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord =\n+            _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      ZNRecord znRecord =\n+          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+      if (znRecord == null || !znRecord\n+          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .contains(shardingKey)) {\n+        // This realm does not exist or shardingKey doesn't exist. Return true!\n+        return true;\n+      }\n+      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .remove(shardingKey);\n+      // Overwrite this ZNRecord with the sharding key removed\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean setRoutingData(Map<String, List<String>> routingData) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      if (routingData == null) {\n+        throw new IllegalArgumentException(\"routingData given is null!\");\n+      }\n+\n+      // Remove existing routing data\n+      for (String zkRealm : _zkClient\n+          .getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NTE5NDQz", "url": "https://github.com/apache/helix/pull/727#pullrequestreview-355519443", "createdAt": "2020-02-08T01:35:49Z", "commit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTozNTo0OVrOFnOdsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTozNTo0OVrOFnOdsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3NTc2Mw==", "bodyText": "IMO the test cases are not complete. Each of the test cases should at least cover both true and false situations. The test for setRoutingData needs to make sure it overwrites.", "url": "https://github.com/apache/helix/pull/727#discussion_r376675763", "createdAt": "2020-02-08T01:35:49Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.server.AbstractTestClass;\n+import org.junit.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestZkRoutingDataWriter extends AbstractTestClass {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4"}, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b6214bf75d25adabe3bb947382f6cee94e6072c4", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/b6214bf75d25adabe3bb947382f6cee94e6072c4", "committedDate": "2020-02-07T04:03:07Z", "message": "Remove unused import"}, "afterCommit": {"oid": "4c09e1fd298985277d1c1e004d5412630e3e8523", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/4c09e1fd298985277d1c1e004d5412630e3e8523", "committedDate": "2020-02-09T23:09:47Z", "message": "Fix tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c09e1fd298985277d1c1e004d5412630e3e8523", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/4c09e1fd298985277d1c1e004d5412630e3e8523", "committedDate": "2020-02-09T23:09:47Z", "message": "Fix tests"}, "afterCommit": {"oid": "fe35863d0be0b07edd40631b14cdbac60bcda0c4", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/fe35863d0be0b07edd40631b14cdbac60bcda0c4", "committedDate": "2020-02-09T23:11:36Z", "message": "Fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MTkwMTYy", "url": "https://github.com/apache/helix/pull/727#pullrequestreview-356190162", "createdAt": "2020-02-10T19:10:08Z", "commit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToxMDowOFrOFnyHtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMToxMDozNFrOFn1rGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTk1OA==", "bodyText": "This logic looks good to me. I just would like to ask a further question. Let's say user failed to add realm due to non-exists namespace. Then the user would like to add the namespace, how they can do it?", "url": "https://github.com/apache/helix/pull/727#discussion_r377259958", "createdAt": "2020-02-10T19:10:08Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -132,26 +131,38 @@ public String getMetadataStoreRealm(String namespace, String shardingKey) {\n \n   @Override\n   public boolean addMetadataStoreRealm(String namespace, String realm) {\n-    // TODO implement when MetadataStoreRoutingDataWriter is ready\n-    throw new UnsupportedOperationException();\n+    if (!_routingDataWriterMap.containsKey(namespace)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MDQ1NA==", "bodyText": "Is there possible an operation to rename realm/sharding key?", "url": "https://github.com/apache/helix/pull/727#discussion_r377260454", "createdAt": "2020-02-10T19:11:07Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/MetadataStoreRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An interface for a DAO that writes to the metadata store that stores routing data.\n+ * Note: Each data writer connects to a single namespace.\n+ */\n+public interface MetadataStoreRoutingDataWriter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MTU2Ng==", "bodyText": "If you got ZkNodeExistsException, it means creation failed. Would you like to add it again? Why not use _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, true) to create its parent?", "url": "https://github.com/apache/helix/pull/727#discussion_r377261566", "createdAt": "2020-02-10T19:13:20Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxMTQzMw==", "bodyText": "Can we combine these try catches into one and handle the problem by different exceptions?", "url": "https://github.com/apache/helix/pull/727#discussion_r377311433", "createdAt": "2020-02-10T20:56:17Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    // TODO: Fill in when Helix REST implementations are ready\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+      if (!_zkClient.exists(realmPath)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord = _zkClient.readData(realmPath);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient.writeData(realmPath, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxODE2OQ==", "bodyText": "else clause may not need for this case.", "url": "https://github.com/apache/helix/pull/727#discussion_r377318169", "createdAt": "2020-02-10T21:10:34Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    // TODO: Fill in when Helix REST implementations are ready\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+      if (!_zkClient.exists(realmPath)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord = _zkClient.readData(realmPath);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient.writeData(realmPath, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      ZNRecord znRecord =\n+          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+      if (znRecord == null || !znRecord\n+          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .contains(shardingKey)) {\n+        // This realm does not exist or shardingKey doesn't exist. Return true!\n+        return true;\n+      }\n+      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .remove(shardingKey);\n+      // Overwrite this ZNRecord with the sharding key removed\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean setRoutingData(Map<String, List<String>> routingData) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      if (routingData == null) {\n+        throw new IllegalArgumentException(\"routingData given is null!\");\n+      }\n+\n+      // Remove existing routing data\n+      for (String zkRealm : _zkClient\n+          .getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+        if (!_zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm)) {\n+          LOG.error(\n+              \"Failed to delete existing routing data in setRoutingData()! Namespace: {}, Realm: {}\",\n+              _namespace, zkRealm);\n+          return false;\n+        }\n+      }\n+\n+      // For each ZkRealm, write the given routing data to ZooKeeper\n+      for (Map.Entry<String, List<String>> routingDataEntry : routingData.entrySet()) {\n+        String zkRealm = routingDataEntry.getKey();\n+        List<String> shardingKeyList = routingDataEntry.getValue();\n+\n+        ZNRecord znRecord = new ZNRecord(zkRealm);\n+        znRecord\n+            .setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeyList);\n+\n+        String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + zkRealm;\n+        try {\n+          if (!_zkClient.exists(realmPath)) {\n+            _zkClient.createPersistent(realmPath);\n+          }\n+          _zkClient.writeData(realmPath, znRecord);\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to write data in setRoutingData()! Namespace: {}, Realm: {}\",\n+              _namespace, zkRealm, e);\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized void close() {\n+    _zkClient.close();\n+  }\n+\n+  /**\n+   * Creates a ZK realm ZNode and populates it with an empty ZNRecord if it doesn't exist already.\n+   * @param realm\n+   * @return\n+   */\n+  private boolean createZkRealm(String realm) {\n+    if (_zkClient.exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm)) {\n+      LOG.warn(\"createZkRealm() called for realm: {}, but this realm already exists! Namespace: {}\",\n+          realm, _namespace);\n+      return true;\n+    } else {\n+      try {\n+        _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+        _zkClient.writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm,\n+            new ZNRecord(realm));\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to create ZkRealm: {}, Namespace: \", realm, _namespace);\n+        return false;\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "originalPosition": 250}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjY3NzAw", "url": "https://github.com/apache/helix/pull/727#pullrequestreview-356267700", "createdAt": "2020-02-10T21:14:31Z", "commit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMToxNDozMVrOFn1yZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMzoxNDoxOVrOFn5D6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMDAzOA==", "bodyText": "Shall we make it as singleton?", "url": "https://github.com/apache/helix/pull/727#discussion_r377320038", "createdAt": "2020-02-10T21:14:31Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/concurrency/ZkDistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.rest.metadatastore.concurrency;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkDistributedLeaderElection implements IZkDataListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkDistributedLeaderElection.class);\n+  private static final String PREFIX = \"MSDS_SERVER_\";\n+\n+  private final HelixZkClient _zkClient;\n+  private final String _basePath;\n+  private final ZNRecord _participantInfo;\n+  private ZNRecord _currentLeaderInfo;\n+\n+  private String _myEphemeralSequentialPath;\n+  private volatile boolean _isLeader;\n+\n+  public ZkDistributedLeaderElection(HelixZkClient zkClient, String basePath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTIwMA==", "bodyText": "Shall we create this ephemeral node first instead of creating storing structure?", "url": "https://github.com/apache/helix/pull/727#discussion_r377321200", "createdAt": "2020-02-10T21:16:58Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/concurrency/ZkDistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.rest.metadatastore.concurrency;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkDistributedLeaderElection implements IZkDataListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkDistributedLeaderElection.class);\n+  private static final String PREFIX = \"MSDS_SERVER_\";\n+\n+  private final HelixZkClient _zkClient;\n+  private final String _basePath;\n+  private final ZNRecord _participantInfo;\n+  private ZNRecord _currentLeaderInfo;\n+\n+  private String _myEphemeralSequentialPath;\n+  private volatile boolean _isLeader;\n+\n+  public ZkDistributedLeaderElection(HelixZkClient zkClient, String basePath,\n+      ZNRecord participantInfo) {\n+    synchronized (this) {\n+      if (zkClient == null || zkClient.isClosed()) {\n+        throw new IllegalArgumentException(\"ZkClient cannot be null or closed!\");\n+      }\n+      _zkClient = zkClient;\n+      _zkClient.setZkSerializer(new ZNRecordSerializer());\n+      if (basePath == null || basePath.isEmpty()) {\n+        throw new IllegalArgumentException(\"lockBasePath cannot be null or empty!\");\n+      }\n+      _basePath = basePath;\n+      _participantInfo = participantInfo;\n+      _isLeader = false;\n+    }\n+    init();\n+  }\n+\n+  /**\n+   * Create the base path if it doesn't exist and create an ephemeral sequential ZNode.\n+   */\n+  private void init() {\n+    try {\n+      _zkClient.createPersistent(_basePath, true);\n+    } catch (ZkNodeExistsException e) {\n+      // Okay if it exists already\n+    }\n+\n+    // Create my ephemeral sequential node with my information\n+    _myEphemeralSequentialPath = _zkClient", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3MDQ0Nw==", "bodyText": "Should this be state change? There should not be any case of ZNode data change, right?", "url": "https://github.com/apache/helix/pull/727#discussion_r377370447", "createdAt": "2020-02-10T23:05:11Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/concurrency/ZkDistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.rest.metadatastore.concurrency;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkDistributedLeaderElection implements IZkDataListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkDistributedLeaderElection.class);\n+  private static final String PREFIX = \"MSDS_SERVER_\";\n+\n+  private final HelixZkClient _zkClient;\n+  private final String _basePath;\n+  private final ZNRecord _participantInfo;\n+  private ZNRecord _currentLeaderInfo;\n+\n+  private String _myEphemeralSequentialPath;\n+  private volatile boolean _isLeader;\n+\n+  public ZkDistributedLeaderElection(HelixZkClient zkClient, String basePath,\n+      ZNRecord participantInfo) {\n+    synchronized (this) {\n+      if (zkClient == null || zkClient.isClosed()) {\n+        throw new IllegalArgumentException(\"ZkClient cannot be null or closed!\");\n+      }\n+      _zkClient = zkClient;\n+      _zkClient.setZkSerializer(new ZNRecordSerializer());\n+      if (basePath == null || basePath.isEmpty()) {\n+        throw new IllegalArgumentException(\"lockBasePath cannot be null or empty!\");\n+      }\n+      _basePath = basePath;\n+      _participantInfo = participantInfo;\n+      _isLeader = false;\n+    }\n+    init();\n+  }\n+\n+  /**\n+   * Create the base path if it doesn't exist and create an ephemeral sequential ZNode.\n+   */\n+  private void init() {\n+    try {\n+      _zkClient.createPersistent(_basePath, true);\n+    } catch (ZkNodeExistsException e) {\n+      // Okay if it exists already\n+    }\n+\n+    // Create my ephemeral sequential node with my information\n+    _myEphemeralSequentialPath = _zkClient\n+        .create(_basePath + \"/\" + PREFIX, _participantInfo, CreateMode.EPHEMERAL_SEQUENTIAL);\n+    if (_myEphemeralSequentialPath == null) {\n+      throw new IllegalStateException(\n+          \"Unable to create ephemeral sequential node at path: \" + _basePath);\n+    }\n+    tryAcquiringLeadership();\n+  }\n+\n+  private void tryAcquiringLeadership() {\n+    List<String> children = _zkClient.getChildren(_basePath);\n+    Collections.sort(children);\n+    String leaderName = children.get(0);\n+    ZNRecord leaderInfo = _zkClient.readData(_basePath + \"/\" + leaderName, true);\n+\n+    String[] myNameArray = _myEphemeralSequentialPath.split(\"/\");\n+    String myName = myNameArray[myNameArray.length - 1];\n+\n+    if (leaderName.equals(myName)) {\n+      // My turn for leadership\n+      _isLeader = true;\n+      _currentLeaderInfo = leaderInfo;\n+      LOG.info(\"{} acquired leadership! Info: {}\", myName, leaderInfo);\n+    } else {\n+      // Watch the ephemeral ZNode before me for a deletion event\n+      String beforeMe = children.get(children.indexOf(myName) - 1);\n+      _zkClient.subscribeDataChanges(_basePath + \"/\" + beforeMe, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8302d3f8df671f18cfe39dce668cccd4a75cfcbd"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3MzAwMA==", "bodyText": "Then let's have a todo here. Since we are working the ZKClient module. Let's have clear different exceptions for different errors. It will benefit the coding convention with that.", "url": "https://github.com/apache/helix/pull/727#discussion_r377373000", "createdAt": "2020-02-10T23:12:26Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package org.apache.helix.rest.metadatastore.accessor;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.rest.metadatastore.concurrency.ZkDistributedLeaderElection;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n+\n+  private final String _namespace;\n+  private final HelixZkClient _zkClient;\n+  private final ZkDistributedLeaderElection _leaderElection;\n+\n+  public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+\n+    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n+    // create() semantic will fail if it already exists\n+    try {\n+      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n+    } catch (ZkNodeExistsException e) {\n+      // This is okay\n+    }\n+\n+    // Get the hostname (REST endpoint) from System property\n+    // TODO: Fill in when Helix REST implementations are ready\n+    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n+        MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+  }\n+\n+  @Override\n+  public synchronized boolean addMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return createZkRealm(realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean deleteMetadataStoreRealm(String realm) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+    }\n+\n+    // TODO: Forward the request to leader\n+    return true;\n+  }\n+\n+  @Override\n+  public synchronized boolean addShardingKey(String realm, String shardingKey) {\n+    if (_leaderElection.isLeader()) {\n+      if (_zkClient.isClosed()) {\n+        throw new IllegalStateException(\"ZkClient is closed!\");\n+      }\n+      // If the realm does not exist already, then create the realm\n+      String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+      if (!_zkClient.exists(realmPath)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord = _zkClient.readData(realmPath);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient.writeData(realmPath, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxMTQzMw=="}, "originalCommit": {"oid": "6aabd9a6b560a2e41c0f0a8e65f80dab31ca077d"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM3MzY3NQ==", "bodyText": "Was data delete referring the content of ZNode instead of ZNode it self?", "url": "https://github.com/apache/helix/pull/727#discussion_r377373675", "createdAt": "2020-02-10T23:14:19Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/concurrency/ZkDistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.rest.metadatastore.concurrency;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.I0Itec.zkclient.exception.ZkNodeExistsException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ZkDistributedLeaderElection implements IZkDataListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkDistributedLeaderElection.class);\n+  private static final String PREFIX = \"MSDS_SERVER_\";\n+\n+  private final HelixZkClient _zkClient;\n+  private final String _basePath;\n+  private final ZNRecord _participantInfo;\n+  private ZNRecord _currentLeaderInfo;\n+\n+  private String _myEphemeralSequentialPath;\n+  private volatile boolean _isLeader;\n+\n+  public ZkDistributedLeaderElection(HelixZkClient zkClient, String basePath,\n+      ZNRecord participantInfo) {\n+    synchronized (this) {\n+      if (zkClient == null || zkClient.isClosed()) {\n+        throw new IllegalArgumentException(\"ZkClient cannot be null or closed!\");\n+      }\n+      _zkClient = zkClient;\n+      _zkClient.setZkSerializer(new ZNRecordSerializer());\n+      if (basePath == null || basePath.isEmpty()) {\n+        throw new IllegalArgumentException(\"lockBasePath cannot be null or empty!\");\n+      }\n+      _basePath = basePath;\n+      _participantInfo = participantInfo;\n+      _isLeader = false;\n+    }\n+    init();\n+  }\n+\n+  /**\n+   * Create the base path if it doesn't exist and create an ephemeral sequential ZNode.\n+   */\n+  private void init() {\n+    try {\n+      _zkClient.createPersistent(_basePath, true);\n+    } catch (ZkNodeExistsException e) {\n+      // Okay if it exists already\n+    }\n+\n+    // Create my ephemeral sequential node with my information\n+    _myEphemeralSequentialPath = _zkClient\n+        .create(_basePath + \"/\" + PREFIX, _participantInfo, CreateMode.EPHEMERAL_SEQUENTIAL);\n+    if (_myEphemeralSequentialPath == null) {\n+      throw new IllegalStateException(\n+          \"Unable to create ephemeral sequential node at path: \" + _basePath);\n+    }\n+    tryAcquiringLeadership();\n+  }\n+\n+  private void tryAcquiringLeadership() {\n+    List<String> children = _zkClient.getChildren(_basePath);\n+    Collections.sort(children);\n+    String leaderName = children.get(0);\n+    ZNRecord leaderInfo = _zkClient.readData(_basePath + \"/\" + leaderName, true);\n+\n+    String[] myNameArray = _myEphemeralSequentialPath.split(\"/\");\n+    String myName = myNameArray[myNameArray.length - 1];\n+\n+    if (leaderName.equals(myName)) {\n+      // My turn for leadership\n+      _isLeader = true;\n+      _currentLeaderInfo = leaderInfo;\n+      LOG.info(\"{} acquired leadership! Info: {}\", myName, leaderInfo);\n+    } else {\n+      // Watch the ephemeral ZNode before me for a deletion event\n+      String beforeMe = children.get(children.indexOf(myName) - 1);\n+      _zkClient.subscribeDataChanges(_basePath + \"/\" + beforeMe, this);\n+    }\n+  }\n+\n+  public synchronized boolean isLeader() {\n+    return _isLeader;\n+  }\n+\n+  public synchronized ZNRecord getCurrentLeaderInfo() {\n+    return _currentLeaderInfo;\n+  }\n+\n+  @Override\n+  public synchronized void handleStateChanged(Watcher.Event.KeeperState state) {\n+    if (state == Watcher.Event.KeeperState.SyncConnected) {\n+      init();\n+    }\n+  }\n+\n+  @Override\n+  public void handleNewSession(String sessionId) {\n+    return;\n+  }\n+\n+  @Override\n+  public void handleSessionEstablishmentError(Throwable error) {\n+    return;\n+  }\n+\n+  @Override\n+  public void handleDataChange(String s, Object o) {\n+    return;\n+  }\n+\n+  @Override\n+  public void handleDataDeleted(String s) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8302d3f8df671f18cfe39dce668cccd4a75cfcbd"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MzY1MTMw", "url": "https://github.com/apache/helix/pull/727#pullrequestreview-356365130", "createdAt": "2020-02-11T00:43:44Z", "commit": {"oid": "8302d3f8df671f18cfe39dce668cccd4a75cfcbd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f031375b63c0beaa1c70aa352e80f5031f06583", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/8f031375b63c0beaa1c70aa352e80f5031f06583", "committedDate": "2020-02-11T00:46:55Z", "message": "Add MetadataStoreRoutingDataWriter and its ZK implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c52b7b4b31292e6ece44a68a34bc0be4097bfd57", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/c52b7b4b31292e6ece44a68a34bc0be4097bfd57", "committedDate": "2020-02-11T00:46:55Z", "message": "Complete implementation with lock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7f4543ab1fb138333b4192d171b0c2e583197ce", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/c7f4543ab1fb138333b4192d171b0c2e583197ce", "committedDate": "2020-02-11T00:46:55Z", "message": "Fix typo and add more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13167dd9a8369523ed91d67a28f67d33747a3051", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/13167dd9a8369523ed91d67a28f67d33747a3051", "committedDate": "2020-02-11T00:46:55Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0db0ffbb0e8bf89cd624d70921ae158f56f0ae3e", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/0db0ffbb0e8bf89cd624d70921ae158f56f0ae3e", "committedDate": "2020-02-11T00:52:22Z", "message": "Integrate with MetadataStoreDirectory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "070a2de721ede141d216bb5691971fba22ccc260", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/070a2de721ede141d216bb5691971fba22ccc260", "committedDate": "2020-02-11T00:52:23Z", "message": "Add tests and fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6655992bf9ef72ab9dab424e5b84d33cd7ffa1b9", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/6655992bf9ef72ab9dab424e5b84d33cd7ffa1b9", "committedDate": "2020-02-11T00:52:23Z", "message": "Use DistributedLeaderElection instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd085a225eb81533586dfedd9407aafca58eb51f", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/bd085a225eb81533586dfedd9407aafca58eb51f", "committedDate": "2020-02-11T00:52:23Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3505d1355b9cb0c35ada895581fd3088bf2746fb", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/3505d1355b9cb0c35ada895581fd3088bf2746fb", "committedDate": "2020-02-11T00:52:23Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3530a627677b7e46bec13506e4bd3eb72d141486", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/3530a627677b7e46bec13506e4bd3eb72d141486", "committedDate": "2020-02-11T00:52:23Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1da51e1cce24ad7631b3c1c9f9f594c10c687aaf", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/1da51e1cce24ad7631b3c1c9f9f594c10c687aaf", "committedDate": "2020-02-11T00:52:23Z", "message": "clean up code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63c67e7c11ab2158e380a4d9536f06e19f4f865a", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/63c67e7c11ab2158e380a4d9536f06e19f4f865a", "committedDate": "2020-02-11T00:52:23Z", "message": "remove unncessary else"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "879ab5a4d8c1d6533a8a0d1f95ed73128d0b7e06", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/879ab5a4d8c1d6533a8a0d1f95ed73128d0b7e06", "committedDate": "2020-02-11T00:52:23Z", "message": "remove unnecessary throw exception"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6767f31dd8c80301c50c2036094d13cef258ae4b", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/6767f31dd8c80301c50c2036094d13cef258ae4b", "committedDate": "2020-02-11T00:46:05Z", "message": "remove unnecessary throw exception"}, "afterCommit": {"oid": "879ab5a4d8c1d6533a8a0d1f95ed73128d0b7e06", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/879ab5a4d8c1d6533a8a0d1f95ed73128d0b7e06", "committedDate": "2020-02-11T00:52:23Z", "message": "remove unnecessary throw exception"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4931, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}