{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDI4NTA5", "number": 861, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNDozNzoxMFrODlrXzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNzowNToyMFrODnKodw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODM0NTEwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNDozNzoxMVrOFys8wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTo0MDozNFrOFzITWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTU2OA==", "bodyText": "Like you mentioned, do we need the checked exception signature? If yes, what is the consideration to have it thrown checked exceptions?", "url": "https://github.com/apache/helix/pull/861#discussion_r388709568", "createdAt": "2020-03-06T04:37:11Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -135,37 +138,74 @@\n   public static final String removeConstraint = \"removeConstraint\";\n \n   private static final Logger _logger = LoggerFactory.getLogger(ClusterSetup.class);\n-  private final String _zkServerAddress;\n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private String _zkServerAddress;\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n   private final HelixAdmin _admin;\n \n   public ClusterSetup(String zkServerAddress) {\n     _zkServerAddress = zkServerAddress;\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n-    _zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // First, try to start on multi-realm mode using FederatedZkClient\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n+          new RealmAwareZkClient.RealmAwareZkClientConfig());\n+    } catch (InvalidRoutingDataException | IOException | IllegalStateException e) {\n+      // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be found\n+      // Fall back to single-realm mode using SharedZkClient (HelixZkClient)\n+      // This is to preserve backward-compatibility\n+      if (zkServerAddress == null || zkServerAddress.isEmpty()) {\n+        throw new IllegalArgumentException(\"ZK server address is null or empty!\");\n+      }\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+    }\n+\n+    _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = false;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient) {\n+  public ClusterSetup(RealmAwareZkClient zkClient) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = true;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient, HelixAdmin zkHelixAdmin) {\n+  public ClusterSetup(RealmAwareZkClient zkClient, HelixAdmin zkHelixAdmin) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = zkHelixAdmin;\n     _usesExternalZkClient = true;\n   }\n \n+  private ClusterSetup(Builder builder) throws IOException, InvalidRoutingDataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0MjMyMQ==", "bodyText": "Good cross validation. This shouldn't be needed. Let me update the PR \ud83d\udc4d", "url": "https://github.com/apache/helix/pull/861#discussion_r389042321", "createdAt": "2020-03-06T17:32:53Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -135,37 +138,74 @@\n   public static final String removeConstraint = \"removeConstraint\";\n \n   private static final Logger _logger = LoggerFactory.getLogger(ClusterSetup.class);\n-  private final String _zkServerAddress;\n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private String _zkServerAddress;\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n   private final HelixAdmin _admin;\n \n   public ClusterSetup(String zkServerAddress) {\n     _zkServerAddress = zkServerAddress;\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n-    _zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // First, try to start on multi-realm mode using FederatedZkClient\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n+          new RealmAwareZkClient.RealmAwareZkClientConfig());\n+    } catch (InvalidRoutingDataException | IOException | IllegalStateException e) {\n+      // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be found\n+      // Fall back to single-realm mode using SharedZkClient (HelixZkClient)\n+      // This is to preserve backward-compatibility\n+      if (zkServerAddress == null || zkServerAddress.isEmpty()) {\n+        throw new IllegalArgumentException(\"ZK server address is null or empty!\");\n+      }\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+    }\n+\n+    _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = false;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient) {\n+  public ClusterSetup(RealmAwareZkClient zkClient) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = true;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient, HelixAdmin zkHelixAdmin) {\n+  public ClusterSetup(RealmAwareZkClient zkClient, HelixAdmin zkHelixAdmin) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = zkHelixAdmin;\n     _usesExternalZkClient = true;\n   }\n \n+  private ClusterSetup(Builder builder) throws IOException, InvalidRoutingDataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTU2OA=="}, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NzcyMw==", "bodyText": "Discussed with @pkuwm offline.\nWe decided to keep these checked exceptions. As a matter of fact, all builder-based constructors should throw checked exceptions because things could go wrong on multi-realm mode.", "url": "https://github.com/apache/helix/pull/861#discussion_r389157723", "createdAt": "2020-03-06T21:40:34Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -135,37 +138,74 @@\n   public static final String removeConstraint = \"removeConstraint\";\n \n   private static final Logger _logger = LoggerFactory.getLogger(ClusterSetup.class);\n-  private final String _zkServerAddress;\n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private String _zkServerAddress;\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n   private final HelixAdmin _admin;\n \n   public ClusterSetup(String zkServerAddress) {\n     _zkServerAddress = zkServerAddress;\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n-    _zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // First, try to start on multi-realm mode using FederatedZkClient\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n+          new RealmAwareZkClient.RealmAwareZkClientConfig());\n+    } catch (InvalidRoutingDataException | IOException | IllegalStateException e) {\n+      // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be found\n+      // Fall back to single-realm mode using SharedZkClient (HelixZkClient)\n+      // This is to preserve backward-compatibility\n+      if (zkServerAddress == null || zkServerAddress.isEmpty()) {\n+        throw new IllegalArgumentException(\"ZK server address is null or empty!\");\n+      }\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+    }\n+\n+    _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = false;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient) {\n+  public ClusterSetup(RealmAwareZkClient zkClient) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = true;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient, HelixAdmin zkHelixAdmin) {\n+  public ClusterSetup(RealmAwareZkClient zkClient, HelixAdmin zkHelixAdmin) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = zkHelixAdmin;\n     _usesExternalZkClient = true;\n   }\n \n+  private ClusterSetup(Builder builder) throws IOException, InvalidRoutingDataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTU2OA=="}, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODM0ODEzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNDo0MDowNlrOFys-vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTo0MDo1NFrOFzIT6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDA3OQ==", "bodyText": "If it fails, shall we fall it back to connect to single ZK?", "url": "https://github.com/apache/helix/pull/861#discussion_r388710079", "createdAt": "2020-03-06T04:40:06Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -135,37 +138,74 @@\n   public static final String removeConstraint = \"removeConstraint\";\n \n   private static final Logger _logger = LoggerFactory.getLogger(ClusterSetup.class);\n-  private final String _zkServerAddress;\n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private String _zkServerAddress;\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n   private final HelixAdmin _admin;\n \n   public ClusterSetup(String zkServerAddress) {\n     _zkServerAddress = zkServerAddress;\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n-    _zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // First, try to start on multi-realm mode using FederatedZkClient\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n+          new RealmAwareZkClient.RealmAwareZkClientConfig());\n+    } catch (InvalidRoutingDataException | IOException | IllegalStateException e) {\n+      // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be found\n+      // Fall back to single-realm mode using SharedZkClient (HelixZkClient)\n+      // This is to preserve backward-compatibility\n+      if (zkServerAddress == null || zkServerAddress.isEmpty()) {\n+        throw new IllegalArgumentException(\"ZK server address is null or empty!\");\n+      }\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+    }\n+\n+    _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = false;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient) {\n+  public ClusterSetup(RealmAwareZkClient zkClient) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = true;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient, HelixAdmin zkHelixAdmin) {\n+  public ClusterSetup(RealmAwareZkClient zkClient, HelixAdmin zkHelixAdmin) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = zkHelixAdmin;\n     _usesExternalZkClient = true;\n   }\n \n+  private ClusterSetup(Builder builder) throws IOException, InvalidRoutingDataException {\n+    switch (builder._realmMode) {\n+      case MULTI_REALM:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1Nzg2Nw==", "bodyText": "Discussed offline. We shouldn't fall back on multi-realm mode.", "url": "https://github.com/apache/helix/pull/861#discussion_r389157867", "createdAt": "2020-03-06T21:40:54Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -135,37 +138,74 @@\n   public static final String removeConstraint = \"removeConstraint\";\n \n   private static final Logger _logger = LoggerFactory.getLogger(ClusterSetup.class);\n-  private final String _zkServerAddress;\n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private String _zkServerAddress;\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n   private final HelixAdmin _admin;\n \n   public ClusterSetup(String zkServerAddress) {\n     _zkServerAddress = zkServerAddress;\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n-    _zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // First, try to start on multi-realm mode using FederatedZkClient\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n+          new RealmAwareZkClient.RealmAwareZkClientConfig());\n+    } catch (InvalidRoutingDataException | IOException | IllegalStateException e) {\n+      // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be found\n+      // Fall back to single-realm mode using SharedZkClient (HelixZkClient)\n+      // This is to preserve backward-compatibility\n+      if (zkServerAddress == null || zkServerAddress.isEmpty()) {\n+        throw new IllegalArgumentException(\"ZK server address is null or empty!\");\n+      }\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+    }\n+\n+    _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = false;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient) {\n+  public ClusterSetup(RealmAwareZkClient zkClient) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = new ZKHelixAdmin(_zkClient);\n     _usesExternalZkClient = true;\n   }\n \n-  public ClusterSetup(HelixZkClient zkClient, HelixAdmin zkHelixAdmin) {\n+  public ClusterSetup(RealmAwareZkClient zkClient, HelixAdmin zkHelixAdmin) {\n     _zkServerAddress = zkClient.getServers();\n     _zkClient = zkClient;\n     _admin = zkHelixAdmin;\n     _usesExternalZkClient = true;\n   }\n \n+  private ClusterSetup(Builder builder) throws IOException, InvalidRoutingDataException {\n+    switch (builder._realmMode) {\n+      case MULTI_REALM:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDA3OQ=="}, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODM2Mzc4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNDo1MzoxNVrOFytIEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTozOToyOFrOFzIRzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMjQ2Ng==", "bodyText": "If zk address is not set for multi-realm mode, a user would not expect an IllegalArgumentException. Shall we throw an IllegalStateException as the user doesn't set this argument? And also include the original exception message/stack?", "url": "https://github.com/apache/helix/pull/861#discussion_r388712466", "createdAt": "2020-03-06T04:53:15Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -135,37 +138,74 @@\n   public static final String removeConstraint = \"removeConstraint\";\n \n   private static final Logger _logger = LoggerFactory.getLogger(ClusterSetup.class);\n-  private final String _zkServerAddress;\n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private String _zkServerAddress;\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n   private final HelixAdmin _admin;\n \n   public ClusterSetup(String zkServerAddress) {\n     _zkServerAddress = zkServerAddress;\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n-    _zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // First, try to start on multi-realm mode using FederatedZkClient\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n+          new RealmAwareZkClient.RealmAwareZkClientConfig());\n+    } catch (InvalidRoutingDataException | IOException | IllegalStateException e) {\n+      // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be found\n+      // Fall back to single-realm mode using SharedZkClient (HelixZkClient)\n+      // This is to preserve backward-compatibility\n+      if (zkServerAddress == null || zkServerAddress.isEmpty()) {\n+        throw new IllegalArgumentException(\"ZK server address is null or empty!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NzMyNw==", "bodyText": "If we want to preserve the existing behavior, I say we just remove this check (because the original implementation doesn't have this check).\nI am not sure what you're asking exactly... could you explain?", "url": "https://github.com/apache/helix/pull/861#discussion_r389157327", "createdAt": "2020-03-06T21:39:28Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -135,37 +138,74 @@\n   public static final String removeConstraint = \"removeConstraint\";\n \n   private static final Logger _logger = LoggerFactory.getLogger(ClusterSetup.class);\n-  private final String _zkServerAddress;\n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private String _zkServerAddress;\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n   private final HelixAdmin _admin;\n \n   public ClusterSetup(String zkServerAddress) {\n     _zkServerAddress = zkServerAddress;\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkServerAddress));\n-    _zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // First, try to start on multi-realm mode using FederatedZkClient\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n+          new RealmAwareZkClient.RealmAwareZkClientConfig());\n+    } catch (InvalidRoutingDataException | IOException | IllegalStateException e) {\n+      // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be found\n+      // Fall back to single-realm mode using SharedZkClient (HelixZkClient)\n+      // This is to preserve backward-compatibility\n+      if (zkServerAddress == null || zkServerAddress.isEmpty()) {\n+        throw new IllegalArgumentException(\"ZK server address is null or empty!\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMjQ2Ng=="}, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODQ2NTI3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjoxMjowNVrOFyuGLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMjo1MTo0MFrOFzJzJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyODM2NA==", "bodyText": "nit, is this import needed anymore?", "url": "https://github.com/apache/helix/pull/861#discussion_r388728364", "createdAt": "2020-03-06T06:12:05Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -78,6 +78,7 @@\n import org.apache.helix.util.HelixUtil;\n import org.apache.helix.util.RebalanceUtil;\n import org.apache.helix.zookeeper.api.client.HelixZkClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4MjI0NA==", "bodyText": "Needed. HelixZkClient is still used.", "url": "https://github.com/apache/helix/pull/861#discussion_r389182244", "createdAt": "2020-03-06T22:51:40Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -78,6 +78,7 @@\n import org.apache.helix.util.HelixUtil;\n import org.apache.helix.util.RebalanceUtil;\n import org.apache.helix.zookeeper.api.client.HelixZkClient;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyODM2NA=="}, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODQ2Njg0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjoxMzoxM1rOFyuHHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMToyODozMFrOFzIAxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyODYwNg==", "bodyText": "It seems this field can still be final. Why do we need to remove the final keyword?", "url": "https://github.com/apache/helix/pull/861#discussion_r388728606", "createdAt": "2020-03-06T06:13:13Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -135,37 +138,74 @@\n   public static final String removeConstraint = \"removeConstraint\";\n \n   private static final Logger _logger = LoggerFactory.getLogger(ClusterSetup.class);\n-  private final String _zkServerAddress;\n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private String _zkServerAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1Mjk2Ng==", "bodyText": "If the user wants to create this class on multi-realm mode, FederatedZkClient will be used. FederatedZkClient does not and should not expose ZkAddress because it's an internal state info.\nIn fact, this _zkServerAddress was not being used anywhere and doesn't need to exist. I've removed this field from this class for further safety. I think we want to avoid exposing specific ZK server-related details as much as possible in a multi-zk environment to prevent misuse and unauthorized operations.", "url": "https://github.com/apache/helix/pull/861#discussion_r389152966", "createdAt": "2020-03-06T21:28:30Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -135,37 +138,74 @@\n   public static final String removeConstraint = \"removeConstraint\";\n \n   private static final Logger _logger = LoggerFactory.getLogger(ClusterSetup.class);\n-  private final String _zkServerAddress;\n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private String _zkServerAddress;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyODYwNg=="}, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODQ3MTY1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjoxNTo0NlrOFyuJvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMToxODo0MFrOFzHxOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyOTI3OA==", "bodyText": "I see similar builders in multiple PRs for the different accessor or tools. Can we have a parent ZkClient builder which contains basic info and validation, and these builders can be the children of that parent.", "url": "https://github.com/apache/helix/pull/861#discussion_r388729278", "createdAt": "2020-03-06T06:15:46Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -1570,4 +1610,66 @@ public static void main(String[] args) throws Exception {\n     int ret = processCommandLineArgs(args);\n     System.exit(ret);\n   }\n+\n+  public static class Builder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0NDA2OA==", "bodyText": "@jiajunwang This was an option considered carefully, but let me note here that having a parent builder doesn't actually remove duplicate code because all setters and constructors will have to either be re-written or overriden. This is because setters return Builder objects that aren't compatible with children builders. Take a look at the ZkClusterVerifier PR - in that PR, it makes more sense to have a parent Builder, but we don't see the reduction in duplicate code.\nIn general, having an inheritance hierarchy for static Builders is not necessarily a good idea because 1) it doesn't reduce code duplication, 2) Builder's setter and validation logic need to / may evolve differently, and inheritance might make that difficult in the future.", "url": "https://github.com/apache/helix/pull/861#discussion_r389044068", "createdAt": "2020-03-06T17:36:22Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -1570,4 +1610,66 @@ public static void main(String[] args) throws Exception {\n     int ret = processCommandLineArgs(args);\n     System.exit(ret);\n   }\n+\n+  public static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyOTI3OA=="}, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NDkyOA==", "bodyText": "For 2) the setter and validation logic should be common for the ZK parameters. And ZK related input and validation will be evolved the same. That's why a single class would help us to reduce maintenance costs.\nFor 1) There are multiple options to avoid the problem. Not sure if we have these options evaluated. If any document, that would be great so I can take a look : )\n\nPass the ZK Client builder to the verifier's builders. So there is no inheritance, but the ZK client building logic is in the client builder only.\nUse a template class as mentioned here, https://stackoverflow.com/questions/4031857/way-to-make-java-parent-class-method-return-object-of-child-class\nSince ZK parameters are in most cases requried, include them in the constructor and you don't need to worry about the return value. In the verifier builder, the constructor calls the super(...) constructor to finish the ZK client build.\nThere could be more ways.", "url": "https://github.com/apache/helix/pull/861#discussion_r389074928", "createdAt": "2020-03-06T18:40:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -1570,4 +1610,66 @@ public static void main(String[] args) throws Exception {\n     int ret = processCommandLineArgs(args);\n     System.exit(ret);\n   }\n+\n+  public static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyOTI3OA=="}, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0ODk4Nw==", "bodyText": "There aren't any documents. However, I think this input is valid.\nLet's use this to track this issue. I think it would be wise to first focus on making Java APIs realm-aware, and take a step back and look at all of our Helix Java API classes and determine how we should refactor the Builders.\n#873", "url": "https://github.com/apache/helix/pull/861#discussion_r389148987", "createdAt": "2020-03-06T21:18:40Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterSetup.java", "diffHunk": "@@ -1570,4 +1610,66 @@ public static void main(String[] args) throws Exception {\n     int ret = processCommandLineArgs(args);\n     System.exit(ret);\n   }\n+\n+  public static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyOTI3OA=="}, "originalCommit": {"oid": "2ab24ad0df5a7c5d86aea338fbc076a780415e3b"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzYxMjc2OnYy", "diffSide": "RIGHT", "path": "helix-common/src/main/java/org/apache/helix/SystemPropertyKeys.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTo0Njo1NlrOF09CUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTo0Njo1NlrOF09CUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA3MDI4OQ==", "bodyText": "I understand there is no rule for naming convention for a property key. But are we considering xxx.yyy.zzz in lowercase ? I would prefer this way as it is more readable, commonly used and easier to troubleshoot. I prefer this way. Just 2 cents", "url": "https://github.com/apache/helix/pull/861#discussion_r391070289", "createdAt": "2020-03-11T15:46:56Z", "author": {"login": "huizhilu"}, "path": "helix-common/src/main/java/org/apache/helix/SystemPropertyKeys.java", "diffHunk": "@@ -57,4 +60,7 @@\n \n   // MBean monitor for helix.\n   public static final String HELIX_MONITOR_TIME_WINDOW_LENGTH_MS = \"helix.monitor.slidingTimeWindow.ms\";\n+\n+  // Multi-ZK mode enable/disable flag\n+  public static final String MULTI_ZK_ENABLED = \"helix.multiZkEnabled\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7beee40b316e59d4154fd872eba57f09d654413"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzk1MjU1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNzowNToyMFrOF1AZFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMDozMToyMlrOF1Nu6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyNTI2OQ==", "bodyText": "Nit: not sure whether or not we would allow users to set upper case \u201cTRUE\u201d and honor it as true. I just use getBoolean() to restrict it to true if and only if string is lowercase \u201ctrue\u201d.", "url": "https://github.com/apache/helix/pull/861#discussion_r391125269", "createdAt": "2020-03-11T17:05:20Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -123,23 +127,23 @@ public ConfigAccessor(RealmAwareZkClient zkClient) {\n    * @param zkAddress\n    */\n   public ConfigAccessor(String zkAddress) {\n-    // First, attempt to connect on multi-realm mode using FederatedZkClient\n-    RealmAwareZkClient zkClient;\n-    try {\n-      zkClient = new FederatedZkClient(\n-          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n-          new RealmAwareZkClient.RealmAwareZkClientConfig());\n-    } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n-      // Connecting multi-realm failed - fall back to creating it on single-realm mode using the given ZK address\n-      LOG.info(\n-          \"ConfigAccessor: not able to connect on multi-realm mode; connecting single-realm mode to ZK: {}\",\n-          zkAddress, e);\n-      zkClient = SharedZkClientFactory.getInstance()\n-          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n-              new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-    }\n-    _zkClient = zkClient;\n     _usesExternalZkClient = false;\n+\n+    // If the multi ZK config is enabled, use FederatedZkClient on multi-realm mode\n+    if (Boolean.parseBoolean(System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7beee40b316e59d4154fd872eba57f09d654413"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0Mzg0OA==", "bodyText": "They should both be considered as true. Either way works.", "url": "https://github.com/apache/helix/pull/861#discussion_r391343848", "createdAt": "2020-03-12T00:31:22Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -123,23 +127,23 @@ public ConfigAccessor(RealmAwareZkClient zkClient) {\n    * @param zkAddress\n    */\n   public ConfigAccessor(String zkAddress) {\n-    // First, attempt to connect on multi-realm mode using FederatedZkClient\n-    RealmAwareZkClient zkClient;\n-    try {\n-      zkClient = new FederatedZkClient(\n-          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n-          new RealmAwareZkClient.RealmAwareZkClientConfig());\n-    } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n-      // Connecting multi-realm failed - fall back to creating it on single-realm mode using the given ZK address\n-      LOG.info(\n-          \"ConfigAccessor: not able to connect on multi-realm mode; connecting single-realm mode to ZK: {}\",\n-          zkAddress, e);\n-      zkClient = SharedZkClientFactory.getInstance()\n-          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n-              new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-    }\n-    _zkClient = zkClient;\n     _usesExternalZkClient = false;\n+\n+    // If the multi ZK config is enabled, use FederatedZkClient on multi-realm mode\n+    if (Boolean.parseBoolean(System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyNTI2OQ=="}, "originalCommit": {"oid": "f7beee40b316e59d4154fd872eba57f09d654413"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1344, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}