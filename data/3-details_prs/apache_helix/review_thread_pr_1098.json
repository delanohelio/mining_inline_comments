{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NDk3NzM1", "number": 1098, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjo1NTozOVrOEGN7-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODowNTo1OFrOEG27VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTU1MjU3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/OnlineOfflineWithBootstrapSMD.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjo1NTozOVrOGk4EnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjo1NTozOVrOGk4EnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMDYwNQ==", "bodyText": "Indent/format.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441320605", "createdAt": "2020-06-17T06:55:39Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/model/OnlineOfflineWithBootstrapSMD.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.HelixDefinedState;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+\n+/**\n+ * Helix built-in state model definition based on Online-Offline but with the additional bootstrap\n+ * state.\n+ */\n+public final class OnlineOfflineWithBootstrapSMD extends StateModelDefinition {\n+  public static final String name = \"OnlineOfflineWithBootstrap\";\n+\n+  /**\n+   * Instantiate from a pre-populated record\n+   *\n+   * @param record ZNRecord representing a state model definition\n+   */\n+  private OnlineOfflineWithBootstrapSMD(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  public enum States {\n+    ONLINE, BOOTSTRAP, OFFLINE\n+  }\n+\n+  /**\n+   * Build OnlineOfflineWithBootstrap state model definition\n+   *\n+   * @return\n+   */\n+  public static OnlineOfflineWithBootstrapSMD build() {\n+    Builder builder = new Builder(name);\n+    // init state\n+    builder.initialState(States.OFFLINE.name());\n+\n+    // add states\n+    builder.addState(States.ONLINE.name(), 0);\n+    builder.addState(States.BOOTSTRAP.name(), 1);\n+    builder.addState(States.OFFLINE.name(), 2);\n+    for (HelixDefinedState state : HelixDefinedState.values()) {\n+    builder.addState(state.name());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTU5MTk3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAbstractRebalancer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzowODozOFrOGk4dOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzowODozOFrOGk4dOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNjkwNQ==", "bodyText": "Accident typo?", "url": "https://github.com/apache/helix/pull/1098#discussion_r441326905", "createdAt": "2020-06-17T07:08:38Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAbstractRebalancer.java", "diffHunk": "@@ -56,11 +56,11 @@ public void testComputeBestPossibleState(String comment, String stateModelName,\n             new IdealState(\"test\"), new ClusterConfig(\"TestCluster\"), partition,\n             MonitoredAbnormalResolver.DUMMY_STATE_RESOLVER);\n \n-    Assert.assertEquals(bestPossibleMap, expectedBestPossibleMap);\n+    Assert.assertTrue(bestPossibleMap.equals(expectedBestPossibleMap));\n   }\n \n   @DataProvider(name = \"TestComputeBestPossibleStateInput\")\n-  public Object[][] loadTestComputeBestPossibleStateInput() {\n+  public Object[][] loadTestComputeBestPossiblqeStateInput() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTU5OTA4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAbstractRebalancer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzoxMDo1N1rOGk4hrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODoxNToyNVrOGlRhWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyODA0Nw==", "bodyText": "Just curious: what's your thought of changing to equals style? I think Assert.assertEquals() works fine, even Assert.assertEquals(map, null) or Assert.assertEquals(null, map) still works. But Assert.assertTrue(null.equals(expectedBestPossibleMap)) won't work. (though in this test bestPossibleMap won't be null).", "url": "https://github.com/apache/helix/pull/1098#discussion_r441328047", "createdAt": "2020-06-17T07:10:57Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAbstractRebalancer.java", "diffHunk": "@@ -56,11 +56,11 @@ public void testComputeBestPossibleState(String comment, String stateModelName,\n             new IdealState(\"test\"), new ClusterConfig(\"TestCluster\"), partition,\n             MonitoredAbnormalResolver.DUMMY_STATE_RESOLVER);\n \n-    Assert.assertEquals(bestPossibleMap, expectedBestPossibleMap);\n+    Assert.assertTrue(bestPossibleMap.equals(expectedBestPossibleMap));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTczNzU2MA==", "bodyText": "This is an Assert bug. assertEquals does not work for mapping or list. In general, it is doing left join. We want inner join : )", "url": "https://github.com/apache/helix/pull/1098#discussion_r441737560", "createdAt": "2020-06-17T18:15:25Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAbstractRebalancer.java", "diffHunk": "@@ -56,11 +56,11 @@ public void testComputeBestPossibleState(String comment, String stateModelName,\n             new IdealState(\"test\"), new ClusterConfig(\"TestCluster\"), partition,\n             MonitoredAbnormalResolver.DUMMY_STATE_RESOLVER);\n \n-    Assert.assertEquals(bestPossibleMap, expectedBestPossibleMap);\n+    Assert.assertTrue(bestPossibleMap.equals(expectedBestPossibleMap));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyODA0Nw=="}, "originalCommit": {"oid": "29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE2NjQ4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozMjowM1rOGlSFFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODo0NDozOFrOGlSg0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0NjcxMA==", "bodyText": "We can also additional check for single top state since multi top state even does not require these operations", "url": "https://github.com/apache/helix/pull/1098#discussion_r441746710", "createdAt": "2020-06-17T18:32:03Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc1MzgxMQ==", "bodyText": "I thought about it, but if we have a state model which requires 2 top states, and replica is 4, do we still want this improvement? My answer is yes. I don't think we want to lose the universality.\nIn addition, it may not really prevent all the issues. For example, if the replica is 1, without a complete fix, I guess there will still be issues. So we should fix it and fix it for all cases.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441753811", "createdAt": "2020-06-17T18:44:38Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0NjcxMA=="}, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjIyMTg2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODo0ODowMVrOGlSozQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTowNzowNFrOGlTnzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc1NTg1Mw==", "bodyText": "Is there any reasons to remove the liveAndEnabled check?", "url": "https://github.com/apache/helix/pull/1098#discussion_r441755853", "createdAt": "2020-06-17T18:48:01Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();\n+            if (!assigned.contains(currentStatePrioritizedInstance)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MTk4MQ==", "bodyText": "I moved this logic above. Inactive nodes have been removed from the currentStatePrioritizedInstanceList. This shortens the instance list and saves some computing.\nNote that we may don't want to do it for the preferencelist since it is not deepcopy.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441771981", "createdAt": "2020-06-17T19:07:04Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();\n+            if (!assigned.contains(currentStatePrioritizedInstance)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc1NTg1Mw=="}, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjI3NzIyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODo1NzoyM1rOGlTPeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDoxODoxMVrOGlbgWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2NTc1Mg==", "bodyText": "Using index will be hard for code reader to understand it. Suggest to using a queue to replace the for loop.\nSo it could be:  while (!queue.isEmpty()) {\nxxxxx\nif (!proposedInstance.equals(instance)) {\nqueue.offer(instance); // add back\n}\n}", "url": "https://github.com/apache/helix/pull/1098#discussion_r441765752", "createdAt": "2020-06-17T18:57:23Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();\n+            if (!assigned.contains(currentStatePrioritizedInstance)) {\n               proposedInstance = currentStatePrioritizedInstance;\n+              // If we find a different instance for the partition placement, then we need to check\n+              // the same instance again or it will not be assigned with any partitions.\n+              if (!proposedInstance.equals(instance)) {\n+                i--;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MzQxMw==", "bodyText": "This is a trade-off.\nI agree queue would be much simpler. And with the queue, I can do more optimization.\nHowever, since this calculation will be run many times. Creating a queue here might prolong the rebalance time a lot. Let me see if I can profile this.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441773413", "createdAt": "2020-06-17T19:09:49Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();\n+            if (!assigned.contains(currentStatePrioritizedInstance)) {\n               proposedInstance = currentStatePrioritizedInstance;\n+              // If we find a different instance for the partition placement, then we need to check\n+              // the same instance again or it will not be assigned with any partitions.\n+              if (!proposedInstance.equals(instance)) {\n+                i--;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2NTc1Mg=="}, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMDk0MQ==", "bodyText": "I tried it, with some enhancement, the performance is actually slightly better.\nThe only downside is that we introduced many more changes to make it clearer. Please review the new change.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441900941", "createdAt": "2020-06-18T00:17:26Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();\n+            if (!assigned.contains(currentStatePrioritizedInstance)) {\n               proposedInstance = currentStatePrioritizedInstance;\n+              // If we find a different instance for the partition placement, then we need to check\n+              // the same instance again or it will not be assigned with any partitions.\n+              if (!proposedInstance.equals(instance)) {\n+                i--;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2NTc1Mg=="}, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMTE0Ng==", "bodyText": "One thing to note here, offer does not work. Adding the item to the back will dramatically change the preference list order, that is not what we want.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441901146", "createdAt": "2020-06-18T00:18:11Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();\n+            if (!assigned.contains(currentStatePrioritizedInstance)) {\n               proposedInstance = currentStatePrioritizedInstance;\n+              // If we find a different instance for the partition placement, then we need to check\n+              // the same instance again or it will not be assigned with any partitions.\n+              if (!proposedInstance.equals(instance)) {\n+                i--;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2NTc1Mg=="}, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjMwNTk2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTowNDoyNlrOGlTiWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOToxMTowOVrOGlTwLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MDU4Ng==", "bodyText": "Maybe I am wrong. But could that be a scenario of:\npreference list = 1, 2, 3\ncurrent state = 4, 5, 6\nThen we keep assign ONLINE to 4,5,6. There will not be any movement. For DelayedAutoRebalance we may dont have it. But for default AutoRebalancer Or SemiAuto, we may use this for AbstractRebalancer then there will not be any movement.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441770586", "createdAt": "2020-06-17T19:04:26Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3NDEyNQ==", "bodyText": "currentStatePrioritizedInstance != current state instances.\nIn your case, the currentStatePrioritizedInstance will be 1,2,3.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441774125", "createdAt": "2020-06-17T19:11:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MDU4Ng=="}, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjI2ODM2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODowNTo1OFrOGl6hvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoxODoyMVrOGl68CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwOTQwNQ==", "bodyText": "This should not happen, right. You do the assignedInstances both for peek of the queue and after adjust instance.", "url": "https://github.com/apache/helix/pull/1098#discussion_r442409405", "createdAt": "2020-06-18T18:05:58Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -352,60 +356,137 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     }\n \n     // (3) Assign normal states to instances.\n-    // When we choose the top-state (e.g. MASTER) replica for a partition, we prefer to choose it from\n-    // these replicas which are already in the secondary states (e.g, SLAVE) instead of in lower-state.\n-    // This is because a replica in secondary state will take shorter time to transition to the top-state,\n-    // which could minimize the impact to the application's availability.\n-    // To achieve that, we sort the preferenceList based on CurrentState, by treating top-state and second-states with\n-    // same priority and rely on the fact that Collections.sort() is stable.\n-    List<String> statesPriorityList = stateModelDef.getStatesPriorityList();\n-    Set<String> assigned = new HashSet<>();\n-    Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n-    liveAndEnabled.removeAll(disabledInstancesForPartition);\n-\n-    // Sort the instances based on replicas' state priority in the current state\n-    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n-    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n-\n-    // Assign the state to the instances that appear in the preference list.\n-    for (String state : statesPriorityList) {\n+    assignStatesToInstances(preferenceList, stateModelDef, currentStateMap, liveInstances,\n+        disabledInstancesForPartition, bestPossibleStateMap);\n+\n+    return bestPossibleStateMap;\n+  }\n+\n+  /**\n+   * Assign the states to the instances listed in the preference list according to inputs.\n+   * Note that when we choose the top-state (e.g. MASTER) replica for a partition, we prefer to\n+   * choose it from these replicas which are already in the secondary states (e.g, SLAVE) instead\n+   * of in lower-state. This is because a replica in secondary state will take shorter time to\n+   * transition to the top-state, which could minimize the impact to the application's availability.\n+   * To achieve that, we sort the preferenceList based on CurrentState, by treating top-state and\n+   * second-states with same priority and rely on the fact that Collections.sort() is stable.\n+   */\n+  private void assignStatesToInstances(final List<String> preferenceList,\n+      final StateModelDefinition stateModelDef, final Map<String, String> currentStateMap,\n+      final Set<String> liveInstances, final Set<String> disabledInstancesForPartition,\n+      Map<String, String> bestPossibleStateMap) {\n+    // Record the assigned instances to avoid double calculating or conflict assignment.\n+    Set<String> assignedInstances = new HashSet<>();\n+\n+    Set<String> liveAndEnabled =\n+        liveInstances.stream().filter(instance -> !disabledInstancesForPartition.contains(instance))\n+            .collect(Collectors.toSet());\n+\n+    Queue<String> preferredActiveInstanceQueue = new LinkedList<>(preferenceList);\n+    preferredActiveInstanceQueue.retainAll(liveAndEnabled);\n+    int totalCandidateCount = preferredActiveInstanceQueue.size();\n+\n+    // Sort the preferred instances based on replicas' state priority in the current state.\n+    // Note that if one instance exists in the current states but not in the preference list, then\n+    // it won't show in the prioritized list.\n+    List<String> currentStatePrioritizedList = new ArrayList<>(preferredActiveInstanceQueue);\n+    currentStatePrioritizedList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n+    Iterator<String> currentStatePrioritizedInstanceIter = currentStatePrioritizedList.iterator();\n+\n+    // Assign the states to the instances that appear in the preference list.\n+    for (String state : stateModelDef.getStatesPriorityList()) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n-      for (String instance : preferenceList) {\n+      while (!preferredActiveInstanceQueue.isEmpty()) {\n         if (stateCount <= 0) {\n           break; // continue assigning for the next state\n         }\n-        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+        String peekInstance = preferredActiveInstanceQueue.peek();\n+        if (assignedInstances.contains(peekInstance)) {\n+          preferredActiveInstanceQueue.poll();\n           continue; // continue checking for the next available instance\n         }\n-        String proposedInstance = instance;\n-        // Additional check and alternate the assignment for reducing top state handoff.\n-        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()\n-            .contains(currentStateMap.getOrDefault(instance, stateModelDef.getInitialState()))) {\n-          // If the desired state is the top state, but the instance cannot be transited to the\n-          // top state in one hop, try to keep the top state on current host or a host with a closer\n-          // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n-              proposedInstance = currentStatePrioritizedInstance;\n-              break;\n-            }\n-          }\n-          // Note that if all the current top state instances are not assignable, then we fallback\n-          // to the default logic that assigning the state according to preference list order.\n+        String proposedInstance = adjustInstanceIfNecessary(state, peekInstance,\n+            currentStateMap.getOrDefault(peekInstance, stateModelDef.getInitialState()),\n+            stateModelDef, assignedInstances, totalCandidateCount - assignedInstances.size(),\n+            stateCount, currentStatePrioritizedInstanceIter);\n+\n+        if (proposedInstance.equals(peekInstance)) {\n+          // If the peeked instance is the final decision, then poll it from the queue.\n+          preferredActiveInstanceQueue.poll();\n         }\n-        // Assign the desired state to the proposed instance\n+        // else, if we found a different instance for the partition placement, then we need to\n+        // check the same instance again or it will not be assigned with any partitions.\n+\n+        // Assign the desired state to the proposed instance if not on ERROR state.\n         if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(proposedInstance))) {\n           bestPossibleStateMap.put(proposedInstance, HelixDefinedState.ERROR.toString());\n         } else {\n           bestPossibleStateMap.put(proposedInstance, state);\n           stateCount--;\n         }\n-        assigned.add(proposedInstance);\n+        // Note that in either case, the proposed instance is considered to be assigned with a state\n+        // by now.\n+        if (!assignedInstances.add(proposedInstance)) {\n+          throw new AssertionError(String\n+              .format(\"The proposed instance %s has been already assigned before.\",\n+                  proposedInstance));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6de71e6d43c6ea535103007defc599cf3beabd76"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjEzNg==", "bodyText": "Yeah, this is for the sanity check. If something goes wrong, I hope it fails early. This could be very hard to debug. And if we have some other customized SM defs, it might not be covered by the unit test. Adding this assertion will help us identify issues much easier.", "url": "https://github.com/apache/helix/pull/1098#discussion_r442416136", "createdAt": "2020-06-18T18:18:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -352,60 +356,137 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     }\n \n     // (3) Assign normal states to instances.\n-    // When we choose the top-state (e.g. MASTER) replica for a partition, we prefer to choose it from\n-    // these replicas which are already in the secondary states (e.g, SLAVE) instead of in lower-state.\n-    // This is because a replica in secondary state will take shorter time to transition to the top-state,\n-    // which could minimize the impact to the application's availability.\n-    // To achieve that, we sort the preferenceList based on CurrentState, by treating top-state and second-states with\n-    // same priority and rely on the fact that Collections.sort() is stable.\n-    List<String> statesPriorityList = stateModelDef.getStatesPriorityList();\n-    Set<String> assigned = new HashSet<>();\n-    Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n-    liveAndEnabled.removeAll(disabledInstancesForPartition);\n-\n-    // Sort the instances based on replicas' state priority in the current state\n-    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n-    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n-\n-    // Assign the state to the instances that appear in the preference list.\n-    for (String state : statesPriorityList) {\n+    assignStatesToInstances(preferenceList, stateModelDef, currentStateMap, liveInstances,\n+        disabledInstancesForPartition, bestPossibleStateMap);\n+\n+    return bestPossibleStateMap;\n+  }\n+\n+  /**\n+   * Assign the states to the instances listed in the preference list according to inputs.\n+   * Note that when we choose the top-state (e.g. MASTER) replica for a partition, we prefer to\n+   * choose it from these replicas which are already in the secondary states (e.g, SLAVE) instead\n+   * of in lower-state. This is because a replica in secondary state will take shorter time to\n+   * transition to the top-state, which could minimize the impact to the application's availability.\n+   * To achieve that, we sort the preferenceList based on CurrentState, by treating top-state and\n+   * second-states with same priority and rely on the fact that Collections.sort() is stable.\n+   */\n+  private void assignStatesToInstances(final List<String> preferenceList,\n+      final StateModelDefinition stateModelDef, final Map<String, String> currentStateMap,\n+      final Set<String> liveInstances, final Set<String> disabledInstancesForPartition,\n+      Map<String, String> bestPossibleStateMap) {\n+    // Record the assigned instances to avoid double calculating or conflict assignment.\n+    Set<String> assignedInstances = new HashSet<>();\n+\n+    Set<String> liveAndEnabled =\n+        liveInstances.stream().filter(instance -> !disabledInstancesForPartition.contains(instance))\n+            .collect(Collectors.toSet());\n+\n+    Queue<String> preferredActiveInstanceQueue = new LinkedList<>(preferenceList);\n+    preferredActiveInstanceQueue.retainAll(liveAndEnabled);\n+    int totalCandidateCount = preferredActiveInstanceQueue.size();\n+\n+    // Sort the preferred instances based on replicas' state priority in the current state.\n+    // Note that if one instance exists in the current states but not in the preference list, then\n+    // it won't show in the prioritized list.\n+    List<String> currentStatePrioritizedList = new ArrayList<>(preferredActiveInstanceQueue);\n+    currentStatePrioritizedList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n+    Iterator<String> currentStatePrioritizedInstanceIter = currentStatePrioritizedList.iterator();\n+\n+    // Assign the states to the instances that appear in the preference list.\n+    for (String state : stateModelDef.getStatesPriorityList()) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n-      for (String instance : preferenceList) {\n+      while (!preferredActiveInstanceQueue.isEmpty()) {\n         if (stateCount <= 0) {\n           break; // continue assigning for the next state\n         }\n-        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+        String peekInstance = preferredActiveInstanceQueue.peek();\n+        if (assignedInstances.contains(peekInstance)) {\n+          preferredActiveInstanceQueue.poll();\n           continue; // continue checking for the next available instance\n         }\n-        String proposedInstance = instance;\n-        // Additional check and alternate the assignment for reducing top state handoff.\n-        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()\n-            .contains(currentStateMap.getOrDefault(instance, stateModelDef.getInitialState()))) {\n-          // If the desired state is the top state, but the instance cannot be transited to the\n-          // top state in one hop, try to keep the top state on current host or a host with a closer\n-          // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n-              proposedInstance = currentStatePrioritizedInstance;\n-              break;\n-            }\n-          }\n-          // Note that if all the current top state instances are not assignable, then we fallback\n-          // to the default logic that assigning the state according to preference list order.\n+        String proposedInstance = adjustInstanceIfNecessary(state, peekInstance,\n+            currentStateMap.getOrDefault(peekInstance, stateModelDef.getInitialState()),\n+            stateModelDef, assignedInstances, totalCandidateCount - assignedInstances.size(),\n+            stateCount, currentStatePrioritizedInstanceIter);\n+\n+        if (proposedInstance.equals(peekInstance)) {\n+          // If the peeked instance is the final decision, then poll it from the queue.\n+          preferredActiveInstanceQueue.poll();\n         }\n-        // Assign the desired state to the proposed instance\n+        // else, if we found a different instance for the partition placement, then we need to\n+        // check the same instance again or it will not be assigned with any partitions.\n+\n+        // Assign the desired state to the proposed instance if not on ERROR state.\n         if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(proposedInstance))) {\n           bestPossibleStateMap.put(proposedInstance, HelixDefinedState.ERROR.toString());\n         } else {\n           bestPossibleStateMap.put(proposedInstance, state);\n           stateCount--;\n         }\n-        assigned.add(proposedInstance);\n+        // Note that in either case, the proposed instance is considered to be assigned with a state\n+        // by now.\n+        if (!assignedInstances.add(proposedInstance)) {\n+          throw new AssertionError(String\n+              .format(\"The proposed instance %s has been already assigned before.\",\n+                  proposedInstance));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwOTQwNQ=="}, "originalCommit": {"oid": "6de71e6d43c6ea535103007defc599cf3beabd76"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1170, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}