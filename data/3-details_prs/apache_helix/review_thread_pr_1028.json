{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNDUxMDI1", "number": 1028, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoxMToxNVrOEAQjkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoyMDo0MFrOEAQuzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzA2NzA2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoxMToxNVrOGbba8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMTowNzozNlrOGbdLMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxNDAwMg==", "bodyText": "We can let it be info since I will not see ClusterConfig change so frequently.", "url": "https://github.com/apache/helix/pull/1028#discussion_r431414002", "createdAt": "2020-05-27T20:11:15Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -723,6 +729,43 @@ public void setAsyncTasksThreadPool(ExecutorService asyncTasksThreadPool) {\n     _asyncTasksThreadPool = asyncTasksThreadPool;\n   }\n \n+\n+  public AbnormalStateResolver getAbnormalStateResolver(String stateModel) {\n+    return _abnormalStateResolverMap\n+        .getOrDefault(stateModel, AbnormalStateResolver.DUMMY_STATE_RESOLVER);\n+  }\n+\n+  private void refreshAbnormalStateResolverMap(ClusterConfig clusterConfig) {\n+    if (clusterConfig == null) {\n+      logger.debug(\"Skip refreshing abnormal state resolvers because the ClusterConfig is missing\");\n+      return;\n+    }\n+    Map<String, String> resolverMap = clusterConfig.getAbnormalStateResolverMap();\n+    logger.debug(\"Start loading the abnormal state resolvers with configuration {}\", resolverMap);\n+    // Remove any resolver configuration that does not exist anymore.\n+    _abnormalStateResolverMap.keySet().retainAll(resolverMap.keySet());\n+    // Reload the resolver classes into cache based on the configuration.\n+    for (String stateModel : resolverMap.keySet()) {\n+      String resolverClassName = resolverMap.get(stateModel);\n+      if (resolverClassName == null || resolverClassName.isEmpty()) {\n+        // skip the empty definition.\n+        continue;\n+      }\n+      if (!resolverClassName.equals(getAbnormalStateResolver(stateModel).getClass().getName())) {\n+        try {\n+          AbnormalStateResolver resolver = AbnormalStateResolver.class\n+              .cast(HelixUtil.loadClass(getClass(), resolverClassName).newInstance());\n+          _abnormalStateResolverMap.put(stateModel, resolver);\n+        } catch (Exception e) {\n+          throw new HelixException(String\n+              .format(\"Failed to instantiate the abnormal state resolver %s for state model %s\",\n+                  resolverClassName, stateModel));\n+        }\n+      } // else, nothing to update since the same resolver class has been loaded.\n+    }\n+    logger.debug(\"Finish loading the abnormal state resolvers {}\", _abnormalStateResolverMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed4bc2d1136213c227771be33fab9c7042ae26ae"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0MjczOQ==", "bodyText": "Sure", "url": "https://github.com/apache/helix/pull/1028#discussion_r431442739", "createdAt": "2020-05-27T21:07:36Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -723,6 +729,43 @@ public void setAsyncTasksThreadPool(ExecutorService asyncTasksThreadPool) {\n     _asyncTasksThreadPool = asyncTasksThreadPool;\n   }\n \n+\n+  public AbnormalStateResolver getAbnormalStateResolver(String stateModel) {\n+    return _abnormalStateResolverMap\n+        .getOrDefault(stateModel, AbnormalStateResolver.DUMMY_STATE_RESOLVER);\n+  }\n+\n+  private void refreshAbnormalStateResolverMap(ClusterConfig clusterConfig) {\n+    if (clusterConfig == null) {\n+      logger.debug(\"Skip refreshing abnormal state resolvers because the ClusterConfig is missing\");\n+      return;\n+    }\n+    Map<String, String> resolverMap = clusterConfig.getAbnormalStateResolverMap();\n+    logger.debug(\"Start loading the abnormal state resolvers with configuration {}\", resolverMap);\n+    // Remove any resolver configuration that does not exist anymore.\n+    _abnormalStateResolverMap.keySet().retainAll(resolverMap.keySet());\n+    // Reload the resolver classes into cache based on the configuration.\n+    for (String stateModel : resolverMap.keySet()) {\n+      String resolverClassName = resolverMap.get(stateModel);\n+      if (resolverClassName == null || resolverClassName.isEmpty()) {\n+        // skip the empty definition.\n+        continue;\n+      }\n+      if (!resolverClassName.equals(getAbnormalStateResolver(stateModel).getClass().getName())) {\n+        try {\n+          AbnormalStateResolver resolver = AbnormalStateResolver.class\n+              .cast(HelixUtil.loadClass(getClass(), resolverClassName).newInstance());\n+          _abnormalStateResolverMap.put(stateModel, resolver);\n+        } catch (Exception e) {\n+          throw new HelixException(String\n+              .format(\"Failed to instantiate the abnormal state resolver %s for state model %s\",\n+                  resolverClassName, stateModel));\n+        }\n+      } // else, nothing to update since the same resolver class has been loaded.\n+    }\n+    logger.debug(\"Finish loading the abnormal state resolvers {}\", _abnormalStateResolverMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxNDAwMg=="}, "originalCommit": {"oid": "ed4bc2d1136213c227771be33fab9c7042ae26ae"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzA5NTgwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoyMDo0MFrOGbbtIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMTo1ODowNFrOGbeoJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxODY1Nw==", "bodyText": "Are we changing the logic? For this change, we add optionalOverwrittenStates.isPresent(). This result could come from IS dropping or preference list is null. In this case, it will direct return.\nIf you are not returning, it will execute following code, which may have NPE or some errors?", "url": "https://github.com/apache/helix/pull/1028#discussion_r431418657", "createdAt": "2020-05-27T20:20:40Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java", "diffHunk": "@@ -276,39 +278,20 @@ public ResourceAssignment computeBestPossiblePartitionState(ResourceControllerDa\n     return partitionMapping;\n   }\n \n-  /**\n-   * compute best state for resource in AUTO ideal state mode\n-   * @param liveInstances\n-   * @param stateModelDef\n-   * @param preferenceList\n-   * @param currentStateOutput\n-   *          : instance->state for each partition\n-   * @param disabledInstancesForPartition\n-   * @param idealState\n-   * @param  clusterConfig\n-   * @param  partition\n-   * @return\n-   */\n   @Override\n   protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n       StateModelDefinition stateModelDef, List<String> preferenceList,\n       CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n-      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n-\n+      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n+      AbnormalStateResolver resolver) {\n+    Optional<Map<String, String>> optionalOverwrittenStates =\n+        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n+            idealState, partition, resolver);\n+    if (optionalOverwrittenStates.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed4bc2d1136213c227771be33fab9c7042ae26ae"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0NDg0Nw==", "bodyText": "If the IS drops or preference list is null, optionalOverwrittenStates will also be filled, and it will return directly.\nThe intention here is to keep the original behavior. Did you see any exception?", "url": "https://github.com/apache/helix/pull/1028#discussion_r431444847", "createdAt": "2020-05-27T21:11:41Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java", "diffHunk": "@@ -276,39 +278,20 @@ public ResourceAssignment computeBestPossiblePartitionState(ResourceControllerDa\n     return partitionMapping;\n   }\n \n-  /**\n-   * compute best state for resource in AUTO ideal state mode\n-   * @param liveInstances\n-   * @param stateModelDef\n-   * @param preferenceList\n-   * @param currentStateOutput\n-   *          : instance->state for each partition\n-   * @param disabledInstancesForPartition\n-   * @param idealState\n-   * @param  clusterConfig\n-   * @param  partition\n-   * @return\n-   */\n   @Override\n   protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n       StateModelDefinition stateModelDef, List<String> preferenceList,\n       CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n-      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n-\n+      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n+      AbnormalStateResolver resolver) {\n+    Optional<Map<String, String>> optionalOverwrittenStates =\n+        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n+            idealState, partition, resolver);\n+    if (optionalOverwrittenStates.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxODY1Nw=="}, "originalCommit": {"oid": "ed4bc2d1136213c227771be33fab9c7042ae26ae"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ2NjUzMg==", "bodyText": "I see. I was worrying about the Optional.empty(). But since this is not part of those two functions. The logic should be same.", "url": "https://github.com/apache/helix/pull/1028#discussion_r431466532", "createdAt": "2020-05-27T21:58:04Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java", "diffHunk": "@@ -276,39 +278,20 @@ public ResourceAssignment computeBestPossiblePartitionState(ResourceControllerDa\n     return partitionMapping;\n   }\n \n-  /**\n-   * compute best state for resource in AUTO ideal state mode\n-   * @param liveInstances\n-   * @param stateModelDef\n-   * @param preferenceList\n-   * @param currentStateOutput\n-   *          : instance->state for each partition\n-   * @param disabledInstancesForPartition\n-   * @param idealState\n-   * @param  clusterConfig\n-   * @param  partition\n-   * @return\n-   */\n   @Override\n   protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n       StateModelDefinition stateModelDef, List<String> preferenceList,\n       CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n-      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n-\n+      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n+      AbnormalStateResolver resolver) {\n+    Optional<Map<String, String>> optionalOverwrittenStates =\n+        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n+            idealState, partition, resolver);\n+    if (optionalOverwrittenStates.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxODY1Nw=="}, "originalCommit": {"oid": "ed4bc2d1136213c227771be33fab9c7042ae26ae"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1073, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}