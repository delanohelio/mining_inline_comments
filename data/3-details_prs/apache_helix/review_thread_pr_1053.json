{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2OTMwMjU1", "number": 1053, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMzoyOTozN1rOEB_PLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTozOTo1MVrOECNdXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTIwMTA5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMzoyOTozN1rOGeK1fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMzo1ODo1MFrOGeLOkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI4Nzk5Ng==", "bodyText": "Nit: usually a good idea to add a TestHelper.verify() to make sure the cluster has been dropped. This is recommended.", "url": "https://github.com/apache/helix/pull/1053#discussion_r434287996", "createdAt": "2020-06-03T03:29:37Z", "author": {"login": "narendly"}, "path": "helix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java", "diffHunk": "@@ -356,51 +360,57 @@ public void testDropInstance() throws Exception {\n         \"MasterSlave\", true); // do rebalance\n \n     // add fake liveInstance\n-    ZKHelixDataAccessor accessor =\n-        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(ZK_ADDR));\n-    Builder keyBuilder = new Builder(clusterName);\n-    LiveInstance liveInstance = new LiveInstance(\"localhost_12918\");\n-    liveInstance.setSessionId(\"session_0\");\n-    liveInstance.setHelixVersion(\"version_0\");\n-    accessor.setProperty(keyBuilder.liveInstance(\"localhost_12918\"), liveInstance);\n+    HelixDataAccessor accessor = new ZKHelixDataAccessor(clusterName,\n+        new ZkBaseDataAccessor.Builder<ZNRecord>()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkClientType(ZkBaseDataAccessor.ZkClientType.DEDICATED)\n+            .setZkAddress(ZK_ADDR)\n+            .build());\n \n-    // drop without stop the process, should throw exception\n     try {\n-      ClusterSetup.processCommandLineArgs(new String[] {\n-          \"--zkSvr\", ZK_ADDR, \"--dropNode\", clusterName, \"localhost:12918\"\n-      });\n-      Assert.fail(\"Should throw exception since localhost_12918 is still in LIVEINSTANCES/\");\n-    } catch (Exception e) {\n-      // OK\n+      Builder keyBuilder = new Builder(clusterName);\n+      LiveInstance liveInstance = new LiveInstance(instanceName);\n+      liveInstance.setSessionId(\"session_0\");\n+      liveInstance.setHelixVersion(\"version_0\");\n+      accessor.setProperty(keyBuilder.liveInstance(instanceName), liveInstance);\n+\n+      // Drop instance without stopping the live instance, should throw HelixException\n+      try {\n+        ClusterSetup.processCommandLineArgs(\n+            new String[]{\"--zkSvr\", ZK_ADDR, \"--dropNode\", clusterName, instanceAddress});\n+        Assert.fail(\"Should throw exception since localhost_12918 is still in LIVEINSTANCES/\");\n+      } catch (HelixException expected) {\n+        Assert.assertEquals(expected.getMessage(),\n+            \"Cannot drop instance \" + instanceName + \" as it is still live. Please stop it first\");\n+      }\n+      accessor.removeProperty(keyBuilder.liveInstance(instanceName));\n+\n+      // drop without disable, should throw exception\n+      try {\n+        ClusterSetup.processCommandLineArgs(\n+            new String[]{\"--zkSvr\", ZK_ADDR, \"--dropNode\", clusterName, instanceAddress});\n+        Assert.fail(\"Should throw exception since \" + instanceName + \" is enabled\");\n+      } catch (HelixException expected) {\n+        Assert.assertEquals(expected.getMessage(),\n+            \"Node \" + instanceName + \" is enabled, cannot drop\");\n+      }\n+\n+      // Disable the instance\n+      ClusterSetup.processCommandLineArgs(\n+          new String[]{\"--zkSvr\", ZK_ADDR, \"--enableInstance\", clusterName, instanceName, \"false\"});\n+      // Drop the instance\n+      ClusterSetup.processCommandLineArgs(\n+          new String[]{\"--zkSvr\", ZK_ADDR, \"--dropNode\", clusterName, instanceAddress});\n+\n+      Assert.assertNull(accessor.getProperty(keyBuilder.instanceConfig(instanceName)),\n+          \"Instance config should be dropped\");\n+      Assert.assertFalse(_gZkClient.exists(PropertyPathBuilder.instance(clusterName, instanceName)),\n+          \"Instance/host should be dropped\");\n+    } finally {\n+      // Have to close the dedicated zkclient in accessor to avoid zkclient leakage.\n+      accessor.getBaseDataAccessor().close();\n+      TestHelper.dropCluster(clusterName, _gZkClient);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb60cb0ff836b5c4e82a9db1b7b6d398db11f752"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NDQxOA==", "bodyText": "Verified and updated.", "url": "https://github.com/apache/helix/pull/1053#discussion_r434294418", "createdAt": "2020-06-03T03:58:50Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java", "diffHunk": "@@ -356,51 +360,57 @@ public void testDropInstance() throws Exception {\n         \"MasterSlave\", true); // do rebalance\n \n     // add fake liveInstance\n-    ZKHelixDataAccessor accessor =\n-        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(ZK_ADDR));\n-    Builder keyBuilder = new Builder(clusterName);\n-    LiveInstance liveInstance = new LiveInstance(\"localhost_12918\");\n-    liveInstance.setSessionId(\"session_0\");\n-    liveInstance.setHelixVersion(\"version_0\");\n-    accessor.setProperty(keyBuilder.liveInstance(\"localhost_12918\"), liveInstance);\n+    HelixDataAccessor accessor = new ZKHelixDataAccessor(clusterName,\n+        new ZkBaseDataAccessor.Builder<ZNRecord>()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkClientType(ZkBaseDataAccessor.ZkClientType.DEDICATED)\n+            .setZkAddress(ZK_ADDR)\n+            .build());\n \n-    // drop without stop the process, should throw exception\n     try {\n-      ClusterSetup.processCommandLineArgs(new String[] {\n-          \"--zkSvr\", ZK_ADDR, \"--dropNode\", clusterName, \"localhost:12918\"\n-      });\n-      Assert.fail(\"Should throw exception since localhost_12918 is still in LIVEINSTANCES/\");\n-    } catch (Exception e) {\n-      // OK\n+      Builder keyBuilder = new Builder(clusterName);\n+      LiveInstance liveInstance = new LiveInstance(instanceName);\n+      liveInstance.setSessionId(\"session_0\");\n+      liveInstance.setHelixVersion(\"version_0\");\n+      accessor.setProperty(keyBuilder.liveInstance(instanceName), liveInstance);\n+\n+      // Drop instance without stopping the live instance, should throw HelixException\n+      try {\n+        ClusterSetup.processCommandLineArgs(\n+            new String[]{\"--zkSvr\", ZK_ADDR, \"--dropNode\", clusterName, instanceAddress});\n+        Assert.fail(\"Should throw exception since localhost_12918 is still in LIVEINSTANCES/\");\n+      } catch (HelixException expected) {\n+        Assert.assertEquals(expected.getMessage(),\n+            \"Cannot drop instance \" + instanceName + \" as it is still live. Please stop it first\");\n+      }\n+      accessor.removeProperty(keyBuilder.liveInstance(instanceName));\n+\n+      // drop without disable, should throw exception\n+      try {\n+        ClusterSetup.processCommandLineArgs(\n+            new String[]{\"--zkSvr\", ZK_ADDR, \"--dropNode\", clusterName, instanceAddress});\n+        Assert.fail(\"Should throw exception since \" + instanceName + \" is enabled\");\n+      } catch (HelixException expected) {\n+        Assert.assertEquals(expected.getMessage(),\n+            \"Node \" + instanceName + \" is enabled, cannot drop\");\n+      }\n+\n+      // Disable the instance\n+      ClusterSetup.processCommandLineArgs(\n+          new String[]{\"--zkSvr\", ZK_ADDR, \"--enableInstance\", clusterName, instanceName, \"false\"});\n+      // Drop the instance\n+      ClusterSetup.processCommandLineArgs(\n+          new String[]{\"--zkSvr\", ZK_ADDR, \"--dropNode\", clusterName, instanceAddress});\n+\n+      Assert.assertNull(accessor.getProperty(keyBuilder.instanceConfig(instanceName)),\n+          \"Instance config should be dropped\");\n+      Assert.assertFalse(_gZkClient.exists(PropertyPathBuilder.instance(clusterName, instanceName)),\n+          \"Instance/host should be dropped\");\n+    } finally {\n+      // Have to close the dedicated zkclient in accessor to avoid zkclient leakage.\n+      accessor.getBaseDataAccessor().close();\n+      TestHelper.dropCluster(clusterName, _gZkClient);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI4Nzk5Ng=="}, "originalCommit": {"oid": "eb60cb0ff836b5c4e82a9db1b7b6d398db11f752"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzUzMTE3OnYy", "diffSide": "LEFT", "path": "helix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTozOTo1MVrOGehw7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxOToxMjoxMVrOGepuLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2MzY2Mg==", "bodyText": "Does this mean if user constructs a ZKHelixDataAccessor with a ZK-ADDR, they can create an ephemeral node before, but not anymore after they bump to 1.0.0?", "url": "https://github.com/apache/helix/pull/1053#discussion_r434663662", "createdAt": "2020-06-03T15:39:51Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java", "diffHunk": "@@ -356,51 +360,65 @@ public void testDropInstance() throws Exception {\n         \"MasterSlave\", true); // do rebalance\n \n     // add fake liveInstance\n-    ZKHelixDataAccessor accessor =\n-        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(ZK_ADDR));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06dc161aa23cd5b1c0255256991f5a7febac6b09"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5NDAyOQ==", "bodyText": "@lei-xia No, it doesn't. Before 1.0.0, a ZKHelixDataAccessor with a ZK-ADDR is not able to create an ephemeral node, either. It is also by default using a shared zkclient internally. The only difference is the type of exceptions: before 1.0.0, HelixException is thrown from sharedZkClient, while in 1.0.0, UnsupportedOperationException is thrown.\nThe root cause for this test is, even though a live instance(ephemeral node) is not created by the ZKHelixDataAccessor with a ZK-ADDR, the test still passes, because the test doesn't catch or verify the correct result.", "url": "https://github.com/apache/helix/pull/1053#discussion_r434794029", "createdAt": "2020-06-03T19:12:11Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java", "diffHunk": "@@ -356,51 +360,65 @@ public void testDropInstance() throws Exception {\n         \"MasterSlave\", true); // do rebalance\n \n     // add fake liveInstance\n-    ZKHelixDataAccessor accessor =\n-        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(ZK_ADDR));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2MzY2Mg=="}, "originalCommit": {"oid": "06dc161aa23cd5b1c0255256991f5a7febac6b09"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1112, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}