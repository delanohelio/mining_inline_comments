{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMDkxNzQ0", "number": 731, "title": "Add TrieRoutingData constructor", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #730\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis PR adds a constructor to TrieRoutingData. The constructor takes in a mapping of sharding keys to realm addresses and parses it into a trie.\nTests\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO] Tests run: 117, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 20.509 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 117, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  46.303 s\n[INFO] Finished at: 2020-02-06T11:56:22-08:00\n[INFO] -----------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-06T20:16:28Z", "url": "https://github.com/apache/helix/pull/731", "merged": true, "mergeCommit": {"oid": "494f5a1d2d79f9b21319a86b60018bd12c2571b1"}, "closed": true, "closedAt": "2020-02-11T00:41:11Z", "author": {"login": "NealSun96"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBwgWVgH2gAyMzcyMDkxNzQ0OmRlNDk3NTZlZDI4N2MyOGVkYjYwNzJmYzI5OTgwMmEwYzMxYjhjN2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDF8C9AFqTM1NjM0NDk3MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "de49756ed287c28edb6072fc299802a0c31b8c7b", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/de49756ed287c28edb6072fc299802a0c31b8c7b", "committedDate": "2020-02-06T20:10:47Z", "message": "add TrieRoutingData constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b", "committedDate": "2020-02-06T20:14:18Z", "message": "fix formating"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODI4ODUy", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-354828852", "createdAt": "2020-02-06T22:51:52Z", "commit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo1MTo1M1rOFms9dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjo1NToxMFrOFmtCNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjgzNw==", "bodyText": "If the code is not necessary, let's remove it.", "url": "https://github.com/apache/helix/pull/731#discussion_r376126837", "createdAt": "2020-02-06T22:51:53Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -179,10 +179,10 @@ public void refreshRoutingData(String namespace) {\n     }\n \n     if (_routingDataMap != null) {\n-      MetadataStoreRoutingData newRoutingData =\n-          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n+//      MetadataStoreRoutingData newRoutingData =\n+//          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n       // TODO call constructRoutingData() here.\n-      _routingDataMap.put(namespace, newRoutingData);\n+//      _routingDataMap.put(namespace, newRoutingData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNzY2Mg==", "bodyText": "Is this necessary to special handling? following constructTrie logic will not handle the root sharding key?", "url": "https://github.com/apache/helix/pull/731#discussion_r376127662", "createdAt": "2020-02-06T22:54:10Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -37,12 +39,14 @@\n \n   private final TrieNode _rootNode;\n \n-  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n-  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n-  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n-  // will therefore be implemented later.\n-  public TrieRoutingData(TrieNode rootNode) {\n-    _rootNode = rootNode;\n+  public TrieRoutingData(Map<String, List<String>> routingData) throws InvalidRoutingDataException {\n+    if (isRootShardingKey(routingData)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyODA1NQ==", "bodyText": "Better not call variables directly.", "url": "https://github.com/apache/helix/pull/731#discussion_r376128055", "createdAt": "2020-02-06T22:55:10Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0NzQ4MDU4", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-354748058", "createdAt": "2020-02-06T20:26:29Z", "commit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMDoyNjozMFrOFmpGUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDoxMjoxOVrOFmujBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2MzU2OQ==", "bodyText": "shardingKeys.get(0).equals(\"\") could be shardingKeys.get(0).isEmpty()", "url": "https://github.com/apache/helix/pull/731#discussion_r376063569", "createdAt": "2020-02-06T20:26:30Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4MDg1MA==", "bodyText": "substring(0, 1) -> charAt(0) could improve performance O(N) -> O(1) and less string objects.", "url": "https://github.com/apache/helix/pull/731#discussion_r376080850", "createdAt": "2020-02-06T21:04:19Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MjU5MQ==", "bodyText": "It seems helpful if new TrieNode could create the HashMap so you don't have to always create and pass an empty map? I would hide the map data structure from external view.", "url": "https://github.com/apache/helix/pull/731#discussion_r376142591", "createdAt": "2020-02-06T23:36:53Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);\n+\n+        // If the key section is not the last section yet, perform the following\n+        while (nextDelimiterIndex > 0) {\n+          // If the node is already a leaf node, the current sharding key is invalid\n+          if (nextNode != null && nextNode._isLeaf) {\n+            throw new InvalidRoutingDataException(shardingKey.substring(0, nextDelimiterIndex)\n+                + \" is already a sharding key. \" + shardingKey + \" cannot be a sharding key.\");\n+          } else if (nextNode == null) {\n+            nextNode = new TrieNode(new HashMap<>(), shardingKey.substring(0, nextDelimiterIndex),\n+                false, \"\");\n+            curNode._children.put(keySection, nextNode);\n+          }\n+          prevDelimiterIndex = nextDelimiterIndex;\n+          nextDelimiterIndex = shardingKey.indexOf(DELIMITER, prevDelimiterIndex + 1);\n+          keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+              nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+          curNode = nextNode;\n+          nextNode = curNode._children.get(keySection);\n+        }\n+\n+        // If the last node already exists, it's a part of another sharding key, making the current\n+        // sharding key invalid\n+        if (nextNode != null) {\n+          throw new InvalidRoutingDataException(shardingKey\n+              + \" is a part of another sharding key, therefore it cannot be a sharding key.\");\n+        }\n+        nextNode = new TrieNode(new HashMap<>(), shardingKey, true, entry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODkxMw==", "bodyText": "isLeaf is not necessary in the constructor because you can expose an API isLeaf() to check if this node has children or not, right? Save one field for the TrieNode.", "url": "https://github.com/apache/helix/pull/731#discussion_r376148913", "createdAt": "2020-02-06T23:58:29Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);\n+\n+        // If the key section is not the last section yet, perform the following\n+        while (nextDelimiterIndex > 0) {\n+          // If the node is already a leaf node, the current sharding key is invalid\n+          if (nextNode != null && nextNode._isLeaf) {\n+            throw new InvalidRoutingDataException(shardingKey.substring(0, nextDelimiterIndex)\n+                + \" is already a sharding key. \" + shardingKey + \" cannot be a sharding key.\");\n+          } else if (nextNode == null) {\n+            nextNode = new TrieNode(new HashMap<>(), shardingKey.substring(0, nextDelimiterIndex),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDg0NA==", "bodyText": "You can check this first isEmpty(), throw exception before you add DELIMITER to the shardingKey. Could've saved one string object for this loop.", "url": "https://github.com/apache/helix/pull/731#discussion_r376150844", "createdAt": "2020-02-07T00:05:07Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MjgzNw==", "bodyText": "For this part, it seems you can just get a string array shardingKey.split(DELIMITER)  and use the array? This would reduce time complexity. Notice that string.substring() takes O(N) time.", "url": "https://github.com/apache/helix/pull/731#discussion_r376152837", "createdAt": "2020-02-07T00:12:19Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODY1OTQ4", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-354865948", "createdAt": "2020-02-07T00:30:00Z", "commit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDozMDowMFrOFmu1MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDozMDowMFrOFmu1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1NzQ4OQ==", "bodyText": "With the complete implementation of TrieRoutingData, you should be able to implement the logic here, correct?", "url": "https://github.com/apache/helix/pull/731#discussion_r376157489", "createdAt": "2020-02-07T00:30:00Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -179,10 +179,10 @@ public void refreshRoutingData(String namespace) {\n     }\n \n     if (_routingDataMap != null) {\n-      MetadataStoreRoutingData newRoutingData =\n-          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n+//      MetadataStoreRoutingData newRoutingData =\n+//          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n       // TODO call constructRoutingData() here.\n-      _routingDataMap.put(namespace, newRoutingData);\n+//      _routingDataMap.put(namespace, newRoutingData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODY4ODM5", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-354868839", "createdAt": "2020-02-07T00:39:48Z", "commit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDozOTo0OFrOFmu_eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDozOTo0OFrOFmu_eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MDEyMQ==", "bodyText": "Null check on routingData?", "url": "https://github.com/apache/helix/pull/731#discussion_r376160121", "createdAt": "2020-02-07T00:39:48Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -37,12 +39,14 @@\n \n   private final TrieNode _rootNode;\n \n-  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n-  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n-  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n-  // will therefore be implemented later.\n-  public TrieRoutingData(TrieNode rootNode) {\n-    _rootNode = rootNode;\n+  public TrieRoutingData(Map<String, List<String>> routingData) throws InvalidRoutingDataException {\n+    if (isRootShardingKey(routingData)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTY2OTI2", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-354966926", "createdAt": "2020-02-07T07:19:07Z", "commit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNzoxOTowN1rOFm0HlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNzoyNTozMlrOFm0OLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NDExNw==", "bodyText": "@NealSun96 You just need to re-construct a fresh instance of TrieRoutingData here. If that's still not clear, we could work together offline :)", "url": "https://github.com/apache/helix/pull/731#discussion_r376244117", "createdAt": "2020-02-07T07:19:07Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -179,10 +179,10 @@ public void refreshRoutingData(String namespace) {\n     }\n \n     if (_routingDataMap != null) {\n-      MetadataStoreRoutingData newRoutingData =\n-          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n+//      MetadataStoreRoutingData newRoutingData =\n+//          new TrieRoutingData(new TrieRoutingData.TrieNode(null, null, false, null));\n       // TODO call constructRoutingData() here.\n-      _routingDataMap.put(namespace, newRoutingData);\n+//      _routingDataMap.put(namespace, newRoutingData);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjgzNw=="}, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTE0Mw==", "bodyText": "@NealSun96\nCan you do a quick analysis here - one method would require the reader/traverser to keep track of the nodes it's traversing and construct a path, and the implementation you're providing here is \"caching\" the path in the name. Which one makes more sense? Think in the context of what kind of operations would be called more frequently - as in is there a real benefit to caching?", "url": "https://github.com/apache/helix/pull/731#discussion_r376245143", "createdAt": "2020-02-07T07:22:44Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MjgzNw=="}, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTM1OQ==", "bodyText": "\"There exist\"", "url": "https://github.com/apache/helix/pull/731#discussion_r376245359", "createdAt": "2020-02-07T07:23:34Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTQ0OA==", "bodyText": "constructs", "url": "https://github.com/apache/helix/pull/731#discussion_r376245448", "createdAt": "2020-02-07T07:23:54Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NTgwNw==", "bodyText": "Why is it possible to have two different cases? What does it mean to have just \"/\", and what does it mean to have an empty string?", "url": "https://github.com/apache/helix/pull/731#discussion_r376245807", "createdAt": "2020-02-07T07:25:32Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTcwMDMy", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-354970032", "createdAt": "2020-02-07T07:28:22Z", "commit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNzoyODoyM1rOFm0Rbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNzoyODoyM1rOFm0Rbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NjYzOA==", "bodyText": "\"the following\" ? Can you spell it out?", "url": "https://github.com/apache/helix/pull/731#discussion_r376246638", "createdAt": "2020-02-07T07:28:23Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);\n+\n+        // If the key section is not the last section yet, perform the following", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTcwNjYw", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-354970660", "createdAt": "2020-02-07T07:30:12Z", "commit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNzozMDoxMlrOFm0TVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNzozMDoxMlrOFm0TVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI0NzEyNg==", "bodyText": "Do you think you could add more descriptions about each test case?", "url": "https://github.com/apache/helix/pull/731#discussion_r376247126", "createdAt": "2020-02-07T07:30:12Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/TestTrieRoutingData.java", "diffHunk": "@@ -19,146 +19,180 @@\n  * under the License.\n  */\n \n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.NoSuchElementException;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n import org.testng.Assert;\n import org.testng.annotations.Test;\n \n public class TestTrieRoutingData {\n-  // TODO: add constructor related tests after constructor is finished\n+  private TrieRoutingData _trie;\n \n   @Test\n-  public void testGetAllMappingUnderPathFromRoot() {\n-    TrieRoutingData trie = constructTestTrie();\n-    Map<String, String> result = trie.getAllMappingUnderPath(\"/\");\n-    Assert.assertEquals(result.size(), 4);\n-    Assert.assertEquals(result.get(\"/b/c/d\"), \"realmAddressD\");\n-    Assert.assertEquals(result.get(\"/b/c/e\"), \"realmAddressE\");\n-    Assert.assertEquals(result.get(\"/b/f\"), \"realmAddressF\");\n-    Assert.assertEquals(result.get(\"/g\"), \"realmAddressG\");\n+  public void testConstructionSpecialCase() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODgxNjk3", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-354881697", "createdAt": "2020-02-07T01:22:38Z", "commit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMToyMjozOVrOFmvrUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjo0MjowOFrOFnMYFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MTM0NQ==", "bodyText": "I meant, you can compare two chars (DELIMITER could have a char variable?) so you don't have to create this single string each time. But actually, considering overall performance, it is still like O(7 * N) vs O(2 * N). So, up to you.", "url": "https://github.com/apache/helix/pull/731#discussion_r376171345", "createdAt": "2020-02-07T01:22:39Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4MDg1MA=="}, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MjUyMw==", "bodyText": "Nit, routingData.size() is enough.", "url": "https://github.com/apache/helix/pull/731#discussion_r376172523", "createdAt": "2020-02-07T01:27:14Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3NDExNg==", "bodyText": "If a node is leaf, then it shouldn't have any children.  This is enough.  In my opinion, _isLeaf is redundant.", "url": "https://github.com/apache/helix/pull/731#discussion_r376174116", "createdAt": "2020-02-07T01:33:54Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);\n+\n+        // If the key section is not the last section yet, perform the following\n+        while (nextDelimiterIndex > 0) {\n+          // If the node is already a leaf node, the current sharding key is invalid\n+          if (nextNode != null && nextNode._isLeaf) {\n+            throw new InvalidRoutingDataException(shardingKey.substring(0, nextDelimiterIndex)\n+                + \" is already a sharding key. \" + shardingKey + \" cannot be a sharding key.\");\n+          } else if (nextNode == null) {\n+            nextNode = new TrieNode(new HashMap<>(), shardingKey.substring(0, nextDelimiterIndex),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODkxMw=="}, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MTU1OA==", "bodyText": "Agree with @dasahcc . Should have an api getChildren().", "url": "https://github.com/apache/helix/pull/731#discussion_r376641558", "createdAt": "2020-02-07T22:42:08Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -124,8 +128,91 @@ private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.values().size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1\n+            && (shardingKeys.get(0).equals(DELIMITER) || shardingKeys.get(0).equals(\"\"));\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * construct the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          * trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      for (String shardingKey : entry.getValue()) {\n+        // Add a leading delimiter if there isn't any\n+        if (!shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          shardingKey = DELIMITER + shardingKey;\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exists other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode._children.get(keySection);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyODA1NQ=="}, "originalCommit": {"oid": "ddcef624a457a469a0f0fc6c4229ed1d98a9ab3b"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5078724e1583828b9ffbc9801cf423ba0560cf9", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/b5078724e1583828b9ffbc9801cf423ba0560cf9", "committedDate": "2020-02-08T00:18:37Z", "message": "Address all comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/d3e433f8b2547da01e0522ca5a718fd92e535195", "committedDate": "2020-02-08T00:27:57Z", "message": "fix nit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NTY1NjUz", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-355565653", "createdAt": "2020-02-08T19:54:03Z", "commit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQxOTo1NDowM1rOFnRygA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQyMDowNDoyM1rOFnR06A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDI0MA==", "bodyText": "Nit: say exactly what's happening. It helps to put yourself in the user's shoes - \"routingData cannot be null or empty!\".", "url": "https://github.com/apache/helix/pull/731#discussion_r376730240", "createdAt": "2020-02-08T19:54:03Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -37,15 +39,26 @@\n \n   private final TrieNode _rootNode;\n \n-  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n-  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n-  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n-  // will therefore be implemented later.\n-  public TrieRoutingData(TrieNode rootNode) {\n-    _rootNode = rootNode;\n+  public TrieRoutingData(Map<String, List<String>> routingData) throws InvalidRoutingDataException {\n+    if (routingData == null || routingData.isEmpty()) {\n+      throw new InvalidRoutingDataException(\"Missing routing data\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDI1OA==", "bodyText": "Nit: also add that delimiter means \"/\"", "url": "https://github.com/apache/helix/pull/731#discussion_r376730258", "createdAt": "2020-02-08T19:54:42Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -37,15 +39,26 @@\n \n   private final TrieNode _rootNode;\n \n-  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n-  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n-  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n-  // will therefore be implemented later.\n-  public TrieRoutingData(TrieNode rootNode) {\n-    _rootNode = rootNode;\n+  public TrieRoutingData(Map<String, List<String>> routingData) throws InvalidRoutingDataException {\n+    if (routingData == null || routingData.isEmpty()) {\n+      throw new InvalidRoutingDataException(\"Missing routing data\");\n+    }\n+\n+    if (isRootShardingKey(routingData)) {\n+      Map.Entry<String, List<String>> entry = routingData.entrySet().iterator().next();\n+      _rootNode = new TrieNode(Collections.emptyMap(), \"/\", true, entry.getKey());\n+    } else {\n+      _rootNode = new TrieNode(new HashMap<>(), \"/\", false, \"\");\n+      constructTrie(routingData);\n+    }\n   }\n \n-  public Map<String, String> getAllMappingUnderPath(String path) {\n+  public Map<String, String> getAllMappingUnderPath(String path) throws IllegalArgumentException {\n+    if (path.isEmpty() || !path.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided path is empty or does not have a leading delimiter: \" + path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDI2OQ==", "bodyText": "delimiter = \"/\"", "url": "https://github.com/apache/helix/pull/731#discussion_r376730269", "createdAt": "2020-02-08T19:55:00Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -58,20 +71,26 @@ public TrieRoutingData(TrieNode rootNode) {\n     nodeStack.push(curNode);\n     while (!nodeStack.isEmpty()) {\n       curNode = nodeStack.pop();\n-      if (curNode._isLeaf) {\n-        resultMap.put(curNode._name, curNode._realmAddress);\n+      if (curNode.isLeaf()) {\n+        resultMap.put(curNode.getName(), curNode.getRealmAddress());\n       } else {\n-        for (TrieNode child : curNode._children.values()) {\n+        for (TrieNode child : curNode.getChildren().values()) {\n           nodeStack.push(child);\n         }\n       }\n     }\n     return resultMap;\n   }\n \n-  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+  public String getMetadataStoreRealm(String path)\n+      throws IllegalArgumentException, NoSuchElementException {\n+    if (path.isEmpty() || !path.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided path is empty or does not have a leading delimiter: \" + path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQxNA==", "bodyText": "Nit: \"X cannot be a sharding key since one of its parent nodes (parent) is already a sharding key!\"", "url": "https://github.com/apache/helix/pull/731#discussion_r376730414", "createdAt": "2020-02-08T19:57:14Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -88,72 +107,174 @@ public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n    */\n   private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n       throws NoSuchElementException {\n-    if (path.equals(DELIMITER) || path.equals(\"\")) {\n-      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+    if (path.equals(DELIMITER)) {\n+      if (findLeafAlongPath && !_rootNode.isLeaf()) {\n         throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n       }\n       return _rootNode;\n     }\n \n-    String[] splitPath;\n-    if (path.substring(0, 1).equals(DELIMITER)) {\n-      splitPath = path.substring(1).split(DELIMITER, 0);\n-    } else {\n-      splitPath = path.split(DELIMITER, 0);\n-    }\n-\n     TrieNode curNode = _rootNode;\n-    if (findLeafAlongPath && curNode._isLeaf) {\n+    if (findLeafAlongPath && curNode.isLeaf()) {\n       return curNode;\n     }\n-    Map<String, TrieNode> curChildren = curNode._children;\n-    for (String pathSection : splitPath) {\n+    Map<String, TrieNode> curChildren = curNode.getChildren();\n+    for (String pathSection : path.substring(1).split(DELIMITER, 0)) {\n       curNode = curChildren.get(pathSection);\n       if (curNode == null) {\n         throw new NoSuchElementException(\n             \"The provided path is missing from the trie. Path: \" + path);\n       }\n-      if (findLeafAlongPath && curNode._isLeaf) {\n+      if (findLeafAlongPath && curNode.isLeaf()) {\n         return curNode;\n       }\n-      curChildren = curNode._children;\n+      curChildren = curNode.getChildren();\n     }\n     if (findLeafAlongPath) {\n       throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n     }\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1 && shardingKeys.get(0).equals(DELIMITER);\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * constructs the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      if (entry.getValue().isEmpty()) {\n+        throw new InvalidRoutingDataException(\n+            \"Realm address does not have associating sharding keys: \" + entry.getKey());\n+      }\n+      for (String shardingKey : entry.getValue()) {\n+        // Missing leading delimiter is invalid\n+        if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"Sharding key does not have a leading delimiter: \" + shardingKey);\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exist other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode.getChildren().get(keySection);\n+\n+        // If the key section is not the last section yet, go in the loop; if the key section is the\n+        // last section, exit\n+        while (nextDelimiterIndex > 0) {\n+          // If the node is already a leaf node, the current sharding key is invalid; if the node\n+          // doesn't exist, construct a node and continue\n+          if (nextNode != null && nextNode.isLeaf()) {\n+            throw new InvalidRoutingDataException(shardingKey.substring(0, nextDelimiterIndex)\n+                + \" is already a sharding key. \" + shardingKey + \" cannot be a sharding key.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQ0Ng==", "bodyText": "Nit: make this clearer - see above", "url": "https://github.com/apache/helix/pull/731#discussion_r376730446", "createdAt": "2020-02-08T19:57:52Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -88,72 +107,174 @@ public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n    */\n   private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n       throws NoSuchElementException {\n-    if (path.equals(DELIMITER) || path.equals(\"\")) {\n-      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+    if (path.equals(DELIMITER)) {\n+      if (findLeafAlongPath && !_rootNode.isLeaf()) {\n         throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n       }\n       return _rootNode;\n     }\n \n-    String[] splitPath;\n-    if (path.substring(0, 1).equals(DELIMITER)) {\n-      splitPath = path.substring(1).split(DELIMITER, 0);\n-    } else {\n-      splitPath = path.split(DELIMITER, 0);\n-    }\n-\n     TrieNode curNode = _rootNode;\n-    if (findLeafAlongPath && curNode._isLeaf) {\n+    if (findLeafAlongPath && curNode.isLeaf()) {\n       return curNode;\n     }\n-    Map<String, TrieNode> curChildren = curNode._children;\n-    for (String pathSection : splitPath) {\n+    Map<String, TrieNode> curChildren = curNode.getChildren();\n+    for (String pathSection : path.substring(1).split(DELIMITER, 0)) {\n       curNode = curChildren.get(pathSection);\n       if (curNode == null) {\n         throw new NoSuchElementException(\n             \"The provided path is missing from the trie. Path: \" + path);\n       }\n-      if (findLeafAlongPath && curNode._isLeaf) {\n+      if (findLeafAlongPath && curNode.isLeaf()) {\n         return curNode;\n       }\n-      curChildren = curNode._children;\n+      curChildren = curNode.getChildren();\n     }\n     if (findLeafAlongPath) {\n       throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n     }\n     return curNode;\n   }\n \n-  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n-  static class TrieNode {\n+  /**\n+   * Checks for the edge case when the only sharding key in provided routing data is the delimiter\n+   * or an empty string. When this is the case, the trie is valid and contains only one node, which\n+   * is the root node, and the root node is a leaf node with a realm address associated with it.\n+   * @param routingData - a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @return whether the edge case is true\n+   */\n+  private boolean isRootShardingKey(Map<String, List<String>> routingData) {\n+    if (routingData.size() == 1) {\n+      for (List<String> shardingKeys : routingData.values()) {\n+        return shardingKeys.size() == 1 && shardingKeys.get(0).equals(DELIMITER);\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided routing data. It loops through all sharding keys and\n+   * constructs the trie in a top down manner.\n+   * @param routingData- a mapping from \"sharding keys\" to \"realm addresses\" to be parsed into a\n+   *          trie\n+   * @throws InvalidRoutingDataException - when there is an empty sharding key (edge case that\n+   *           always renders the routing data invalid); when there is a sharding key which already\n+   *           contains a sharding key (invalid); when there is a sharding key that is a part of\n+   *           another sharding key (invalid)\n+   */\n+  private void constructTrie(Map<String, List<String>> routingData)\n+      throws InvalidRoutingDataException {\n+    for (Map.Entry<String, List<String>> entry : routingData.entrySet()) {\n+      if (entry.getValue().isEmpty()) {\n+        throw new InvalidRoutingDataException(\n+            \"Realm address does not have associating sharding keys: \" + entry.getKey());\n+      }\n+      for (String shardingKey : entry.getValue()) {\n+        // Missing leading delimiter is invalid\n+        if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"Sharding key does not have a leading delimiter: \" + shardingKey);\n+        }\n+\n+        // Root can only be a sharding key if it's the only sharding key. Since this method is\n+        // running, the special case has already been checked, therefore it's definitely invalid\n+        if (shardingKey.equals(DELIMITER)) {\n+          throw new InvalidRoutingDataException(\n+              \"There exist other sharding keys. Root cannot be a sharding key.\");\n+        }\n+\n+        // Locate the next delimiter\n+        int nextDelimiterIndex = shardingKey.indexOf(DELIMITER, 1);\n+        int prevDelimiterIndex = 0;\n+        String keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+            nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+        TrieNode curNode = _rootNode;\n+        TrieNode nextNode = curNode.getChildren().get(keySection);\n+\n+        // If the key section is not the last section yet, go in the loop; if the key section is the\n+        // last section, exit\n+        while (nextDelimiterIndex > 0) {\n+          // If the node is already a leaf node, the current sharding key is invalid; if the node\n+          // doesn't exist, construct a node and continue\n+          if (nextNode != null && nextNode.isLeaf()) {\n+            throw new InvalidRoutingDataException(shardingKey.substring(0, nextDelimiterIndex)\n+                + \" is already a sharding key. \" + shardingKey + \" cannot be a sharding key.\");\n+          } else if (nextNode == null) {\n+            nextNode = new TrieNode(new HashMap<>(), shardingKey.substring(0, nextDelimiterIndex),\n+                false, \"\");\n+            curNode.addChild(keySection, nextNode);\n+          }\n+          prevDelimiterIndex = nextDelimiterIndex;\n+          nextDelimiterIndex = shardingKey.indexOf(DELIMITER, prevDelimiterIndex + 1);\n+          keySection = shardingKey.substring(prevDelimiterIndex + 1,\n+              nextDelimiterIndex > 0 ? nextDelimiterIndex : shardingKey.length());\n+          curNode = nextNode;\n+          nextNode = curNode.getChildren().get(keySection);\n+        }\n+\n+        // If the last node already exists, it's a part of another sharding key, making the current\n+        // sharding key invalid\n+        if (nextNode != null) {\n+          throw new InvalidRoutingDataException(shardingKey\n+              + \" is a part of another sharding key, therefore it cannot be a sharding key.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDQ4OQ==", "bodyText": "Let's use {} instead of \"+\" for Loggers.", "url": "https://github.com/apache/helix/pull/731#discussion_r376730489", "createdAt": "2020-02-08T19:58:36Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -170,20 +170,21 @@ public void refreshRoutingData(String namespace) {\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDU0NQ==", "bodyText": "As we discussed offline, consider renaming this to \"rawRoutingData\" and add some comment here because it could be confusing later.", "url": "https://github.com/apache/helix/pull/731#discussion_r376730545", "createdAt": "2020-02-08T19:59:44Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -170,20 +170,21 @@ public void refreshRoutingData(String namespace) {\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      return;\n     }\n \n     try {\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      Map<String, List<String>> routingData = _routingDataReaderMap.get(namespace).getRoutingData();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDU5MQ==", "bodyText": "Null check  on _realmToShardingKeysMap since method is not necessarily threadsafe.", "url": "https://github.com/apache/helix/pull/731#discussion_r376730591", "createdAt": "2020-02-08T20:00:48Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -170,20 +170,21 @@ public void refreshRoutingData(String namespace) {\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      return;\n     }\n \n     try {\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      Map<String, List<String>> routingData = _routingDataReaderMap.get(namespace).getRoutingData();\n+      _realmToShardingKeysMap.put(namespace, routingData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDcxNA==", "bodyText": "As a matter of fact, let's do this check right in the beginning of this method.\nIf any of the maps (_routingZkAddressMap, _routingZkAddressMap, _routingDataMap) are null, just return.", "url": "https://github.com/apache/helix/pull/731#discussion_r376730714", "createdAt": "2020-02-08T20:02:23Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -170,20 +170,21 @@ public void refreshRoutingData(String namespace) {\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      return;\n     }\n \n     try {\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      Map<String, List<String>> routingData = _routingDataReaderMap.get(namespace).getRoutingData();\n+      _realmToShardingKeysMap.put(namespace, routingData);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDU5MQ=="}, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjczMDg1Ng==", "bodyText": "Not necessarily. There are a few different places where you could get this exception, so your log could be misleading.\nYou should do LOG.error(\"Failed to refresh cached routing data for namespace {}, namespace, e); This propagates the correct exception message.", "url": "https://github.com/apache/helix/pull/731#discussion_r376730856", "createdAt": "2020-02-08T20:04:23Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -170,20 +170,21 @@ public void refreshRoutingData(String namespace) {\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      return;\n     }\n \n     try {\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      Map<String, List<String>> routingData = _routingDataReaderMap.get(namespace).getRoutingData();\n+      _realmToShardingKeysMap.put(namespace, routingData);\n+\n+      if (_routingDataMap != null) {\n+        MetadataStoreRoutingData newRoutingData = new TrieRoutingData(routingData);\n+        _routingDataMap.put(namespace, newRoutingData);\n+      }\n     } catch (InvalidRoutingDataException e) {\n-      LOG.error(\"Failed to get routing data for namespace: \" + namespace + \"!\");\n+      LOG.error(\"Routing data construction has failed for namespace: \" + namespace + \"!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e433f8b2547da01e0522ca5a718fd92e535195"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "964b45fde44404203e3f186698d1ec07cea8bc0c", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/964b45fde44404203e3f186698d1ec07cea8bc0c", "committedDate": "2020-02-10T18:23:30Z", "message": "modify exception messages and naming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f9b1fe29aac3503df78d0784439be118e113841", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/6f9b1fe29aac3503df78d0784439be118e113841", "committedDate": "2020-02-10T19:06:13Z", "message": "change exception messages and add null checks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MTkwNjk2", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-356190696", "createdAt": "2020-02-10T19:10:56Z", "commit": {"oid": "6f9b1fe29aac3503df78d0784439be118e113841"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToxMDo1N1rOFnyJTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToxMDo1N1rOFnyJTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MDM2NA==", "bodyText": "Nit: usually passing the error itself is enough:\nLOG.error(\"Failed to refresh cached routing data for namespace {}\", namespace, e);", "url": "https://github.com/apache/helix/pull/731#discussion_r377260364", "createdAt": "2020-02-10T19:10:57Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -156,34 +156,42 @@ public boolean deleteShardingKey(String namespace, String realm, String sharding\n \n   /**\n    * Callback for updating the cached routing data.\n-   * Note: this method should not synchronize on the class or the map. We do not want namespaces blocking each other.\n+   * Note: this method should not synchronize on the class or the map. We do not want namespaces\n+   * blocking each other.\n    * Threadsafe map is used for _realmToShardingKeysMap.\n-   * The global consistency of the in-memory routing data is not a requirement (eventual consistency is enough).\n+   * The global consistency of the in-memory routing data is not a requirement (eventual consistency\n+   * is enough).\n    * @param namespace\n    */\n   @Override\n   public void refreshRoutingData(String namespace) {\n-    // Safe to ignore the callback if routingDataMap is null.\n+    // Safe to ignore the callback if any of the mapping is null.\n     // If routingDataMap is null, then it will be populated by the constructor anyway\n     // If routingDataMap is not null, then it's safe for the callback function to update it\n+    if (_routingZkAddressMap == null || _routingDataMap == null || _realmToShardingKeysMap == null) {\n+      LOG.error(\"Construction is not completed! \");\n+      return;\n+    }\n \n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n-      LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n+      LOG.error(\"Failed to refresh internally-cached routing data! Namespace not found: {}\",\n+          namespace);\n+      return;\n     }\n \n     try {\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      Map<String, List<String>> rawRoutingData =\n+          _routingDataReaderMap.get(namespace).getRoutingData();\n+      _realmToShardingKeysMap.put(namespace, rawRoutingData);\n+\n+      MetadataStoreRoutingData routingData = new TrieRoutingData(rawRoutingData);\n+      _routingDataMap.put(namespace, routingData);\n     } catch (InvalidRoutingDataException e) {\n-      LOG.error(\"Failed to get routing data for namespace: \" + namespace + \"!\");\n+      LOG.error(\"Failed to refresh cached routing data for namespace {}, exception: {}\", namespace,\n+          e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9b1fe29aac3503df78d0784439be118e113841"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MTkxNTgy", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-356191582", "createdAt": "2020-02-10T19:12:18Z", "commit": {"oid": "6f9b1fe29aac3503df78d0784439be118e113841"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47281ba31a23615e644fbfda489ea400f0e3e3b3", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/47281ba31a23615e644fbfda489ea400f0e3e3b3", "committedDate": "2020-02-10T20:07:52Z", "message": "change logging parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0418ffa310372602e471f1042cbd86ea16aad1b8", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/0418ffa310372602e471f1042cbd86ea16aad1b8", "committedDate": "2020-02-10T23:36:58Z", "message": "rename TrieNode fields to reduce confusion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MzQ0OTcw", "url": "https://github.com/apache/helix/pull/731#pullrequestreview-356344970", "createdAt": "2020-02-10T23:42:59Z", "commit": {"oid": "0418ffa310372602e471f1042cbd86ea16aad1b8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4936, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}