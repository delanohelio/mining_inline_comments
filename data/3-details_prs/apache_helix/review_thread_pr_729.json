{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMDI4MTE2", "number": 729, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMDoxODoyNFrODd0UFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzoxNzo1N1rODi4zgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTkyNDA0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMDoxODoyNFrOFmo4HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMDoyNTowOVrOFmpD_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA1OTkzMw==", "bodyText": "You can use _record.getLongField(CustomizedStateProperty.CURRENT_STATE.name(), NON_EXIST), while NON_EXIST = -1L as variable", "url": "https://github.com/apache/helix/pull/729#discussion_r376059933", "createdAt": "2020-02-06T20:18:24Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Customized states of partitions in a resource for an instance.\n+ */\n+public class CustomizedState extends HelixProperty {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedState.class);\n+\n+  /**\n+   * Lookup keys for the customized state\n+   */\n+  public enum CustomizedStateProperty {\n+    PREVIOUS_STATE,\n+    CURRENT_STATE,\n+    START_TIME,\n+    END_TIME\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a resource\n+   * @param resourceName name identifying the resource\n+   */\n+  public CustomizedState(String resourceName) {\n+    super(resourceName);\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a pre-populated ZNRecord\n+   * @param record a ZNRecord corresponding to the customized state\n+   */\n+  public CustomizedState(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  /**\n+   * Get the name of the resource\n+   * @return String resource identifier\n+   */\n+  public String getResourceName() {\n+    return _record.getId();\n+  }\n+\n+  /**\n+   * Get the partitions on this instance and the state that each partition is currently in.\n+   * @return (partition, state) pairs\n+   */\n+  public Map<String, String> getPartitionStateMap() {\n+    Map<String, String> map = new HashMap<String, String>();\n+    Map<String, Map<String, String>> mapFields = _record.getMapFields();\n+    for (String partitionName : mapFields.keySet()) {\n+      Map<String, String> tempMap = mapFields.get(partitionName);\n+      if (tempMap != null) {\n+        map.put(partitionName, tempMap.get(CustomizedStateProperty.CURRENT_STATE.name()));\n+      }\n+    }\n+    return map;\n+  }\n+\n+  /**\n+   * Get the state of a partition on this instance\n+   * @param partitionName the name of the partition\n+   * @return the state, or null if the partition is not present\n+   */\n+  public String getState(String partitionName) {\n+    return getProperty(partitionName, CustomizedStateProperty.CURRENT_STATE);\n+  }\n+\n+  public long getStartTime(String partitionName) {\n+    String startTime = getProperty(partitionName, CustomizedStateProperty.START_TIME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "737d708104997ce8eaa6e3d8686e76b20d845c31"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2Mjk3Mw==", "bodyText": "Same as following.", "url": "https://github.com/apache/helix/pull/729#discussion_r376062973", "createdAt": "2020-02-06T20:25:09Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Customized states of partitions in a resource for an instance.\n+ */\n+public class CustomizedState extends HelixProperty {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedState.class);\n+\n+  /**\n+   * Lookup keys for the customized state\n+   */\n+  public enum CustomizedStateProperty {\n+    PREVIOUS_STATE,\n+    CURRENT_STATE,\n+    START_TIME,\n+    END_TIME\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a resource\n+   * @param resourceName name identifying the resource\n+   */\n+  public CustomizedState(String resourceName) {\n+    super(resourceName);\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a pre-populated ZNRecord\n+   * @param record a ZNRecord corresponding to the customized state\n+   */\n+  public CustomizedState(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  /**\n+   * Get the name of the resource\n+   * @return String resource identifier\n+   */\n+  public String getResourceName() {\n+    return _record.getId();\n+  }\n+\n+  /**\n+   * Get the partitions on this instance and the state that each partition is currently in.\n+   * @return (partition, state) pairs\n+   */\n+  public Map<String, String> getPartitionStateMap() {\n+    Map<String, String> map = new HashMap<String, String>();\n+    Map<String, Map<String, String>> mapFields = _record.getMapFields();\n+    for (String partitionName : mapFields.keySet()) {\n+      Map<String, String> tempMap = mapFields.get(partitionName);\n+      if (tempMap != null) {\n+        map.put(partitionName, tempMap.get(CustomizedStateProperty.CURRENT_STATE.name()));\n+      }\n+    }\n+    return map;\n+  }\n+\n+  /**\n+   * Get the state of a partition on this instance\n+   * @param partitionName the name of the partition\n+   * @return the state, or null if the partition is not present\n+   */\n+  public String getState(String partitionName) {\n+    return getProperty(partitionName, CustomizedStateProperty.CURRENT_STATE);\n+  }\n+\n+  public long getStartTime(String partitionName) {\n+    String startTime = getProperty(partitionName, CustomizedStateProperty.START_TIME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA1OTkzMw=="}, "originalCommit": {"oid": "737d708104997ce8eaa6e3d8686e76b20d845c31"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTkzNjQzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMDoyMjozNlrOFmo_og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMDoyMjozNlrOFmo_og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2MTg1OA==", "bodyText": "Better to have partitionStateMap with arguments CURRENTSTATE or PREVIOUS STATE. Will be flexible enough for future retrieving other states information.", "url": "https://github.com/apache/helix/pull/729#discussion_r376061858", "createdAt": "2020-02-06T20:22:36Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Customized states of partitions in a resource for an instance.\n+ */\n+public class CustomizedState extends HelixProperty {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedState.class);\n+\n+  /**\n+   * Lookup keys for the customized state\n+   */\n+  public enum CustomizedStateProperty {\n+    PREVIOUS_STATE,\n+    CURRENT_STATE,\n+    START_TIME,\n+    END_TIME\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a resource\n+   * @param resourceName name identifying the resource\n+   */\n+  public CustomizedState(String resourceName) {\n+    super(resourceName);\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a pre-populated ZNRecord\n+   * @param record a ZNRecord corresponding to the customized state\n+   */\n+  public CustomizedState(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  /**\n+   * Get the name of the resource\n+   * @return String resource identifier\n+   */\n+  public String getResourceName() {\n+    return _record.getId();\n+  }\n+\n+  /**\n+   * Get the partitions on this instance and the state that each partition is currently in.\n+   * @return (partition, state) pairs\n+   */\n+  public Map<String, String> getPartitionStateMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "737d708104997ce8eaa6e3d8686e76b20d845c31"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTk0Mjg5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMDoyNDo1MlrOFmpDiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMTozNjoyOFrOFmrC4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2Mjg1Ng==", "bodyText": "From code perspective, we need to check it. But when we push data to ZK, it is better to remove non-reported entries to save spaces.", "url": "https://github.com/apache/helix/pull/729#discussion_r376062856", "createdAt": "2020-02-06T20:24:52Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Customized states of partitions in a resource for an instance.\n+ */\n+public class CustomizedState extends HelixProperty {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedState.class);\n+\n+  /**\n+   * Lookup keys for the customized state\n+   */\n+  public enum CustomizedStateProperty {\n+    PREVIOUS_STATE,\n+    CURRENT_STATE,\n+    START_TIME,\n+    END_TIME\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a resource\n+   * @param resourceName name identifying the resource\n+   */\n+  public CustomizedState(String resourceName) {\n+    super(resourceName);\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a pre-populated ZNRecord\n+   * @param record a ZNRecord corresponding to the customized state\n+   */\n+  public CustomizedState(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  /**\n+   * Get the name of the resource\n+   * @return String resource identifier\n+   */\n+  public String getResourceName() {\n+    return _record.getId();\n+  }\n+\n+  /**\n+   * Get the partitions on this instance and the state that each partition is currently in.\n+   * @return (partition, state) pairs\n+   */\n+  public Map<String, String> getPartitionStateMap() {\n+    Map<String, String> map = new HashMap<String, String>();\n+    Map<String, Map<String, String>> mapFields = _record.getMapFields();\n+    for (String partitionName : mapFields.keySet()) {\n+      Map<String, String> tempMap = mapFields.get(partitionName);\n+      if (tempMap != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16415b743f71e226a0a91bf79f2275d03165003"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5NTQ1Ng==", "bodyText": "Yeah, this data is only used for validation, and will not be written to zk.", "url": "https://github.com/apache/helix/pull/729#discussion_r376095456", "createdAt": "2020-02-06T21:36:28Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Customized states of partitions in a resource for an instance.\n+ */\n+public class CustomizedState extends HelixProperty {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedState.class);\n+\n+  /**\n+   * Lookup keys for the customized state\n+   */\n+  public enum CustomizedStateProperty {\n+    PREVIOUS_STATE,\n+    CURRENT_STATE,\n+    START_TIME,\n+    END_TIME\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a resource\n+   * @param resourceName name identifying the resource\n+   */\n+  public CustomizedState(String resourceName) {\n+    super(resourceName);\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a pre-populated ZNRecord\n+   * @param record a ZNRecord corresponding to the customized state\n+   */\n+  public CustomizedState(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  /**\n+   * Get the name of the resource\n+   * @return String resource identifier\n+   */\n+  public String getResourceName() {\n+    return _record.getId();\n+  }\n+\n+  /**\n+   * Get the partitions on this instance and the state that each partition is currently in.\n+   * @return (partition, state) pairs\n+   */\n+  public Map<String, String> getPartitionStateMap() {\n+    Map<String, String> map = new HashMap<String, String>();\n+    Map<String, Map<String, String>> mapFields = _record.getMapFields();\n+    for (String partitionName : mapFields.keySet()) {\n+      Map<String, String> tempMap = mapFields.get(partitionName);\n+      if (tempMap != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2Mjg1Ng=="}, "originalCommit": {"oid": "d16415b743f71e226a0a91bf79f2275d03165003"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTczMjk5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzozMjozNFrOFnNOvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODo1ODozOVrOFoVJOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1NTU0OA==", "bodyText": "You probably don't need this since you build the path using instanceCustomizedState", "url": "https://github.com/apache/helix/pull/729#discussion_r376655548", "createdAt": "2020-02-07T23:32:34Z", "author": {"login": "mgao0"}, "path": "helix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java", "diffHunk": "@@ -112,6 +115,12 @@\n         \"/{clusterName}/INSTANCES/{instanceName}/CURRENTSTATES/{sessionId}/{resourceName}\");\n     addEntry(PropertyType.CURRENTSTATES, 5,\n         \"/{clusterName}/INSTANCES/{instanceName}/CURRENTSTATES/{sessionId}/{resourceName}/{bucketName}\");\n+    addEntry(PropertyType.CUSTOMIZEDSTATES, 2,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b653edaf7154e5ee0895082fa814e7ef24435f6"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzMzc4Ng==", "bodyText": "Actually this one is not deprecated. It's used in initialization. If I remove this one, the path is not created.", "url": "https://github.com/apache/helix/pull/729#discussion_r377833786", "createdAt": "2020-02-11T18:58:39Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java", "diffHunk": "@@ -112,6 +115,12 @@\n         \"/{clusterName}/INSTANCES/{instanceName}/CURRENTSTATES/{sessionId}/{resourceName}\");\n     addEntry(PropertyType.CURRENTSTATES, 5,\n         \"/{clusterName}/INSTANCES/{instanceName}/CURRENTSTATES/{sessionId}/{resourceName}/{bucketName}\");\n+    addEntry(PropertyType.CUSTOMIZEDSTATES, 2,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1NTU0OA=="}, "originalCommit": {"oid": "4b653edaf7154e5ee0895082fa814e7ef24435f6"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTc0NjYzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo0Mjo1N1rOFnNXdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo0Mjo1N1rOFnNXdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1Nzc4MA==", "bodyText": "mapFields.putIfAbsent() should do the same thing but simpler", "url": "https://github.com/apache/helix/pull/729#discussion_r376657780", "createdAt": "2020-02-07T23:42:57Z", "author": {"login": "mgao0"}, "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "diffHunk": "@@ -0,0 +1,155 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Customized states of partitions in a resource for an instance.\n+ */\n+public class CustomizedState extends HelixProperty {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedState.class);\n+  private static long NON_EXIST = -1L;\n+\n+  /**\n+   * Lookup keys for the customized state\n+   */\n+  public enum CustomizedStateProperty {\n+    PREVIOUS_STATE,\n+    CURRENT_STATE,\n+    START_TIME,\n+    END_TIME\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a resource\n+   * @param resourceName name identifying the resource\n+   */\n+  public CustomizedState(String resourceName) {\n+    super(resourceName);\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a pre-populated ZNRecord\n+   * @param record a ZNRecord corresponding to the customized state\n+   */\n+  public CustomizedState(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  /**\n+   * Get the name of the resource\n+   * @return String resource identifier\n+   */\n+  public String getResourceName() {\n+    return _record.getId();\n+  }\n+\n+  /**\n+   * Get the partitions on this instance and the specified property that each partition is currently having.\n+   * @return (partition, property) pairs\n+   */\n+  public Map<String, String> getPartitionStateMap(CustomizedStateProperty property) {\n+    Map<String, String> map = new HashMap<String, String>();\n+    Map<String, Map<String, String>> mapFields = _record.getMapFields();\n+    for (String partitionName : mapFields.keySet()) {\n+      Map<String, String> tempMap = mapFields.get(partitionName);\n+      if (tempMap != null) {\n+        map.put(partitionName, tempMap.get(property.name()));\n+      }\n+    }\n+    return map;\n+  }\n+\n+  /**\n+   * Get the state of a partition on this instance\n+   * @param partitionName the name of the partition\n+   * @return the state, or null if the partition is not present\n+   */\n+  public String getState(String partitionName) {\n+    return getProperty(partitionName, CustomizedStateProperty.CURRENT_STATE);\n+  }\n+\n+  public long getStartTime(String partitionName) {\n+    return _record.getLongField(CustomizedStateProperty.START_TIME.name(), NON_EXIST);\n+  }\n+\n+  public long getEndTime(String partitionName) {\n+    return _record.getLongField(CustomizedStateProperty.END_TIME.name(), NON_EXIST);\n+  }\n+\n+  public String getPreviousState(String partitionName) {\n+    return getProperty(partitionName, CustomizedStateProperty.PREVIOUS_STATE);\n+  }\n+\n+  private String getProperty(String partitionName, CustomizedStateProperty property) {\n+    Map<String, String> mapField = _record.getMapField(partitionName);\n+    if (mapField != null) {\n+      return mapField.get(property.name());\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Set the state that a partition is currently in on this instance\n+   * @param partitionName the name of the partition\n+   * @param state the state of the partition\n+   */\n+  public void setState(String partitionName, String state) {\n+    setProperty(partitionName, CustomizedStateProperty.CURRENT_STATE, state);\n+  }\n+\n+  public void setStartTime(String partitionName, long startTime) {\n+    setProperty(partitionName, CustomizedStateProperty.START_TIME, String.valueOf(startTime));\n+  }\n+\n+  public void setEndTime(String partitionName, long endTime) {\n+    setProperty(partitionName, CustomizedStateProperty.END_TIME, String.valueOf(endTime));\n+  }\n+\n+  public void setPreviousState(String partitionName, String state) {\n+    setProperty(partitionName, CustomizedStateProperty.PREVIOUS_STATE, state);\n+  }\n+\n+  private void setProperty(String partitionName, CustomizedStateProperty property, String value) {\n+    Map<String, Map<String, String>> mapFields = _record.getMapFields();\n+    if (mapFields.get(partitionName) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b653edaf7154e5ee0895082fa814e7ef24435f6"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzcyNDgyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxODozNDoxNFrOFnw-eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTowMzoyNlrOFnx6pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0MTIwOA==", "bodyText": "This will override other partition's data, right?  You need to read existing ZNRecord back, merge your changes and update to ZK.", "url": "https://github.com/apache/helix/pull/729#discussion_r377241208", "createdAt": "2020-02-10T18:34:14Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package org.apache.helix.customizedstate;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.CustomizedState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for Helix customers to operate on customized state\n+ */\n+public class CustomizedStateProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateProvider.class);\n+  private final HelixManager _helixManager;\n+  String _instanceName;\n+\n+  public CustomizedStateProvider(HelixManager helixManager, String instanceName) {\n+    _helixManager = helixManager;\n+    _instanceName = instanceName;\n+  }\n+\n+  /**\n+   * Update the customized state based on the resource name and partition name\n+   */\n+  public synchronized void updateCustomizedState(String customizedStateName, String resourceName,\n+      String partitionName, Map<String, String> customizedState) {\n+    HelixDataAccessor accessor = _helixManager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey =\n+        keyBuilder.customizedState(_instanceName, customizedStateName, resourceName);\n+    ZNRecord record = new ZNRecord(resourceName);\n+    Map<String, Map<String, String>> mapFields = new HashMap<>();\n+    mapFields.put(partitionName, customizedState);\n+    record.setMapFields(mapFields);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08d0b7f2c25e0b065f7604a84a172daa912f1266"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0MTcyMg==", "bodyText": "Also, if I have 5 fields in my customized state map, but here I will like just to update 1 of them, do I need to specified other 4 fields again in this map? Your implementation seems requiring so.", "url": "https://github.com/apache/helix/pull/729#discussion_r377241722", "createdAt": "2020-02-10T18:35:21Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package org.apache.helix.customizedstate;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.CustomizedState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for Helix customers to operate on customized state\n+ */\n+public class CustomizedStateProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateProvider.class);\n+  private final HelixManager _helixManager;\n+  String _instanceName;\n+\n+  public CustomizedStateProvider(HelixManager helixManager, String instanceName) {\n+    _helixManager = helixManager;\n+    _instanceName = instanceName;\n+  }\n+\n+  /**\n+   * Update the customized state based on the resource name and partition name\n+   */\n+  public synchronized void updateCustomizedState(String customizedStateName, String resourceName,\n+      String partitionName, Map<String, String> customizedState) {\n+    HelixDataAccessor accessor = _helixManager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey =\n+        keyBuilder.customizedState(_instanceName, customizedStateName, resourceName);\n+    ZNRecord record = new ZNRecord(resourceName);\n+    Map<String, Map<String, String>> mapFields = new HashMap<>();\n+    mapFields.put(partitionName, customizedState);\n+    record.setMapFields(mapFields);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0MTIwOA=="}, "originalCommit": {"oid": "08d0b7f2c25e0b065f7604a84a172daa912f1266"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1NjYxMw==", "bodyText": "Using update actually will not override other partition's data. I tested in the unit test. It will only override the same key's.\nFor the fields update, I was actually thinking about it. The implementation right now only support full update. I can add partial update. It's be useful if there're many fields that actually do not change.", "url": "https://github.com/apache/helix/pull/729#discussion_r377256613", "createdAt": "2020-02-10T19:03:26Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package org.apache.helix.customizedstate;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.CustomizedState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for Helix customers to operate on customized state\n+ */\n+public class CustomizedStateProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateProvider.class);\n+  private final HelixManager _helixManager;\n+  String _instanceName;\n+\n+  public CustomizedStateProvider(HelixManager helixManager, String instanceName) {\n+    _helixManager = helixManager;\n+    _instanceName = instanceName;\n+  }\n+\n+  /**\n+   * Update the customized state based on the resource name and partition name\n+   */\n+  public synchronized void updateCustomizedState(String customizedStateName, String resourceName,\n+      String partitionName, Map<String, String> customizedState) {\n+    HelixDataAccessor accessor = _helixManager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey =\n+        keyBuilder.customizedState(_instanceName, customizedStateName, resourceName);\n+    ZNRecord record = new ZNRecord(resourceName);\n+    Map<String, Map<String, String>> mapFields = new HashMap<>();\n+    mapFields.put(partitionName, customizedState);\n+    record.setMapFields(mapFields);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0MTIwOA=="}, "originalCommit": {"oid": "08d0b7f2c25e0b065f7604a84a172daa912f1266"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTMyMDk3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProviderFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxODoxMVrOFpgWvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxODoxMVrOFpgWvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NjA0Ng==", "bodyText": "Remove else clause.", "url": "https://github.com/apache/helix/pull/729#discussion_r379066046", "createdAt": "2020-02-13T19:18:11Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProviderFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.customizedstate;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Singleton factory that build customized state provider.\n+ */\n+public class CustomizedStateProviderFactory {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateProvider.class);\n+  private final HashMap<String, CustomizedStateProvider> _customizedStateProviderMap =\n+      new HashMap<>();\n+  private HelixManager _helixManager;\n+\n+  protected CustomizedStateProviderFactory() {\n+  }\n+\n+  private static class SingletonHelper {\n+    private static final CustomizedStateProviderFactory INSTANCE =\n+        new CustomizedStateProviderFactory();\n+  }\n+\n+  public static CustomizedStateProviderFactory getInstance() {\n+    return SingletonHelper.INSTANCE;\n+  }\n+\n+  public CustomizedStateProvider buildCustomizedStateProvider(String instanceName) {\n+    if (_helixManager == null) {\n+      throw new HelixException(\"Helix Manager has not been set yet.\");\n+    } else {\n+      return buildCustomizedStateProvider(_helixManager, instanceName);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb938800a2dc7cefdfbe32d0d35b2b5c7d5f043"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTMyMjAwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProviderFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxODozMVrOFpgXYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxODozMVrOFpgXYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NjIwOA==", "bodyText": "Same here. Remove else clause.", "url": "https://github.com/apache/helix/pull/729#discussion_r379066208", "createdAt": "2020-02-13T19:18:31Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProviderFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.customizedstate;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Singleton factory that build customized state provider.\n+ */\n+public class CustomizedStateProviderFactory {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateProvider.class);\n+  private final HashMap<String, CustomizedStateProvider> _customizedStateProviderMap =\n+      new HashMap<>();\n+  private HelixManager _helixManager;\n+\n+  protected CustomizedStateProviderFactory() {\n+  }\n+\n+  private static class SingletonHelper {\n+    private static final CustomizedStateProviderFactory INSTANCE =\n+        new CustomizedStateProviderFactory();\n+  }\n+\n+  public static CustomizedStateProviderFactory getInstance() {\n+    return SingletonHelper.INSTANCE;\n+  }\n+\n+  public CustomizedStateProvider buildCustomizedStateProvider(String instanceName) {\n+    if (_helixManager == null) {\n+      throw new HelixException(\"Helix Manager has not been set yet.\");\n+    } else {\n+      return buildCustomizedStateProvider(_helixManager, instanceName);\n+    }\n+  }\n+\n+  /**\n+   * Build a customized state provider based on the specified input. If the instance already has a\n+   * provider, return it. Otherwise, build a new one and put it in the map.\n+   * @param helixManager The helix manager that belongs to the instance\n+   * @param instanceName The name of the instance\n+   * @return CustomizedStateProvider\n+   */\n+  public CustomizedStateProvider buildCustomizedStateProvider(HelixManager helixManager,\n+      String instanceName) {\n+    synchronized (_customizedStateProviderMap) {\n+      if (_customizedStateProviderMap.get(instanceName) != null) {\n+        return _customizedStateProviderMap.get(instanceName);\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb938800a2dc7cefdfbe32d0d35b2b5c7d5f043"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODEyNDM0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODowMjo1MlrOFuPfQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxODozMFrOFuR4bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMjU3Nw==", "bodyText": "You set start time and end time into map fields, but this getLongField gets information from simple fields right?", "url": "https://github.com/apache/helix/pull/729#discussion_r384032577", "createdAt": "2020-02-25T18:02:52Z", "author": {"login": "mgao0"}, "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Customized states of partitions in a resource for an instance.\n+ */\n+public class CustomizedState extends HelixProperty {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedState.class);\n+  private static long NON_EXIST = -1L;\n+\n+  /**\n+   * Lookup keys for the customized state\n+   */\n+  public enum CustomizedStateProperty {\n+    PREVIOUS_STATE,\n+    CURRENT_STATE,\n+    START_TIME,\n+    END_TIME\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a resource\n+   * @param resourceName name identifying the resource\n+   */\n+  public CustomizedState(String resourceName) {\n+    super(resourceName);\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a pre-populated ZNRecord\n+   * @param record a ZNRecord corresponding to the customized state\n+   */\n+  public CustomizedState(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  /**\n+   * Get the name of the resource\n+   * @return String resource identifier\n+   */\n+  public String getResourceName() {\n+    return _record.getId();\n+  }\n+\n+  /**\n+   * Get the partitions on this instance and the specified property that each partition is currently having.\n+   * @return (partition, property) pairs\n+   */\n+  public Map<String, String> getPartitionStateMap(CustomizedStateProperty property) {\n+    Map<String, String> map = new HashMap<String, String>();\n+    Map<String, Map<String, String>> mapFields = _record.getMapFields();\n+    for (String partitionName : mapFields.keySet()) {\n+      Map<String, String> tempMap = mapFields.get(partitionName);\n+      if (tempMap != null) {\n+        map.put(partitionName, tempMap.get(property.name()));\n+      }\n+    }\n+    return map;\n+  }\n+\n+  /**\n+   * Get the state of a partition on this instance\n+   * @param partitionName the name of the partition\n+   * @return the state, or null if the partition is not present\n+   */\n+  public String getState(String partitionName) {\n+    return getProperty(partitionName, CustomizedStateProperty.CURRENT_STATE);\n+  }\n+\n+  public long getStartTime(String partitionName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df40d429c1bc4663903f7d204c3175ff47d5b0e8"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MTc5MA==", "bodyText": "Good catch. I accidentally changed this to be wrong during a previous cleanup. Updated.", "url": "https://github.com/apache/helix/pull/729#discussion_r384071790", "createdAt": "2020-02-25T19:18:30Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/model/CustomizedState.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Customized states of partitions in a resource for an instance.\n+ */\n+public class CustomizedState extends HelixProperty {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedState.class);\n+  private static long NON_EXIST = -1L;\n+\n+  /**\n+   * Lookup keys for the customized state\n+   */\n+  public enum CustomizedStateProperty {\n+    PREVIOUS_STATE,\n+    CURRENT_STATE,\n+    START_TIME,\n+    END_TIME\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a resource\n+   * @param resourceName name identifying the resource\n+   */\n+  public CustomizedState(String resourceName) {\n+    super(resourceName);\n+  }\n+\n+  /**\n+   * Instantiate a customized state with a pre-populated ZNRecord\n+   * @param record a ZNRecord corresponding to the customized state\n+   */\n+  public CustomizedState(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  /**\n+   * Get the name of the resource\n+   * @return String resource identifier\n+   */\n+  public String getResourceName() {\n+    return _record.getId();\n+  }\n+\n+  /**\n+   * Get the partitions on this instance and the specified property that each partition is currently having.\n+   * @return (partition, property) pairs\n+   */\n+  public Map<String, String> getPartitionStateMap(CustomizedStateProperty property) {\n+    Map<String, String> map = new HashMap<String, String>();\n+    Map<String, Map<String, String>> mapFields = _record.getMapFields();\n+    for (String partitionName : mapFields.keySet()) {\n+      Map<String, String> tempMap = mapFields.get(partitionName);\n+      if (tempMap != null) {\n+        map.put(partitionName, tempMap.get(property.name()));\n+      }\n+    }\n+    return map;\n+  }\n+\n+  /**\n+   * Get the state of a partition on this instance\n+   * @param partitionName the name of the partition\n+   * @return the state, or null if the partition is not present\n+   */\n+  public String getState(String partitionName) {\n+    return getProperty(partitionName, CustomizedStateProperty.CURRENT_STATE);\n+  }\n+\n+  public long getStartTime(String partitionName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMjU3Nw=="}, "originalCommit": {"oid": "df40d429c1bc4663903f7d204c3175ff47d5b0e8"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODg1OTMxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTo1Mzo0OFrOFuWnBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTo1Mzo0OFrOFuWnBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0OTI1Mg==", "bodyText": "Are we sure this is required path? That's not a good idea to add this. If we add this and existing product uses Helix library for participant will have check failure since Instance is already created.", "url": "https://github.com/apache/helix/pull/729#discussion_r384149252", "createdAt": "2020-02-25T21:53:48Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -139,6 +139,7 @@ public static boolean isInstanceSetup(HelixZkClient zkclient, String clusterName\n       requiredPaths.add(PropertyPathBuilder.instanceConfig(clusterName, instanceName));\n       requiredPaths.add(PropertyPathBuilder.instanceMessage(clusterName, instanceName));\n       requiredPaths.add(PropertyPathBuilder.instanceCurrentState(clusterName, instanceName));\n+      requiredPaths.add(PropertyPathBuilder.instanceCustomizedState(clusterName, instanceName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d6079c21a471a282ee3e724a7083f09b9947a91"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTA4ODY0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzoxNzo1N1rOFuY1Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzoxNzo1N1rOFuY1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4NTY1NA==", "bodyText": "nit: remove one of the dots in \". . \"", "url": "https://github.com/apache/helix/pull/729#discussion_r384185654", "createdAt": "2020-02-25T23:17:57Z", "author": {"login": "alirezazamani"}, "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProvider.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.customizedstate;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.model.CustomizedState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for Helix customers to operate on customized state\n+ */\n+public class CustomizedStateProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateProvider.class);\n+  private final HelixManager _helixManager;\n+  private final HelixDataAccessor _helixDataAccessor;\n+  private String _instanceName;\n+\n+  public CustomizedStateProvider(HelixManager helixManager, String instanceName) {\n+    _helixManager = helixManager;\n+    _instanceName = instanceName;\n+    _helixDataAccessor = _helixManager.getHelixDataAccessor();\n+  }\n+\n+  /**\n+   * Update a specific customized state based on the resource name and partition name. The\n+   * customized state is input as a single string\n+   */\n+  public synchronized void updateCustomizedState(String customizedStateName, String resourceName,\n+      String partitionName, String customizedState) {\n+    Map<String, String> customizedStateMap = new HashMap<>();\n+    customizedStateMap.put(CustomizedState.CustomizedStateProperty.CURRENT_STATE.name(), customizedState);\n+    updateCustomizedState(customizedStateName, resourceName, partitionName, customizedStateMap);\n+  }\n+\n+  /**\n+   * Update a specific customized state based on the resource name and partition name. . The", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d6079c21a471a282ee3e724a7083f09b9947a91"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1600, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}