{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExMTQ5ODE0", "number": 1489, "title": "Refine the HelixTaskExecutor to reduce duplicate code and clarify the code structure.", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nThis PR is related to #1488 given we need to clean up the related code so as to make the further fix. But it won't address the issue.\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nRefine the HelixTaskExecutor to reduce duplicate code and clarify the code structure.\nThere is a minor code logic change for optimization. But there is no business logic change in this PR.\nTests\n\n The following tests are written for this issue:\n\nNA\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[ERROR] Failures:\n[ERROR]   TestRoutingTableProviderPeriodicRefresh.testPeriodicRefresh:214 expected:<4> but was:<3>\n[INFO]\n[ERROR] Tests run: 1234, Failures: 1, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 01:28 h\n[INFO] Finished at: 2020-10-28T15:46:36-07:00\n[INFO] ------------------------------------------------------------------------\nThis test keeps failing on the master branch too. We are investigating this problem separately.\nDocumentation (Optional)\n\nIn case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCommits\n\nMy commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\nMy diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-10-27T22:40:48Z", "url": "https://github.com/apache/helix/pull/1489", "merged": true, "mergeCommit": {"oid": "215d4072756651ea7f242adc68442780828ba0f9"}, "closed": true, "closedAt": "2020-10-29T20:41:23Z", "author": {"login": "jiajunwang"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWy-gpABqjM5Mjg4ODkwOTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXHyPHAFqTUxOTI2NjgzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5527cf0b40edcbb2e4352a3f5621694fc4a91309", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/5527cf0b40edcbb2e4352a3f5621694fc4a91309", "committedDate": "2020-10-27T22:32:15Z", "message": "Refine the HelixTaskExecutor to reduce duplicate code and clarify the code structure.\n\nThere is minor code logic change for optimization. But there is no business logic change in this PR."}, "afterCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/0777cd369d48fba480ac9ffb7e0b309fda7540ee", "committedDate": "2020-10-28T01:06:27Z", "message": "Refine the HelixTaskExecutor to reduce duplicate code and clarify the code structure.\n\nThere is minor code logic change for optimization. But there is no business logic change in this PR."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MDQ1NzI2", "url": "https://github.com/apache/helix/pull/1489#pullrequestreview-519045726", "createdAt": "2020-10-28T20:13:08Z", "commit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxMzowOFrOHp7p-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxMzowOFrOHp7p-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMTA2NQ==", "bodyText": "All the above changes seems to be non-essential change, right?", "url": "https://github.com/apache/helix/pull/1489#discussion_r513731065", "createdAt": "2020-10-28T20:13:08Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -192,43 +191,38 @@ public void registerMessageHandlerFactory(String type, MessageHandlerFactory fac\n   @Override\n   public void registerMessageHandlerFactory(String type, MessageHandlerFactory factory,\n       int threadpoolSize) {\n-    if (factory instanceof  MultiTypeMessageHandlerFactory) {\n+    if (factory instanceof MultiTypeMessageHandlerFactory) {\n       if (!((MultiTypeMessageHandlerFactory) factory).getMessageTypes().contains(type)) {\n         throw new HelixException(\"Message factory type mismatch. Type: \" + type + \", factory: \"\n             + ((MultiTypeMessageHandlerFactory) factory).getMessageTypes());\n       }\n     } else {\n       if (!factory.getMessageType().equals(type)) {\n         throw new HelixException(\n-            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory.getMessageType());\n+            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory\n+                .getMessageType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTExNTE3", "url": "https://github.com/apache/helix/pull/1489#pullrequestreview-519111517", "createdAt": "2020-10-28T21:50:06Z", "commit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMTo1MDowNlrOHp-1AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMTo1NDoxMFrOHp-8sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4MzA0MA==", "bodyText": "We can use putIfAbsent since we are not using the return value anymore here.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513783040", "createdAt": "2020-10-28T21:50:06Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -192,43 +191,38 @@ public void registerMessageHandlerFactory(String type, MessageHandlerFactory fac\n   @Override\n   public void registerMessageHandlerFactory(String type, MessageHandlerFactory factory,\n       int threadpoolSize) {\n-    if (factory instanceof  MultiTypeMessageHandlerFactory) {\n+    if (factory instanceof MultiTypeMessageHandlerFactory) {\n       if (!((MultiTypeMessageHandlerFactory) factory).getMessageTypes().contains(type)) {\n         throw new HelixException(\"Message factory type mismatch. Type: \" + type + \", factory: \"\n             + ((MultiTypeMessageHandlerFactory) factory).getMessageTypes());\n       }\n     } else {\n       if (!factory.getMessageType().equals(type)) {\n         throw new HelixException(\n-            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory.getMessageType());\n+            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory\n+                .getMessageType());\n       }\n     }\n \n     _isShuttingDown = false;\n \n-    MsgHandlerFactoryRegistryItem newItem = new MsgHandlerFactoryRegistryItem(factory, threadpoolSize);\n+    MsgHandlerFactoryRegistryItem newItem =\n+        new MsgHandlerFactoryRegistryItem(factory, threadpoolSize);\n     MsgHandlerFactoryRegistryItem prevItem = _hdlrFtyRegistry.putIfAbsent(type, newItem);\n     if (prevItem == null) {\n-      ExecutorService newPool = Executors.newFixedThreadPool(threadpoolSize, new ThreadFactory() {\n-        @Override public Thread newThread(Runnable r) {\n-          return new Thread(r, \"HelixTaskExecutor-message_handle_thread_\" + thread_uid.getAndIncrement());\n-        }\n-      });\n-      ExecutorService prevExecutor = _executorMap.putIfAbsent(type, newPool);\n-      if (prevExecutor != null) {\n-        LOG.warn(\"Skip creating a new thread pool for type: \" + type + \", already existing pool: \"\n-            + prevExecutor + \", isShutdown: \" + prevExecutor.isShutdown());\n-        newPool.shutdown();\n-        newPool = null;\n-      } else {\n+      _executorMap.computeIfAbsent(type, msgType -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NTAwOQ==", "bodyText": "nit: better to name it as isNoOpMessage? The word check could be confusing here.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513785009", "createdAt": "2020-10-28T21:54:10Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkForNoOpMessage(Message message, String instanceName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 532}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTI1MzE5", "url": "https://github.com/apache/helix/pull/1489#pullrequestreview-519125319", "createdAt": "2020-10-28T22:15:18Z", "commit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjoxNToxOFrOHp_gmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjoxNToxOFrOHp_gmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NDIwMA==", "bodyText": "This is not just check noOp, it also has other functionalities, check message expired or cancellation logic. Shall we change the name of this one?\nMore importantly, any exception thrown out here without statemodel marked as ERROR can cause controller sending another message repeatedly. Can you this invariant to the comment? So later if someone not familiar with this code can understand the intention here.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513794200", "createdAt": "2020-10-28T22:15:18Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkForNoOpMessage(Message message, String instanceName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 532}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTI1ODQ1", "url": "https://github.com/apache/helix/pull/1489#pullrequestreview-519125845", "createdAt": "2020-10-28T22:16:19Z", "commit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjoxNjoxOVrOHp_iSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjoxNjoxOVrOHp_iSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NDYzMg==", "bodyText": "why remove these two lines?", "url": "https://github.com/apache/helix/pull/1489#discussion_r513794632", "createdAt": "2020-10-28T22:16:19Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -810,164 +799,52 @@ public void onMessage(String instanceName, List<Message> messages,\n     Set<String> createCurStateNames = new HashSet<>();\n \n     for (Message message : messages) {\n-      try {\n-        // nop messages are simply removed. It is used to trigger onMessage() in\n-        // situations such as register a new message handler factory\n-        if (message.getMsgType().equalsIgnoreCase(MessageType.NO_OP.toString())) {\n-          LOG.info(\n-              \"Dropping NO-OP message. mid: \" + message.getId() + \", from: \" + message.getMsgSrc());\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.DISCARDED);\n-          continue;\n-        }\n-\n-        String tgtSessionId = message.getTgtSessionId();\n-        // sessionId mismatch normally means message comes from expired session, just remove it\n-        if (!sessionId.equals(tgtSessionId) && !tgtSessionId.equals(\"*\")) {\n-          String warningMessage =\n-              \"SessionId does NOT match. expected sessionId: \" + sessionId\n-                  + \", tgtSessionId in message: \" + tgtSessionId + \", messageId: \"\n-                  + message.getMsgId();\n-          LOG.warn(warningMessage);\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.DISCARDED);\n-          _statusUpdateUtil.logWarning(message, HelixStateMachineEngine.class, warningMessage, manager);\n-\n-          // Proactively send a session sync message from participant to controller\n-          // upon session mismatch after a new session is established\n-          if (manager.getInstanceType() == InstanceType.PARTICIPANT\n-              || manager.getInstanceType() == InstanceType.CONTROLLER_PARTICIPANT) {\n-            if (message.getCreateTimeStamp() > manager.getSessionStartTime()) {\n-              syncSessionToController(manager);\n-            }\n-          }\n-          continue;\n-        }\n-\n-        if ((manager.getInstanceType() == InstanceType.CONTROLLER\n-            || manager.getInstanceType() == InstanceType.CONTROLLER_PARTICIPANT)\n-            && MessageType.PARTICIPANT_SESSION_CHANGE.name().equals(message.getMsgType())) {\n-          LOG.info(String.format(\"Controller received PARTICIPANT_SESSION_CHANGE msg from src: %s\",\n-              message.getMsgSrc()));\n-          PropertyKey key = new Builder(manager.getClusterName()).liveInstances();\n-          List<LiveInstance> liveInstances =\n-              manager.getHelixDataAccessor().getChildValues(key, true);\n-          _controller.onLiveInstanceChange(liveInstances, changeContext);\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.COMPLETED);\n-          continue;\n-        }\n-\n-        // don't process message that is of READ or UNPROCESSABLE state\n-        if (MessageState.NEW != message.getMsgState()) {\n-          // It happens because we don't delete message right after\n-          // read. Instead we keep it until the current state is updated.\n-          // We will read the message again if there is a new message but we\n-          // check for the status and ignore if its already read\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Message already read. msgId: \" + message.getMsgId());\n-          }\n-          continue;\n-        }\n-\n-        if (message.isExpired()) {\n-          LOG.info(\n-              \"Dropping expired message. mid: \" + message.getId() + \", from: \" + message.getMsgSrc()\n-                  + \" relayed from: \" + message.getRelaySrcHost());\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.DISCARDED);\n-          continue;\n-        }\n-\n-        // State Transition Cancellation\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          boolean success = cancelNotStartedStateTransition(message, stateTransitionHandlers, accessor, instanceName);\n-          if (success) {\n-            continue;\n-          }\n-        }\n-\n-        _monitor.reportReceivedMessage(message);\n-      } catch (Exception e) {\n-        LOG.error(\"Failed to process the message {}. Deleting the message from ZK. Exception: {}\",\n-            message, e);\n-        removeMessageFromTaskAndFutureMap(message);\n-        removeMessageFromZK(accessor, message, instanceName);\n+      if (checkForNoOpMessage(message, instanceName, changeContext, manager, sessionId,\n+          stateTransitionHandlers)) {\n+        // skip the following operations for the no-op messages.\n         continue;\n       }\n-\n       // create message handlers, if handlers not found, leave its state as NEW\n       NotificationContext msgWorkingContext = changeContext.clone();\n       try {\n-        MessageHandler createHandler = createMessageHandler(message, msgWorkingContext);\n-        if (createHandler == null) {\n+        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n+        if (msgHandler == null) {\n+          // Failed to create message handler, skip processing this message in this callback.\n+          // The same message process will be retried in the next round.\n           continue;\n         }\n         if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n             .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          String messageTarget =\n-              getMessageTarget(message.getResourceName(), message.getPartitionName());\n-\n-          if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n-              && isStateTransitionInProgress(messageTarget)) {\n-\n-            String taskId = _messageTaskMap.get(messageTarget);\n-            Message msg = _taskMap.get(taskId).getTask().getMessage();\n-\n-            // If there is another state transition for same partition is going on,\n-            // discard the message. Controller will resend if this is a valid message\n-            String errMsg = String.format(\n-                \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n-                message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n-                String.valueOf(msg.isRelayMessage()), msg.getReadTimeStamp(),\n-                System.currentTimeMillis(), message.getFromState(), message.getToState());\n-            handleUnprocessableMessage(message, null /* exception */, errMsg, accessor,\n-                instanceName, manager);\n-            continue;\n-          }\n-          if (createHandler instanceof HelixStateTransitionHandler) {\n-            // We only check to state if there is no ST task scheduled/executing.\n-            HelixStateTransitionHandler.StaleMessageValidateResult result =\n-                ((HelixStateTransitionHandler) createHandler).staleMessageValidator();\n-            if (!result.isValid) {\n-              handleUnprocessableMessage(message, null /* exception */,\n-                  result.exception.getMessage(), accessor, instanceName, manager);\n-              continue;\n-            }\n-          }\n-          if (stateTransitionHandlers.containsKey(messageTarget)) {\n-            // If there are 2 messages in same batch about same partition's state transition,\n-            // the later one is discarded\n-            Message duplicatedMessage = stateTransitionHandlers.get(messageTarget)._message;\n-            String errMsg = String.format(\n-                \"Duplicated state transition message: %s. Existing: %s->%s; New (Discarded): %s->%s\",\n-                message.getMsgId(), duplicatedMessage.getFromState(),\n-                duplicatedMessage.getToState(), message.getFromState(), message.getToState());\n-            handleUnprocessableMessage(message, null /* exception */, errMsg, accessor,\n-                instanceName, manager);\n+          if (validateStateTransitionMessage(message, instanceName, manager,\n+              stateTransitionHandlers, msgHandler)) {\n+            // Need future process by triggering state transition\n+            String msgTarget =\n+                getMessageTarget(message.getResourceName(), message.getPartitionName());\n+            stateTransitionHandlers.put(msgTarget, msgHandler);\n+            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n+          } else {\n+            // skip the following operations for the invalid/expired state transition messages.\n             continue;\n           }\n-\n-          stateTransitionHandlers\n-              .put(getMessageTarget(message.getResourceName(), message.getPartitionName()),\n-                  createHandler);\n-          stateTransitionContexts\n-              .put(getMessageTarget(message.getResourceName(), message.getPartitionName()),\n-                  msgWorkingContext);\n         } else {\n-          nonStateTransitionHandlers.add(createHandler);\n+          // Need future process non state transition messages by triggering the handler\n+          nonStateTransitionHandlers.add(msgHandler);\n           nonStateTransitionContexts.add(msgWorkingContext);\n         }\n       } catch (Exception e) {\n         handleUnprocessableMessage(message, e, e.getMessage(), accessor, instanceName, manager);\n         continue;\n       }\n \n-      markReadMessage(message, msgWorkingContext, manager);\n-      readMsgs.add(message);\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 465}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ea105430205475ea9b97f4182564f6719aa5045", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/6ea105430205475ea9b97f4182564f6719aa5045", "committedDate": "2020-10-29T00:36:33Z", "message": "Refine the HelixTaskExecutor to reduce duplicate code and clarify the code structure.\n\nThere is minor code logic change for optimization. But there is no business logic change in this PR."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/78fb311b83fcc0e6365fc9212711795d62cc3e2c", "committedDate": "2020-10-29T00:36:33Z", "message": "Address comment."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "79941c973145d9b70f18faa12a48034e18fa8ed6", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/79941c973145d9b70f18faa12a48034e18fa8ed6", "committedDate": "2020-10-28T23:01:07Z", "message": "Address comment."}, "afterCommit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/78fb311b83fcc0e6365fc9212711795d62cc3e2c", "committedDate": "2020-10-29T00:36:33Z", "message": "Address comment."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MjY1NzY4", "url": "https://github.com/apache/helix/pull/1489#pullrequestreview-519265768", "createdAt": "2020-10-29T01:17:59Z", "commit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMToxNzo1OVrOHqDKVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMToxNzo1OVrOHqDKVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg1NDAzOA==", "bodyText": "nit, put this line also into try{} block.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513854038", "createdAt": "2020-10-29T01:17:59Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n+      NotificationContext changeContext, HelixManager manager, String sessionId,\n+      Map<String, MessageHandler> stateTransitionHandlers) {\n+    HelixDataAccessor accessor = manager.getHelixDataAccessor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c"}, "originalPosition": 535}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MjY2ODMw", "url": "https://github.com/apache/helix/pull/1489#pullrequestreview-519266830", "createdAt": "2020-10-29T01:21:42Z", "commit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4379, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}