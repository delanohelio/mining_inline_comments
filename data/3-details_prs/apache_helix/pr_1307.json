{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNjczNTMz", "number": 1307, "title": "Add TrieClusterTopology for retrieving hierarchical topology", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixed #1306\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis PR implements a cluster topology using a trie. The trie is constructed in a way that each non end node represents a domain, and each end node represents an instance. This data structure could help retrieve the topology under any given domain efficiently.\nTests\n\n The following tests are written for this issue:\n\nTestTrieClusterTopology.java\n\n The following is the result of the \"mvn test\" command on the appropriate module:\nhelix-core:\n[WARNING] Tests run: 1206, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 3,971.319 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[WARNING] Tests run: 1206, Failures: 0, Errors: 0, Skipped: 1\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:06 h\n[INFO] Finished at: 2020-09-23T23:08:37-07:00\n[INFO] ------------------------------------------------------------------------\n\nhelix-rest:\nknown issue: #1336\n[ERROR] Failures:\n[ERROR]   TestClusterAccessor.testUpdateConfigFields:167 \u00bb IndexOutOfBounds Index: 0, Si...\n[INFO]\n[ERROR] Tests run: 168, Failures: 1, Errors: 0, Skipped: 25\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  31.376 s\n[INFO] Finished at: 2020-09-23T23:49:39-07:00\n(Before CI test pass, please copy & paste the result of \"mvn test\")\nDocumentation (Optional)\n\nIn case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCommits\n\nMy commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\nMy diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-08-24T17:52:05Z", "url": "https://github.com/apache/helix/pull/1307", "merged": true, "mergeCommit": {"oid": "d9a487731746394ae8aa53b0d1ee7e8bf79fd85b"}, "closed": true, "closedAt": "2020-09-24T18:38:52Z", "author": {"login": "zhangmeng916"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCKxbBgFqTQ3Mzk3MzAzNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMFkrjgBqjM4MDQ1NjE2NjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTczMDM3", "url": "https://github.com/apache/helix/pull/1307#pullrequestreview-473973037", "createdAt": "2020-08-24T22:58:07Z", "commit": {"oid": "3d93799208a5117168735d53f5c94f62ccd6e810"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NzU3NDU3", "url": "https://github.com/apache/helix/pull/1307#pullrequestreview-474757457", "createdAt": "2020-08-25T18:45:54Z", "commit": {"oid": "3d93799208a5117168735d53f5c94f62ccd6e810"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo0NTo1NVrOHGlMQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo0NTo1NVrOHGlMQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2Mjg1MQ==", "bodyText": "Thanks for the detailed reply.\nI think the previous 3 points can be achieved by adding a flag to Topology::ClusterTopologyConfig and maybe using non static 'DEFAULT_DOMAIN_PREFIX'. Just like how we accommodate the 'faultZone' compute in this class.\nFor the point 4,\nMaybe we could read the tree and bypass default node (or throw exception when we find a default node in the path)\nIn my own opinion, I think the final question would be, do we construct topology tree in class Topology for these instances? If yes, its better to read from the same tree. If not, I think it's ok to have another orthogonal data structure representing the hierarchy.", "url": "https://github.com/apache/helix/pull/1307#discussion_r476662851", "createdAt": "2020-08-25T18:45:55Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \"_\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/instance will return [\"group\", \"zone\", \"rack\", \"instance\"].\n+    _topologyKeys = Arrays.asList(clusterConfig.getTopology().trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    _rootNode = new TrieNode(new HashMap<>(), DELIMITER);\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a set of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/instance, the result may be {\n+   * [\"group_0\": {\"zone_0/rack_0/instance_0\", \"zone_1/rack_1/instance_1\"}], [\"group_1\": {\"zone_1\n+   * /rack_1/instance_1\", \"zone_1/rack_1/instance_2\"}]}\n+   */\n+  public Map<String, Set<String>> getClusterTopology() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a set of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"rack_0\": {\"instance_0\", \"instance_1\"},\n+   * [\"rack_1\": {\"instance_2\", \"instance_3\"}]}\n+   */\n+  public Map<String, Set<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, Set<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      String key = child.getKey();\n+      results.put(key,\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath() + DELIMITER));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(_topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", _topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(_topologyKeys[i], domain.get(_topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private Set<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    Set<String> results = new HashSet<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _rootNode;\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    Set<String> toRemoveConfig = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+      if (domainAsMap.isEmpty()) {\n+        logger.info(String.format(\"Domain for instance %s is not set\", instanceName));\n+        toRemoveConfig.add(instanceName);\n+      } else {\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\",\n+                domainAsMap.get(key), instanceName));\n+            toRemoveConfig.add(instanceName);\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    toRemoveConfig.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private void constructTrie(Map<String, InstanceConfig> instanceConfigMap) {\n+    removeInvalidInstanceConfig(instanceConfigMap);\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = _rootNode;\n+      String path = \"\";\n+      for (int i = 0; i < _topologyKeys.length; i++) {\n+        String key = _topologyKeys[i] + CONNECTOR + entry.getValue().get(_topologyKeys[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d93799208a5117168735d53f5c94f62ccd6e810"}, "originalPosition": 208}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d93799208a5117168735d53f5c94f62ccd6e810", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/3d93799208a5117168735d53f5c94f62ccd6e810", "committedDate": "2020-08-24T17:48:13Z", "message": "add TrieClusterTopology"}, "afterCommit": {"oid": "0c9b7b12e03cad3aad66cb98c1cbdbcf0e82c8fd", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/0c9b7b12e03cad3aad66cb98c1cbdbcf0e82c8fd", "committedDate": "2020-08-28T00:13:55Z", "message": "add TrieClusterTopology"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0c9b7b12e03cad3aad66cb98c1cbdbcf0e82c8fd", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/0c9b7b12e03cad3aad66cb98c1cbdbcf0e82c8fd", "committedDate": "2020-08-28T00:13:55Z", "message": "add TrieClusterTopology"}, "afterCommit": {"oid": "7f7b3a14f9b7af0184f8f5298e10d051734fedaf", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/7f7b3a14f9b7af0184f8f5298e10d051734fedaf", "committedDate": "2020-08-31T23:59:08Z", "message": "Merge branch 'topology'"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7f7b3a14f9b7af0184f8f5298e10d051734fedaf", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/7f7b3a14f9b7af0184f8f5298e10d051734fedaf", "committedDate": "2020-08-31T23:59:08Z", "message": "Merge branch 'topology'"}, "afterCommit": {"oid": "8e4822c59e373c9ce170880022df38b32fd07a47", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/8e4822c59e373c9ce170880022df38b32fd07a47", "committedDate": "2020-09-01T00:01:45Z", "message": "Add more APIs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e4822c59e373c9ce170880022df38b32fd07a47", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/8e4822c59e373c9ce170880022df38b32fd07a47", "committedDate": "2020-09-01T00:01:45Z", "message": "Add more APIs"}, "afterCommit": {"oid": "7e73114f7c91ae0cc63e29de4739b80648933b2b", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/7e73114f7c91ae0cc63e29de4739b80648933b2b", "committedDate": "2020-09-01T00:04:37Z", "message": "add more APIs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e73114f7c91ae0cc63e29de4739b80648933b2b", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/7e73114f7c91ae0cc63e29de4739b80648933b2b", "committedDate": "2020-09-01T00:04:37Z", "message": "add more APIs"}, "afterCommit": {"oid": "d6c019306e0c040e9e3d844d87053fb8841b1eeb", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/d6c019306e0c040e9e3d844d87053fb8841b1eeb", "committedDate": "2020-09-02T17:29:16Z", "message": "add more APIs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6c019306e0c040e9e3d844d87053fb8841b1eeb", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/d6c019306e0c040e9e3d844d87053fb8841b1eeb", "committedDate": "2020-09-02T17:29:16Z", "message": "add more APIs"}, "afterCommit": {"oid": "ed21c95682a73da4afa115403d56bd44ce5c9145", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/ed21c95682a73da4afa115403d56bd44ce5c9145", "committedDate": "2020-09-08T16:41:02Z", "message": "add Helix admin API"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NzI3MTEx", "url": "https://github.com/apache/helix/pull/1307#pullrequestreview-474727111", "createdAt": "2020-08-25T18:02:14Z", "commit": {"oid": "3d93799208a5117168735d53f5c94f62ccd6e810"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODowMjoxNFrOHGju6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODowNjowNVrOHGj3Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzODk1Mw==", "bodyText": "Shall we make some marks of leaf nodes? Then leaf nodes contains a list of instance names or something. Otherwise, it may not be very efficient for most of cases.", "url": "https://github.com/apache/helix/pull/1307#discussion_r476638953", "createdAt": "2020-08-25T18:02:14Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \"_\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/instance will return [\"group\", \"zone\", \"rack\", \"instance\"].\n+    _topologyKeys = Arrays.asList(clusterConfig.getTopology().trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    _rootNode = new TrieNode(new HashMap<>(), DELIMITER);\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a set of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/instance, the result may be {\n+   * [\"group_0\": {\"zone_0/rack_0/instance_0\", \"zone_1/rack_1/instance_1\"}], [\"group_1\": {\"zone_1\n+   * /rack_1/instance_1\", \"zone_1/rack_1/instance_2\"}]}\n+   */\n+  public Map<String, Set<String>> getClusterTopology() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a set of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"rack_0\": {\"instance_0\", \"instance_1\"},\n+   * [\"rack_1\": {\"instance_2\", \"instance_3\"}]}\n+   */\n+  public Map<String, Set<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, Set<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      String key = child.getKey();\n+      results.put(key,\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath() + DELIMITER));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(_topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", _topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(_topologyKeys[i], domain.get(_topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private Set<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    Set<String> results = new HashSet<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _rootNode;\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    Set<String> toRemoveConfig = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+      if (domainAsMap.isEmpty()) {\n+        logger.info(String.format(\"Domain for instance %s is not set\", instanceName));\n+        toRemoveConfig.add(instanceName);\n+      } else {\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\",\n+                domainAsMap.get(key), instanceName));\n+            toRemoveConfig.add(instanceName);\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    toRemoveConfig.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private void constructTrie(Map<String, InstanceConfig> instanceConfigMap) {\n+    removeInvalidInstanceConfig(instanceConfigMap);\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = _rootNode;\n+      String path = \"\";\n+      for (int i = 0; i < _topologyKeys.length; i++) {\n+        String key = _topologyKeys[i] + CONNECTOR + entry.getValue().get(_topologyKeys[i]);\n+        path = path + DELIMITER + key;\n+        TrieNode nextNode = curNode.getChildren().get(key);\n+        if (nextNode == null) {\n+          nextNode = new TrieNode(new HashMap<>(), path);\n+        }\n+        curNode.addChild(key, nextNode);\n+        curNode = nextNode;\n+      }\n+    }\n+  }\n+\n+  private static class TrieNode {\n+    // A mapping between trie key and children nodes.\n+    private Map<String, TrieNode> _children;\n+\n+    // the complete path/prefix leading to the current node.\n+    private final String _path;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d93799208a5117168735d53f5c94f62ccd6e810"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzOTYzMQ==", "bodyText": "If cluster config does not have topology, we should throw exception or give an empty return.", "url": "https://github.com/apache/helix/pull/1307#discussion_r476639631", "createdAt": "2020-08-25T18:03:30Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \"_\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/instance will return [\"group\", \"zone\", \"rack\", \"instance\"].\n+    _topologyKeys = Arrays.asList(clusterConfig.getTopology().trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d93799208a5117168735d53f5c94f62ccd6e810"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0MTA4Mg==", "bodyText": "Is this only for testing? The input is an empty map..", "url": "https://github.com/apache/helix/pull/1307#discussion_r476641082", "createdAt": "2020-08-25T18:06:05Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \"_\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/instance will return [\"group\", \"zone\", \"rack\", \"instance\"].\n+    _topologyKeys = Arrays.asList(clusterConfig.getTopology().trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    _rootNode = new TrieNode(new HashMap<>(), DELIMITER);\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a set of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/instance, the result may be {\n+   * [\"group_0\": {\"zone_0/rack_0/instance_0\", \"zone_1/rack_1/instance_1\"}], [\"group_1\": {\"zone_1\n+   * /rack_1/instance_1\", \"zone_1/rack_1/instance_2\"}]}\n+   */\n+  public Map<String, Set<String>> getClusterTopology() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d93799208a5117168735d53f5c94f62ccd6e810"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NDk2Nzgx", "url": "https://github.com/apache/helix/pull/1307#pullrequestreview-485496781", "createdAt": "2020-09-10T00:59:38Z", "commit": {"oid": "4381a247f4967b2a2534bcca6e0cebf87803ca68"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMDo1OTozOFrOHPfLpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNTo1MDoyN1rOHPkBlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwMTU3NA==", "bodyText": "I think adding 5 new methods to HelixAdmin is overkill. Can we just add a method that returns the ClusterTopology and then relies on the ClusterTopology class methods to return information?", "url": "https://github.com/apache/helix/pull/1307#discussion_r486001574", "createdAt": "2020-09-10T00:59:38Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixAdmin.java", "diffHunk": "@@ -420,6 +420,41 @@ void addStateModelDef(String clusterName, String stateModelDef, StateModelDefini\n    */\n   void removeCloudConfig(String clusterName);\n \n+  /**\n+   * Get the topology of a specific cluster\n+   * @param clusterName\n+   */\n+  Map<String, List<String>> getClusterTopology(String clusterName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4381a247f4967b2a2534bcca6e0cebf87803ca68"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NDg2NQ==", "bodyText": "How are the callers supposed to know which instance has been removed because the configuration is invalid?\nIn addition, the removal is directly modifying the input map. So it could dangerous since it may change the caller's map implicitly.", "url": "https://github.com/apache/helix/pull/1307#discussion_r486064865", "createdAt": "2020-09-10T05:02:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = new TrieNode(new HashMap<>(), \"\", \"ROOT\");\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getClusterTopology() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    if (domainType.equals(_topologyKeys[0])) {\n+      return getClusterTopology();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < _topologyKeys.length; i++) {\n+      if (_topologyKeys[i].equals(domainType)) {\n+        parentDomainType = _topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the end nodes under fault zone type. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getInstancesUnderFaultZone() {\n+    return getTopologyUnderDomainType(_faultZoneType);\n+  }\n+\n+  private Map<String, String> convertPathToDomain(String path) {\n+    Map<String, String> results = new HashMap<>();\n+    for (String part : path.substring(1).split(DELIMITER)) {\n+      results.put(part.substring(0, part.indexOf(CONNECTOR)),\n+          part.substring(part.indexOf(CONNECTOR) + 1));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(_topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", _topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(_topologyKeys[i], domain.get(_topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _rootNode;\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domain) {\n+    List<TrieNode> results = new ArrayList<>();\n+    TrieNode curNode = _rootNode;\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode.getDomainType().equals(domain)) {\n+        results.add(curNode);\n+      } else {\n+        for (TrieNode child : curNode.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return results;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    Set<String> toRemoveConfig = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+      if (domainAsMap.isEmpty()) {\n+        logger.info(String.format(\"Domain for instance %s is not set\", instanceName));\n+        toRemoveConfig.add(instanceName);\n+      } else {\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            toRemoveConfig.add(instanceName);\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    toRemoveConfig.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private void constructTrie(Map<String, InstanceConfig> instanceConfigMap) {\n+    removeInvalidInstanceConfig(instanceConfigMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4381a247f4967b2a2534bcca6e0cebf87803ca68"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NjgwNg==", "bodyText": "nit, this check is not necessary. The else condition will ensure an instance with an empty list to be removed.", "url": "https://github.com/apache/helix/pull/1307#discussion_r486066806", "createdAt": "2020-09-10T05:07:07Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = new TrieNode(new HashMap<>(), \"\", \"ROOT\");\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getClusterTopology() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    if (domainType.equals(_topologyKeys[0])) {\n+      return getClusterTopology();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < _topologyKeys.length; i++) {\n+      if (_topologyKeys[i].equals(domainType)) {\n+        parentDomainType = _topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the end nodes under fault zone type. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getInstancesUnderFaultZone() {\n+    return getTopologyUnderDomainType(_faultZoneType);\n+  }\n+\n+  private Map<String, String> convertPathToDomain(String path) {\n+    Map<String, String> results = new HashMap<>();\n+    for (String part : path.substring(1).split(DELIMITER)) {\n+      results.put(part.substring(0, part.indexOf(CONNECTOR)),\n+          part.substring(part.indexOf(CONNECTOR) + 1));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(_topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", _topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(_topologyKeys[i], domain.get(_topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _rootNode;\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domain) {\n+    List<TrieNode> results = new ArrayList<>();\n+    TrieNode curNode = _rootNode;\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode.getDomainType().equals(domain)) {\n+        results.add(curNode);\n+      } else {\n+        for (TrieNode child : curNode.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return results;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    Set<String> toRemoveConfig = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+      if (domainAsMap.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4381a247f4967b2a2534bcca6e0cebf87803ca68"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3OTg2Nw==", "bodyText": "What if topology awareness is disabled on this cluster? Shall we still throw Exception?", "url": "https://github.com/apache/helix/pull/1307#discussion_r486079867", "createdAt": "2020-09-10T05:47:26Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4381a247f4967b2a2534bcca6e0cebf87803ca68"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4MDQ4OA==", "bodyText": "I think we are not requiring such strict formatting elsewhere. For example, spaces are ignored.\nSo maybe you should also trim here so as to ensure the logic is consistent.", "url": "https://github.com/apache/helix/pull/1307#discussion_r486080488", "createdAt": "2020-09-10T05:49:16Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4381a247f4967b2a2534bcca6e0cebf87803ca68"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4MDkxNg==", "bodyText": "Can we let constructTrie() return a root which is constructed by the private method internally?\nThis helps to simplify the code a little bit.", "url": "https://github.com/apache/helix/pull/1307#discussion_r486080916", "createdAt": "2020-09-10T05:50:27Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = new TrieNode(new HashMap<>(), \"\", \"ROOT\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4381a247f4967b2a2534bcca6e0cebf87803ca68"}, "originalPosition": 74}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "db128fa9c4db1ddb4afa135c951b353acb50e00a", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/db128fa9c4db1ddb4afa135c951b353acb50e00a", "committedDate": "2020-09-15T00:35:35Z", "message": "refactor"}, "afterCommit": {"oid": "bcd932ecc85cddffbaf63c6aeb287f6350413cad", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/bcd932ecc85cddffbaf63c6aeb287f6350413cad", "committedDate": "2020-09-15T00:41:49Z", "message": "refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MzM2ODQ2", "url": "https://github.com/apache/helix/pull/1307#pullrequestreview-488336846", "createdAt": "2020-09-15T05:33:34Z", "commit": {"oid": "bcd932ecc85cddffbaf63c6aeb287f6350413cad"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozMzozNFrOHRxUVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozNTo0NlrOHRxXUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTg2Mg==", "bodyText": "Didn't we agree to add one method that returns ClusterTopology object here?", "url": "https://github.com/apache/helix/pull/1307#discussion_r488395862", "createdAt": "2020-09-15T05:33:34Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixAdmin.java", "diffHunk": "@@ -420,6 +420,24 @@ void addStateModelDef(String clusterName, String stateModelDef, StateModelDefini\n    */\n   void removeCloudConfig(String clusterName);\n \n+  /**\n+   * Get the topology of a specific cluster\n+   * @param clusterName\n+   */\n+  Map<String, List<String>> getAllTopology(String clusterName);\n+\n+  /**\n+   * Get all the instances under the fault zone\n+   * @param clusterName\n+   */\n+  Map<String, List<String>> getInstancesUnderFaultZone(String clusterName);\n+\n+  /**\n+   * Get all the instances whose domain config is not valid\n+   * @param clusterName\n+   */\n+  List<String> getInvalidInstances(String clusterName);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcd932ecc85cddffbaf63c6aeb287f6350413cad"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NjYyNg==", "bodyText": "Can we just refer to the DELIMITER and CONNECTOR in ClusterTrie?", "url": "https://github.com/apache/helix/pull/1307#discussion_r488396626", "createdAt": "2020-09-15T05:35:46Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+  private static final String DELIMITER = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcd932ecc85cddffbaf63c6aeb287f6350413cad"}, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "56d564fae40250c39c492a01f148679504d8907f", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/56d564fae40250c39c492a01f148679504d8907f", "committedDate": "2020-09-17T05:02:25Z", "message": "return cluster topology as an object in Helix Amdin"}, "afterCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/33a8259a569be75ba983bbae4c3c692fd284073a", "committedDate": "2020-09-17T20:22:43Z", "message": "return cluster topology as an object in Helix Amdin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMDg1NjQ3", "url": "https://github.com/apache/helix/pull/1307#pullrequestreview-491085647", "createdAt": "2020-09-18T01:10:48Z", "commit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwMToxMDo0OFrOHT6ixg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwNTozNDoxOVrOHT-sBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NDE2Ng==", "bodyText": "nit, final for the ClusterConfig too?", "url": "https://github.com/apache/helix/pull/1307#discussion_r490644166", "createdAt": "2020-09-18T01:10:48Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NDc0Ng==", "bodyText": "nit, Collections.EMPTY_MAP?", "url": "https://github.com/apache/helix/pull/1307#discussion_r490644746", "createdAt": "2020-09-18T01:13:06Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NjA4NQ==", "bodyText": "I feel these methods can be put into the ClusterTrie class, given we can generalize the domain concept to the trie node keys. But we can also refactor later when we are migrating our existing Topology.java to use the same class.", "url": "https://github.com/apache/helix/pull/1307#discussion_r490646085", "createdAt": "2020-09-18T01:18:33Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domain.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domain) {\n+    List<TrieNode> results = new ArrayList<>();\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode.getDomainType().equals(domain)) {\n+        results.add(curNode);\n+      } else {\n+        for (TrieNode child : curNode.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return results;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0Njk0Nw==", "bodyText": "Why we need 2 ZkBaseDataAccessors here?", "url": "https://github.com/apache/helix/pull/1307#discussion_r490646947", "createdAt": "2020-09-18T01:21:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1156,6 +1157,30 @@ public void removeCloudConfig(String clusterName) {\n     accessor.removeProperty(keyBuilder.cloudConfig());\n   }\n \n+  @Override\n+  public ClusterTopology getClusterTopology(String clusterName) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    String path = PropertyPathBuilder.instanceConfig(clusterName);\n+    BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_zkClient);\n+    List<ZNRecord> znRecords = baseAccessor.getChildren(path, null, 0, 0, 0);\n+    for (ZNRecord record : znRecords) {\n+      if (record != null) {\n+        InstanceConfig instanceConfig = new InstanceConfig(record);\n+        instanceConfigMap.put(instanceConfig.getInstanceName(), instanceConfig);\n+      }\n+    }\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_zkClient));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NzI0Mg==", "bodyText": "nit, but it would be cleaner if we use ZkBaseDataAccessor for all information access, IMHO.", "url": "https://github.com/apache/helix/pull/1307#discussion_r490647242", "createdAt": "2020-09-18T01:22:57Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1156,6 +1157,30 @@ public void removeCloudConfig(String clusterName) {\n     accessor.removeProperty(keyBuilder.cloudConfig());\n   }\n \n+  @Override\n+  public ClusterTopology getClusterTopology(String clusterName) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    String path = PropertyPathBuilder.instanceConfig(clusterName);\n+    BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_zkClient);\n+    List<ZNRecord> znRecords = baseAccessor.getChildren(path, null, 0, 0, 0);\n+    for (ZNRecord record : znRecords) {\n+      if (record != null) {\n+        InstanceConfig instanceConfig = new InstanceConfig(record);\n+        instanceConfigMap.put(instanceConfig.getInstanceName(), instanceConfig);\n+      }\n+    }\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_zkClient));\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    List<LiveInstance> liveInstances = accessor.getChildValues(keyBuilder.liveInstances(), true);\n+    List<String> liveNodes = new ArrayList<>();\n+    liveInstances.forEach(liveInstance -> liveNodes.add(liveInstance.getInstanceName()));\n+\n+    ConfigAccessor configAccessor = new ConfigAccessor(_zkClient);\n+    ClusterConfig clusterConfig = configAccessor.getClusterConfig(clusterName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0Nzc5NA==", "bodyText": "For generic, change to _key (node key)?", "url": "https://github.com/apache/helix/pull/1307#discussion_r490647794", "createdAt": "2020-09-18T01:24:57Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieNode.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+\n+public class TrieNode {\n+  // A mapping between trie key and children nodes.\n+  private Map<String, TrieNode> _children;\n+\n+  // the complete path/prefix leading to the current node.\n+  private final String _path;\n+\n+  private final String _domainType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0ODUyOA==", "bodyText": "nit, I'm not sure if it is feasible given all the usages, but we can always create new children map inside the constructor instead of allowing input.", "url": "https://github.com/apache/helix/pull/1307#discussion_r490648528", "createdAt": "2020-09-18T01:27:27Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieNode.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+\n+public class TrieNode {\n+  // A mapping between trie key and children nodes.\n+  private Map<String, TrieNode> _children;\n+\n+  // the complete path/prefix leading to the current node.\n+  private final String _path;\n+\n+  private final String _domainType;\n+\n+  TrieNode(Map<String, TrieNode> children, String path, String domainType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY5OTcwOQ==", "bodyText": "Seems the paths contain all the information starts from the root. Will it be too much duplicate information?\nConsidering this object might be created frequently depends on the caller code, it could be better to just save the info about the current layer.", "url": "https://github.com/apache/helix/pull/1307#discussion_r490699709", "createdAt": "2020-09-18T04:47:41Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            _invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        _invalidInstances.add(instanceName);\n+      }\n+    }\n+    _invalidInstances.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private void validateClusterConfig(ClusterConfig clusterConfig) {\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private TrieNode constructTrie(Map<String, InstanceConfig> instanceConfigMap) {\n+    TrieNode rootNode = new TrieNode(new HashMap<>(), \"\", \"ROOT\");\n+    removeInvalidInstanceConfig(instanceConfigMap);\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = rootNode;\n+      String path = \"\";\n+      for (int i = 0; i < _topologyKeys.length; i++) {\n+        String key = _topologyKeys[i] + CONNECTOR + entry.getValue().get(_topologyKeys[i]);\n+        path = path + DELIMITER + key;\n+        TrieNode nextNode = curNode.getChildren().get(key);\n+        if (nextNode == null) {\n+          nextNode = new TrieNode(new HashMap<>(), path, _topologyKeys[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMjc0Mg==", "bodyText": "nit, domain -> domainType", "url": "https://github.com/apache/helix/pull/1307#discussion_r490702742", "createdAt": "2020-09-18T04:59:36Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domain.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domain) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMjgwNA==", "bodyText": "nit, domain -> domainMap", "url": "https://github.com/apache/helix/pull/1307#discussion_r490702804", "createdAt": "2020-09-18T04:59:49Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domain.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwNDIwMQ==", "bodyText": "Regardless of what I mentioned above, I think you can merge getPathUnderNode() and getStartNodes() to avoid duplicate logic. Some minor change is required, of course. But I think its a better option.\nHigh-level, you need a method that searches for multiple nodes under a certain scope. And another method that gets a certain node (getStartNode).", "url": "https://github.com/apache/helix/pull/1307#discussion_r490704201", "createdAt": "2020-09-18T05:04:57Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domain.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwNTIzMw==", "bodyText": "And, just curious, where does the \"start\" come from? The leaf node is a special case. But here the logic is generic, so it is just getNode(), right?", "url": "https://github.com/apache/helix/pull/1307#discussion_r490705233", "createdAt": "2020-09-18T05:09:11Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domain.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMjgwNA=="}, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwODA4MA==", "bodyText": "We may not need these 2 functions for supporting the public methods.\nI think what we want is a query method that accepts a Map of domain type and value pairs. However, the trick is that the value could be a wildcard \"*\" or just put null. Then we just need to maintain one set of logic. And for sure, no duplicate logic.", "url": "https://github.com/apache/helix/pull/1307#discussion_r490708080", "createdAt": "2020-09-18T05:19:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwODc0Ng==", "bodyText": "Better to put _topologyKeys to the parameter. This is a better style since the private methods will not depend on each other.", "url": "https://github.com/apache/helix/pull/1307#discussion_r490708746", "createdAt": "2020-09-18T05:22:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwOTMzOQ==", "bodyText": "nit, just return the _topologyKeys as the return value. So we don't modify the object field secretly inside a \"validate\" method. Moreover, maybe call it getTopologyDef() would be more straightforward.", "url": "https://github.com/apache/helix/pull/1307#discussion_r490709339", "createdAt": "2020-09-18T05:24:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            _invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        _invalidInstances.add(instanceName);\n+      }\n+    }\n+    _invalidInstances.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private void validateClusterConfig(ClusterConfig clusterConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwOTQ5Mw==", "bodyText": "Same here, better to put the _topologyKeys into the parameter list.", "url": "https://github.com/apache/helix/pull/1307#discussion_r490709493", "createdAt": "2020-09-18T05:25:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            _invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        _invalidInstances.add(instanceName);\n+      }\n+    }\n+    _invalidInstances.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private void validateClusterConfig(ClusterConfig clusterConfig) {\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private TrieNode constructTrie(Map<String, InstanceConfig> instanceConfigMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcxMDA4NA==", "bodyText": "instanceConfigMap.keyset().removeAll(_invalidInstances)", "url": "https://github.com/apache/helix/pull/1307#discussion_r490710084", "createdAt": "2020-09-18T05:27:25Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            _invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        _invalidInstances.add(instanceName);\n+      }\n+    }\n+    _invalidInstances.forEach(entry -> instanceConfigMap.remove(entry));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcxMTEzNw==", "bodyText": "In general, private methods are better to be \"independent\" with the object. So that maintenance of the class would be much easier.\nSuggest to change to\nprivate List getInvalidIstanceConfig(Map<String, InstanceConfig> instanceConfigMap);\nThen we can do instanceConfigMap.keyset().removeAll(_invalidInstances) in the caller where the object fields are updated in a centralized place.", "url": "https://github.com/apache/helix/pull/1307#discussion_r490711137", "createdAt": "2020-09-18T05:31:07Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwODc0Ng=="}, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcxMjA3MA==", "bodyText": "So to summary the following comments, my suggestion would be,\nvalidateInstanceConfig(liveNodes, instanceConfigMap);\n_topologyKeys = getTopologyKeys(clusterConfig);\n_faultZoneType = clusterConfig.getFaultZoneType();\n_invalidInstances = getInvalidInstances(instanceConfigMap);\ninstanceConfigMap.keyset().removeAll(_invalidInstances);\n_rootNode = constructTrie(instanceConfigMap, _topologyKeys);\nWould this be cleaner and easier to maintain for the long term?", "url": "https://github.com/apache/helix/pull/1307#discussion_r490712070", "createdAt": "2020-09-18T05:34:19Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODY1NjI5", "url": "https://github.com/apache/helix/pull/1307#pullrequestreview-493865629", "createdAt": "2020-09-22T21:38:23Z", "commit": {"oid": "8109e14891f68cfde011ec4bfabd9e8b5e192014"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTozODoyM1rOHWNTZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTozODoyM1rOHWNTZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0ODY3OQ==", "bodyText": "The same example that I gave Xiaoyuan for the Topology.java change,\n\"/group/ zone/ rack /host\", do we accept this one? With your current logic, I think it will return \"[\"group\", \" zone\", \" rack \", \"host\"]\". Please mind the space in the keys. It will cause a mismatch in the later algorithm.", "url": "https://github.com/apache/helix/pull/1307#discussion_r493048679", "createdAt": "2020-09-22T21:38:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,155 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    topologyDef = Arrays.asList(topologyDefInConfig.trim().split(DELIMITER)).stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8109e14891f68cfde011ec4bfabd9e8b5e192014"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzOTQyMjYw", "url": "https://github.com/apache/helix/pull/1307#pullrequestreview-493942260", "createdAt": "2020-09-23T01:03:36Z", "commit": {"oid": "cdc9581cbab07741966b99f5727149743d97b318"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMTowMzozNlrOHWRYmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMToxMzo0NFrOHWRihg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNTU0Ng==", "bodyText": "I guess this is not necessary?", "url": "https://github.com/apache/helix/pull/1307#discussion_r493115546", "createdAt": "2020-09-23T01:03:36Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/TrieNode.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+public class TrieNode {\n+  // A mapping between trie key and children nodes.\n+  private Map<String, TrieNode> _children;\n+\n+  // the complete path/prefix leading to the current node.\n+  private final String _path;\n+\n+  private final String _nodeKey;\n+\n+  TrieNode(String path, String nodeKey) {\n+    _path = path;\n+    _nodeKey = nodeKey;\n+    _children = new HashMap<>();\n+  }\n+\n+  public Map<String, TrieNode> getChildren() {\n+    return _children;\n+  }\n+\n+  public String getPath() {\n+    return _path;\n+  }\n+\n+  public String getNodeKey() {\n+    return _nodeKey;\n+  }\n+\n+  public void addChildrenMap(Map <String, TrieNode> children) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc9581cbab07741966b99f5727149743d97b318"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNjk3Ng==", "bodyText": "Better to add one more check that, if the topologyDefInConfig does not start with DELIMITER, then it is invalid.", "url": "https://github.com/apache/helix/pull/1307#discussion_r493116976", "createdAt": "2020-09-23T01:09:08Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc9581cbab07741966b99f5727149743d97b318"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNzA3NQ==", "bodyText": "nit, the first tirm becomes unnecessary with the later one in the map().", "url": "https://github.com/apache/helix/pull/1307#discussion_r493117075", "createdAt": "2020-09-23T01:09:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    topologyDef =\n+        Arrays.asList(topologyDefInConfig.trim().split(DELIMITER)).stream().map(str -> str.trim())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc9581cbab07741966b99f5727149743d97b318"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNzIxOQ==", "bodyText": "StringBuilder for the performance.", "url": "https://github.com/apache/helix/pull/1307#discussion_r493117219", "createdAt": "2020-09-23T01:10:07Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    topologyDef =\n+        Arrays.asList(topologyDefInConfig.trim().split(DELIMITER)).stream().map(str -> str.trim())\n+            .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (topologyDef.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    return topologyDef;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private TrieNode constructTrie(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    TrieNode rootNode = new TrieNode(\"\", \"ROOT\");\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = rootNode;\n+      String path = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc9581cbab07741966b99f5727149743d97b318"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExODA4Ng==", "bodyText": "I guess you just need the full path for the leaf node.", "url": "https://github.com/apache/helix/pull/1307#discussion_r493118086", "createdAt": "2020-09-23T01:13:44Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    topologyDef =\n+        Arrays.asList(topologyDefInConfig.trim().split(DELIMITER)).stream().map(str -> str.trim())\n+            .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (topologyDef.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    return topologyDef;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private TrieNode constructTrie(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    TrieNode rootNode = new TrieNode(\"\", \"ROOT\");\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = rootNode;\n+      String path = \"\";\n+      for (int i = 0; i < topologyKeys.length; i++) {\n+        String key = topologyKeys[i] + CONNECTOR + entry.getValue().get(topologyKeys[i]);\n+        path = path + DELIMITER + key;\n+        TrieNode nextNode = curNode.getChildren().get(key);\n+        if (nextNode == null) {\n+          nextNode = new TrieNode(path, topologyKeys[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc9581cbab07741966b99f5727149743d97b318"}, "originalPosition": 148}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e8f7305002d26bb1625cd71854bf58aef57aa2ad", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/e8f7305002d26bb1625cd71854bf58aef57aa2ad", "committedDate": "2020-09-23T18:48:00Z", "message": "fix comments on trim"}, "afterCommit": {"oid": "535026bb0c815f37bbb3ccbe3f3c37f33ce91e71", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/535026bb0c815f37bbb3ccbe3f3c37f33ce91e71", "committedDate": "2020-09-23T19:07:19Z", "message": "fix comments on trim"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "535026bb0c815f37bbb3ccbe3f3c37f33ce91e71", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/535026bb0c815f37bbb3ccbe3f3c37f33ce91e71", "committedDate": "2020-09-23T19:07:19Z", "message": "fix comments on trim"}, "afterCommit": {"oid": "7c8bcb2072c992ef46b4c962612423a160066794", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/7c8bcb2072c992ef46b4c962612423a160066794", "committedDate": "2020-09-23T19:11:39Z", "message": "fix comments on trim"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c8bcb2072c992ef46b4c962612423a160066794", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/7c8bcb2072c992ef46b4c962612423a160066794", "committedDate": "2020-09-23T19:11:39Z", "message": "fix comments on trim"}, "afterCommit": {"oid": "ce68505dee561049563af529635a7d1c09af1f61", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/ce68505dee561049563af529635a7d1c09af1f61", "committedDate": "2020-09-23T22:43:32Z", "message": "fix comments on trim"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MTUzODI1", "url": "https://github.com/apache/helix/pull/1307#pullrequestreview-495153825", "createdAt": "2020-09-24T01:06:09Z", "commit": {"oid": "ce68505dee561049563af529635a7d1c09af1f61"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTowNjowOVrOHXGOwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTowNjowOVrOHXGOwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MTM3Ng==", "bodyText": "Shall we move them to ClusterTrie? They are useful to read the tree for all reader classes, right?", "url": "https://github.com/apache/helix/pull/1307#discussion_r493981376", "createdAt": "2020-09-24T01:06:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, final ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(Collections.emptyMap());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domainMap A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domainMap) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domainMap);\n+    TrieNode startNode = getNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domainMap) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domainMap == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domainMap.size(); i++) {\n+      if (!domainMap.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domainMap.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getNode(LinkedHashMap<String, String> domainMap) {\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domainMap.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domainType) {\n+    List<TrieNode> results = new ArrayList<>();\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode.getNodeKey().equals(domainType)) {\n+        results.add(curNode);\n+      } else {\n+        for (TrieNode child : curNode.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return results;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce68505dee561049563af529635a7d1c09af1f61"}, "originalPosition": 239}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9928635e7566a4d903b43f6ea8b784d12120f82", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/e9928635e7566a4d903b43f6ea8b784d12120f82", "committedDate": "2020-09-24T18:31:44Z", "message": "add TrieClusterTopology"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d6fcfec749fe16780c6a8a82dc6318f549eed74", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/0d6fcfec749fe16780c6a8a82dc6318f549eed74", "committedDate": "2020-09-24T18:31:44Z", "message": "add more APIs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0d5b5942631387765937e7666158f12f2596f7c", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/b0d5b5942631387765937e7666158f12f2596f7c", "committedDate": "2020-09-24T18:32:50Z", "message": "add Helix admin API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8f6a43a7391b56f7f46b220fdd24f7620bbe79e", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/b8f6a43a7391b56f7f46b220fdd24f7620bbe79e", "committedDate": "2020-09-24T18:32:57Z", "message": "fix comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67690af4a6a15ba6d70551b088ac6a7267f9e7fa", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/67690af4a6a15ba6d70551b088ac6a7267f9e7fa", "committedDate": "2020-09-24T18:32:57Z", "message": "refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c37ec62bf1bfcdaedf0e5cf3c1fc37c376992f00", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/c37ec62bf1bfcdaedf0e5cf3c1fc37c376992f00", "committedDate": "2020-09-24T18:33:34Z", "message": "return cluster topology as an object in Helix Amdin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbccd628d227b44114cb26a2ef983c4c6c6abb0a", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/bbccd628d227b44114cb26a2ef983c4c6c6abb0a", "committedDate": "2020-09-24T18:33:37Z", "message": "fix partial comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c02810fc71bcc6db0526f3bb721fdac9c9fae13a", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/c02810fc71bcc6db0526f3bb721fdac9c9fae13a", "committedDate": "2020-09-24T18:33:37Z", "message": "fix function name and string space in topology def"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dbf3c6ee6b528005ceb2a5fb9c468d48fe73e25", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/4dbf3c6ee6b528005ceb2a5fb9c468d48fe73e25", "committedDate": "2020-09-24T18:33:37Z", "message": "fix comments on trim"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6c6aafeabc55f5cd710721249177d11e3c4283d", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/d6c6aafeabc55f5cd710721249177d11e3c4283d", "committedDate": "2020-09-24T18:33:37Z", "message": "move function"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e40978c9c6aaee080591e11c4dff63371b2b1c00", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/e40978c9c6aaee080591e11c4dff63371b2b1c00", "committedDate": "2020-09-24T04:08:21Z", "message": "move function"}, "afterCommit": {"oid": "d6c6aafeabc55f5cd710721249177d11e3c4283d", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/d6c6aafeabc55f5cd710721249177d11e3c4283d", "committedDate": "2020-09-24T18:33:37Z", "message": "move function"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4241, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}