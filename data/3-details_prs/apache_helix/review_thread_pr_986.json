{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMzI5MDgx", "number": 986, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMzoyMTo0MFrOD4gkpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMzoyMTo0MFrOD4gkpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTgwNTE2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMzoyMTo0MFrOGPYG3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMjoxMToyN1rOGRnQ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng==", "bodyText": "I think you already sorted the preference list based on the state. Why not just replace the looping of preference list with the sorted list but add this logic?\nThis logic makes two order of preference list intersected each other that logic is not very clear.", "url": "https://github.com/apache/helix/pull/986#discussion_r418776796", "createdAt": "2020-05-01T23:21:40Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -305,45 +305,60 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n     liveAndEnabled.removeAll(disabledInstancesForPartition);\n \n-    for (String state : statesPriorityList) {\n-      // Use the the specially ordered preferenceList for choosing instance for top state.\n-      if (state.equals(statesPriorityList.get(0))) {\n-        List<String> preferenceListForTopState = new ArrayList<>(preferenceList);\n-        Collections.sort(preferenceListForTopState,\n-            new TopStatePreferenceListComparator(currentStateMap, stateModelDef));\n-        preferenceList = preferenceListForTopState;\n-      }\n+    // Sort the instances based on replicas' state priority in the current state\n+    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n+    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n \n+    // Assign the state to the instances that appear in the preference list.\n+    for (String state : statesPriorityList) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n       for (String instance : preferenceList) {\n         if (stateCount <= 0) {\n-          break;\n+          break; // continue assigning for the next state\n+        }\n+        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+          continue; // continue checking for the next available instance\n         }\n-        if (!assigned.contains(instance) && liveAndEnabled.contains(instance)) {\n-          if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(instance))) {\n-            bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.toString());\n-          } else {\n-            bestPossibleStateMap.put(instance, state);\n-            stateCount--;\n+        String proposedInstance = instance;\n+        // Additional check and alternate the assignment for reducing top state handoff.\n+        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30816eece784e18df6fedc1412a27bf39d6cd9f2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MDY2OA==", "bodyText": "I thought about it. But even I move this logic to the sorting logic, the sorting itself will be comparing one list with 2 logics. This interesting trick is just moved to another place. I don't have a way to eliminate it for now.\nThen why I want to put it here instead of the sorting logic? Because the sorting logic is away from this business logic block. That would be even harder for me to reason even with comments.\nPut it here, I understand it is intersecting the same list, but I can at least give it a good reason.", "url": "https://github.com/apache/helix/pull/986#discussion_r418780668", "createdAt": "2020-05-01T23:41:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -305,45 +305,60 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n     liveAndEnabled.removeAll(disabledInstancesForPartition);\n \n-    for (String state : statesPriorityList) {\n-      // Use the the specially ordered preferenceList for choosing instance for top state.\n-      if (state.equals(statesPriorityList.get(0))) {\n-        List<String> preferenceListForTopState = new ArrayList<>(preferenceList);\n-        Collections.sort(preferenceListForTopState,\n-            new TopStatePreferenceListComparator(currentStateMap, stateModelDef));\n-        preferenceList = preferenceListForTopState;\n-      }\n+    // Sort the instances based on replicas' state priority in the current state\n+    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n+    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n \n+    // Assign the state to the instances that appear in the preference list.\n+    for (String state : statesPriorityList) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n       for (String instance : preferenceList) {\n         if (stateCount <= 0) {\n-          break;\n+          break; // continue assigning for the next state\n+        }\n+        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+          continue; // continue checking for the next available instance\n         }\n-        if (!assigned.contains(instance) && liveAndEnabled.contains(instance)) {\n-          if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(instance))) {\n-            bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.toString());\n-          } else {\n-            bestPossibleStateMap.put(instance, state);\n-            stateCount--;\n+        String proposedInstance = instance;\n+        // Additional check and alternate the assignment for reducing top state handoff.\n+        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}, "originalCommit": {"oid": "30816eece784e18df6fedc1412a27bf39d6cd9f2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MTAwMQ==", "bodyText": "Please consider this as a skiplist type design/implementation.", "url": "https://github.com/apache/helix/pull/986#discussion_r418781001", "createdAt": "2020-05-01T23:43:36Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -305,45 +305,60 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n     liveAndEnabled.removeAll(disabledInstancesForPartition);\n \n-    for (String state : statesPriorityList) {\n-      // Use the the specially ordered preferenceList for choosing instance for top state.\n-      if (state.equals(statesPriorityList.get(0))) {\n-        List<String> preferenceListForTopState = new ArrayList<>(preferenceList);\n-        Collections.sort(preferenceListForTopState,\n-            new TopStatePreferenceListComparator(currentStateMap, stateModelDef));\n-        preferenceList = preferenceListForTopState;\n-      }\n+    // Sort the instances based on replicas' state priority in the current state\n+    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n+    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n \n+    // Assign the state to the instances that appear in the preference list.\n+    for (String state : statesPriorityList) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n       for (String instance : preferenceList) {\n         if (stateCount <= 0) {\n-          break;\n+          break; // continue assigning for the next state\n+        }\n+        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+          continue; // continue checking for the next available instance\n         }\n-        if (!assigned.contains(instance) && liveAndEnabled.contains(instance)) {\n-          if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(instance))) {\n-            bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.toString());\n-          } else {\n-            bestPossibleStateMap.put(instance, state);\n-            stateCount--;\n+        String proposedInstance = instance;\n+        // Additional check and alternate the assignment for reducing top state handoff.\n+        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}, "originalCommit": {"oid": "30816eece784e18df6fedc1412a27bf39d6cd9f2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk3OTM3NQ==", "bodyText": "I see you point. Purely relies on sorting is fine because the previous author use it in wrong way. We suppose to sort it before looping.\nAnyway, I am OK to keep the current behavior. But can you add a TODO here. To remind that we can refactor the logic based on sorting with comprehensive test in the future?", "url": "https://github.com/apache/helix/pull/986#discussion_r420979375", "createdAt": "2020-05-06T17:50:15Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -305,45 +305,60 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n     liveAndEnabled.removeAll(disabledInstancesForPartition);\n \n-    for (String state : statesPriorityList) {\n-      // Use the the specially ordered preferenceList for choosing instance for top state.\n-      if (state.equals(statesPriorityList.get(0))) {\n-        List<String> preferenceListForTopState = new ArrayList<>(preferenceList);\n-        Collections.sort(preferenceListForTopState,\n-            new TopStatePreferenceListComparator(currentStateMap, stateModelDef));\n-        preferenceList = preferenceListForTopState;\n-      }\n+    // Sort the instances based on replicas' state priority in the current state\n+    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n+    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n \n+    // Assign the state to the instances that appear in the preference list.\n+    for (String state : statesPriorityList) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n       for (String instance : preferenceList) {\n         if (stateCount <= 0) {\n-          break;\n+          break; // continue assigning for the next state\n+        }\n+        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+          continue; // continue checking for the next available instance\n         }\n-        if (!assigned.contains(instance) && liveAndEnabled.contains(instance)) {\n-          if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(instance))) {\n-            bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.toString());\n-          } else {\n-            bestPossibleStateMap.put(instance, state);\n-            stateCount--;\n+        String proposedInstance = instance;\n+        // Additional check and alternate the assignment for reducing top state handoff.\n+        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}, "originalCommit": {"oid": "30816eece784e18df6fedc1412a27bf39d6cd9f2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk4OTY3Ng==", "bodyText": "Not exactly. Actually, I don't agree this is a TODO work to put everything in a sorting method. That is just an alternative design, and I don't think it is cleaner than the current one.\nConsidering the proposed universal sorting method, it is actually merging 2 orders (preference list order and the current state order). However, there is no clear way to define the priority score.\nNote the logic here is that if the node is not on secondary state or above but it is attempted to be a master, we should find alternatives according to the current state order.\nThis logic cannot be done with only the 2 orders. We have to know the proposed states assignment. For example, how many top states and where to assign based on the preference state.\nGive this, to merging the sort in one method (instead of the current design), we will need to:\n\npropose a state assignment based on the preference list\ninput this proposed state mapping as one additional input to the sorting method, and then sort accordingly.\ncalculate another state assignment based on the re-sorted list.\n\nIt seems more confusing and slower than the current design.", "url": "https://github.com/apache/helix/pull/986#discussion_r420989676", "createdAt": "2020-05-06T18:06:24Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -305,45 +305,60 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n     liveAndEnabled.removeAll(disabledInstancesForPartition);\n \n-    for (String state : statesPriorityList) {\n-      // Use the the specially ordered preferenceList for choosing instance for top state.\n-      if (state.equals(statesPriorityList.get(0))) {\n-        List<String> preferenceListForTopState = new ArrayList<>(preferenceList);\n-        Collections.sort(preferenceListForTopState,\n-            new TopStatePreferenceListComparator(currentStateMap, stateModelDef));\n-        preferenceList = preferenceListForTopState;\n-      }\n+    // Sort the instances based on replicas' state priority in the current state\n+    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n+    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n \n+    // Assign the state to the instances that appear in the preference list.\n+    for (String state : statesPriorityList) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n       for (String instance : preferenceList) {\n         if (stateCount <= 0) {\n-          break;\n+          break; // continue assigning for the next state\n+        }\n+        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+          continue; // continue checking for the next available instance\n         }\n-        if (!assigned.contains(instance) && liveAndEnabled.contains(instance)) {\n-          if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(instance))) {\n-            bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.toString());\n-          } else {\n-            bestPossibleStateMap.put(instance, state);\n-            stateCount--;\n+        String proposedInstance = instance;\n+        // Additional check and alternate the assignment for reducing top state handoff.\n+        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}, "originalCommit": {"oid": "30816eece784e18df6fedc1412a27bf39d6cd9f2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEyMjI4NA==", "bodyText": "Hmm. The sorting logic could be complicated. Alright, let's revisit the logic if it requires refactoring later.", "url": "https://github.com/apache/helix/pull/986#discussion_r421122284", "createdAt": "2020-05-06T22:11:27Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -305,45 +305,60 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n     liveAndEnabled.removeAll(disabledInstancesForPartition);\n \n-    for (String state : statesPriorityList) {\n-      // Use the the specially ordered preferenceList for choosing instance for top state.\n-      if (state.equals(statesPriorityList.get(0))) {\n-        List<String> preferenceListForTopState = new ArrayList<>(preferenceList);\n-        Collections.sort(preferenceListForTopState,\n-            new TopStatePreferenceListComparator(currentStateMap, stateModelDef));\n-        preferenceList = preferenceListForTopState;\n-      }\n+    // Sort the instances based on replicas' state priority in the current state\n+    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n+    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n \n+    // Assign the state to the instances that appear in the preference list.\n+    for (String state : statesPriorityList) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n       for (String instance : preferenceList) {\n         if (stateCount <= 0) {\n-          break;\n+          break; // continue assigning for the next state\n+        }\n+        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+          continue; // continue checking for the next available instance\n         }\n-        if (!assigned.contains(instance) && liveAndEnabled.contains(instance)) {\n-          if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(instance))) {\n-            bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.toString());\n-          } else {\n-            bestPossibleStateMap.put(instance, state);\n-            stateCount--;\n+        String proposedInstance = instance;\n+        // Additional check and alternate the assignment for reducing top state handoff.\n+        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}, "originalCommit": {"oid": "30816eece784e18df6fedc1412a27bf39d6cd9f2"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1481, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}