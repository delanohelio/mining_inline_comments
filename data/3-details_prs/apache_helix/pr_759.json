{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MDQ4MzIx", "number": 759, "title": "Add validation logic to MSD write operations", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #758\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis PR add routing data validation logic. When a user attempts to add a sharding key to some existing routing data, validation logic is used to confirm that the addition will leave the resulting routing data in a valid state. We make use of the existing trie structure to efficiently check if a sharding key results in an ambiguity case. Some old code in TrieRoutingData is modified to minimize duplicate code and make everything a lot cleaner.\nTests\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO] Tests run: 143, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 21.642 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 143, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  47.466 s\n[INFO] Finished at: 2020-02-13T11:13:56-08:00\n[INFO] ------------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-13T19:29:59Z", "url": "https://github.com/apache/helix/pull/759", "merged": true, "mergeCommit": {"oid": "8c050b3928af3e4076311744076dcc75cc21e602"}, "closed": true, "closedAt": "2020-02-18T17:38:13Z", "author": {"login": "NealSun96"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDw3b9gH2gAyMzc1MDQ4MzIxOjIxNDhkMDkyMWE2NWIxYWQ4YjRjMDAwZDYxY2IwYWZmZDA3Y2UwMjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcFlVHHgH2gAyMzc1MDQ4MzIxOjM0NDY3NDNmOWM5NTEyMDljMTYzY2U1MWNkMDE0MjZhZWUyNzNjNDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2148d0921a65b1ad8b4c000d61cb0affd07ce023", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/2148d0921a65b1ad8b4c000d61cb0affd07ce023", "committedDate": "2020-02-13T01:43:51Z", "message": "add validation logic to TrieRoutingData and add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/9f0886dcb893527696c7ad0ada56be10c028cab2", "committedDate": "2020-02-13T19:25:37Z", "message": "furnish the related code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTIyNTI2", "url": "https://github.com/apache/helix/pull/759#pullrequestreview-358522526", "createdAt": "2020-02-13T20:18:59Z", "commit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoxOTowMFrOFpiNHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoxOTowMFrOFpiNHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5NjM1MA==", "bodyText": "The name for this method is a little confusing. Do you think something like findClosestParentNode or findClosetShardingKeyNode or findClosestTerminalNode would be easier to understand?", "url": "https://github.com/apache/helix/pull/759#discussion_r379096350", "createdAt": "2020-02-13T20:19:00Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided\n+   * path (meaning the traversal ended before the last node of the path is reached), the provided\n+   * path is not associated with any sharding key and can be added as a sharding key without\n+   * creating ambiguity cases among sharding keys.\n    * @param path - the path where the search is conducted\n-   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n-   * @return the node pointed by the path or a leaf node along the path\n-   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n-   *           found\n+   * @return a TrieNode that represents the longest prefix of the path\n    */\n-  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n-      throws NoSuchElementException {\n+  private TrieNode getLongestPrefixNodeAlongPath(String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTI1NjA1", "url": "https://github.com/apache/helix/pull/759#pullrequestreview-358525605", "createdAt": "2020-02-13T20:24:11Z", "commit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoyNDoxMVrOFpiW5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoyNDoxMVrOFpiW5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5ODg1Mg==", "bodyText": "\"longest prefix\"? Could we just call it the closest existing sharding key node?", "url": "https://github.com/apache/helix/pull/759#discussion_r379098852", "createdAt": "2020-02-13T20:24:11Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTI2NDk3", "url": "https://github.com/apache/helix/pull/759#pullrequestreview-358526497", "createdAt": "2020-02-13T20:25:39Z", "commit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoyNTozOVrOFpiZYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoyNTozOVrOFpiZYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5OTQ5MQ==", "bodyText": "Is this scenario possible (assuming that the existing routing data is valid)?", "url": "https://github.com/apache/helix/pull/759#discussion_r379099491", "createdAt": "2020-02-13T20:25:39Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTY5MTAy", "url": "https://github.com/apache/helix/pull/759#pullrequestreview-358569102", "createdAt": "2020-02-13T21:37:18Z", "commit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTozNzoxOFrOFpkaBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTozNzoxOFrOFpkaBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMjQyMA==", "bodyText": "last-seen existing node?", "url": "https://github.com/apache/helix/pull/759#discussion_r379132420", "createdAt": "2020-02-13T21:37:18Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjExOTY4", "url": "https://github.com/apache/helix/pull/759#pullrequestreview-358611968", "createdAt": "2020-02-13T22:57:27Z", "commit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11dc9a6d14290802cbc6e65a5e6cea9abf11adb0", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/11dc9a6d14290802cbc6e65a5e6cea9abf11adb0", "committedDate": "2020-02-14T00:09:19Z", "message": "change comment wording"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjY0ODc4", "url": "https://github.com/apache/helix/pull/759#pullrequestreview-358664878", "createdAt": "2020-02-14T01:32:09Z", "commit": {"oid": "11dc9a6d14290802cbc6e65a5e6cea9abf11adb0"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTozMjoxMFrOFppMjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0MjoxNlrOFppWCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMDg5Mg==", "bodyText": "/** is for Javadoc. I don't think Javadoc should be added to a private method, as end users don't have access to private fields or logic. I suggest you change /** to /* for regular comments.", "url": "https://github.com/apache/helix/pull/759#discussion_r379210892", "createdAt": "2020-02-14T01:32:10Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11dc9a6d14290802cbc6e65a5e6cea9abf11adb0"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzMyMw==", "bodyText": "Are below cases valid?\n\n/x/y/z/\n/x//y/z", "url": "https://github.com/apache/helix/pull/759#discussion_r379213323", "createdAt": "2020-02-14T01:42:16Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/TestTrieRoutingData.java", "diffHunk": "@@ -249,7 +251,44 @@ public void testGetMetadataStoreRealmNoLeaf() {\n       _trie.getMetadataStoreRealm(\"/b/c\");\n       Assert.fail(\"Expecting NoSuchElementException\");\n     } catch (NoSuchElementException e) {\n-      Assert.assertTrue(e.getMessage().contains(\"No leaf node found along the path. Path: /b/c\"));\n+      Assert.assertTrue(\n+          e.getMessage().contains(\"No sharding key found within the provided path. Path: /b/c\"));\n     }\n   }\n+\n+  @Test(dependsOnMethods = \"testConstructionNormal\")\n+  public void testIsShardingKeyInsertionValidNoSlash() {\n+    try {\n+      _trie.isShardingKeyInsertionValid(\"x/y/z\");\n+      Assert.fail(\"Expecting IllegalArgumentException\");\n+    } catch (IllegalArgumentException e) {\n+      Assert.assertTrue(e.getMessage().contains(\n+          \"Provided shardingKey is empty or does not have a leading \\\"/\\\" character: x/y/z\"));\n+    }\n+  }\n+\n+  @Test(dependsOnMethods = \"testConstructionNormal\")\n+  public void testIsShardingKeyInsertionValidSlashOnly() {\n+    Assert.assertFalse(_trie.isShardingKeyInsertionValid(\"/\"));\n+  }\n+\n+  @Test(dependsOnMethods = \"testConstructionNormal\")\n+  public void testIsShardingKeyInsertionValidNormal() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11dc9a6d14290802cbc6e65a5e6cea9abf11adb0"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d419add6a62e0abb70763f11cfd77875fcc0287", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/9d419add6a62e0abb70763f11cfd77875fcc0287", "committedDate": "2020-02-15T00:06:27Z", "message": "implement idempotency feature for addShardingKey"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3446743f9c951209c163ce51cd01426aee273c48", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/3446743f9c951209c163ce51cd01426aee273c48", "committedDate": "2020-02-18T17:25:15Z", "message": "fix formatting"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4958, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}