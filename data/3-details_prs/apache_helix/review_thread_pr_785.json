{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NDQ0NjA5", "number": 785, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNzoyNDo1NVrODhaowg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMTowMTowM1rODiAtaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzY2MDE4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/ClusterEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNzoyNDo1NVrOFsIk5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMTo0NTo1MlrOFspLkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyMjE4MA==", "bodyText": "Thanks for the PR!\n\n\nCan we just replace clone() logic with what you have in the copy constructor? If the constructor is private, then I think it'd just be simpler to put this \"copy\" logic in clone() (it seems pretty simple anyways).\n\n\nWith that said, do we still need addAttribute() anymore?", "url": "https://github.com/apache/helix/pull/785#discussion_r381822180", "createdAt": "2020-02-20T07:24:55Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/ClusterEvent.java", "diffHunk": "@@ -55,6 +55,19 @@ public ClusterEvent(String clusterName, ClusterEventType eventType, String event\n     _eventId = eventId;\n   }\n \n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee1cbd02dbed2804afafb80ec6d0194c61bfff42"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NjM2OA==", "bodyText": "That's really what I thought initially. But it turns out the variable _eventAttributeMap is final, which means I cannot mutate the value.\nAre you also referring to this\nClusterEvent newEvent = new ClusterEvent(_clusterName, _eventType, eventId);\t    return new ClusterEvent(this, eventId);\nnewEvent.setCreationTime(_creationTime);\nnewEvent._eventAttributeMap = new HashMap(__eventAttributeMap);\n\nUnless we change the map to non-final", "url": "https://github.com/apache/helix/pull/785#discussion_r382356368", "createdAt": "2020-02-21T01:45:52Z", "author": {"login": "i3wangyi"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/ClusterEvent.java", "diffHunk": "@@ -55,6 +55,19 @@ public ClusterEvent(String clusterName, ClusterEventType eventType, String event\n     _eventId = eventId;\n   }\n \n+  /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyMjE4MA=="}, "originalCommit": {"oid": "ee1cbd02dbed2804afafb80ec6d0194c61bfff42"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzgxNDc2OnYy", "diffSide": "LEFT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/ClusterEvent.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODoyNjo1M1rOFsKB3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMToxMDoxNlrOFtEsaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0NTk4MA==", "bodyText": "@i3wangyi I am a bit confused and not convinced by the root cause: \"In ClusterEvent.java, the hashmap update itself while in its for loop\". If so, each time this method is called, the ConcurrentModificationException would be thrown and it does not work at all.\nThe maps _eventAttributeMap are different objects. So addAttribute() does not add the attributes to the original event's map, but the new event's different map.\nSo I think the root cause could be another place (eg. another thread) updating the original event's map while in for loop.", "url": "https://github.com/apache/helix/pull/785#discussion_r381845980", "createdAt": "2020-02-20T08:26:53Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/ClusterEvent.java", "diffHunk": "@@ -114,11 +127,6 @@ public String toString() {\n   }\n \n   public ClusterEvent clone(String eventId) {\n-    ClusterEvent newEvent = new ClusterEvent(_clusterName, _eventType, eventId);\n-    newEvent.setCreationTime(_creationTime);\n-    for (String attributeName : _eventAttributeMap.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee1cbd02dbed2804afafb80ec6d0194c61bfff42"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NzMzNA==", "bodyText": "You're right! I'll update the root cause in #785. I was initially unaware of the different objects of _eventAttributeMap, cause the old code is readable at first sight and it's not thread-safe.\nThis fix is still valid under multi-threads. Added one test but making it multi-threading and produce the same issue is non-trivial.", "url": "https://github.com/apache/helix/pull/785#discussion_r382357334", "createdAt": "2020-02-21T01:49:14Z", "author": {"login": "i3wangyi"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/ClusterEvent.java", "diffHunk": "@@ -114,11 +127,6 @@ public String toString() {\n   }\n \n   public ClusterEvent clone(String eventId) {\n-    ClusterEvent newEvent = new ClusterEvent(_clusterName, _eventType, eventId);\n-    newEvent.setCreationTime(_creationTime);\n-    for (String attributeName : _eventAttributeMap.keySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0NTk4MA=="}, "originalCommit": {"oid": "ee1cbd02dbed2804afafb80ec6d0194c61bfff42"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3OTI4NA==", "bodyText": "Can you explain why the copy constructor is different from the original for-loop? Maybe I miss something, but I see that new HashMap<>(map) is basically also a for-loop to copy the original map entries, which means, the entries could still change and throws concurrent mod exception for the step new HashMap<>(map).\nPlease correct me if I am wrong. Appreciate it!", "url": "https://github.com/apache/helix/pull/785#discussion_r382379284", "createdAt": "2020-02-21T03:23:49Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/ClusterEvent.java", "diffHunk": "@@ -114,11 +127,6 @@ public String toString() {\n   }\n \n   public ClusterEvent clone(String eventId) {\n-    ClusterEvent newEvent = new ClusterEvent(_clusterName, _eventType, eventId);\n-    newEvent.setCreationTime(_creationTime);\n-    for (String attributeName : _eventAttributeMap.keySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0NTk4MA=="}, "originalCommit": {"oid": "ee1cbd02dbed2804afafb80ec6d0194c61bfff42"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2NzA3Mw==", "bodyText": "@pkuwm Thanks! I was under the impression that copy over a map is a thread-safe operation in some languages(python, e.g). I just tried it in Java, it still suffers the same exception. So I believe the right fix & less code change is to make it ConcurrentHashMap. Also added a test for it.", "url": "https://github.com/apache/helix/pull/785#discussion_r382767073", "createdAt": "2020-02-21T19:34:12Z", "author": {"login": "i3wangyi"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/ClusterEvent.java", "diffHunk": "@@ -114,11 +127,6 @@ public String toString() {\n   }\n \n   public ClusterEvent clone(String eventId) {\n-    ClusterEvent newEvent = new ClusterEvent(_clusterName, _eventType, eventId);\n-    newEvent.setCreationTime(_creationTime);\n-    for (String attributeName : _eventAttributeMap.keySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0NTk4MA=="}, "originalCommit": {"oid": "ee1cbd02dbed2804afafb80ec6d0194c61bfff42"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwNzE0Nw==", "bodyText": "Agreed that ConcurrentHashMap could protect it.", "url": "https://github.com/apache/helix/pull/785#discussion_r382807147", "createdAt": "2020-02-21T21:10:16Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/ClusterEvent.java", "diffHunk": "@@ -114,11 +127,6 @@ public String toString() {\n   }\n \n   public ClusterEvent clone(String eventId) {\n-    ClusterEvent newEvent = new ClusterEvent(_clusterName, _eventType, eventId);\n-    newEvent.setCreationTime(_creationTime);\n-    for (String attributeName : _eventAttributeMap.keySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0NTk4MA=="}, "originalCommit": {"oid": "ee1cbd02dbed2804afafb80ec6d0194c61bfff42"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTg5ODAwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestClusterEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMTowMTowM1rOFtEecg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMToxODo0OFrOFtE5cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwMzU3MA==", "bodyText": "This is a reasonable test. Maybe to make it more accurate in this test, we can use a CountDownLatch as a signal right before clone().\nlatch.countDown(); // Tell 10 threads to modify this the attributeMap.\nclone();\n\nAnd also add more attributes (say, 20) in each thread just to make the time a bit longer.\nThis CountDownLatch and more attributes make sure that the attribute adding is not completed yet before clone().", "url": "https://github.com/apache/helix/pull/785#discussion_r382803570", "createdAt": "2020-02-21T21:01:03Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestClusterEvent.java", "diffHunk": "@@ -19,16 +19,51 @@\n  * under the License.\n  */\n \n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.List;\n+\n+import org.testng.Assert;\n import org.testng.AssertJUnit;\n import org.testng.annotations.Test;\n \n-@Test\n+\n public class TestClusterEvent {\n+\n   @Test\n-  public void testSimplePutandGet() {\n+  public void testSimplePutAndGet() {\n     ClusterEvent event = new ClusterEvent(ClusterEventType.Unknown);\n     AssertJUnit.assertEquals(event.getEventType(), ClusterEventType.Unknown);\n     event.addAttribute(\"attr1\", \"value\");\n     AssertJUnit.assertEquals(event.getAttribute(\"attr1\"), \"value\");\n   }\n+\n+  @Test\n+  public void testThreadSafeClone() throws InterruptedException {\n+    String clusterName = \"TestCluster\";\n+    ClusterEvent event = new ClusterEvent(clusterName, ClusterEventType.Unknown, \"testId\");\n+    for (int i = 0; i < 100; i++) {\n+      event.addAttribute(String.valueOf(i), i);\n+    }\n+    List<Thread> threads = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      threads.add(new Thread(() -> {\n+        String threadName = Thread.currentThread().getName();\n+        event.addAttribute(threadName, threadName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87185bfb5355d9548005fef3e85222253421fbe1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgxMDQ4MA==", "bodyText": "Actually, one additional thread is good enough if it's adding, say, 100 items into the map. It reduces the cost of thread consumptions by test class.", "url": "https://github.com/apache/helix/pull/785#discussion_r382810480", "createdAt": "2020-02-21T21:18:48Z", "author": {"login": "i3wangyi"}, "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestClusterEvent.java", "diffHunk": "@@ -19,16 +19,51 @@\n  * under the License.\n  */\n \n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.List;\n+\n+import org.testng.Assert;\n import org.testng.AssertJUnit;\n import org.testng.annotations.Test;\n \n-@Test\n+\n public class TestClusterEvent {\n+\n   @Test\n-  public void testSimplePutandGet() {\n+  public void testSimplePutAndGet() {\n     ClusterEvent event = new ClusterEvent(ClusterEventType.Unknown);\n     AssertJUnit.assertEquals(event.getEventType(), ClusterEventType.Unknown);\n     event.addAttribute(\"attr1\", \"value\");\n     AssertJUnit.assertEquals(event.getAttribute(\"attr1\"), \"value\");\n   }\n+\n+  @Test\n+  public void testThreadSafeClone() throws InterruptedException {\n+    String clusterName = \"TestCluster\";\n+    ClusterEvent event = new ClusterEvent(clusterName, ClusterEventType.Unknown, \"testId\");\n+    for (int i = 0; i < 100; i++) {\n+      event.addAttribute(String.valueOf(i), i);\n+    }\n+    List<Thread> threads = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      threads.add(new Thread(() -> {\n+        String threadName = Thread.currentThread().getName();\n+        event.addAttribute(threadName, threadName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwMzU3MA=="}, "originalCommit": {"oid": "87185bfb5355d9548005fef3e85222253421fbe1"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1647, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}