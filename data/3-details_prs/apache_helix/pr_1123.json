{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMzc5MDAz", "number": 1123, "title": "Cleanup the persisted assignment state if no resource is on WAGED rebalancer.", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\n#1120\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis is to prevent the WAGED rebalancer reads stale assignment records from the previous rebalance pipeline.\nFor example,\n\nResource A was the only resource. And it is rebalanced by WAGED, then we have a persisted assignment for A.\nResource A was reconfigured to using DelayedRebalancer, then we stop the WAGED rebalancer since there is no more resource using WAGED. So the persisted records are still in ZK.\nResource A is recreated and using WAGED again. In this case, the previous persisted assignment is no longer valid. We should treat A as a brand new resource instead of considering the stale assignment record.\n\nMoreover, this change will help to clean up the ZK persisted data if no resource is using WAGED.\nTests\n\n The following tests are written for this issue:\n\nTestAssignmentMetadataStore, TestWagedRebalancer\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO] Results:\n[INFO]\n[ERROR] Failures:\n[ERROR]   TestJobQueueCleanUp.testJobQueueAutoCleanUp \u00bb ThreadTimeout Method org.testng....\n[INFO]\n[ERROR] Tests run: 1149, Failures: 1, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 01:25 h\n[INFO] Finished at: 2020-06-26T00:00:39-07:00\n[INFO] ------------------------------------------------------------------------\nRerun\n[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 14.508 s - in org.apache.helix.integration.task.TestJobQueueCleanUp\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 23.728 s\n[INFO] Finished at: 2020-06-26T00:01:34-07:00\n[INFO] ------------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation (Optional)\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-06-26T04:50:15Z", "url": "https://github.com/apache/helix/pull/1123", "merged": true, "mergeCommit": {"oid": "0b98a6e42b2e814d388cd22e53911a43212de05a"}, "closed": true, "closedAt": "2020-06-30T22:41:16Z", "author": {"login": "jiajunwang"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcu71XMgH2gAyNDQwMzc5MDAzOjQ2MTAyNGQ1YmM5NzA4N2RhMTM1NDFjZmFjNzAxZThkZTZlODY3MWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwdfl2AFqTQ0MDQzMjYyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "461024d5bc97087da13541cfac701e8de6e8671a", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/461024d5bc97087da13541cfac701e8de6e8671a", "committedDate": "2020-06-26T04:49:17Z", "message": "Cleanup the persisted assignment state if no resource is on WAGED rebalancer.\n\nThis is to prevent the WAGED rebalancer reads stale assignment records from the previous rebalance pipeline.\nFor example,\n1. Resource A was the only resource. And it is rebalanced by WAGED, then we have a persisted assignment for A.\n2. Resource A was reconfigured to using DelayedRebalancer, then we stop the WAGED rebalancer since there is no more resource using WAGED. So the persisted records are still in ZK.\n3. Resource A is recreated and using WAGED again. In this case, the previous persisted assignment is no longer valid. We should treat A as a brand new resource instead of considering the stale assignment record.\n\nMoreover, this change will help to clean up the ZK persisted data if no resource is using WAGED."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e04a577e219e665eeaad0aabdad45c92b7af7aa", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/0e04a577e219e665eeaad0aabdad45c92b7af7aa", "committedDate": "2020-06-26T05:30:06Z", "message": "fix test case."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MDU0NDA4", "url": "https://github.com/apache/helix/pull/1123#pullrequestreview-438054408", "createdAt": "2020-06-26T06:55:03Z", "commit": {"oid": "0e04a577e219e665eeaad0aabdad45c92b7af7aa"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNjo1NTowM1rOGpVwXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzowMTo0MVrOGpV6PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMTI0NA==", "bodyText": "No need to execute following removes ops? Just return the empty list?", "url": "https://github.com/apache/helix/pull/1123#discussion_r446001244", "createdAt": "2020-06-26T06:55:03Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/waged/TestAssignmentMetadataStore.java", "diffHunk": "@@ -172,13 +197,17 @@ public void testAssignmentCache() {\n \n   /**\n    * Returns a list of existing version numbers only.\n+   *\n    * @param metadataType\n    * @return\n    */\n   private List<String> getExistingVersionNumbers(String metadataType) {\n     List<String> children = _baseAccessor\n         .getChildNames(\"/\" + CLUSTER_NAME + \"/ASSIGNMENT_METADATA/\" + metadataType,\n             AccessOption.PERSISTENT);\n+    if (children == null) {\n+      children = Collections.EMPTY_LIST;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e04a577e219e665eeaad0aabdad45c92b7af7aa"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMTcxOQ==", "bodyText": "Nit, Assert.assertTrue(_store.getBaseline().isEmpty());? Or is it because _store.getBaseline() may return null?", "url": "https://github.com/apache/helix/pull/1123#discussion_r446001719", "createdAt": "2020-06-26T06:56:15Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/waged/TestAssignmentMetadataStore.java", "diffHunk": "@@ -107,55 +84,103 @@ public void afterClass() {\n    */\n   @Test\n   public void testReadEmptyBaseline() {\n-    Map<String, ResourceAssignment> baseline = _store.getBaseline();\n-    Assert.assertTrue(baseline.isEmpty());\n+    // This should be the first test. Assert there is no record in ZK.\n+    // Check that only one version exists\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 0);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 0);\n+    // Read from cache and the result is empty.\n+    Assert.assertTrue(_store.getBaseline().isEmpty());\n+    Assert.assertTrue(_store.getBestPossibleAssignment().isEmpty());\n   }\n \n   /**\n    * Test that if the old assignment and new assignment are the same,\n    */\n   @Test(dependsOnMethods = \"testReadEmptyBaseline\")\n   public void testAvoidingRedundantWrite() {\n-    String baselineKey = \"BASELINE\";\n-    String bestPossibleKey = \"BEST_POSSIBLE\";\n-\n     Map<String, ResourceAssignment> dummyAssignment = getDummyAssignment();\n \n     // Call persist functions\n     _store.persistBaseline(dummyAssignment);\n     _store.persistBestPossibleAssignment(dummyAssignment);\n \n     // Check that only one version exists\n-    List<String> baselineVersions = getExistingVersionNumbers(baselineKey);\n-    List<String> bestPossibleVersions = getExistingVersionNumbers(bestPossibleKey);\n-    Assert.assertEquals(baselineVersions.size(), 1);\n-    Assert.assertEquals(bestPossibleVersions.size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 1);\n \n     // Call persist functions again\n     _store.persistBaseline(dummyAssignment);\n     _store.persistBestPossibleAssignment(dummyAssignment);\n \n     // Check that only one version exists still\n-    baselineVersions = getExistingVersionNumbers(baselineKey);\n-    bestPossibleVersions = getExistingVersionNumbers(bestPossibleKey);\n-    Assert.assertEquals(baselineVersions.size(), 1);\n-    Assert.assertEquals(bestPossibleVersions.size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 1);\n   }\n \n-  @Test\n+  @Test(dependsOnMethods = \"testAvoidingRedundantWrite\")\n   public void testAssignmentCache() {\n     Map<String, ResourceAssignment> dummyAssignment = getDummyAssignment();\n     // Call persist functions\n     _store.persistBaseline(dummyAssignment);\n     _store.persistBestPossibleAssignment(dummyAssignment);\n \n+    // Check that only one version exists\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 1);\n+\n+    // Same data in cache\n     Assert.assertEquals(_store._bestPossibleAssignment, dummyAssignment);\n     Assert.assertEquals(_store._globalBaseline, dummyAssignment);\n \n+    dummyAssignment.values().stream().forEach(assignment -> {\n+      assignment.addReplicaMap(new Partition(\"foo\"), Collections.emptyMap());\n+    });\n+\n+    // Call persist functions\n+    _store.persistBaseline(dummyAssignment);\n+    _store.persistBestPossibleAssignment(dummyAssignment);\n+\n+    // Check that two versions exist\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 2);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 2);\n+\n+    // Same data in cache\n+    Assert.assertEquals(_store._bestPossibleAssignment, dummyAssignment);\n+    Assert.assertEquals(_store._globalBaseline, dummyAssignment);\n+\n+    // Clear cache\n     _store.reset();\n \n     Assert.assertEquals(_store._bestPossibleAssignment, null);\n     Assert.assertEquals(_store._globalBaseline, null);\n+\n+    // Check the persisted data is not changed.\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 2);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 2);\n+  }\n+\n+  @Test(dependsOnMethods = \"testAssignmentCache\")\n+  void testClearAssignment() {\n+    // Check the persisted data is not empty\n+    List<String> baselineVersions = getExistingVersionNumbers(BASELINE_KEY);\n+    List<String> bestPossibleVersions = getExistingVersionNumbers(BEST_POSSIBLE_KEY);\n+    int baselineVersionCount = baselineVersions.size();\n+    int bestPossibleVersionCount = bestPossibleVersions.size();\n+    Assert.assertTrue(baselineVersionCount > 0);\n+    Assert.assertTrue(bestPossibleVersionCount > 0);\n+\n+    _store.clearAssignmentMetadata();\n+\n+    // 1. cache is cleaned up\n+    Assert.assertEquals(_store._bestPossibleAssignment, Collections.emptyMap());\n+    Assert.assertEquals(_store._globalBaseline, Collections.emptyMap());\n+    // 2. refresh the cache and then read from ZK again to ensure the persisted assignments is empty\n+    _store.reset();\n+    Assert.assertEquals(_store.getBaseline(), Collections.emptyMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e04a577e219e665eeaad0aabdad45c92b7af7aa"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMjU4NA==", "bodyText": "How about removing the whole cluster deleteRecursively(\"/CLUSTER_NAME\")?", "url": "https://github.com/apache/helix/pull/1123#discussion_r446002584", "createdAt": "2020-06-26T06:58:37Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/waged/TestAssignmentMetadataStore.java", "diffHunk": "@@ -28,74 +29,50 @@\n import org.apache.helix.HelixManagerFactory;\n import org.apache.helix.InstanceType;\n import org.apache.helix.common.ZkTestBase;\n-import org.apache.helix.integration.manager.ClusterControllerManager;\n-import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.manager.zk.ZkBucketDataAccessor;\n import org.apache.helix.model.Partition;\n import org.apache.helix.model.ResourceAssignment;\n import org.testng.Assert;\n import org.testng.annotations.AfterClass;\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.Test;\n \n-\n public class TestAssignmentMetadataStore extends ZkTestBase {\n-  protected static final int NODE_NR = 5;\n-  protected static final int START_PORT = 12918;\n-  protected static final String STATE_MODEL = \"MasterSlave\";\n-  protected static final String TEST_DB = \"TestDB\";\n-  protected static final int _PARTITIONS = 20;\n+  private static final int DEFAULT_BUCKET_SIZE = 50 * 1024; // 50KB\n+  private static final String BASELINE_KEY = \"BASELINE\";\n+  private static final String BEST_POSSIBLE_KEY = \"BEST_POSSIBLE\";\n \n+  protected static final String TEST_DB = \"TestDB\";\n   protected HelixManager _manager;\n   protected final String CLASS_NAME = getShortClassName();\n   protected final String CLUSTER_NAME = CLUSTER_PREFIX + \"_\" + CLASS_NAME;\n \n-  protected MockParticipantManager[] _participants = new MockParticipantManager[NODE_NR];\n-  protected ClusterControllerManager _controller;\n-  protected int _replica = 3;\n-\n   private AssignmentMetadataStore _store;\n \n   @BeforeClass\n-  public void beforeClass()\n-      throws Exception {\n+  public void beforeClass() throws Exception {\n     super.beforeClass();\n \n     // setup storage cluster\n     _gSetupTool.addCluster(CLUSTER_NAME, true);\n-    _gSetupTool.addResourceToCluster(CLUSTER_NAME, TEST_DB, _PARTITIONS, STATE_MODEL);\n-    for (int i = 0; i < NODE_NR; i++) {\n-      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n-      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n-    }\n-    _gSetupTool.rebalanceStorageCluster(CLUSTER_NAME, TEST_DB, _replica);\n-\n-    // start dummy participants\n-    for (int i = 0; i < NODE_NR; i++) {\n-      String instanceName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n-      _participants[i] = new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, instanceName);\n-      _participants[i].syncStart();\n-    }\n-\n-    // start controller\n-    String controllerName = CONTROLLER_PREFIX + \"_0\";\n-    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n-    _controller.syncStart();\n \n     // create cluster manager\n     _manager = HelixManagerFactory\n         .getZKHelixManager(CLUSTER_NAME, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n     _manager.connect();\n \n-    // create AssignmentMetadataStore\n-    _store = new AssignmentMetadataStore(_manager.getMetadataStoreConnectionString(),\n-        _manager.getClusterName());\n+    // Create AssignmentMetadataStore. No version clean up to ensure the test result is stable.\n+    _store = new AssignmentMetadataStore(\n+        new ZkBucketDataAccessor(_manager.getMetadataStoreConnectionString(), DEFAULT_BUCKET_SIZE,\n+            Integer.MAX_VALUE), _manager.getClusterName());\n   }\n \n   @AfterClass\n   public void afterClass() {\n     if (_store != null) {\n       _store.close();\n     }\n+    _baseAccessor.remove(\"/\" + CLUSTER_NAME + \"/ASSIGNMENT_METADATA\", AccessOption.PERSISTENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e04a577e219e665eeaad0aabdad45c92b7af7aa"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMzc3Mg==", "bodyText": "New elements need to add to this empty map?", "url": "https://github.com/apache/helix/pull/1123#discussion_r446003772", "createdAt": "2020-06-26T07:01:41Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/AssignmentMetadataStore.java", "diffHunk": "@@ -70,7 +70,7 @@ protected AssignmentMetadataStore(BucketDataAccessor bucketDataAccessor, String\n         _globalBaseline = splitAssignments(baseline);\n       } catch (ZkNoNodeException ex) {\n         // Metadata does not exist, so return an empty map\n-        _globalBaseline = Collections.emptyMap();\n+        _globalBaseline = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e04a577e219e665eeaad0aabdad45c92b7af7aa"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e11aa5b4c6077268898310161faedecde189cd0", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/1e11aa5b4c6077268898310161faedecde189cd0", "committedDate": "2020-06-26T07:08:23Z", "message": "Address comment."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzAzODE4", "url": "https://github.com/apache/helix/pull/1123#pullrequestreview-440303818", "createdAt": "2020-06-30T19:01:59Z", "commit": {"oid": "1e11aa5b4c6077268898310161faedecde189cd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOTowMTo1OVrOGrKf3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOTowMTo1OVrOGrKf3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMzk1MQ==", "bodyText": "This change is non-essential, right?", "url": "https://github.com/apache/helix/pull/1123#discussion_r447913951", "createdAt": "2020-06-30T19:01:59Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/AssignmentMetadataStore.java", "diffHunk": "@@ -70,7 +70,7 @@ protected AssignmentMetadataStore(BucketDataAccessor bucketDataAccessor, String\n         _globalBaseline = splitAssignments(baseline);\n       } catch (ZkNoNodeException ex) {\n         // Metadata does not exist, so return an empty map\n-        _globalBaseline = Collections.emptyMap();\n+        _globalBaseline = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e11aa5b4c6077268898310161faedecde189cd0"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzE1MjUy", "url": "https://github.com/apache/helix/pull/1123#pullrequestreview-440315252", "createdAt": "2020-06-30T19:19:13Z", "commit": {"oid": "1e11aa5b4c6077268898310161faedecde189cd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOToxOToxM1rOGrLDMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOToxOToxM1rOGrLDMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMjk5NQ==", "bodyText": "What is going to catch this one?", "url": "https://github.com/apache/helix/pull/1123#discussion_r447922995", "createdAt": "2020-06-30T19:19:13Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/AssignmentMetadataStore.java", "diffHunk": "@@ -95,53 +95,56 @@ protected AssignmentMetadataStore(BucketDataAccessor bucketDataAccessor, String\n    * @return true if a new baseline was persisted.\n    * @throws HelixException if the method failed to persist the baseline.\n    */\n-  // TODO: Enhance the return value so it is more intuitive to understand when the persist fails and\n-  // TODO: when it is skipped.\n   public synchronized boolean persistBaseline(Map<String, ResourceAssignment> globalBaseline) {\n-    // TODO: Make the write async?\n-    // If baseline hasn't changed, skip writing to metadata store\n-    if (compareAssignments(_globalBaseline, globalBaseline)) {\n-      return false;\n-    }\n-    // Persist to ZK\n-    HelixProperty combinedAssignments = combineAssignments(BASELINE_KEY, globalBaseline);\n-    try {\n-      _dataAccessor.compressedBucketWrite(_baselinePath, combinedAssignments);\n-    } catch (IOException e) {\n-      // TODO: Improve failure handling\n-      throw new HelixException(\"Failed to persist baseline!\", e);\n-    }\n-\n-    // Update the in-memory reference\n-    _globalBaseline = globalBaseline;\n-    return true;\n+    return persistAssignment(globalBaseline, getBaseline(), _baselinePath, BASELINE_KEY);\n   }\n \n   /**\n    * @return true if a new best possible assignment was persisted.\n    * @throws HelixException if the method failed to persist the baseline.\n    */\n-  // TODO: Enhance the return value so it is more intuitive to understand when the persist fails and\n-  // TODO: when it is skipped.\n   public synchronized boolean persistBestPossibleAssignment(\n       Map<String, ResourceAssignment> bestPossibleAssignment) {\n+    return persistAssignment(bestPossibleAssignment, getBestPossibleAssignment(), _bestPossiblePath,\n+        BEST_POSSIBLE_KEY);\n+  }\n+\n+  public synchronized void clearAssignmentMetadata() {\n+    persistAssignment(Collections.emptyMap(), getBaseline(), _baselinePath, BASELINE_KEY);\n+    persistAssignment(Collections.emptyMap(), getBestPossibleAssignment(), _bestPossiblePath,\n+        BEST_POSSIBLE_KEY);\n+  }\n+\n+  /**\n+   * @param newAssignment\n+   * @param cachedAssignment\n+   * @param path the path of the assignment record\n+   * @param key  the key of the assignment in the record\n+   * @return true if a new assignment was persisted.\n+   */\n+  // TODO: Enhance the return value so it is more intuitive to understand when the persist fails and\n+  // TODO: when it is skipped.\n+  private boolean persistAssignment(Map<String, ResourceAssignment> newAssignment,\n+      Map<String, ResourceAssignment> cachedAssignment, String path,\n+      String key) {\n     // TODO: Make the write async?\n-    // If bestPossibleAssignment hasn't changed, skip writing to metadata store\n-    if (compareAssignments(_bestPossibleAssignment, bestPossibleAssignment)) {\n+    // If the assignment hasn't changed, skip writing to metadata store\n+    if (compareAssignments(cachedAssignment, newAssignment)) {\n       return false;\n     }\n     // Persist to ZK\n-    HelixProperty combinedAssignments =\n-        combineAssignments(BEST_POSSIBLE_KEY, bestPossibleAssignment);\n+    HelixProperty combinedAssignments = combineAssignments(key, newAssignment);\n     try {\n-      _dataAccessor.compressedBucketWrite(_bestPossiblePath, combinedAssignments);\n+      _dataAccessor.compressedBucketWrite(path, combinedAssignments);\n     } catch (IOException e) {\n       // TODO: Improve failure handling\n-      throw new HelixException(\"Failed to persist BestPossibleAssignment!\", e);\n+      throw new HelixException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e11aa5b4c6077268898310161faedecde189cd0"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDMyNjIy", "url": "https://github.com/apache/helix/pull/1123#pullrequestreview-440432622", "createdAt": "2020-06-30T22:36:12Z", "commit": {"oid": "1e11aa5b4c6077268898310161faedecde189cd0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4527, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}