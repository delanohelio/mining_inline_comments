{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3OTg5ODUw", "number": 788, "title": "Implement request forwarding for ZkRoutingDataWriter", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #778 , #794 , #795 , #800 , #801\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nBecause of the single-writer design for ZkRoutingDataWriter, we are utilizing ZkDistributedLeaderElection to choose a leader instance and non-leaders will forward write requests to the leader. This PR:\n\nimplements the logic for request forwarding;\nchanges the current MSDS endpoints behaviors such that the endpoints now respect the return values of underlying methods (previously, if the underlying methods return false, the endpoints will still return OK which is not desirable);\nenables the previously disabled MSDS endpoints tests;\nfixes TestMetadataStoreDirectoryAccessor to allow tests to be run in leader mode (the previous version disallows tests to be run in leader mode);\nfixes 2 bugs that break endpoionts tests (#794, #795);\nadds unit tests for follower situations in TestZkRoutingDataWriter, which uncovers a bug on leader election that causes null pointer for followers (#801, fixed);\nmakes ZkMetadataStoreDirectory singleton (#800);\nadded integration tests for the entire flow.\n\nTests\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n[INFO] Tests run: 131, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 24.278 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 131, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  52.393 s\n[INFO] Finished at: 2020-02-25T18:48:33-08:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-20T21:44:43Z", "url": "https://github.com/apache/helix/pull/788", "merged": true, "mergeCommit": {"oid": "7804319c5456ca27183f43212f461592010e3aaa"}, "closed": true, "closedAt": "2020-02-27T01:21:45Z", "author": {"login": "NealSun96"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGSpzpgFqTM2MjI2NDU5OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIQ3F8AH2gAyMzc3OTg5ODUwOjFhMDgyNzliNmU2YjIzNTViZTZmMmUyYjlhMWY3ZjI2ZjQ1ZDc3Nzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjY0NTk5", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-362264599", "createdAt": "2020-02-20T21:59:19Z", "commit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMTo1OToxOVrOFskmqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoxMzozMVrOFsk_LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTM4Nw==", "bodyText": "Can we refactor this out into a private method getCurrentLeaderEndpoint()? That will make the code more readable and reduce duplication.", "url": "https://github.com/apache/helix/pull/788#discussion_r382281387", "createdAt": "2020-02-20T21:59:19Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTk4Mg==", "bodyText": "What's the point of recording \"\"? Do you really need the ternary operator in this case?", "url": "https://github.com/apache/helix/pull/788#discussion_r382281982", "createdAt": "2020-02-20T22:00:38Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NDg5NA==", "bodyText": "See above - refactor!", "url": "https://github.com/apache/helix/pull/788#discussion_r382284894", "createdAt": "2020-02-20T22:07:08Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTE1Nw==", "bodyText": "Could we configure a timeout for these requests?\nhttps://www.baeldung.com/httpclient-timeout\nSomething like 1 minute sounds reasonable. Make that 1 minute a constant somewhere and you could use it throughout.", "url": "https://github.com/apache/helix/pull/788#discussion_r382285157", "createdAt": "2020-02-20T22:07:43Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTY3MA==", "bodyText": "Why is the ternary necessary?\nDid you meant to have a log msg like:\n\"the forwarded request to leader has failed for deleteMetadataStoreRealm:  \"?", "url": "https://github.com/apache/helix/pull/788#discussion_r382285670", "createdAt": "2020-02-20T22:08:53Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NjAyNg==", "bodyText": "refactor?", "url": "https://github.com/apache/helix/pull/788#discussion_r382286026", "createdAt": "2020-02-20T22:09:42Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -136,7 +180,23 @@ public synchronized boolean addShardingKey(String realm, String shardingKey) {\n       return true;\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm\n+            + \"/sharding-keys/\" + shardingKey;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NjI4NA==", "bodyText": "Nit: \"failed\"", "url": "https://github.com/apache/helix/pull/788#discussion_r382286284", "createdAt": "2020-02-20T22:10:18Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -225,6 +302,11 @@ public synchronized boolean setRoutingData(Map<String, List<String>> routingData\n   @Override\n   public synchronized void close() {\n     _zkClient.close();\n+    try {\n+      _forwardHttpClient.close();\n+    } catch (IOException e) {\n+      LOG.error(\"HttpClient fails to close. \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg==", "bodyText": "Where are you throwing an IllegalStateException?", "url": "https://github.com/apache/helix/pull/788#discussion_r382286772", "createdAt": "2020-02-20T22:11:27Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -90,9 +90,13 @@ public Response getAllMetadataStoreRealms() {\n   @Path(\"/metadata-store-realms/{realm}\")\n   public Response addMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n     try {\n-      _metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm);\n+      if (!_metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm)) {\n+        return serverError();\n+      }\n     } catch (IllegalArgumentException ex) {\n       return notFound(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzU5MA==", "bodyText": "Nit: rename to MSDS_SERVER_HOSTNAME_KEY?\nAnd for the actual value, let's use \"msds_hostname\" so it doesn't conflict with some general \"instance_hostname\" key.", "url": "https://github.com/apache/helix/pull/788#discussion_r382287590", "createdAt": "2020-02-20T22:13:21Z", "author": {"login": "narendly"}, "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -37,5 +37,6 @@\n   // Field name in JSON REST response of getting sharding keys.\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n-\n+  // The key for system properties that contains the hostname of an instance\n+  public static final String HOSTNAME_SYSTEM_PROPERTY_KEY = \"instance_hostname\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzY2MA==", "bodyText": "hostname of the MSDS server instance", "url": "https://github.com/apache/helix/pull/788#discussion_r382287660", "createdAt": "2020-02-20T22:13:31Z", "author": {"login": "narendly"}, "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -37,5 +37,6 @@\n   // Field name in JSON REST response of getting sharding keys.\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n-\n+  // The key for system properties that contains the hostname of an instance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/ad07262cd6d99f7c9771a5768f466bb08d278be9", "committedDate": "2020-02-20T21:41:29Z", "message": "revert to notFound"}, "afterCommit": {"oid": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "committedDate": "2020-02-20T23:32:44Z", "message": "revert to notFound"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzA3MDc0", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-362307074", "createdAt": "2020-02-20T23:26:38Z", "commit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzoyNjozOFrOFsmtSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzo0MTozMlrOFsnDnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTg1MA==", "bodyText": "What if the property is not set in system?", "url": "https://github.com/apache/helix/pull/788#discussion_r382315850", "createdAt": "2020-02-20T23:26:38Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +71,12 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    ZNRecord myServerInfo = new ZNRecord(\n+        System.getProperty(MetadataStoreRoutingConstants.HOSTNAME_SYSTEM_PROPERTY_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjYxMA==", "bodyText": "I would use created code rather than the hard coded 201: easier to read and maintain", "url": "https://github.com/apache/helix/pull/788#discussion_r382316610", "createdAt": "2020-02-20T23:28:47Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTgxNw==", "bodyText": "If that\u2019s the case, I would put it in addMetadatStoreRealm or a proper place, but not here in this endpoint logic. It is not endpoint logic\u2019s responsibility to process such exception.", "url": "https://github.com/apache/helix/pull/788#discussion_r382319817", "createdAt": "2020-02-20T23:37:16Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -90,9 +90,13 @@ public Response getAllMetadataStoreRealms() {\n   @Path(\"/metadata-store-realms/{realm}\")\n   public Response addMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n     try {\n-      _metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm);\n+      if (!_metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm)) {\n+        return serverError();\n+      }\n     } catch (IllegalArgumentException ex) {\n       return notFound(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw==", "bodyText": "Can we have a message in the server error message why it fails or what the client should do? Server error is too plain.", "url": "https://github.com/apache/helix/pull/788#discussion_r382321567", "createdAt": "2020-02-20T23:41:32Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -153,9 +161,13 @@ public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n   public Response addShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n     try {\n-      _metadataStoreDirectory.addShardingKey(_namespace, realm, shardingKey);\n+      if (!_metadataStoreDirectory.addShardingKey(_namespace, realm, shardingKey)) {\n+        return serverError();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzE3ODE3", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-362317817", "createdAt": "2020-02-20T23:51:41Z", "commit": {"oid": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzo1MTo0MVrOFsnQjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzo1OTo0NlrOFsnavg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNDg3OA==", "bodyText": "+1. We could probably throw an IllegalStateException here if System.getProperty returns null.", "url": "https://github.com/apache/helix/pull/788#discussion_r382324878", "createdAt": "2020-02-20T23:51:41Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +71,12 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    ZNRecord myServerInfo = new ZNRecord(\n+        System.getProperty(MetadataStoreRoutingConstants.HOSTNAME_SYSTEM_PROPERTY_KEY));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTg1MA=="}, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTM4MA==", "bodyText": "+1. Don't we already have this as part of Helix REST? See javax.ws.rs.core.Response;?", "url": "https://github.com/apache/helix/pull/788#discussion_r382325380", "createdAt": "2020-02-20T23:53:06Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjYxMA=="}, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjExNw==", "bodyText": "You could do this:\nString errorMessage = \"The forwarded request from \" + (this node's hostname) + \" to leader \" + (leader's hostname) + \" has failed for addMetadataStoreRealm()!\";\nif (respEntity != null) {\n  errorMessage += \" Response: \" + EntityUtils.toString(respEntity);\n}\nLOG. error(errorMessage);", "url": "https://github.com/apache/helix/pull/788#discussion_r382326117", "createdAt": "2020-02-20T23:55:28Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTk4Mg=="}, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjM1NA==", "bodyText": "More helpful to include which host is forwarding to which leader.", "url": "https://github.com/apache/helix/pull/788#discussion_r382326354", "createdAt": "2020-02-20T23:56:12Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjQ0Mw==", "bodyText": "See above", "url": "https://github.com/apache/helix/pull/788#discussion_r382326443", "createdAt": "2020-02-20T23:56:29Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTY3MA=="}, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjU1OA==", "bodyText": "Improve logging with host name and leader host name", "url": "https://github.com/apache/helix/pull/788#discussion_r382326558", "createdAt": "2020-02-20T23:56:50Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for deleteMetadataStoreRealm\",\n+          e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzEzMg==", "bodyText": "+1. Let's make sure the MSDS server logs the errors. it would be helpful if we could include as much detail as possible including the host name, etc.", "url": "https://github.com/apache/helix/pull/788#discussion_r382327132", "createdAt": "2020-02-20T23:58:39Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -90,9 +90,13 @@ public Response getAllMetadataStoreRealms() {\n   @Path(\"/metadata-store-realms/{realm}\")\n   public Response addMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n     try {\n-      _metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm);\n+      if (!_metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm)) {\n+        return serverError();\n+      }\n     } catch (IllegalArgumentException ex) {\n       return notFound(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, "originalCommit": {"oid": "ad07262cd6d99f7c9771a5768f466bb08d278be9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzQ4Ng==", "bodyText": "Remove?", "url": "https://github.com/apache/helix/pull/788#discussion_r382327486", "createdAt": "2020-02-20T23:59:46Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -102,9 +106,13 @@ public Response addMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   @Path(\"/metadata-store-realms/{realm}\")\n   public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n     try {\n-      _metadataStoreDirectory.deleteMetadataStoreRealm(_namespace, realm);\n+      if (!_metadataStoreDirectory.deleteMetadataStoreRealm(_namespace, realm)) {\n+        return serverError();\n+      }\n     } catch (IllegalArgumentException ex) {\n       return notFound(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NjY2ODc4", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-364666878", "createdAt": "2020-02-26T07:21:31Z", "commit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNzoyMTozMVrOFugcvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNzoyMTozMVrOFugcvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDQ2MQ==", "bodyText": "Can you do\ngetInstance().init(namespace, zkAddress); here to cut down on duplicate code?", "url": "https://github.com/apache/helix/pull/788#discussion_r384310461", "createdAt": "2020-02-26T07:21:31Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -42,49 +42,77 @@\n \n \n /**\n+ * NOTE: This is a singleton class. DO NOT EXTEND!\n  * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update\n  * callback.\n  */\n public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n   private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n \n-  // TODO: enable the line below when implementation is complete\n   // The following maps' keys represent the namespace\n-  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n-  private final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n-  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n-  private final Map<String, String> _routingZkAddressMap;\n+  // NOTE: made protected for testing reasons. DO NOT MODIFY!\n+  protected final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  protected final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n+  protected final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  protected final Map<String, String> _routingZkAddressMap;\n   // <namespace, <realm, <list of sharding keys>> mappings\n-  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+  protected final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n \n-  /**\n-   * Creates a ZkMetadataStoreDirectory based on the given routing ZK addresses.\n-   * @param routingZkAddressMap (namespace, routing ZK connect string)\n-   * @throws InvalidRoutingDataException\n-   */\n-  public ZkMetadataStoreDirectory(Map<String, String> routingZkAddressMap)\n+  private static volatile ZkMetadataStoreDirectory _zkMetadataStoreDirectoryInstance;\n+\n+  public static ZkMetadataStoreDirectory getInstance() {\n+    if (_zkMetadataStoreDirectoryInstance == null) {\n+      synchronized (ZkMetadataStoreDirectory.class) {\n+        if (_zkMetadataStoreDirectoryInstance == null) {\n+          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n+        }\n+      }\n+    }\n+\n+    return _zkMetadataStoreDirectoryInstance;\n+  }\n+\n+  public static ZkMetadataStoreDirectory getInstance(String namespace, String zkAddress)\n       throws InvalidRoutingDataException {\n-    if (routingZkAddressMap == null || routingZkAddressMap.isEmpty()) {\n-      throw new InvalidRoutingDataException(\"Routing ZK Addresses given are invalid!\");\n+    if (_zkMetadataStoreDirectoryInstance == null) {\n+      synchronized (ZkMetadataStoreDirectory.class) {\n+        if (_zkMetadataStoreDirectoryInstance == null) {\n+          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n+        }\n+      }\n     }\n-    _routingDataReaderMap = new HashMap<>();\n-    _routingDataWriterMap = new HashMap<>();\n-    _routingZkAddressMap = routingZkAddressMap;\n+    _zkMetadataStoreDirectoryInstance.init(namespace, zkAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NjY3NTQ5", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-364667549", "createdAt": "2020-02-26T07:23:05Z", "commit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "state": "COMMENTED", "comments": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNzoyMzowNVrOFugesA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNzo1NDozMFrOFuhH7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDk2MA==", "bodyText": "Remove print statements? We want to avoid this kind of stuff in production code.", "url": "https://github.com/apache/helix/pull/788#discussion_r384310960", "createdAt": "2020-02-26T07:23:05Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -40,8 +52,11 @@\n   private final String _namespace;\n   private final HelixZkClient _zkClient;\n   private final ZkDistributedLeaderElection _leaderElection;\n+  private final CloseableHttpClient _forwardHttpClient;\n+  private final String _myHostName;\n \n   public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    System.out.println(\"writer created namespace=\" + namespace + \" zkAddress=\" + zkAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTIwNg==", "bodyText": "Also include the check: _myHostName.isEmpty()", "url": "https://github.com/apache/helix/pull/788#discussion_r384311206", "createdAt": "2020-02-26T07:23:48Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +77,21 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTU2MA==", "bodyText": "Let's make this a Java constant so that we could make this configurable later.\nprivate static final int HTTP_REQUEST_TIMEOUT = 60;", "url": "https://github.com/apache/helix/pull/788#discussion_r384311560", "createdAt": "2020-02-26T07:24:46Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +77,21 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null) {\n+      throw new IllegalStateException(\n+          \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n+              + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n+    }\n+    ZNRecord myServerInfo = new ZNRecord(_myHostName);\n+\n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+\n+    int timeout = 60; // seconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjM0MA==", "bodyText": "Generally a good idea to refactor this to a private method so that it's easier to read. For instance, create private String getUrlSuffix()\nSome of these string literals have already been defined in MetadataStoreDirectoryConstants.java. Could you use the constants there please?", "url": "https://github.com/apache/helix/pull/788#discussion_r384312340", "createdAt": "2020-02-26T07:27:16Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,8 +103,9 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzA0MQ==", "bodyText": "Same here, let's make these String constants.\nI believe \"addMetadataStoreRealm\" should come from MetadataStoreDirectoryConstants.\n\"put\" could be a private enum called\nenum RequestForwardingHttpVerbs {\n    PUT,\n    POST,\n    DELETE\n}\n``` something like this.", "url": "https://github.com/apache/helix/pull/788#discussion_r384313041", "createdAt": "2020-02-26T07:29:26Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,8 +103,9 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzE0Mg==", "bodyText": "Refactor into a private method.", "url": "https://github.com/apache/helix/pull/788#discussion_r384313142", "createdAt": "2020-02-26T07:29:45Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -87,11 +114,12 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      return deleteZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzI3Ng==", "bodyText": "Use constants. No magic string literals floating around the code.", "url": "https://github.com/apache/helix/pull/788#discussion_r384313276", "createdAt": "2020-02-26T07:30:08Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -87,11 +114,12 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      return deleteZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteMetadataStoreRealm\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzQzOQ==", "bodyText": "Replace string literals.", "url": "https://github.com/apache/helix/pull/788#discussion_r384313439", "createdAt": "2020-02-26T07:30:41Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -100,44 +128,14 @@ public synchronized boolean addShardingKey(String realm, String shardingKey) {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      // If the realm does not exist already, then create the realm\n-      String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n-      if (!_zkClient.exists(realmPath)) {\n-        // Create the realm\n-        if (!createZkRealm(realm)) {\n-          // Failed to create the realm - log and return false\n-          LOG.error(\n-              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n-              _namespace, realm, shardingKey);\n-          return false;\n-        }\n-      }\n-\n-      // Add the sharding key to an empty ZNRecord\n-      ZNRecord znRecord;\n-      try {\n-        znRecord = _zkClient.readData(realmPath);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n-          Collections.singletonList(shardingKey));\n-      try {\n-        _zkClient.writeData(realmPath, znRecord);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      return true;\n+      return createZkShardingKey(realm, shardingKey);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix =\n+        \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm + \"/sharding-keys/\"\n+            + shardingKey;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addShardingKey\",\n+        Response.Status.CREATED.getStatusCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzUyMw==", "bodyText": "String literals.", "url": "https://github.com/apache/helix/pull/788#discussion_r384313523", "createdAt": "2020-02-26T07:30:53Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -146,31 +144,14 @@ public synchronized boolean deleteShardingKey(String realm, String shardingKey)\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      ZNRecord znRecord =\n-          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n-      if (znRecord == null || !znRecord\n-          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .contains(shardingKey)) {\n-        // This realm does not exist or shardingKey doesn't exist. Return true!\n-        return true;\n-      }\n-      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .remove(shardingKey);\n-      // Overwrite this ZNRecord with the sharding key removed\n-      try {\n-        _zkClient\n-            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      return true;\n+      return deleteZkShardingKey(realm, shardingKey);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix =\n+        \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm + \"/sharding-keys/\"\n+            + shardingKey;\n+    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteShardingKey\",\n+        Response.Status.OK.getStatusCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDE0Nw==", "bodyText": "Use an enum here instead of String literals.", "url": "https://github.com/apache/helix/pull/788#discussion_r384314147", "createdAt": "2020-02-26T07:32:50Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +235,119 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n+      int expectedResponseCode) throws IllegalArgumentException {\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + url_suffix;\n+    System.out.println(url);\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDQzMQ==", "bodyText": "Also a good idea to log the response code.", "url": "https://github.com/apache/helix/pull/788#discussion_r384314431", "createdAt": "2020-02-26T07:33:40Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +235,119 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n+      int expectedResponseCode) throws IllegalArgumentException {\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + url_suffix;\n+    System.out.println(url);\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n+    }\n+\n+    return sendRequestToLeader(request, expectedResponseCode, endPoint, leaderHostName);\n+  }\n+\n+  // Set to be protected for testing purposes\n+  protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n+      String endPoint, String leaderHostName) {\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(request);\n+      if (response.getStatusLine().getStatusCode() != expectedResponseCode) {\n+        HttpEntity respEntity = response.getEntity();\n+        String errorLog =\n+            \"The forwarded request to leader has failed for \" + endPoint + \". Current hostname: \"\n+                + _myHostName + \" Leader hostname: \" + leaderHostName;\n+        if (respEntity != null) {\n+          errorLog += \" Response: \" + EntityUtils.toString(respEntity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDQ5Mw==", "bodyText": "Remove empty line?", "url": "https://github.com/apache/helix/pull/788#discussion_r384314493", "createdAt": "2020-02-26T07:33:53Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +235,119 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n+      int expectedResponseCode) throws IllegalArgumentException {\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + url_suffix;\n+    System.out.println(url);\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n+    }\n+\n+    return sendRequestToLeader(request, expectedResponseCode, endPoint, leaderHostName);\n+  }\n+\n+  // Set to be protected for testing purposes\n+  protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n+      String endPoint, String leaderHostName) {\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(request);\n+      if (response.getStatusLine().getStatusCode() != expectedResponseCode) {\n+        HttpEntity respEntity = response.getEntity();\n+        String errorLog =\n+            \"The forwarded request to leader has failed for \" + endPoint + \". Current hostname: \"\n+                + _myHostName + \" Leader hostname: \" + leaderHostName;\n+        if (respEntity != null) {\n+          errorLog += \" Response: \" + EntityUtils.toString(respEntity);\n+        }\n+        LOG.error(errorLog);\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\n+          \"The forwarded request to leader raised an exception for {}. Current hostname: {} Leader hostname: {}\",\n+          endPoint, _myHostName, leaderHostName, e);\n+      return false;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDc4Mw==", "bodyText": "Nit: \"Initialize\" would the the term.", "url": "https://github.com/apache/helix/pull/788#discussion_r384314783", "createdAt": "2020-02-26T07:34:48Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -64,6 +66,8 @@ public ServerContext(String zkAddr) {\n     // cannot be started correctly.\n     _helixDataAccessorPool = new HashMap<>();\n     _taskDriverPool = new HashMap<>();\n+    // Initiate the singleton ZkMetadataStoreDirectory instance to allow it to be closed later", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTE0NA==", "bodyText": "Could you add some comments about the Jersey behavior here for reference as a block comment?", "url": "https://github.com/apache/helix/pull/788#discussion_r384315144", "createdAt": "2020-02-26T07:35:56Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -152,8 +155,13 @@ public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n   @Path(\"/metadata-store-realms/{realm}/sharding-keys/{sharding-key: .+}\")\n   public Response addShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n+    if (shardingKey.charAt(0) != '/') {\n+      shardingKey = \"/\" + shardingKey;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTMzMg==", "bodyText": "Now this is duplicate code. Could you refactor this out to a private method? You could explain the JAX-RS behavior around slashes there.", "url": "https://github.com/apache/helix/pull/788#discussion_r384315332", "createdAt": "2020-02-26T07:36:26Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -165,8 +173,13 @@ public Response addShardingKey(@PathParam(\"realm\") String realm,\n   @Path(\"/metadata-store-realms/{realm}/sharding-keys/{sharding-key: .+}\")\n   public Response deleteShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n+    if (shardingKey.charAt(0) != '/') {\n+      shardingKey = \"/\" + shardingKey;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg==", "bodyText": "Also add here that the reason we are not putting this in the test package is because the Jersey framework does not recognize resources in the test package when it spins up servers.", "url": "https://github.com/apache/helix/pull/788#discussion_r384315906", "createdAt": "2020-02-26T07:38:07Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjE0OA==", "bodyText": "Static boolean -> make it all caps?", "url": "https://github.com/apache/helix/pull/788#discussion_r384316148", "createdAt": "2020-02-26T07:38:49Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjM0MA==", "bodyText": "Do not leave any stacktraces here. Let's use LOG.error(...)", "url": "https://github.com/apache/helix/pull/788#discussion_r384316340", "createdAt": "2020-02-26T07:39:31Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;\n+  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n+  public static MetadataStoreDirectory _mockMSDInstance;\n+\n+  /**\n+   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n+   */\n+  @Override\n+  protected void buildMetadataStoreDirectory(String namespace, String address) {\n+    try {\n+      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n+      _mockMSDInstance = _metadataStoreDirectory;\n+    } catch (InvalidRoutingDataException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjQzMQ==", "bodyText": "Not impossible, but difficult. You're making it happen here ;)", "url": "https://github.com/apache/helix/pull/788#discussion_r384316431", "createdAt": "2020-02-26T07:39:50Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;\n+  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n+  public static MetadataStoreDirectory _mockMSDInstance;\n+\n+  /**\n+   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n+   */\n+  @Override\n+  protected void buildMetadataStoreDirectory(String namespace, String address) {\n+    try {\n+      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n+      _mockMSDInstance = _metadataStoreDirectory;\n+    } catch (InvalidRoutingDataException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n+   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjk2MQ==", "bodyText": "Could you create an issue and link that issue here as a TODO? The TODO should talk about how you should make this a configurable thing where developers could just feed in configs (like # of servers and names of resources to be included) to start multiple mock server instances. The purpose is to test features that involve multiple servers (like distributed leader election, distributed locking, etc.)", "url": "https://github.com/apache/helix/pull/788#discussion_r384316961", "createdAt": "2020-02-26T07:41:21Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzI4OA==", "bodyText": "Nit: Should you clear the maps?", "url": "https://github.com/apache/helix/pull/788#discussion_r384317288", "createdAt": "2020-02-26T07:42:19Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;\n+  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n+  public static MetadataStoreDirectory _mockMSDInstance;\n+\n+  /**\n+   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n+   */\n+  @Override\n+  protected void buildMetadataStoreDirectory(String namespace, String address) {\n+    try {\n+      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n+      _mockMSDInstance = _metadataStoreDirectory;\n+    } catch (InvalidRoutingDataException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n+   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,\n+   * therefore this is the only way to create another instance.\n+   */\n+  class MockZkMetadataStoreDirectory extends ZkMetadataStoreDirectory {\n+    MockZkMetadataStoreDirectory(String namespace, String zkAddress)\n+        throws InvalidRoutingDataException {\n+      super();\n+\n+      // Manually populate the map so that MockZkRoutingDataWriter can be passed in\n+      _routingZkAddressMap.put(namespace, zkAddress);\n+      _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n+      _routingDataWriterMap.put(namespace, new MockZkRoutingDataWriter(namespace, zkAddress));\n+      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      _routingDataMap.put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n+    }\n+\n+    @Override\n+    public void close() {\n+      _routingDataReaderMap.values().forEach(MetadataStoreRoutingDataReader::close);\n+      _routingDataWriterMap.values().forEach(MetadataStoreRoutingDataWriter::close);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzgwOA==", "bodyText": "Nit: MockZkRoutingDataWriter so there's no ambiguity?", "url": "https://github.com/apache/helix/pull/788#discussion_r384317808", "createdAt": "2020-02-26T07:43:47Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -40,15 +41,35 @@\n   private static final String DUMMY_SHARDING_KEY = \"SHARDING_KEY\";\n   private MetadataStoreRoutingDataWriter _zkRoutingDataWriter;\n \n+  // MockWriter is used for testing request forwarding features in non-leader situations\n+  class MockWriter extends ZkRoutingDataWriter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODIwNw==", "bodyText": "Shouldn't you make the HTTP call? Otherwise you won't be covering distributed leader election? I think we should make the HTTP call here to the leader. Otherwise it's not a true integration test.\nOr is this meant to be a unit test?", "url": "https://github.com/apache/helix/pull/788#discussion_r384318207", "createdAt": "2020-02-26T07:44:56Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -40,15 +41,35 @@\n   private static final String DUMMY_SHARDING_KEY = \"SHARDING_KEY\";\n   private MetadataStoreRoutingDataWriter _zkRoutingDataWriter;\n \n+  // MockWriter is used for testing request forwarding features in non-leader situations\n+  class MockWriter extends ZkRoutingDataWriter {\n+    HttpUriRequest calledRequest;\n+\n+    MockWriter(String namespace, String zkAddress) {\n+      super(namespace, zkAddress);\n+    }\n+\n+    // This method does not call super() because the http call should not be actually made\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAzOQ==", "bodyText": "Why do you need to create a new HashSet out of a set?\nYou could probably return Collections.unmodifiableSet(....keySet()) as well if you want to prevent modifications", "url": "https://github.com/apache/helix/pull/788#discussion_r384319039", "createdAt": "2020-02-26T07:47:21Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/MetadataStoreDirectoryAccessorTestBase.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+\n+\n+public class MetadataStoreDirectoryAccessorTestBase extends AbstractTestClass {\n+  /*\n+   * The following are constants to be used for testing.\n+   */\n+  protected static final String TEST_NAMESPACE_URI_PREFIX = \"/namespaces/\" + TEST_NAMESPACE;\n+  protected static final String NON_EXISTING_NAMESPACE_URI_PREFIX =\n+      \"/namespaces/not-existed-namespace/metadata-store-realms/\";\n+  protected static final String TEST_REALM_1 = \"testRealm1\";\n+  protected static final List<String> TEST_SHARDING_KEYS_1 =\n+      Arrays.asList(\"/sharding/key/1/a\", \"/sharding/key/1/b\", \"/sharding/key/1/c\");\n+  protected static final String TEST_REALM_2 = \"testRealm2\";\n+  protected static final List<String> TEST_SHARDING_KEYS_2 =\n+      Arrays.asList(\"/sharding/key/1/d\", \"/sharding/key/1/e\", \"/sharding/key/1/f\");\n+  protected static final String TEST_REALM_3 = \"testRealm3\";\n+  protected static final String TEST_SHARDING_KEY = \"/sharding/key/1/x\";\n+\n+  // List of all ZK addresses, each of which corresponds to a namespace/routing ZK\n+  protected List<String> _zkList;\n+  protected MetadataStoreRoutingDataReader _routingDataReader;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    _zkList = new ArrayList<>(ZK_SERVER_MAP.keySet());\n+\n+    deleteRoutingDataPath();\n+\n+    // Write dummy mappings in ZK\n+    // Create a node that represents a realm address and add 3 sharding keys to it\n+    ZNRecord znRecord = new ZNRecord(\"RoutingInfo\");\n+\n+    _zkList.forEach(zk -> {\n+      ZK_SERVER_MAP.get(zk).getZkClient().setZkSerializer(new ZNRecordSerializer());\n+      // Write first realm and sharding keys pair\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          TEST_SHARDING_KEYS_1);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_1,\n+              true);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_1,\n+              znRecord);\n+\n+      // Create another realm and sharding keys pair\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          TEST_SHARDING_KEYS_2);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_2,\n+              true);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_2,\n+              znRecord);\n+    });\n+\n+    _routingDataReader = new ZkRoutingDataReader(TEST_NAMESPACE, _zkAddrTestNS, null);\n+\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY,\n+        getBaseUri().toString());\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    System.clearProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    deleteRoutingDataPath();\n+  }\n+\n+  protected void deleteRoutingDataPath() throws Exception {\n+    Assert.assertTrue(TestHelper.verify(() -> {\n+      _zkList.forEach(zk -> ZK_SERVER_MAP.get(zk).getZkClient()\n+          .deleteRecursively(MetadataStoreRoutingConstants.ROUTING_DATA_PATH));\n+\n+      for (String zk : _zkList) {\n+        if (ZK_SERVER_MAP.get(zk).getZkClient()\n+            .exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }, TestHelper.WAIT_DURATION), \"Routing data path should be deleted after the tests.\");\n+  }\n+\n+  protected Set<String> getAllMetadataStoreRealmsHelper() throws InvalidRoutingDataException {\n+    return new HashSet<>(_routingDataReader.getRoutingData().keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTI1NA==", "bodyText": "Avoid static imports. Just qualify with \"MetadataStoreRoutingConstants.\"", "url": "https://github.com/apache/helix/pull/788#discussion_r384319254", "createdAt": "2020-02-26T07:48:03Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTQzMg==", "bodyText": "Nit: I think TestMSDAccessorLeaderElection sounds better.", "url": "https://github.com/apache/helix/pull/788#discussion_r384319432", "createdAt": "2020-02-26T07:48:32Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTU5Ng==", "bodyText": "private static final String is how you declare a constant.", "url": "https://github.com/apache/helix/pull/788#discussion_r384319596", "createdAt": "2020-02-26T07:49:00Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDE5MQ==", "bodyText": "We see a lot of getPort() + 1's here. Let's just create a new variable,\nint newPort = getPort() + 1; and use newPort throughout? This will make your code more readable.", "url": "https://github.com/apache/helix/pull/788#discussion_r384320191", "createdAt": "2020-02-26T07:50:45Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDMyMQ==", "bodyText": "LOG.error instead of printing stacktrace please.", "url": "https://github.com/apache/helix/pull/788#discussion_r384320321", "createdAt": "2020-02-26T07:51:04Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDczNw==", "bodyText": "\"put\" could be an enum.", "url": "https://github.com/apache/helix/pull/788#discussion_r384320737", "createdAt": "2020-02-26T07:52:15Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n+    // it didn't exist yet.\n+    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // Set the new uri to be used in leader election\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n+\n+    // Start http client for testing\n+    _httpClient = HttpClients.createDefault();\n+\n+    // Start zkclient to verify leader election behavior\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+    _mockHelixRestServer.shutdown();\n+    _httpClient.close();\n+    _zkClient.close();\n+  }\n+\n+  @Test\n+  public void testAddMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n+        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDc3Mg==", "bodyText": "Use enum for \"delete\"", "url": "https://github.com/apache/helix/pull/788#discussion_r384320772", "createdAt": "2020-02-26T07:52:23Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n+    // it didn't exist yet.\n+    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // Set the new uri to be used in leader election\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n+\n+    // Start http client for testing\n+    _httpClient = HttpClients.createDefault();\n+\n+    // Start zkclient to verify leader election behavior\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+    _mockHelixRestServer.shutdown();\n+    _httpClient.close();\n+    _zkClient.close();\n+  }\n+\n+  @Test\n+  public void testAddMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n+        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n+        Response.Status.CREATED.getStatusCode());\n+    expectedRealmsSet.add(TEST_REALM_3);\n+    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n+  public void testDeleteMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMTUxOA==", "bodyText": "Enum!", "url": "https://github.com/apache/helix/pull/788#discussion_r384321518", "createdAt": "2020-02-26T07:54:30Z", "author": {"login": "narendly"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n+    // it didn't exist yet.\n+    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // Set the new uri to be used in leader election\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n+\n+    // Start http client for testing\n+    _httpClient = HttpClients.createDefault();\n+\n+    // Start zkclient to verify leader election behavior\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+    _mockHelixRestServer.shutdown();\n+    _httpClient.close();\n+    _zkClient.close();\n+  }\n+\n+  @Test\n+  public void testAddMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n+        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n+        Response.Status.CREATED.getStatusCode());\n+    expectedRealmsSet.add(TEST_REALM_3);\n+    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n+  public void testDeleteMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n+        Response.Status.OK.getStatusCode());\n+    expectedRealmsSet.remove(TEST_REALM_3);\n+    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n+  public void testAddShardingKeyRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n+    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n+        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n+    sendRequestAndValidate(\n+        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n+        Response.Status.CREATED.getStatusCode());\n+    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n+    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n+  public void testDeleteShardingKeyRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n+    sendRequestAndValidate(\n+        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n+        Response.Status.OK.getStatusCode());\n+    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n+    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  private void sendRequestAndValidate(String url_suffix, String request_method,\n+      int expectedResponseCode) throws IllegalArgumentException, IOException {\n+    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11590ba901e970e4298b9515e7514e9f61d42f84"}, "originalPosition": 175}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/f77c181059e08811faa96e3b0ed242d3ca78ef8f", "committedDate": "2020-02-26T18:08:29Z", "message": "implement request forwarding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b00953af8a4c2d64b00d10d900516a300a287ce", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/2b00953af8a4c2d64b00d10d900516a300a287ce", "committedDate": "2020-02-26T18:08:29Z", "message": "revert to notFound"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd396337b593ea4172e7b895fa4355214e322e54", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/bd396337b593ea4172e7b895fa4355214e322e54", "committedDate": "2020-02-26T18:13:37Z", "message": "fix existing bugs and make accessor tests work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "committedDate": "2020-02-26T18:14:11Z", "message": "address comments, add tests, convert MSD to singleton, fix leader election"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "798fd3d3251c43f80074b161da1f0d54bbef4f48", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/798fd3d3251c43f80074b161da1f0d54bbef4f48", "committedDate": "2020-02-26T18:17:40Z", "message": "add integration tests, modify sharding keys endpoint, correct writer forwarding behavior"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "committedDate": "2020-02-26T18:17:40Z", "message": "address first comments, need to rebase"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e0012bbab82fee7109fd3137aaa86ee78b282a3c", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/e0012bbab82fee7109fd3137aaa86ee78b282a3c", "committedDate": "2020-02-26T17:52:23Z", "message": "address first comments, need to rebase"}, "afterCommit": {"oid": "54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "committedDate": "2020-02-26T18:17:40Z", "message": "address first comments, need to rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/b8e14234b348fd4059a374468691d87d6a4a88b8", "committedDate": "2020-02-26T20:22:14Z", "message": "address many comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjQwNDA0", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-365240404", "createdAt": "2020-02-26T21:04:21Z", "commit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTowNDoyMVrOFu8JJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTowNDoyMVrOFu8JJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NDE5Nw==", "bodyText": "Is there a reason why you couldn't include * 1000 in the constant itself?", "url": "https://github.com/apache/helix/pull/788#discussion_r384764197", "createdAt": "2020-02-26T21:04:21Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +77,24 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null || _myHostName.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n+              + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n+    }\n+    ZNRecord myServerInfo = new ZNRecord(_myHostName);\n+\n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+\n+    RequestConfig config = RequestConfig.custom()\n+        .setConnectTimeout(MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)\n+        .setConnectionRequestTimeout(\n+            MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)\n+        .setSocketTimeout(MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjQyMjM0", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-365242234", "createdAt": "2020-02-26T21:07:19Z", "commit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTowNzoyMFrOFu8OvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTowNzoyMFrOFu8OvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NTYyOA==", "bodyText": "If you want these HTTP verbs included in MetadataStoreRoutingConstants , you could use a more generalized name like HttpVerbs.  HttpRequestForwardingVerbs if you want to keep it as an enum in this class.\nIf you want to generalize and put this in MetadataStoreRoutingConstants, then I'm pretty sure you could already find the supported HTTP verb enum somewhere defined in helix-rest module. Use that instead.", "url": "https://github.com/apache/helix/pull/788#discussion_r384765628", "createdAt": "2020-02-26T21:07:20Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,8 +106,11 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String urlSuffix =\n+        constructUrlSuffix(MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, realm);\n+    return forwardRequestToLeader(urlSuffix,\n+        MetadataStoreRoutingConstants.HttpRequestForwardingVerbs.PUT, \"addMetadataStoreRealm\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjQyODI2", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-365242826", "createdAt": "2020-02-26T21:08:17Z", "commit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTowODoxOFrOFu8QmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTowODoxOFrOFu8QmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NjEwNQ==", "bodyText": "I still see a string literal here?", "url": "https://github.com/apache/helix/pull/788#discussion_r384766105", "createdAt": "2020-02-26T21:08:18Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -146,31 +152,15 @@ public synchronized boolean deleteShardingKey(String realm, String shardingKey)\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      ZNRecord znRecord =\n-          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n-      if (znRecord == null || !znRecord\n-          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .contains(shardingKey)) {\n-        // This realm does not exist or shardingKey doesn't exist. Return true!\n-        return true;\n-      }\n-      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .remove(shardingKey);\n-      // Overwrite this ZNRecord with the sharding key removed\n-      try {\n-        _zkClient\n-            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      return true;\n+      return deleteZkShardingKey(realm, shardingKey);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String urlSuffix =\n+        constructUrlSuffix(MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, realm,\n+            MetadataStoreRoutingConstants.MSDS_GET_ALL_SHARDING_KEYS_ENDPOINT, shardingKey);\n+    return forwardRequestToLeader(urlSuffix,\n+        MetadataStoreRoutingConstants.HttpRequestForwardingVerbs.DELETE, \"deleteShardingKey\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "originalPosition": 186}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjQ0Mjk2", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-365244296", "createdAt": "2020-02-26T21:10:28Z", "commit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxMDoyOFrOFu8VJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxMDoyOFrOFu8VJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzI2OQ==", "bodyText": "Do not rely on this behavior. Let's make sure this method creates a valid URL. Would you be okay with this failing when we swap out the HTTP client we're using right now with a different one?\nDo you think making this assumption is hacky? Could we improve it?", "url": "https://github.com/apache/helix/pull/788#discussion_r384767269", "createdAt": "2020-02-26T21:10:28Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +244,126 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient.writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private String constructUrlSuffix(String... urlParams) {\n+    List<String> allUrlParameters = new ArrayList<>(\n+        Arrays.asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, _namespace));\n+    allUrlParameters.addAll(Arrays.asList(urlParams));\n+    // HttpUriRequest will convert all double slashes to single slashes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "originalPosition": 289}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjUxODc3", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-365251877", "createdAt": "2020-02-26T21:22:32Z", "commit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToyMjozM1rOFu8u-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToyMjozM1rOFu8u-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mzg4Mg==", "bodyText": "If you want to do this, I think you could find HTTP verbs defined elsewhere already.", "url": "https://github.com/apache/helix/pull/788#discussion_r384773882", "createdAt": "2020-02-26T21:22:33Z", "author": {"login": "narendly"}, "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -20,6 +20,11 @@\n  */\n \n public class MetadataStoreRoutingConstants {\n+  public enum HttpRequestForwardingVerbs {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c3039213453521df2ad78afa27795e69e187dab", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/7c3039213453521df2ad78afa27795e69e187dab", "committedDate": "2020-02-27T00:00:39Z", "message": "address remaining comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4edecd6800350ac57f1d09c60f4d9fa36ab27c6", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/a4edecd6800350ac57f1d09c60f4d9fa36ab27c6", "committedDate": "2020-02-27T00:08:14Z", "message": "move mock class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzUzMjA1", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-365353205", "createdAt": "2020-02-27T01:05:25Z", "commit": {"oid": "a4edecd6800350ac57f1d09c60f4d9fa36ab27c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTowNToyNVrOFvB9cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTowNToyNVrOFvB9cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1OTUwNg==", "bodyText": "Remove empty line", "url": "https://github.com/apache/helix/pull/788#discussion_r384859506", "createdAt": "2020-02-27T01:05:25Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -42,49 +42,69 @@\n \n \n /**\n+ * NOTE: This is a singleton class. DO NOT EXTEND!\n  * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update\n  * callback.\n  */\n public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n   private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n \n-  // TODO: enable the line below when implementation is complete\n   // The following maps' keys represent the namespace\n-  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n-  private final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n-  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n-  private final Map<String, String> _routingZkAddressMap;\n+  // NOTE: made protected for testing reasons. DO NOT MODIFY!\n+  protected final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  protected final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n+  protected final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  protected final Map<String, String> _routingZkAddressMap;\n   // <namespace, <realm, <list of sharding keys>> mappings\n-  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+  protected final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+\n+  private static volatile ZkMetadataStoreDirectory _zkMetadataStoreDirectoryInstance;\n+\n+  public static ZkMetadataStoreDirectory getInstance() {\n+    if (_zkMetadataStoreDirectoryInstance == null) {\n+      synchronized (ZkMetadataStoreDirectory.class) {\n+        if (_zkMetadataStoreDirectoryInstance == null) {\n+          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n+        }\n+      }\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4edecd6800350ac57f1d09c60f4d9fa36ab27c6"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzU0NjA3", "url": "https://github.com/apache/helix/pull/788#pullrequestreview-365354607", "createdAt": "2020-02-27T01:09:42Z", "commit": {"oid": "a4edecd6800350ac57f1d09c60f4d9fa36ab27c6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a08279b6e6b2355be6f2e2b9a1f7f26f45d7779", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/1a08279b6e6b2355be6f2e2b9a1f7f26f45d7779", "committedDate": "2020-02-27T01:16:08Z", "message": "remove empty line"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4991, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}