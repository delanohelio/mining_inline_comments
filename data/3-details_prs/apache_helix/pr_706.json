{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4Nzc5NzE1", "number": 706, "title": "Implement trie routing data", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #701\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis PR is a successor to PR #682 .\nAs mentioned in the github issue, the original design of ShardingKeyTrieNode had numerous issues as revealed by the previous PR's comments, and therefore a new design is purposed and implemented. The previous design's has the following issues:\n\nSince the trie node is exposed to outside users, extra effort is necessary to prevent misuse, such as making the children unmodifiable and make zkRealmAddress getter conditionally inaccessible.\nImplementation details of the trie node are not properly obscured. For any user to iterate through the trie, the user needs to get the children mapping of a node and continue forward.\nTraversal logic is not offered as at any common place and therefore can easily lead to repetition among different users.\n\nWith the new TrieRoutingData class, the trie node is encapsulated as a private class, therefore preventing any misuse. The class offers a sufficient but restrictive set of operations that outsider users may use, and can be expanded upon if necessary. The class implements the RoutingData interface, meaning that other forms of routing data can be implemented later to substitute TrieRoutingData if necessary.\nNOTE: this PR does not complete the TrieRoutingData class. The current constructor is a placeholder (as noted in code comments) because the actual constructor is dependent on a RoutingDataAccessor class which is yet to be implemented (but is second in order). Once the accessor is complemented the constructor will be written in a separate PR.\nTests\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO] Tests run: 97, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 19.733 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 97, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  23.970 s\n[INFO] Finished at: 2020-01-29T13:30:43-08:00\n[INFO] ------------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-01-29T21:42:22Z", "url": "https://github.com/apache/helix/pull/706", "merged": true, "mergeCommit": {"oid": "bba0142305b7cb432368aa32ebf224ad5ee336a0"}, "closed": true, "closedAt": "2020-01-31T19:00:51Z", "author": {"login": "NealSun96"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6s-pNgH2gAyMzY4Nzc5NzE1OjExMjk2NTBiODkwMjZmZjdlNGY1ZTJiNWExZTMxYjY3YWNjMDljYmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_yoVYAH2gAyMzY4Nzc5NzE1OmFmZGNlNTBkNzk1ZWFkMGY5YmQ1ZWU5MTIyMzhjZjQ1M2Q1M2IzOGU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1129650b89026ff7e4f5e2b5a1e31b67acc09cbd", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/1129650b89026ff7e4f5e2b5a1e31b67acc09cbd", "committedDate": "2020-01-15T22:06:47Z", "message": "Implement sharding key prefix-tree class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6e54138b4b6bd368e951ec86c2905827bff0752", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/f6e54138b4b6bd368e951ec86c2905827bff0752", "committedDate": "2020-01-23T01:22:32Z", "message": "Rename the class to TrieNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6782d3b3bf540daf2d3ccf0641e9f93ba35e82b5", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/6782d3b3bf540daf2d3ccf0641e9f93ba35e82b5", "committedDate": "2020-01-24T00:00:44Z", "message": "Addressing all comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fb39e521e72fefcf7c278ddf4c8685b0cf1b27c", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/3fb39e521e72fefcf7c278ddf4c8685b0cf1b27c", "committedDate": "2020-01-24T22:06:03Z", "message": "Add unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e7c4eaabae6419107b36ebe236516e6f0020abe", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/9e7c4eaabae6419107b36ebe236516e6f0020abe", "committedDate": "2020-01-27T19:07:20Z", "message": "return unmodifiablemap for getter on final variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2bfabb1f77cb2eae41f1aef3b11f209ea958f41", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/b2bfabb1f77cb2eae41f1aef3b11f209ea958f41", "committedDate": "2020-01-28T01:39:22Z", "message": "adds default builder children param"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f6ea39dea83bb52c31b6658d0aeaa782e510ac9", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/4f6ea39dea83bb52c31b6658d0aeaa782e510ac9", "committedDate": "2020-01-28T20:48:16Z", "message": "change getZkRealmAddress behaviour"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f5372a1501be6fa7aec5ae99eac8e882a81b38f", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/9f5372a1501be6fa7aec5ae99eac8e882a81b38f", "committedDate": "2020-01-29T21:26:48Z", "message": "implement routing data trie"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2932775e623ae16428b291b0bf07b6ba46093ca7", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/2932775e623ae16428b291b0bf07b6ba46093ca7", "committedDate": "2020-01-29T21:44:48Z", "message": "fix formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDU2MjE0", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-350456214", "createdAt": "2020-01-29T22:02:16Z", "commit": {"oid": "2932775e623ae16428b291b0bf07b6ba46093ca7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMjowMjoxNlrOFjZFXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMjowMjoxNlrOFjZFXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1NTQ1Mg==", "bodyText": "This method is 90% the same as the findTrieNode, can we please merge them?", "url": "https://github.com/apache/helix/pull/706#discussion_r372655452", "createdAt": "2020-01-29T22:02:16Z", "author": {"login": "jiajunwang"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _zkRealmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String zkRealmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _zkRealmAddress = zkRealmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String zkPath) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(zkPath);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (zkPath.substring(zkPath.length() - 1).equals(\"/\")) {\n+      zkPath = zkPath.substring(0, zkPath.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, zkPath);\n+    return resultMap;\n+  }\n+\n+  public String getZkRealm(String zkPath) throws IllegalArgumentException {\n+    TrieNode leafNode = findLeafTrieNodeAlongPath(zkPath);\n+    return leafNode._zkRealmAddress;\n+  }\n+\n+  /**\n+   * Using the root node, find the trie node that the given zkPath is pointing to and return it.\n+   * Raise IllegalArgumentException if the zkPath does not point to any node.\n+   * @param zkPath - the zkPath where the search is conducted\n+   * @return the node pointed by the zkPath\n+   * @throws IllegalArgumentException - when the zkPath points to nothing\n+   */\n+  private TrieNode findTrieNode(String zkPath) throws IllegalArgumentException {\n+    if (zkPath.equals(\"/\") || zkPath.equals(\"\")) {\n+      return _rootNode;\n+    }\n+\n+    if (zkPath.substring(0, 1).equals(\"/\")) {\n+      zkPath = zkPath.substring(1);\n+    }\n+    String[] splitZkPath = zkPath.split(\"/\", 0);\n+    TrieNode curNode = _rootNode;\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitZkPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode != null) {\n+        curChildren = curNode._children;\n+      } else {\n+        throw new IllegalArgumentException(\"the provided zkPath is missing from the trie\");\n+      }\n+    }\n+    return curNode;\n+  }\n+\n+  /**\n+   * Using the root node, find the leaf node along the provided zkPath. Raise\n+   * IllegalArgumentException if the zkPath does not point to any node or if there is no leaf node\n+   * along the path.\n+   * @param zkPath - the zkPath where the search is conducted\n+   * @return the leaf node along the provided zkPath\n+   * @throws IllegalArgumentException - when the zkPath points to nothing or when there is no leaf\n+   *           node along the path.\n+   */\n+  private TrieNode findLeafTrieNodeAlongPath(String zkPath) throws IllegalArgumentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2932775e623ae16428b291b0bf07b6ba46093ca7"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDYzNzcx", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-350463771", "createdAt": "2020-01-29T22:16:16Z", "commit": {"oid": "2932775e623ae16428b291b0bf07b6ba46093ca7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMjoxNjoxNlrOFjZcYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMjoxNjoxNlrOFjZcYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTM0NA==", "bodyText": "Shall we just call it ZkRealmData?\nIt might be confusing because we have routing table provider for completely different usage.", "url": "https://github.com/apache/helix/pull/706#discussion_r372661344", "createdAt": "2020-01-29T22:16:16Z", "author": {"login": "jiajunwang"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/RoutingData.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface RoutingData {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2932775e623ae16428b291b0bf07b6ba46093ca7"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b704e5bcb548493fa0d62c40c6852b9360048c67", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/b704e5bcb548493fa0d62c40c6852b9360048c67", "committedDate": "2020-01-29T22:46:59Z", "message": "combine two methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc", "committedDate": "2020-01-29T23:33:01Z", "message": "remove redundant public"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNTAzOTQ1", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-350503945", "createdAt": "2020-01-29T23:50:25Z", "commit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMzo1MDoyNVrOFjbbRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMzo1Nzo1NFrOFjbkPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5MzgyOQ==", "bodyText": "As we discussed, \"MetadataStoreRoutingData\" might be more appropriate here.", "url": "https://github.com/apache/helix/pull/706#discussion_r372693829", "createdAt": "2020-01-29T23:50:25Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/RoutingData.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface RoutingData {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTM0NA=="}, "originalCommit": {"oid": "2932775e623ae16428b291b0bf07b6ba46093ca7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NDAyNg==", "bodyText": "We could rename this to getMetadataStoreRealm to keep the interface generic.", "url": "https://github.com/apache/helix/pull/706#discussion_r372694026", "createdAt": "2020-01-29T23:51:03Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/RoutingData.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface RoutingData {\n+  /**\n+   * Given a zkPath, return all the \"sharding key-zkRealmAddress\" pairs where the sharding keys\n+   * contain the given zkPath. For example, given \"/ESPRESSO_MT_LD-1/schemata\", return\n+   * {\"/ESPRESSO_MT_LD-1/schemata/ESPRESSO_MT_LD-1\": \"zk-ltx1-0-espresso.prod.linkedin.com:2181\",\n+   * \"/ESPRESSO_MT_LD-1/schemata/ESPRESSO_MT_LD-2\": \"zk-ltx1-1-espresso.prod.linkedin.com:2181\"}.\n+   * If the zkPath is invalid, returns an empty mapping.\n+   * @param zkPath - the zkPath where the search is conducted\n+   * @return all \"sharding key-zkRealmAddress\" pairs where the sharding keys contain the given\n+   *         zkPath if the zkPath is valid; empty mapping otherwise\n+   */\n+  Map<String, String> getAllMappingUnderPath(String zkPath);\n+\n+  /**\n+   * Given a zkPath, return the zkRealmAddress corresponding to the sharding key contained in the\n+   * zkPath. If the zkPath doesn't contain a sharding key, throw IllegalArgumentException.\n+   * @param zkPath - the zkPath where the search is conducted\n+   * @return the zkRealmAddress corresponding to the sharding key contained in the zkPath\n+   * @throws IllegalArgumentException - when the zkPath doesn't contain a sharding key\n+   */\n+  String getZkRealm(String zkPath) throws IllegalArgumentException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NDI4Nw==", "bodyText": "Please refrain from exposing internal details @nealsun-linkedin", "url": "https://github.com/apache/helix/pull/706#discussion_r372694287", "createdAt": "2020-01-29T23:51:54Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/RoutingData.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface RoutingData {\n+  /**\n+   * Given a zkPath, return all the \"sharding key-zkRealmAddress\" pairs where the sharding keys\n+   * contain the given zkPath. For example, given \"/ESPRESSO_MT_LD-1/schemata\", return\n+   * {\"/ESPRESSO_MT_LD-1/schemata/ESPRESSO_MT_LD-1\": \"zk-ltx1-0-espresso.prod.linkedin.com:2181\",\n+   * \"/ESPRESSO_MT_LD-1/schemata/ESPRESSO_MT_LD-2\": \"zk-ltx1-1-espresso.prod.linkedin.com:2181\"}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NDYyNw==", "bodyText": "This is an interface class; therefore, we want to keep it generic. This means that this interface class should be independent of ZK.\nAlso please refrain from using internal details in comments. This is an open source project.", "url": "https://github.com/apache/helix/pull/706#discussion_r372694627", "createdAt": "2020-01-29T23:52:57Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/RoutingData.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.rest.metadatastore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NTcxNQ==", "bodyText": "getMetadataStoreRealm since we want to make this metadata store-agnostic", "url": "https://github.com/apache/helix/pull/706#discussion_r372695715", "createdAt": "2020-01-29T23:56:33Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _zkRealmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String zkRealmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _zkRealmAddress = zkRealmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String zkPath) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(zkPath, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (zkPath.substring(zkPath.length() - 1).equals(\"/\")) {\n+      zkPath = zkPath.substring(0, zkPath.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, zkPath);\n+    return resultMap;\n+  }\n+\n+  public String getZkRealm(String zkPath) throws IllegalArgumentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjEyNQ==", "bodyText": "In general, be careful about terminology you use here. I'd say this class could be used for all metadata stores that use a filesystem API (assuming there are paths).\nSo your variables will have to be named something other than zkPath..", "url": "https://github.com/apache/helix/pull/706#discussion_r372696125", "createdAt": "2020-01-29T23:57:54Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/0099083107a0c60a75657c73b2bcfd73b5f62e0c", "committedDate": "2020-01-30T00:25:07Z", "message": "Address comments about store-agnostic features etc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNTIwNzAy", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-350520702", "createdAt": "2020-01-30T00:40:16Z", "commit": {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMDo0MDoxNlrOFjcRmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMDo1NDowMVrOFjcfJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNzczOA==", "bodyText": "This is not complete realm address. Naming as it could be confusing.", "url": "https://github.com/apache/helix/pull/706#discussion_r372707738", "createdAt": "2020-01-30T00:40:16Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwODMwNw==", "bodyText": "To fast the processing, we can sacrifice some memory usage as storing all the sub children in current node.", "url": "https://github.com/apache/helix/pull/706#discussion_r372708307", "createdAt": "2020-01-30T00:42:20Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDE4NA==", "bodyText": "This logic confuse me here.\nIf you have trie:\na - leaf\nb       c  -leaf\nd   e - leaf\nAnd you are looking for  /a/b with leaf flag as false. Then you will return root as /a. right?  But for searching purpose. I think it is correct to return b node. Can you explain what is expected scenario?", "url": "https://github.com/apache/helix/pull/706#discussion_r372710184", "createdAt": "2020-01-30T00:49:48Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws IllegalArgumentException {\n+    if (path.equals(\"/\") || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new IllegalArgumentException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(\"/\")) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(\"/\", 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDU3NQ==", "bodyText": "Let's try to use iterative way instead of recursive call. You may take more memory in memory stack for function recursive call.", "url": "https://github.com/apache/helix/pull/706#discussion_r372710575", "createdAt": "2020-01-30T00:51:28Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws IllegalArgumentException {\n+    if (path.equals(\"/\") || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new IllegalArgumentException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(\"/\")) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(\"/\", 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new IllegalArgumentException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new IllegalArgumentException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  /**\n+   * Given a trie node, search for all leaf nodes that descend from the given trie node, and add\n+   * all complete paths and realm addresses of these leaf nodes to a provided mapping. This method\n+   * recursively calls itself.\n+   * @param mapping - where the results (complete paths of leaf nodes and their realm addresses)\n+   *          are stored\n+   * @param curNode - the current trie node where the search starts\n+   * @param curPath - the complete path of the current trie node\n+   */\n+  private static void addAllAddressesToMapping(Map<String, String> mapping, TrieNode curNode,\n+      String curPath) {\n+    if (curNode._isLeaf) {\n+      mapping.put(curPath, curNode._realmAddress);\n+      return;\n+    }\n+\n+    for (Map.Entry<String, TrieNode> entry : curNode._children.entrySet()) {\n+      addAllAddressesToMapping(mapping, entry.getValue(), curPath + \"/\" + entry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTIwNw==", "bodyText": "What if the path does not exist? Why we dont use a complete path to add to trie but with partial info trie node to add to the path? Logically, it is not correct.", "url": "https://github.com/apache/helix/pull/706#discussion_r372711207", "createdAt": "2020-01-30T00:54:01Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws IllegalArgumentException {\n+    if (path.equals(\"/\") || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new IllegalArgumentException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(\"/\")) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(\"/\", 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new IllegalArgumentException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new IllegalArgumentException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  /**\n+   * Given a trie node, search for all leaf nodes that descend from the given trie node, and add\n+   * all complete paths and realm addresses of these leaf nodes to a provided mapping. This method\n+   * recursively calls itself.\n+   * @param mapping - where the results (complete paths of leaf nodes and their realm addresses)\n+   *          are stored\n+   * @param curNode - the current trie node where the search starts\n+   * @param curPath - the complete path of the current trie node\n+   */\n+  private static void addAllAddressesToMapping(Map<String, String> mapping, TrieNode curNode,\n+      String curPath) {\n+    if (curNode._isLeaf) {\n+      mapping.put(curPath, curNode._realmAddress);\n+      return;\n+    }\n+\n+    for (Map.Entry<String, TrieNode> entry : curNode._children.entrySet()) {\n+      addAllAddressesToMapping(mapping, entry.getValue(), curPath + \"/\" + entry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNTA3MDEw", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-350507010", "createdAt": "2020-01-29T23:59:08Z", "commit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMzo1OTowOVrOFjblrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMzo1OTo1MVrOFjbmeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjQ5NA==", "bodyText": "Should this be a private class? Also please move this to the end.", "url": "https://github.com/apache/helix/pull/706#discussion_r372696494", "createdAt": "2020-01-29T23:59:09Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjYzOQ==", "bodyText": "Add JavaDoc.", "url": "https://github.com/apache/helix/pull/706#discussion_r372696639", "createdAt": "2020-01-29T23:59:38Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _zkRealmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String zkRealmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _zkRealmAddress = zkRealmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String zkPath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjY5Nw==", "bodyText": "zkPath -> path?", "url": "https://github.com/apache/helix/pull/706#discussion_r372696697", "createdAt": "2020-01-29T23:59:51Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements RoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _zkRealmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String zkRealmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _zkRealmAddress = zkRealmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String zkPath) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjYzOQ=="}, "originalCommit": {"oid": "a1a8c21ea21bd9888b582e8b9c5e22d7cfc49afc"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNTUxMDQ5", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-350551049", "createdAt": "2020-01-30T02:32:10Z", "commit": {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMjozMjoxMFrOFjd1iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMjozMjoxMFrOFjd1iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjczMzMyMw==", "bodyText": "Please use level-by-level traversal for this. We try to avoid recursion in production code.", "url": "https://github.com/apache/helix/pull/706#discussion_r372733323", "createdAt": "2020-01-30T02:32:10Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  static class TrieNode {\n+    final Map<String, TrieNode> _children;\n+    final boolean _isLeaf;\n+    final String _realmAddress;\n+\n+    TrieNode(Map<String, TrieNode> children, String name, boolean isLeaf, String realmAddress) {\n+      _children = children;\n+      _isLeaf = isLeaf;\n+      _realmAddress = realmAddress;\n+    }\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    if (path.substring(path.length() - 1).equals(\"/\")) {\n+      path = path.substring(0, path.length() - 1);\n+    }\n+    addAllAddressesToMapping(resultMap, curNode, path);\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws IllegalArgumentException {\n+    if (path.equals(\"/\") || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new IllegalArgumentException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(\"/\")) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(\"/\", 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new IllegalArgumentException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new IllegalArgumentException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  /**\n+   * Given a trie node, search for all leaf nodes that descend from the given trie node, and add\n+   * all complete paths and realm addresses of these leaf nodes to a provided mapping. This method\n+   * recursively calls itself.\n+   * @param mapping - where the results (complete paths of leaf nodes and their realm addresses)\n+   *          are stored\n+   * @param curNode - the current trie node where the search starts\n+   * @param curPath - the complete path of the current trie node\n+   */\n+  private static void addAllAddressesToMapping(Map<String, String> mapping, TrieNode curNode,\n+      String curPath) {\n+    if (curNode._isLeaf) {\n+      mapping.put(curPath, curNode._realmAddress);\n+      return;\n+    }\n+\n+    for (Map.Entry<String, TrieNode> entry : curNode._children.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0099083107a0c60a75657c73b2bcfd73b5f62e0c"}, "originalPosition": 132}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6596488bbe4836f1cf4094c8b0c9c870261474cb", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/6596488bbe4836f1cf4094c8b0c9c870261474cb", "committedDate": "2020-01-30T18:40:43Z", "message": "change recursive search to iterative"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3", "committedDate": "2020-01-30T18:41:59Z", "message": "reorder private class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTYwNjY0", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351160664", "createdAt": "2020-01-30T21:40:09Z", "commit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMTo0MDowOVrOFj6zcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMTo0MDowOVrOFj6zcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIwNzkyMQ==", "bodyText": "private static final", "url": "https://github.com/apache/helix/pull/706#discussion_r373207921", "createdAt": "2020-01-30T21:40:09Z", "author": {"login": "jiajunwang"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTY0MTEx", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351164111", "createdAt": "2020-01-30T21:46:08Z", "commit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMTo0NjowOFrOFj69eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMTo0NjowOFrOFj69eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxMDQ4OQ==", "bodyText": "nit, nodeStack.pop() can be done before check isLeaf()", "url": "https://github.com/apache/helix/pull/706#discussion_r373210489", "createdAt": "2020-01-30T21:46:08Z", "author": {"login": "jiajunwang"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Stack<TrieNode> nodeStack = new Stack<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      if (nodeStack.peek()._isLeaf) {\n+        resultMap.put(nodeStack.peek()._name, nodeStack.peek()._realmAddress);\n+        nodeStack.pop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10e178bee17a88a0ae4ee91aa4dd179e5bafcee9", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/10e178bee17a88a0ae4ee91aa4dd179e5bafcee9", "committedDate": "2020-01-30T22:39:36Z", "message": "addresses comments based on discussion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTEyNjQ2", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351112646", "createdAt": "2020-01-30T20:15:52Z", "commit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDoxNTo1MlrOFj4j7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDozNDozNlrOFj5EFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MTE4MA==", "bodyText": "Just to make it specific and unambiguous, let's say \"metadata store path sharding key\" and \"metadata store realm address\". And give examples.", "url": "https://github.com/apache/helix/pull/706#discussion_r373171180", "createdAt": "2020-01-30T20:15:52Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreRoutingData.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface MetadataStoreRoutingData {\n+  /**\n+   * Given a path, return all the \"sharding key-realm address\" pairs where the sharding keys", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MTgyNg==", "bodyText": "Could we use an exception like **NotFoundException? IllegalArgumentException would be appropriate if the path was malformed.", "url": "https://github.com/apache/helix/pull/706#discussion_r373171826", "createdAt": "2020-01-30T20:17:22Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreRoutingData.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface MetadataStoreRoutingData {\n+  /**\n+   * Given a path, return all the \"sharding key-realm address\" pairs where the sharding keys\n+   * contain the given path. For example, given \"/a/b\", return {\"/a/b/c\":\n+   * \"realm.address.c.com:1234\", \"/a/b/d\": \"realm.address.d.com:1234\"}. If the path is invalid,\n+   * returns an empty mapping.\n+   * @param path - the path where the search is conducted\n+   * @return all \"sharding key-realm address\" pairs where the sharding keys contain the given\n+   *         path if the path is valid; empty mapping otherwise\n+   */\n+  Map<String, String> getAllMappingUnderPath(String path);\n+\n+  /**\n+   * Given a path, return the realm address corresponding to the sharding key contained in the\n+   * path. If the path doesn't contain a sharding key, throw IllegalArgumentException.\n+   * @param path - the path where the search is conducted\n+   * @return the realm address corresponding to the sharding key contained in the path\n+   * @throws IllegalArgumentException - when the path doesn't contain a sharding key\n+   */\n+  String getMetadataStoreRealm(String path) throws IllegalArgumentException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MjA2Ng==", "bodyText": "private static final for constant declarations", "url": "https://github.com/apache/helix/pull/706#discussion_r373172066", "createdAt": "2020-01-30T20:17:55Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MzQyMw==", "bodyText": "Nit: ArrayDeque might provide better performance. Optional.", "url": "https://github.com/apache/helix/pull/706#discussion_r373173423", "createdAt": "2020-01-30T20:21:12Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Stack<TrieNode> nodeStack = new Stack<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3NTM4OA==", "bodyText": "Could we split this into two methods and remove this boolean flag? You could create another private method for the common logic.", "url": "https://github.com/apache/helix/pull/706#discussion_r373175388", "createdAt": "2020-01-30T20:25:36Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (IllegalArgumentException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Stack<TrieNode> nodeStack = new Stack<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      if (nodeStack.peek()._isLeaf) {\n+        resultMap.put(nodeStack.peek()._name, nodeStack.peek()._realmAddress);\n+        nodeStack.pop();\n+      } else {\n+        curNode = nodeStack.pop();\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws IllegalArgumentException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise IllegalArgumentException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise IllegalArgumentException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws IllegalArgumentException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3OTQxMg==", "bodyText": "Optional: usually I think it might be a good idea to wrap this into a class like MetadataStoreInfo that contains fields like realm address, but it's okay to keep it a string for now.", "url": "https://github.com/apache/helix/pull/706#discussion_r373179412", "createdAt": "2020-01-30T20:34:36Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreRoutingData.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+public interface MetadataStoreRoutingData {\n+  /**\n+   * Given a path, return all the \"sharding key-realm address\" pairs where the sharding keys\n+   * contain the given path. For example, given \"/a/b\", return {\"/a/b/c\":\n+   * \"realm.address.c.com:1234\", \"/a/b/d\": \"realm.address.d.com:1234\"}. If the path is invalid,\n+   * returns an empty mapping.\n+   * @param path - the path where the search is conducted\n+   * @return all \"sharding key-realm address\" pairs where the sharding keys contain the given\n+   *         path if the path is valid; empty mapping otherwise\n+   */\n+  Map<String, String> getAllMappingUnderPath(String path);\n+\n+  /**\n+   * Given a path, return the realm address corresponding to the sharding key contained in the\n+   * path. If the path doesn't contain a sharding key, throw IllegalArgumentException.\n+   * @param path - the path where the search is conducted\n+   * @return the realm address corresponding to the sharding key contained in the path\n+   * @throws IllegalArgumentException - when the path doesn't contain a sharding key\n+   */\n+  String getMetadataStoreRealm(String path) throws IllegalArgumentException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffce3b75e44bbc9d7a41f78fcd2b74c2c410ba3"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b777d07abc5442a2b38053bf5060c231723faff", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/0b777d07abc5442a2b38053bf5060c231723faff", "committedDate": "2020-01-30T23:06:50Z", "message": "make tweaks such as docs, exception types, and stack class choice"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/e96034483252dda15eb84bc2d6001784757bf25c", "committedDate": "2020-01-31T01:16:55Z", "message": "change exception type"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjQ4ODIx", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351248821", "createdAt": "2020-01-31T01:26:50Z", "commit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMToyNjo1MFrOFj_I0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMToyNjo1MFrOFj_I0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3ODkzMQ==", "bodyText": "Nit: Try to make the error msg more helpful by adding the arguments (path and findLeafAlongPath)\nexample:\n\"No terminal node found along the path given! Path: \" + path", "url": "https://github.com/apache/helix/pull/706#discussion_r373278931", "createdAt": "2020-01-31T01:26:50Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjQ5MDQ0", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351249044", "createdAt": "2020-01-31T01:27:46Z", "commit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMToyNzo0NlrOFj_Jjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMToyNzo0NlrOFj_Jjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTExOQ==", "bodyText": "Nit: did we agree to rename this to _isTerminalNode?", "url": "https://github.com/apache/helix/pull/706#discussion_r373279119", "createdAt": "2020-01-31T01:27:46Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new NoSuchElementException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n+  static class TrieNode {\n+    /**\n+     * This field is a mapping between trie key and children nodes. For example, node \"a\" has\n+     * children \"ab\" and \"ac\", therefore the keys are \"b\" and \"c\" respectively.\n+     */\n+    Map<String, TrieNode> _children;\n+    /**\n+     * This field means if the node is a terminal node in the tree sense, not the trie sense. Any\n+     * node that has children cannot possibly be a leaf node because only the node without children\n+     * can store information.\n+     */\n+    final boolean _isLeaf;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "originalPosition": 137}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjQ5Mzky", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351249392", "createdAt": "2020-01-31T01:28:57Z", "commit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMToyODo1N1rOFj_KnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMToyODo1N1rOFj_KnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTM4OA==", "bodyText": "Let's make this errorMsg more helpful. See my comment above.", "url": "https://github.com/apache/helix/pull/706#discussion_r373279388", "createdAt": "2020-01-31T01:28:57Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjQ5NDM0", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351249434", "createdAt": "2020-01-31T01:29:07Z", "commit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMToyOTowN1rOFj_KxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMToyOTowN1rOFj_KxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTQyOA==", "bodyText": "See above.", "url": "https://github.com/apache/helix/pull/706#discussion_r373279428", "createdAt": "2020-01-31T01:29:07Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new NoSuchElementException(\"no leaf node found along the path\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjQ5NzY5", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351249769", "createdAt": "2020-01-31T01:30:19Z", "commit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMTozMDoxOVrOFj_L6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMTozMDoxOVrOFj_L6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3OTcyMQ==", "bodyText": "This is not very clear?\nShouldn't it be : If a node \"a\" has children \"b\", and \"c\", then ....?", "url": "https://github.com/apache/helix/pull/706#discussion_r373279721", "createdAt": "2020-01-31T01:30:19Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new NoSuchElementException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n+  static class TrieNode {\n+    /**\n+     * This field is a mapping between trie key and children nodes. For example, node \"a\" has\n+     * children \"ab\" and \"ac\", therefore the keys are \"b\" and \"c\" respectively.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjUwNDI2", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351250426", "createdAt": "2020-01-31T01:32:38Z", "commit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMTozMjozOFrOFj_OBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMTozMjozOFrOFj_OBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MDI2Mg==", "bodyText": "Didn't we agree to this:\nTrieNode : _name\nroot node: \"/\"\n\"a\": \"a\"\n\"b\": \"b\"\ninstead of \"/a/b\"?\nSince that would just require one String.split, and you'll have a comprehensive list of all nodes' names, which should make the tree traversal simpler as in it won't require any more splitting?", "url": "https://github.com/apache/helix/pull/706#discussion_r373280262", "createdAt": "2020-01-31T01:32:38Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"no leaf node found along the path\");\n+      }\n+      return _rootNode;\n+    }\n+\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      path = path.substring(1);\n+    }\n+    String[] splitPath = path.split(DELIMITER, 0);\n+\n+    TrieNode curNode = _rootNode;\n+    if (findLeafAlongPath && curNode._isLeaf) {\n+      return curNode;\n+    }\n+    Map<String, TrieNode> curChildren = curNode._children;\n+    for (String pathSection : splitPath) {\n+      curNode = curChildren.get(pathSection);\n+      if (curNode == null) {\n+        throw new NoSuchElementException(\"the provided path is missing from the trie\");\n+      }\n+      if (findLeafAlongPath && curNode._isLeaf) {\n+        return curNode;\n+      }\n+      curChildren = curNode._children;\n+    }\n+    if (findLeafAlongPath) {\n+      throw new NoSuchElementException(\"no leaf node found along the path\");\n+    }\n+    return curNode;\n+  }\n+\n+  // TODO: THE CLASS WILL BE CHANGED TO PRIVATE ONCE THE CONSTRUCTOR IS CREATED.\n+  static class TrieNode {\n+    /**\n+     * This field is a mapping between trie key and children nodes. For example, node \"a\" has\n+     * children \"ab\" and \"ac\", therefore the keys are \"b\" and \"c\" respectively.\n+     */\n+    Map<String, TrieNode> _children;\n+    /**\n+     * This field means if the node is a terminal node in the tree sense, not the trie sense. Any\n+     * node that has children cannot possibly be a leaf node because only the node without children\n+     * can store information.\n+     */\n+    final boolean _isLeaf;\n+    /**\n+     * This field aligns the traditional trie design: it entails the complete path/prefix leading to\n+     * the current node. For example, the name of root node is \"/\", then the name of its child node\n+     * is \"/a\", and the name of the child's child node is \"/a/b\".\n+     */\n+    final String _name;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e96034483252dda15eb84bc2d6001784757bf25c"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "221d8ff079f5d2f325074d5d22f7e4c770847e26", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/221d8ff079f5d2f325074d5d22f7e4c770847e26", "committedDate": "2020-01-31T01:51:50Z", "message": "make final edits"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjYwNTk2", "url": "https://github.com/apache/helix/pull/706#pullrequestreview-351260596", "createdAt": "2020-01-31T02:14:40Z", "commit": {"oid": "221d8ff079f5d2f325074d5d22f7e4c770847e26"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjoxNDo0MFrOFj_vFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjoxNDo0MFrOFj_vFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4ODcyNg==", "bodyText": "Why is this if condition required if we're going to do the same thing either way?", "url": "https://github.com/apache/helix/pull/706#discussion_r373288726", "createdAt": "2020-01-31T02:14:40Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {\n+  private static final String DELIMITER = \"/\";\n+\n+  private final TrieNode _rootNode;\n+\n+  // TODO: THIS IS A TEMPORARY PLACEHOLDER. A proper constructor will be created, which will not\n+  // take in a TrieNode; it instead initializes the rootNode and creates a trie based on\n+  // some input data. The constructor is blocked by the implementation of RoutingDataAccessor, and\n+  // will therefore be implemented later.\n+  public TrieRoutingData(TrieNode rootNode) {\n+    _rootNode = rootNode;\n+  }\n+\n+  public Map<String, String> getAllMappingUnderPath(String path) {\n+    TrieNode curNode;\n+    try {\n+      curNode = findTrieNode(path, false);\n+    } catch (NoSuchElementException e) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, String> resultMap = new HashMap<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode._isLeaf) {\n+        resultMap.put(curNode._name, curNode._realmAddress);\n+      } else {\n+        for (TrieNode child : curNode._children.values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  public String getMetadataStoreRealm(String path) throws NoSuchElementException {\n+    TrieNode leafNode = findTrieNode(path, true);\n+    return leafNode._realmAddress;\n+  }\n+\n+  /**\n+   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n+   * given path is pointing to and return it; raise NoSuchElementException if the path does\n+   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n+   * leaf node along the provided path; raise NoSuchElementException if the path does not\n+   * point to any node or if there is no leaf node along the path.\n+   * @param path - the path where the search is conducted\n+   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n+   * @return the node pointed by the path or a leaf node along the path\n+   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n+   *           found\n+   */\n+  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n+      throws NoSuchElementException {\n+    if (path.equals(DELIMITER) || path.equals(\"\")) {\n+      if (findLeafAlongPath && !_rootNode._isLeaf) {\n+        throw new NoSuchElementException(\"No leaf node found along the path. Path: \" + path);\n+      }\n+      return _rootNode;\n+    }\n+\n+    String[] splitPath;\n+    if (path.substring(0, 1).equals(DELIMITER)) {\n+      splitPath = path.substring(1).split(DELIMITER, 0);\n+    } else {\n+      splitPath = path.substring(1).split(DELIMITER, 0);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "221d8ff079f5d2f325074d5d22f7e4c770847e26"}, "originalPosition": 103}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afdce50d795ead0f9bd5ee912238cf453d53b38e", "author": {"user": {"login": "NealSun96", "name": "Neal Sun"}}, "url": "https://github.com/apache/helix/commit/afdce50d795ead0f9bd5ee912238cf453d53b38e", "committedDate": "2020-01-31T17:31:28Z", "message": "fix incorrect substring line"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4897, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}