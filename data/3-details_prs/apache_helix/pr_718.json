{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNTY3Mjcw", "number": 718, "title": "Implement Helix nonblocking lock", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #708\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\nThis is a part of the Helix lock manager service. A HelixLock interface has been added and this PR is the implementation of nonblocking lock according to the interface. This nonblocking lock uses a single persistent znode to represent a lock on a resource. Upon calling acquireLock, the user either gets a \"true\" if they successfully acquired the lock meaning they can start their work on the resource, or a \"false\" if someone else currently has the lock meaning that they cannot work on this resource at this time. User can release the lock when they are done with their work, as well as get the lock information such as the current owner of the lock, any messages left by the lock owner, or the timeout of the lock.\n\nTests\n\n\n The following tests are written for this issue:\nTestZKHelixNonblockingLock\n\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 70.838 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:13 min\n[INFO] Finished at: 2020-02-04T17:58:59-08:00\n[INFO] ------------------------------------------------------------------------\n\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-03T23:08:21Z", "url": "https://github.com/apache/helix/pull/718", "merged": true, "mergeCommit": {"oid": "29c99a0de4a34246d2cb735052ce18e42068edb8"}, "closed": true, "closedAt": "2020-02-20T21:57:52Z", "author": {"login": "mgao0"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcA01JoAH2gAyMzcwNTY3MjcwOjJjZWM5MmZkYjJhNjAyZWRiMThkMzdjYmJlM2NjY2FkYTI3MzQ4YWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGSbLIAFqTM2MjI2MzU0MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2cec92fdb2a602edb18d37cbbe3cccada27348af", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/2cec92fdb2a602edb18d37cbbe3cccada27348af", "committedDate": "2020-02-03T22:39:12Z", "message": "Created Helix distributed lock design (apache#702)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d1b912aab6efc6eb9ef3b41f1cc5acb1eab90d5", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/7d1b912aab6efc6eb9ef3b41f1cc5acb1eab90d5", "committedDate": "2020-02-03T22:41:10Z", "message": "Added LockInfo interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b6f38db03c36fdb158e6d367ec6a55449f84680", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/8b6f38db03c36fdb158e6d367ec6a55449f84680", "committedDate": "2020-02-03T22:41:10Z", "message": "Added details in comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c84a155cb78581d3bc3bee0a8daa7b0ad3a9e72", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/9c84a155cb78581d3bc3bee0a8daa7b0ad3a9e72", "committedDate": "2020-02-03T22:41:10Z", "message": "created Helix nonblocking lock based on zk"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/28218ea4bc100fe864da68c9794e35b0132b7cc6", "committedDate": "2020-02-03T22:54:00Z", "message": "Added unit tests for Helix nonblocking lock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNzYyNzMx", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-352762731", "createdAt": "2020-02-04T07:17:31Z", "commit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzoxNzozMVrOFlKC3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzo0MDowOFrOFlKePw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNjIwNQ==", "bodyText": "suggest to change \"userID\" to \"userId\", and add the param of \"userId\" here.", "url": "https://github.com/apache/helix/pull/718#discussion_r374506205", "createdAt": "2020-02-04T07:17:31Z", "author": {"login": "zhangmeng916"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNjkwMQ==", "bodyText": "same here, add \"userId\"", "url": "https://github.com/apache/helix/pull/718#discussion_r374506901", "createdAt": "2020-02-04T07:19:50Z", "author": {"login": "zhangmeng916"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNzQxOA==", "bodyText": "formatting?", "url": "https://github.com/apache/helix/pull/718#discussion_r374507418", "createdAt": "2020-02-04T07:21:40Z", "author": {"login": "zhangmeng916"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMDg2OQ==", "bodyText": "Better to add comment for this \"set\" operation, and when it may fail.", "url": "https://github.com/apache/helix/pull/718#discussion_r374510869", "createdAt": "2020-02-04T07:32:42Z", "author": {"login": "zhangmeng916"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMTgyMw==", "bodyText": "Is ownerId null a valid scenario? In this case, the lock has no owner. You mean want to add some validation logic for lock info.\nAlso, suggest to change ownerID to ownerId.", "url": "https://github.com/apache/helix/pull/718#discussion_r374511823", "createdAt": "2020-02-04T07:35:46Z", "author": {"login": "zhangmeng916"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to release a lock\n+   * @return true if the lock was successfully released,\n+   * false if the locked is not locked or is not locked by the user,\n+   * or the lock could not be released\n+   */ public boolean releaseLock() {\n+    if (isOwner()) {\n+      return _baseDataAccessor.remove(_lockPath, AccessOption.PERSISTENT);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  /**\n+   * Retrieve the lock information, e.g. lock timeout, lock message, etc.\n+   * @return lock metadata information, return null if there is no lock node for the path provided\n+   */ public LockInfo<String> getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return null;\n+    }\n+    ZKHelixNonblockingLockInfo<String> lockInfo = new ZKHelixNonblockingLockInfo<>();\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    lockInfo.setLockInfoFields(curLockInfo);\n+    return lockInfo;\n+  }\n+\n+  @Override\n+  /**\n+   * Check if the user is current lock owner\n+   * @return true if the user is the lock owner,\n+   * false if the user is not the lock owner or the lock doesn't have a owner\n+   */ public boolean isOwner() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    if (curLockInfo == null) {\n+      return false;\n+    }\n+    String ownerID = curLockInfo.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name());\n+    if (ownerID == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxMzIxNQ==", "bodyText": "Could you also test the case when two threads both try to acquire the lock, independently, and one of them succeed, and the other fail?", "url": "https://github.com/apache/helix/pull/718#discussion_r374513215", "createdAt": "2020-02-04T07:40:08Z", "author": {"login": "zhangmeng916"}, "path": "helix-lock/src/test/java/org/apache/helix/lock/TestZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjA3NTIz", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-353207523", "createdAt": "2020-02-04T18:36:20Z", "commit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODozNjoyMFrOFle-7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODo0NzoxNlrOFlfVYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0OTI2MA==", "bodyText": "Discussed offline, if this one is not for our customer to use immediately, please use private.", "url": "https://github.com/apache/helix/pull/718#discussion_r374849260", "createdAt": "2020-02-04T18:36:20Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDgzOQ==", "bodyText": "Format", "url": "https://github.com/apache/helix/pull/718#discussion_r374850839", "createdAt": "2020-02-04T18:39:24Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to release a lock\n+   * @return true if the lock was successfully released,\n+   * false if the locked is not locked or is not locked by the user,\n+   * or the lock could not be released\n+   */ public boolean releaseLock() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MjYxNQ==", "bodyText": "It could be a race condition. We should never remove the node while releasing it. Simply update the timeout to -1 or so using the update(). So there won't be a chance someone releases the lock at the same time, and the lock is removed unexpectedly.", "url": "https://github.com/apache/helix/pull/718#discussion_r374852615", "createdAt": "2020-02-04T18:42:50Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userID) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userID);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userID) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userID = userID;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to acquire a lock\n+   * @return true if the lock was successfully acquired,\n+   * false if the lock could not be acquired\n+   */ public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userID);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  /**\n+   * Blocking call to release a lock\n+   * @return true if the lock was successfully released,\n+   * false if the locked is not locked or is not locked by the user,\n+   * or the lock could not be released\n+   */ public boolean releaseLock() {\n+    if (isOwner()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MzUyOQ==", "bodyText": "How we prevent 2 clients using the same ID?\nI thing GUID is easier and they should not be specified by our user.", "url": "https://github.com/apache/helix/pull/718#discussion_r374853529", "createdAt": "2020-02-04T18:44:35Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userID;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28218ea4bc100fe864da68c9794e35b0132b7cc6"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1Mzk4NA==", "bodyText": "format", "url": "https://github.com/apache/helix/pull/718#discussion_r374853984", "createdAt": "2020-02-04T18:45:23Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;\n+\n+  enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+  }\n+\n+  @Override\n+  /**\n+   * Create a single filed of LockInfo, or update the value of the field if it already exists\n+   * @param infoKey the key of the LockInfo field\n+   * @param infoValue the value of the LockInfo field\n+   */ public void setInfoValue(String infoKey, String infoValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NDI4NQ==", "bodyText": "getInforValue (InfoKey key)", "url": "https://github.com/apache/helix/pull/718#discussion_r374854285", "createdAt": "2020-02-04T18:45:57Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;\n+\n+  enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+  }\n+\n+  @Override\n+  /**\n+   * Create a single filed of LockInfo, or update the value of the field if it already exists\n+   * @param infoKey the key of the LockInfo field\n+   * @param infoValue the value of the LockInfo field\n+   */ public void setInfoValue(String infoKey, String infoValue) {\n+    lockInfo.put(infoKey, infoValue);\n+  }\n+\n+  @Override\n+  /**\n+   * Get the value of a field in LockInfo\n+   * @param infoKey the key of the LockInfo field\n+   * @return the value of the field or null if this key does not exist\n+   */ public T getInfoValue(String infoKey) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NDM3Nw==", "bodyText": "setInforValue (InfoKey key,  String infoValue)", "url": "https://github.com/apache/helix/pull/718#discussion_r374854377", "createdAt": "2020-02-04T18:46:07Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;\n+\n+  enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+  }\n+\n+  @Override\n+  /**\n+   * Create a single filed of LockInfo, or update the value of the field if it already exists\n+   * @param infoKey the key of the LockInfo field\n+   * @param infoValue the value of the LockInfo field\n+   */ public void setInfoValue(String infoKey, String infoValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1Mzk4NA=="}, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NDUyNA==", "bodyText": "Map<InfoKey, String>", "url": "https://github.com/apache/helix/pull/718#discussion_r374854524", "createdAt": "2020-02-04T18:46:21Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NDY5Mw==", "bodyText": "Should be public if you want strong control on the types.", "url": "https://github.com/apache/helix/pull/718#discussion_r374854693", "createdAt": "2020-02-04T18:46:38Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;\n+\n+  enum InfoKey {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NTAwOA==", "bodyText": "What's the usage? The Helix convention is creating a copy constructor for this scenario.", "url": "https://github.com/apache/helix/pull/718#discussion_r374855008", "createdAt": "2020-02-04T18:47:16Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<T extends String> implements LockInfo<T> {\n+\n+  private Map<String, String> lockInfo;\n+\n+  enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+  }\n+\n+  @Override\n+  /**\n+   * Create a single filed of LockInfo, or update the value of the field if it already exists\n+   * @param infoKey the key of the LockInfo field\n+   * @param infoValue the value of the LockInfo field\n+   */ public void setInfoValue(String infoKey, String infoValue) {\n+    lockInfo.put(infoKey, infoValue);\n+  }\n+\n+  @Override\n+  /**\n+   * Get the value of a field in LockInfo\n+   * @param infoKey the key of the LockInfo field\n+   * @return the value of the field or null if this key does not exist\n+   */ public T getInfoValue(String infoKey) {\n+    return (T) lockInfo.get(infoKey);\n+  }\n+\n+  /**\n+   * Update the lock info with information in a ZNRecord\n+   * @param record Information about the lock that stored as ZNRecord format\n+   */\n+  public void setLockInfoFields(ZNRecord record) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjcyNTIx", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-353272521", "createdAt": "2020-02-04T20:18:18Z", "commit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxODoxOFrOFliGRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoyMjo1MlrOFliOpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMDI5NQ==", "bodyText": "Let's make separator to be consistent either \"/\" or '/'. And it is better to have a constant for it.", "url": "https://github.com/apache/helix/pull/718#discussion_r374900295", "createdAt": "2020-02-04T20:18:18Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMDQ4MA==", "bodyText": "Do not hard code it. Make it as a constant.", "url": "https://github.com/apache/helix/pull/718#discussion_r374900480", "createdAt": "2020-02-04T20:18:45Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (userId.matches(\"[a-f0-9]{8}-[a-f0-9]{4}-4[0-9]{3}-[89ab][a-f0-9]{3}-[0-9a-f]{12}\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMDkwOA==", "bodyText": "you can refactor code like:\nif (!userId.matches(...)) {\nthrow new IllegalArgumentException();\n}\n_userId = userId;", "url": "https://github.com/apache/helix/pull/718#discussion_r374900908", "createdAt": "2020-02-04T20:19:43Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (userId.matches(\"[a-f0-9]{8}-[a-f0-9]{4}-4[0-9]{3}-[89ab][a-f0-9]{3}-[0-9a-f]{12}\")) {\n+      _userId = userId;\n+    } else {\n+      throw new IllegalArgumentException();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMTMzNA==", "bodyText": "Is this formatted?", "url": "https://github.com/apache/helix/pull/718#discussion_r374901334", "createdAt": "2020-02-04T20:20:36Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (userId.matches(\"[a-f0-9]{8}-[a-f0-9]{4}-4[0-9]{3}-[89ab][a-f0-9]{3}-[0-9a-f]{12}\")) {\n+      _userId = userId;\n+    } else {\n+      throw new IllegalArgumentException();\n+    }\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkwMjQzNg==", "bodyText": "If you dont need to return Stat data, then you can pass null as argument. If you need it, set it in the ZNRecord.", "url": "https://github.com/apache/helix/pull/718#discussion_r374902436", "createdAt": "2020-02-04T20:22:52Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZNRecordUpdater;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.helix.util.ZNRecordUtil;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName + '/' + LOCK_ROOT + '/' + scope, zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (userId.matches(\"[a-f0-9]{8}-[a-f0-9]{4}-4[0-9]{3}-[89ab][a-f0-9]{3}-[0-9a-f]{12}\")) {\n+      _userId = userId;\n+    } else {\n+      throw new IllegalArgumentException();\n+    }\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout = System.currentTimeMillis() + _timeout;\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28db99ce4c384dee130067c45415f80fc8358eb1", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/28db99ce4c384dee130067c45415f80fc8358eb1", "committedDate": "2020-02-05T00:25:55Z", "message": "Fixed logic of release and isOwner"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7eb25e8daee8d57d90f612442ece294e9f39a857", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/7eb25e8daee8d57d90f612442ece294e9f39a857", "committedDate": "2020-02-04T18:41:13Z", "message": "Fixed logic of release and isOwner"}, "afterCommit": {"oid": "28db99ce4c384dee130067c45415f80fc8358eb1", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/28db99ce4c384dee130067c45415f80fc8358eb1", "committedDate": "2020-02-05T00:25:55Z", "message": "Fixed logic of release and isOwner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b", "committedDate": "2020-02-05T01:38:13Z", "message": "Added test to acquire lock simultaneously"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MDYxMzcz", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-354061373", "createdAt": "2020-02-05T21:43:09Z", "commit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTo0MzowOVrOFmINBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMjowMDozOFrOFmIsag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNDYxNA==", "bodyText": "Use a string join method? FYI, https://www.geeksforgeeks.org/java-string-join-examples/", "url": "https://github.com/apache/helix/pull/718#discussion_r375524614", "createdAt": "2020-02-05T21:43:09Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNTQyOA==", "bodyText": "I'm not sure why a random string won't work? Given this will be provided by the caller anyway.\nMoreover, if doing so, we will need to document this in detail.", "url": "https://github.com/apache/helix/pull/718#discussion_r375525428", "createdAt": "2020-02-05T21:45:00Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNTg4Mw==", "bodyText": "Use factory. I think the constructor is deprecated and will be private in the new ZK module.", "url": "https://github.com/apache/helix/pull/718#discussion_r375525883", "createdAt": "2020-02-05T21:45:47Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNjQyMA==", "bodyText": "Since this is the only access method you need, why we create a ZkClient first? Note that the accessor constructor will create an instance of zkclient internally.", "url": "https://github.com/apache/helix/pull/718#discussion_r375526420", "createdAt": "2020-02-05T21:46:58Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyNzQ0Mw==", "bodyText": "new LockUpdater(); is doing the same operation, right?", "url": "https://github.com/apache/helix/pull/718#discussion_r375527443", "createdAt": "2020-02-05T21:49:15Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyODAyNQ==", "bodyText": "I'm not 100% sure, but it seems to be better if we have the default value here given the ZnRecord is not complete, znRecord.getSimpleField(InfoKey.OWNER.name(),DEFAULT_OWNER_TEXT );\nSame for the other 2 fields.", "url": "https://github.com/apache/helix/pull/718#discussion_r375528025", "createdAt": "2020-02-05T21:50:29Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<K extends ZKHelixNonblockingLockInfo.InfoKey, V extends String> implements LockInfo<K, V> {\n+\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final String DEFAULT_TIMEOUT_TEXT = String.valueOf(-1);\n+  private Map<InfoKey, String> lockInfo;\n+\n+  public enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+    lockInfo.put(InfoKey.OWNER, DEFAULT_OWNER_TEXT);\n+    lockInfo.put(InfoKey.MESSAGE, DEFAULT_MESSAGE_TEXT);\n+    lockInfo.put(InfoKey.TIMEOUT, DEFAULT_TIMEOUT_TEXT);\n+  }\n+\n+  public ZKHelixNonblockingLockInfo(ZNRecord znRecord) {\n+    this();\n+    lockInfo.put(InfoKey.OWNER, znRecord.getSimpleField(InfoKey.OWNER.name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyODY2OQ==", "bodyText": "Record the current user Id here for debug.", "url": "https://github.com/apache/helix/pull/718#discussion_r375528669", "createdAt": "2020-02-05T21:51:53Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return new ZKHelixNonblockingLockInfo();\n+    }\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new ZKHelixNonblockingLockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    if (curLockInfo == null) {\n+      return false;\n+    }\n+    return userIdMatches(curLockInfo) && !hasTimedOut(curLockInfo);\n+  }\n+\n+  /**\n+   * Check if a lock has timed out\n+   * @param record the current lock information in ZNRecord format\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(ZNRecord record) {\n+    String timeoutStr = record.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name());\n+    return System.currentTimeMillis() >= Long.parseLong(timeoutStr);\n+  }\n+\n+  /**\n+   * Check if the current user Id matches with the owner Id in a lock info\n+   * @param record the lock information in ZNRecord format\n+   * @return return true if the two ids match, otherwise return false.\n+   */\n+  private boolean userIdMatches(ZNRecord record) {\n+    String ownerId = record.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name());\n+    return ownerId.equals(_userId);\n+  }\n+\n+  /**\n+   * Class that specifies how a lock node should be updated with another lock node for a lock owner only\n+   */\n+  private class LockUpdater implements DataUpdater<ZNRecord> {\n+    final ZNRecord _record;\n+\n+    /**\n+     * Initialize a structure for lock owner to update a lock node value\n+     * @param record the lock node value will be updated in ZNRecord format\n+     */\n+    public LockUpdater(ZNRecord record) {\n+      _record = record;\n+    }\n+\n+    @Override\n+    public ZNRecord update(ZNRecord current) {\n+      if (current != null && userIdMatches(current) && !hasTimedOut(current)) {\n+        return _record;\n+      }\n+      throw new HelixException(\"User is not authorized to perform this operation.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTA2MQ==", "bodyText": "Try catch on the update? If the update fails because of use Id mismatch or timeout, the release operation is done.\nNote that ZK exception should still be thrown.", "url": "https://github.com/apache/helix/pull/718#discussion_r375529061", "createdAt": "2020-02-05T21:52:48Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTQ5NQ==", "bodyText": "Call it the deadline or something else. timeout and _timeout together are too confusing...", "url": "https://github.com/apache/helix/pull/718#discussion_r375529495", "createdAt": "2020-02-05T21:53:45Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTg4NA==", "bodyText": "Or, you can also update the _timeout to some name else. Might be easier. Either way.", "url": "https://github.com/apache/helix/pull/718#discussion_r375529884", "createdAt": "2020-02-05T21:54:35Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTQ5NQ=="}, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMDA2Nw==", "bodyText": "setLongField", "url": "https://github.com/apache/helix/pull/718#discussion_r375530067", "createdAt": "2020-02-05T21:54:59Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTAwOA==", "bodyText": "try catch instead of calling twice?", "url": "https://github.com/apache/helix/pull/718#discussion_r375531008", "createdAt": "2020-02-05T21:57:11Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return new ZKHelixNonblockingLockInfo();\n+    }\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTY4Ng==", "bodyText": "getLongField", "url": "https://github.com/apache/helix/pull/718#discussion_r375531686", "createdAt": "2020-02-05T21:58:25Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return new ZKHelixNonblockingLockInfo();\n+    }\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new ZKHelixNonblockingLockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    if (curLockInfo == null) {\n+      return false;\n+    }\n+    return userIdMatches(curLockInfo) && !hasTimedOut(curLockInfo);\n+  }\n+\n+  /**\n+   * Check if a lock has timed out\n+   * @param record the current lock information in ZNRecord format\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(ZNRecord record) {\n+    String timeoutStr = record.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMjY1MA==", "bodyText": "I don't have a strong preference. But it might be easier for our customers if we return the remaining time instead of a boolean. If the lock owner changed, we just return -1.", "url": "https://github.com/apache/helix/pull/718#discussion_r375532650", "createdAt": "2020-02-05T22:00:38Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.UUID;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.manager.zk.ZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.model.HelixConfigScope;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"LOCKS\";\n+  private static final String PATH_DELIMITER = \"/\";\n+  private static final String UUID_FORMAT_REGEX =\n+      \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixConfigScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(PATH_DELIMITER + clusterName + PATH_DELIMITER + LOCK_ROOT + PATH_DELIMITER + scope,\n+        zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    HelixZkClient zkClient = new ZkClient(zkAddress);\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    if (!userId.matches(UUID_FORMAT_REGEX)) {\n+      throw new IllegalArgumentException(\"The input user id is not a valid UUID.\");\n+    }\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<ZNRecord>(zkClient.getServers());\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+    long timeout;\n+\n+    // If the input timeout value is the max value, set the expire time to max value\n+    if (_timeout == Long.MAX_VALUE) {\n+      timeout = _timeout;\n+    } else {\n+      timeout = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo\n+        .setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), String.valueOf(timeout));\n+\n+    // Try to create the lock node\n+    boolean success = _baseDataAccessor.create(_lockPath, lockInfo, AccessOption.PERSISTENT);\n+\n+    // If fail to create the lock node (acquire the lock), compare the timeout timestamp of current lock node with current time, if already passes the timeout, release current lock and try to acquire the lock again\n+    if (!success) {\n+      Stat stat = new Stat();\n+      ZNRecord curLock = _baseDataAccessor.get(_lockPath, stat, AccessOption.PERSISTENT);\n+      long curTimeout =\n+          Long.parseLong(curLock.getSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name()));\n+      if (System.currentTimeMillis() >= curTimeout) {\n+        // set may fail when the znode version changes in between the get and set, meaning there are some changes in the lock\n+        success =\n+            _baseDataAccessor.set(_lockPath, lockInfo, stat.getVersion(), AccessOption.PERSISTENT);\n+      }\n+    }\n+    return success;\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZNRecord(_userId);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_MESSAGE_TEXT);\n+    newLockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(),\n+        ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_TEXT);\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    if (!_baseDataAccessor.exists(_lockPath, AccessOption.PERSISTENT)) {\n+      return new ZKHelixNonblockingLockInfo();\n+    }\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new ZKHelixNonblockingLockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22b6ef97b1bea12b5f9e0b7fd3751fdd8529a95b"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc3a5333c905be1f6b7f9767c70a994567de9277", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/cc3a5333c905be1f6b7f9767c70a994567de9277", "committedDate": "2020-02-06T19:59:05Z", "message": "A few fixes on syntax"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdb109d0f39e9a1a13c5a56a982b29742be72a54", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/cdb109d0f39e9a1a13c5a56a982b29742be72a54", "committedDate": "2020-02-06T20:02:00Z", "message": "Changed method doc for releaseLock in HelixLock interface"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d1af201393f3e64f7ebb153159bf0a468dfb2dfc", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/d1af201393f3e64f7ebb153159bf0a468dfb2dfc", "committedDate": "2020-02-06T02:07:00Z", "message": "A few fixes on syntax"}, "afterCommit": {"oid": "cdb109d0f39e9a1a13c5a56a982b29742be72a54", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/cdb109d0f39e9a1a13c5a56a982b29742be72a54", "committedDate": "2020-02-06T20:02:00Z", "message": "Changed method doc for releaseLock in HelixLock interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0607bcdfd34cf4901eba3d7b0f10e6c5e8743a86", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/0607bcdfd34cf4901eba3d7b0f10e6c5e8743a86", "committedDate": "2020-02-07T01:44:38Z", "message": "Fixed lock path generation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1590f59f85d235929459910152999d17aa3a236", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/f1590f59f85d235929459910152999d17aa3a236", "committedDate": "2020-02-07T04:40:50Z", "message": "simplified acquireLock logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/0b95d02b3873861dd3a71554e65c56f012035e6a", "committedDate": "2020-02-07T22:53:03Z", "message": "Added cluster level to HelixLockScope and convert lock path to uppercase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjU2MDk4", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-356256098", "createdAt": "2020-02-10T20:55:45Z", "commit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MzA5MzMz", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-356309333", "createdAt": "2020-02-10T22:23:31Z", "commit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMjoyMzozMVrOFn3y3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMjozODo0N1rOFn4Ndg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1MjkyNw==", "bodyText": "It could be cleaner if we have an abstract HelixScope class. Then there should be no duplicate code at all.\nThen things we can put into the parent class:\n\nStringTemplate template\nclusterName\nzkPath\ntype\ntheir get methods\nparticipant name is also something in common. But I think this one is not generic enough for the parent abstract class.", "url": "https://github.com/apache/helix/pull/718#discussion_r377352927", "createdAt": "2020-02-10T22:23:31Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.List;\n+\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1Mzk0NA==", "bodyText": "Should this be part of the lock scope?", "url": "https://github.com/apache/helix/pull/718#discussion_r377353944", "createdAt": "2020-02-10T22:25:48Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT;\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_LONG;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"/LOCK\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1Njc3MA==", "bodyText": "Comment that the default constructor creates an unlocked lock.", "url": "https://github.com/apache/helix/pull/718#discussion_r377356770", "createdAt": "2020-02-10T22:31:56Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT;\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_LONG;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"/LOCK\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixLockScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName.toUpperCase() + LOCK_ROOT + scope.getZkPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo.setLongField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), deadline);\n+\n+    LockUpdater updater = new LockUpdater(lockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZKHelixNonblockingLockInfo<>().toZNRecord();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1NzI1NQ==", "bodyText": "Should be true? If there is no such lock node, we can assume timeout == true, right?", "url": "https://github.com/apache/helix/pull/718#discussion_r377357255", "createdAt": "2020-02-10T22:33:00Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT;\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_LONG;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"/LOCK\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixLockScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName.toUpperCase() + LOCK_ROOT + scope.getZkPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    ZNRecord lockInfo = new ZNRecord(_userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.OWNER.name(), _userId);\n+    lockInfo.setSimpleField(ZKHelixNonblockingLockInfo.InfoKey.MESSAGE.name(), _lockMsg);\n+\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    lockInfo.setLongField(ZKHelixNonblockingLockInfo.InfoKey.TIMEOUT.name(), deadline);\n+\n+    LockUpdater updater = new LockUpdater(lockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    ZNRecord newLockInfo = new ZKHelixNonblockingLockInfo<>().toZNRecord();\n+    LockUpdater updater = new LockUpdater(newLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public ZKHelixNonblockingLockInfo getLockInfo() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new ZKHelixNonblockingLockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return userIdMatches(curLockInfo) && !hasTimedOut(curLockInfo);\n+  }\n+\n+  /**\n+   * Check if a lock has timed out\n+   * @param record the current lock information in ZNRecord format\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(ZNRecord record) {\n+    if (record == null) {\n+      return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1ODMzMA==", "bodyText": "This logic should belong to the ZKHelixNonblockingLockInfo class. Considering in the near future, we want to add several more fields into ZKHelixNonblockingLockInfo. You will find we need to update ZKHelixNonblockingLockInfo class and this section.", "url": "https://github.com/apache/helix/pull/718#discussion_r377358330", "createdAt": "2020-02-10T22:35:32Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_OWNER_TEXT;\n+import static org.apache.helix.lock.ZKHelixNonblockingLockInfo.DEFAULT_TIMEOUT_LONG;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private static final String LOCK_ROOT = \"/LOCK\";\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param clusterName the cluster under which the lock will live\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(String clusterName, HelixLockScope scope, String zkAddress,\n+      Long timeout, String lockMsg, String userId) {\n+    this(\"/\" + clusterName.toUpperCase() + LOCK_ROOT + scope.getZkPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1ODkyMQ==", "bodyText": "As I commented above, there should be a default constructor that builds instance with strongly typed parameters. And the other 2 constructors can call that one inside.", "url": "https://github.com/apache/helix/pull/718#discussion_r377358921", "createdAt": "2020-02-10T22:36:52Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<K extends ZKHelixNonblockingLockInfo.InfoKey, V extends String> implements LockInfo<K, V> {\n+\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+  public static final String DEFAULT_TIMEOUT_TEXT = String.valueOf(DEFAULT_TIMEOUT_LONG);\n+  private Map<InfoKey, String> lockInfo;\n+\n+  public enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Constructor of ZKHelixNonblockingLockInfo that set each field to default data\n+   */\n+  public ZKHelixNonblockingLockInfo() {\n+    lockInfo = new HashMap<>();\n+    lockInfo.put(InfoKey.OWNER, DEFAULT_OWNER_TEXT);\n+    lockInfo.put(InfoKey.MESSAGE, DEFAULT_MESSAGE_TEXT);\n+    lockInfo.put(InfoKey.TIMEOUT, DEFAULT_TIMEOUT_TEXT);\n+  }\n+\n+  /**\n+   * Construct a ZKHelixNonblockingLockInfo using a ZNRecord format of data\n+   * @param znRecord A ZNRecord that contains lock information in its simple fields\n+   */\n+  public ZKHelixNonblockingLockInfo(ZNRecord znRecord) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1OTI4NA==", "bodyText": "This could be confusing. I suggest having a static method for building unlocked lock. And you can keep an static final object internal, and we don't need to create new object every time.", "url": "https://github.com/apache/helix/pull/718#discussion_r377359284", "createdAt": "2020-02-10T22:37:46Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<K extends ZKHelixNonblockingLockInfo.InfoKey, V extends String> implements LockInfo<K, V> {\n+\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+  public static final String DEFAULT_TIMEOUT_TEXT = String.valueOf(DEFAULT_TIMEOUT_LONG);\n+  private Map<InfoKey, String> lockInfo;\n+\n+  public enum InfoKey {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Constructor of ZKHelixNonblockingLockInfo that set each field to default data\n+   */\n+  public ZKHelixNonblockingLockInfo() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1OTczNA==", "bodyText": "This class should extend HelixProperty? In that case, you have everything you need regarding ZnRecord.", "url": "https://github.com/apache/helix/pull/718#discussion_r377359734", "createdAt": "2020-02-10T22:38:47Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/ZKHelixNonblockingLockInfo.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ZNRecord;\n+\n+\n+public class ZKHelixNonblockingLockInfo<K extends ZKHelixNonblockingLockInfo.InfoKey, V extends String> implements LockInfo<K, V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b95d02b3873861dd3a71554e65c56f012035e6a"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ab82e6fd94d7e46a81b37e79b5008b8500849cf", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/0ab82e6fd94d7e46a81b37e79b5008b8500849cf", "committedDate": "2020-02-11T18:39:00Z", "message": "refactor LockInfo and some updates on the HelixLockScope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4", "committedDate": "2020-02-14T21:28:07Z", "message": "Created LockScope interface"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MjM0NDIy", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-359234422", "createdAt": "2020-02-14T21:39:04Z", "commit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTozOTowNFrOFqEZ2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTo1MjozM1rOFqEt5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NjY2NQ==", "bodyText": "Should this one be the ownerId? Or what is the use case of this default constructor?", "url": "https://github.com/apache/helix/pull/718#discussion_r379656665", "createdAt": "2020-02-14T21:39:04Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzAwNg==", "bodyText": "Another option, just keep all lock node's ZNRecord id to be \"LOCK\"", "url": "https://github.com/apache/helix/pull/718#discussion_r379657006", "createdAt": "2020-02-14T21:39:54Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NjY2NQ=="}, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzU2OA==", "bodyText": "Should accept LockInfo object.", "url": "https://github.com/apache/helix/pull/718#discussion_r379657568", "createdAt": "2020-02-14T21:41:14Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);\n+    resetLockInfo();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord, set all info fields to default data\n+   * @param znRecord The ZNRecord contains lock node data that used to initialize the LockInfo\n+   */\n+  public LockInfo(ZNRecord znRecord) {\n+    super(znRecord);\n+    setNullLockInfoFieldsToDefault();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public LockInfo(String ownerId, String message, long timeout) {\n+    this(ownerId);\n+    setLockInfoFields(ownerId, message, timeout);\n+  }\n+\n+  /**\n+   * Build a LOCKINFO instance that represents an unlocked lock states\n+   * @return the unlocked lock node LockInfo instance\n+   */\n+  public static LockInfo buildUnlockedLockInfo() {\n+    return new LockInfo(\"\");\n+  }\n+\n+  /**\n+   * Set each field of lock info to user provided values if the values are not null, null values are set to default values\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public void setLockInfoFields(String ownerId, String message, Long timeout) {\n+    _record.setSimpleField(LockInfoAttribute.OWNER.name(),\n+        ownerId == null ? DEFAULT_OWNER_TEXT : ownerId);\n+    _record.setSimpleField(LockInfoAttribute.MESSAGE.name(),\n+        message == null ? DEFAULT_MESSAGE_TEXT : message);\n+    _record.setLongField(LockInfoAttribute.TIMEOUT.name(),\n+        timeout == null ? DEFAULT_TIMEOUT_LONG : timeout);\n+  }\n+\n+  /**\n+   * Set all null values to default values in LockInfo, keep non-null values\n+   */\n+  private void setNullLockInfoFieldsToDefault() {\n+    setLockInfoFields(getOwner(), getMessage(), getTimeout());\n+  }\n+\n+  /**\n+   * Reset the lock info to unlocked lock state\n+   */\n+  public void resetLockInfo() {\n+    setLockInfoFields(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public String getOwner() {\n+    String owner = _record.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public String getMessage() {\n+    String message = _record.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    return message == null ? DEFAULT_MESSAGE_TEXT : message;\n+  }\n+\n+  /**\n+   * Get the value for TIMEOUT attribute of the lock\n+   * @return the expiring time of the lock, -1 if there is no timeout set\n+   */\n+  public Long getTimeout() {\n+    return _record.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock from a ZNRecord\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public static String getOwner(ZNRecord znRecord) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzYxMg==", "bodyText": "Should accept LockInfo object.", "url": "https://github.com/apache/helix/pull/718#discussion_r379657612", "createdAt": "2020-02-14T21:41:20Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);\n+    resetLockInfo();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord, set all info fields to default data\n+   * @param znRecord The ZNRecord contains lock node data that used to initialize the LockInfo\n+   */\n+  public LockInfo(ZNRecord znRecord) {\n+    super(znRecord);\n+    setNullLockInfoFieldsToDefault();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public LockInfo(String ownerId, String message, long timeout) {\n+    this(ownerId);\n+    setLockInfoFields(ownerId, message, timeout);\n+  }\n+\n+  /**\n+   * Build a LOCKINFO instance that represents an unlocked lock states\n+   * @return the unlocked lock node LockInfo instance\n+   */\n+  public static LockInfo buildUnlockedLockInfo() {\n+    return new LockInfo(\"\");\n+  }\n+\n+  /**\n+   * Set each field of lock info to user provided values if the values are not null, null values are set to default values\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public void setLockInfoFields(String ownerId, String message, Long timeout) {\n+    _record.setSimpleField(LockInfoAttribute.OWNER.name(),\n+        ownerId == null ? DEFAULT_OWNER_TEXT : ownerId);\n+    _record.setSimpleField(LockInfoAttribute.MESSAGE.name(),\n+        message == null ? DEFAULT_MESSAGE_TEXT : message);\n+    _record.setLongField(LockInfoAttribute.TIMEOUT.name(),\n+        timeout == null ? DEFAULT_TIMEOUT_LONG : timeout);\n+  }\n+\n+  /**\n+   * Set all null values to default values in LockInfo, keep non-null values\n+   */\n+  private void setNullLockInfoFieldsToDefault() {\n+    setLockInfoFields(getOwner(), getMessage(), getTimeout());\n+  }\n+\n+  /**\n+   * Reset the lock info to unlocked lock state\n+   */\n+  public void resetLockInfo() {\n+    setLockInfoFields(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public String getOwner() {\n+    String owner = _record.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public String getMessage() {\n+    String message = _record.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    return message == null ? DEFAULT_MESSAGE_TEXT : message;\n+  }\n+\n+  /**\n+   * Get the value for TIMEOUT attribute of the lock\n+   * @return the expiring time of the lock, -1 if there is no timeout set\n+   */\n+  public Long getTimeout() {\n+    return _record.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock from a ZNRecord\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public static String getOwner(ZNRecord znRecord) {\n+    if (znRecord == null) {\n+      return DEFAULT_OWNER_TEXT;\n+    }\n+    String owner = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock from a ZNRecord\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public static String getMessage(ZNRecord znRecord) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzY5MA==", "bodyText": "Should accept LockInfo object.", "url": "https://github.com/apache/helix/pull/718#discussion_r379657690", "createdAt": "2020-02-14T21:41:31Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);\n+    resetLockInfo();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord, set all info fields to default data\n+   * @param znRecord The ZNRecord contains lock node data that used to initialize the LockInfo\n+   */\n+  public LockInfo(ZNRecord znRecord) {\n+    super(znRecord);\n+    setNullLockInfoFieldsToDefault();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public LockInfo(String ownerId, String message, long timeout) {\n+    this(ownerId);\n+    setLockInfoFields(ownerId, message, timeout);\n+  }\n+\n+  /**\n+   * Build a LOCKINFO instance that represents an unlocked lock states\n+   * @return the unlocked lock node LockInfo instance\n+   */\n+  public static LockInfo buildUnlockedLockInfo() {\n+    return new LockInfo(\"\");\n+  }\n+\n+  /**\n+   * Set each field of lock info to user provided values if the values are not null, null values are set to default values\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public void setLockInfoFields(String ownerId, String message, Long timeout) {\n+    _record.setSimpleField(LockInfoAttribute.OWNER.name(),\n+        ownerId == null ? DEFAULT_OWNER_TEXT : ownerId);\n+    _record.setSimpleField(LockInfoAttribute.MESSAGE.name(),\n+        message == null ? DEFAULT_MESSAGE_TEXT : message);\n+    _record.setLongField(LockInfoAttribute.TIMEOUT.name(),\n+        timeout == null ? DEFAULT_TIMEOUT_LONG : timeout);\n+  }\n+\n+  /**\n+   * Set all null values to default values in LockInfo, keep non-null values\n+   */\n+  private void setNullLockInfoFieldsToDefault() {\n+    setLockInfoFields(getOwner(), getMessage(), getTimeout());\n+  }\n+\n+  /**\n+   * Reset the lock info to unlocked lock state\n+   */\n+  public void resetLockInfo() {\n+    setLockInfoFields(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public String getOwner() {\n+    String owner = _record.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public String getMessage() {\n+    String message = _record.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    return message == null ? DEFAULT_MESSAGE_TEXT : message;\n+  }\n+\n+  /**\n+   * Get the value for TIMEOUT attribute of the lock\n+   * @return the expiring time of the lock, -1 if there is no timeout set\n+   */\n+  public Long getTimeout() {\n+    return _record.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock from a ZNRecord\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public static String getOwner(ZNRecord znRecord) {\n+    if (znRecord == null) {\n+      return DEFAULT_OWNER_TEXT;\n+    }\n+    String owner = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock from a ZNRecord\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public static String getMessage(ZNRecord znRecord) {\n+    if (znRecord == null) {\n+      return DEFAULT_MESSAGE_TEXT;\n+    }\n+    String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    return message == null ? DEFAULT_MESSAGE_TEXT : message;\n+  }\n \n   /**\n-   * Create a single filed of LockInfo, or update the value of the field if it already exists\n-   * @param infoKey the key of the LockInfo field\n-   * @param infoValue the value of the LockInfo field\n+   * Get the value for TIMEOUT attribute of the lock from a ZNRecord\n+   * @return the expiring time of the lock, -1 if there is no timeout set\n    */\n-  void setInfoValue(String infoKey, T infoValue);\n+  public static long getTimeout(ZNRecord znRecord) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzkzNA==", "bodyText": "And then you can avoid the duplicate code by calling the instance method.", "url": "https://github.com/apache/helix/pull/718#discussion_r379657934", "createdAt": "2020-02-14T21:41:55Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord id, set all info fields to default data\n+   */\n+  public LockInfo(String id) {\n+    super(id);\n+    resetLockInfo();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with a ZNRecord, set all info fields to default data\n+   * @param znRecord The ZNRecord contains lock node data that used to initialize the LockInfo\n+   */\n+  public LockInfo(ZNRecord znRecord) {\n+    super(znRecord);\n+    setNullLockInfoFieldsToDefault();\n+  }\n+\n+  /**\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public LockInfo(String ownerId, String message, long timeout) {\n+    this(ownerId);\n+    setLockInfoFields(ownerId, message, timeout);\n+  }\n+\n+  /**\n+   * Build a LOCKINFO instance that represents an unlocked lock states\n+   * @return the unlocked lock node LockInfo instance\n+   */\n+  public static LockInfo buildUnlockedLockInfo() {\n+    return new LockInfo(\"\");\n+  }\n+\n+  /**\n+   * Set each field of lock info to user provided values if the values are not null, null values are set to default values\n+   * @param ownerId value of OWNER attribute\n+   * @param message value of MESSAGE attribute\n+   * @param timeout value of TIMEOUT attribute\n+   */\n+  public void setLockInfoFields(String ownerId, String message, Long timeout) {\n+    _record.setSimpleField(LockInfoAttribute.OWNER.name(),\n+        ownerId == null ? DEFAULT_OWNER_TEXT : ownerId);\n+    _record.setSimpleField(LockInfoAttribute.MESSAGE.name(),\n+        message == null ? DEFAULT_MESSAGE_TEXT : message);\n+    _record.setLongField(LockInfoAttribute.TIMEOUT.name(),\n+        timeout == null ? DEFAULT_TIMEOUT_LONG : timeout);\n+  }\n+\n+  /**\n+   * Set all null values to default values in LockInfo, keep non-null values\n+   */\n+  private void setNullLockInfoFieldsToDefault() {\n+    setLockInfoFields(getOwner(), getMessage(), getTimeout());\n+  }\n+\n+  /**\n+   * Reset the lock info to unlocked lock state\n+   */\n+  public void resetLockInfo() {\n+    setLockInfoFields(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public String getOwner() {\n+    String owner = _record.getSimpleField(LockInfoAttribute.OWNER.name());\n+    return owner == null ? DEFAULT_OWNER_TEXT : owner;\n+  }\n+\n+  /**\n+   * Get the value for MESSAGE attribute of the lock\n+   * @return the message of the lock, empty string if there is no message set\n+   */\n+  public String getMessage() {\n+    String message = _record.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    return message == null ? DEFAULT_MESSAGE_TEXT : message;\n+  }\n+\n+  /**\n+   * Get the value for TIMEOUT attribute of the lock\n+   * @return the expiring time of the lock, -1 if there is no timeout set\n+   */\n+  public Long getTimeout() {\n+    return _record.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n+  }\n+\n+  /**\n+   * Get the value for OWNER attribute of the lock from a ZNRecord\n+   * @return the owner id of the lock, empty string if there is no owner id set\n+   */\n+  public static String getOwner(ZNRecord znRecord) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1NzU2OA=="}, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1ODk5MQ==", "bodyText": "If not necessary, let's don't adding these get methods for now.", "url": "https://github.com/apache/helix/pull/718#discussion_r379658991", "createdAt": "2020-02-14T21:44:36Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.List;\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope implements LockScope {\n+\n+  /**\n+   * Define various properties of Helix lock, and associate them with the number of arguments required for getting znode path\n+   */\n+  public enum LockScopeProperty {\n+\n+    CLUSTER(1),\n+\n+    PARTICIPANT(2),\n+\n+    RESOURCE(3),\n+\n+    PARTITION(4);\n+\n+    //the number of arguments required to generate a full path for the specific scope\n+    final int _pathArgNum;\n+\n+    /**\n+     * Initialize a LockScopeProperty\n+     * @param pathArgNum the number of arguments required to generate a full path for the specific scope\n+    \\     */\n+    private LockScopeProperty(int pathArgNum) {\n+      _pathArgNum = pathArgNum;\n+    }\n+\n+    /**\n+     * Get the number of template arguments required to generate a full path\n+     * @return number of template arguments in the path\n+     */\n+    public int getPathArgNum() {\n+      return _pathArgNum;\n+    }\n+\n+    /**\n+     * Get the position of this argument from the input that used to generate the scope\n+     * @return the number of position of value for this property in the list of keys input\n+     */\n+    public int getArgPos() {\n+      return _pathArgNum - 1;\n+    }\n+  }\n+\n+  /**\n+   * string templates to generate znode path\n+   */\n+  private static final StringTemplate template = new StringTemplate();\n+\n+  static {\n+    template.addEntry(LockScopeProperty.CLUSTER, 1, \"/{clusterName}/LOCK\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTICIPANT, 2,\n+        \"/{clusterName}/LOCK/{participantName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.RESOURCE, 3,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTITION, 4,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}/{partitionName}\");\n+  }\n+\n+  private final HelixLockScope.LockScopeProperty _type;\n+  private final String _clusterName;\n+  private final String _participantName;\n+  private final String _resourceName;\n+  private final String _partitionName;\n+\n+  private final String _zkPath;\n+\n+  /**\n+   * Initialize with a type of scope and unique identifiers\n+   * @param type the scope\n+   * @param zkPathKeys keys identifying a ZNode location\n+   */\n+  private HelixLockScope(HelixLockScope.LockScopeProperty type, List<String> zkPathKeys) {\n+\n+    if (zkPathKeys.size() != type.getPathArgNum()) {\n+      throw new IllegalArgumentException(\n+          type + \" requires \" + type.getPathArgNum() + \" arguments to get znode, but was: \"\n+              + zkPathKeys);\n+    }\n+\n+    _type = type;\n+\n+    //Initialize the name fields for various scope\n+    _clusterName = zkPathKeys.get(LockScopeProperty.CLUSTER.getArgPos());\n+\n+    if (type.getPathArgNum() >= LockScopeProperty.PARTICIPANT.getPathArgNum()) {\n+      _participantName = zkPathKeys.get(LockScopeProperty.PARTICIPANT.getArgPos());\n+    } else {\n+      _participantName = null;\n+    }\n+\n+    if (type.getPathArgNum() >= LockScopeProperty.RESOURCE.getPathArgNum()) {\n+      _resourceName = zkPathKeys.get(LockScopeProperty.RESOURCE.getArgPos());\n+    } else {\n+      _resourceName = null;\n+    }\n+\n+    if (type.getPathArgNum() >= LockScopeProperty.PARTITION.getPathArgNum()) {\n+      _partitionName = zkPathKeys.get(LockScopeProperty.PARTITION.getArgPos());\n+    } else {\n+      _partitionName = null;\n+    }\n+\n+    _zkPath = template.instantiate(type, zkPathKeys.toArray(new String[0])).toUpperCase();\n+  }\n+\n+  /**\n+   * Get the scope\n+   * @return the type of scope\n+   */\n+  public HelixLockScope.LockScopeProperty getType() {\n+    return _type;\n+  }\n+\n+  /**\n+   * Get the cluster name if it exists\n+   * @return the cluster name\n+   */\n+  public String getClusterName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1OTI5MQ==", "bodyText": "This will be a shared path with the other scope types. I think it might cause some conflicts.", "url": "https://github.com/apache/helix/pull/718#discussion_r379659291", "createdAt": "2020-02-14T21:45:27Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.List;\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope implements LockScope {\n+\n+  /**\n+   * Define various properties of Helix lock, and associate them with the number of arguments required for getting znode path\n+   */\n+  public enum LockScopeProperty {\n+\n+    CLUSTER(1),\n+\n+    PARTICIPANT(2),\n+\n+    RESOURCE(3),\n+\n+    PARTITION(4);\n+\n+    //the number of arguments required to generate a full path for the specific scope\n+    final int _pathArgNum;\n+\n+    /**\n+     * Initialize a LockScopeProperty\n+     * @param pathArgNum the number of arguments required to generate a full path for the specific scope\n+    \\     */\n+    private LockScopeProperty(int pathArgNum) {\n+      _pathArgNum = pathArgNum;\n+    }\n+\n+    /**\n+     * Get the number of template arguments required to generate a full path\n+     * @return number of template arguments in the path\n+     */\n+    public int getPathArgNum() {\n+      return _pathArgNum;\n+    }\n+\n+    /**\n+     * Get the position of this argument from the input that used to generate the scope\n+     * @return the number of position of value for this property in the list of keys input\n+     */\n+    public int getArgPos() {\n+      return _pathArgNum - 1;\n+    }\n+  }\n+\n+  /**\n+   * string templates to generate znode path\n+   */\n+  private static final StringTemplate template = new StringTemplate();\n+\n+  static {\n+    template.addEntry(LockScopeProperty.CLUSTER, 1, \"/{clusterName}/LOCK\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1OTU4NQ==", "bodyText": "Can I lock the whole resource regardless of which participant holding it?", "url": "https://github.com/apache/helix/pull/718#discussion_r379659585", "createdAt": "2020-02-14T21:46:17Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.List;\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope implements LockScope {\n+\n+  /**\n+   * Define various properties of Helix lock, and associate them with the number of arguments required for getting znode path\n+   */\n+  public enum LockScopeProperty {\n+\n+    CLUSTER(1),\n+\n+    PARTICIPANT(2),\n+\n+    RESOURCE(3),\n+\n+    PARTITION(4);\n+\n+    //the number of arguments required to generate a full path for the specific scope\n+    final int _pathArgNum;\n+\n+    /**\n+     * Initialize a LockScopeProperty\n+     * @param pathArgNum the number of arguments required to generate a full path for the specific scope\n+    \\     */\n+    private LockScopeProperty(int pathArgNum) {\n+      _pathArgNum = pathArgNum;\n+    }\n+\n+    /**\n+     * Get the number of template arguments required to generate a full path\n+     * @return number of template arguments in the path\n+     */\n+    public int getPathArgNum() {\n+      return _pathArgNum;\n+    }\n+\n+    /**\n+     * Get the position of this argument from the input that used to generate the scope\n+     * @return the number of position of value for this property in the list of keys input\n+     */\n+    public int getArgPos() {\n+      return _pathArgNum - 1;\n+    }\n+  }\n+\n+  /**\n+   * string templates to generate znode path\n+   */\n+  private static final StringTemplate template = new StringTemplate();\n+\n+  static {\n+    template.addEntry(LockScopeProperty.CLUSTER, 1, \"/{clusterName}/LOCK\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTICIPANT, 2,\n+        \"/{clusterName}/LOCK/{participantName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.RESOURCE, 3,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY1OTc1MA==", "bodyText": "Same here, the participant should not be part of the path.", "url": "https://github.com/apache/helix/pull/718#discussion_r379659750", "createdAt": "2020-02-14T21:46:47Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/HelixLockScope.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.List;\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.util.StringTemplate;\n+\n+\n+/**\n+ *  Defines the various scopes of Helix locks, and how they are represented on Zookeeper\n+ */\n+public class HelixLockScope implements LockScope {\n+\n+  /**\n+   * Define various properties of Helix lock, and associate them with the number of arguments required for getting znode path\n+   */\n+  public enum LockScopeProperty {\n+\n+    CLUSTER(1),\n+\n+    PARTICIPANT(2),\n+\n+    RESOURCE(3),\n+\n+    PARTITION(4);\n+\n+    //the number of arguments required to generate a full path for the specific scope\n+    final int _pathArgNum;\n+\n+    /**\n+     * Initialize a LockScopeProperty\n+     * @param pathArgNum the number of arguments required to generate a full path for the specific scope\n+    \\     */\n+    private LockScopeProperty(int pathArgNum) {\n+      _pathArgNum = pathArgNum;\n+    }\n+\n+    /**\n+     * Get the number of template arguments required to generate a full path\n+     * @return number of template arguments in the path\n+     */\n+    public int getPathArgNum() {\n+      return _pathArgNum;\n+    }\n+\n+    /**\n+     * Get the position of this argument from the input that used to generate the scope\n+     * @return the number of position of value for this property in the list of keys input\n+     */\n+    public int getArgPos() {\n+      return _pathArgNum - 1;\n+    }\n+  }\n+\n+  /**\n+   * string templates to generate znode path\n+   */\n+  private static final StringTemplate template = new StringTemplate();\n+\n+  static {\n+    template.addEntry(LockScopeProperty.CLUSTER, 1, \"/{clusterName}/LOCK\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTICIPANT, 2,\n+        \"/{clusterName}/LOCK/{participantName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.RESOURCE, 3,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}\");\n+    template.addEntry(HelixLockScope.LockScopeProperty.PARTITION, 4,\n+        \"/{clusterName}/LOCK/{participantName}/{resourceName}/{partitionName}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MDQ5Mg==", "bodyText": "This is fine. But if timeout cannot be negative, we should check this in the constructor.", "url": "https://github.com/apache/helix/pull/718#discussion_r379660492", "createdAt": "2020-02-14T21:48:48Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MDgzMA==", "bodyText": "This can be a private constructor if this is the only caller.", "url": "https://github.com/apache/helix/pull/718#discussion_r379660830", "createdAt": "2020-02-14T21:49:45Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,162 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo = new LockInfo(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MTQ2OQ==", "bodyText": "GetCurrentLockInfo? Since this method is not returning this instance's lock info.\nActually, keep it a static method could be cleaner.\nAlso for the following method isOwner().", "url": "https://github.com/apache/helix/pull/718#discussion_r379661469", "createdAt": "2020-02-14T21:51:37Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    LockInfo lockInfo = new LockInfo(_userId);\n+    lockInfo.setLockInfoFields(_userId, _lockMsg, deadline);\n+\n+    LockUpdater updater = new LockUpdater(lockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    // Initialize the lock updater with a default lock info represents the state of a unlocked lock\n+    LockUpdater updater = new LockUpdater(LockInfo.defaultLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public LockInfo getLockInfo() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MTc5OQ==", "bodyText": "Humm... These two are really confusing.", "url": "https://github.com/apache/helix/pull/718#discussion_r379661799", "createdAt": "2020-02-14T21:52:33Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    LockInfo lockInfo = new LockInfo(_userId);\n+    lockInfo.setLockInfoFields(_userId, _lockMsg, deadline);\n+\n+    LockUpdater updater = new LockUpdater(lockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    // Initialize the lock updater with a default lock info represents the state of a unlocked lock\n+    LockUpdater updater = new LockUpdater(LockInfo.defaultLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public LockInfo getLockInfo() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new LockInfo(curLockInfo);\n+  }\n+\n+  @Override\n+  public boolean isOwner() {\n+    LockInfo lockInfo = getLockInfo();\n+    return userIdMatches(lockInfo) && !hasTimedOut(lockInfo);\n+  }\n+\n+  /**\n+   * Check if a lock has timed out\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(LockInfo lockInfo) {\n+    return System.currentTimeMillis() >= lockInfo.getTimeout();\n+  }\n+\n+  /**\n+   * Check if a lock has timed out with lock information stored in a ZNRecord\n+   * @return return true if the lock has timed out, otherwise return false.\n+   */\n+  private boolean hasTimedOut(ZNRecord znRecord) {\n+    return System.currentTimeMillis() >= LockInfo.getTimeout(znRecord);\n+  }\n+\n+  /**\n+   * Check if the current user Id matches with the owner Id in a lock info", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4412fa760ace94ba4fb7e0c24c88575b0c0b2ef4"}, "originalPosition": 133}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "586f717340751420594750a17dfcfca16781865c", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/586f717340751420594750a17dfcfca16781865c", "committedDate": "2020-02-18T17:48:14Z", "message": "Clean up code"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "29d5c2c4a4144cd50c190367ad02e58970c47a9a", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/29d5c2c4a4144cd50c190367ad02e58970c47a9a", "committedDate": "2020-02-15T03:00:31Z", "message": "Clean code"}, "afterCommit": {"oid": "586f717340751420594750a17dfcfca16781865c", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/586f717340751420594750a17dfcfca16781865c", "committedDate": "2020-02-18T17:48:14Z", "message": "Clean up code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjQ4Mjgw", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-360648280", "createdAt": "2020-02-18T20:26:20Z", "commit": {"oid": "586f717340751420594750a17dfcfca16781865c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMDoyNjoyMFrOFrRQPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMDoyODozMVrOFrRUYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNTc3Mg==", "bodyText": "Put a TODO here. This Helix Property will be replaced since distributed lock will be a module independent from Helix.", "url": "https://github.com/apache/helix/pull/718#discussion_r380915772", "createdAt": "2020-02-18T20:26:20Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,109 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.HelixProperty;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo extends HelixProperty {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "586f717340751420594750a17dfcfca16781865c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNjI3MQ==", "bodyText": "Why we dont delete the node instead of updating it?", "url": "https://github.com/apache/helix/pull/718#discussion_r380916271", "createdAt": "2020-02-18T20:27:20Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    if (timeout < 0) {\n+      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    }\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    LockUpdater updater = new LockUpdater(new LockInfo(_userId, _lockMsg, deadline));\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    // Initialize the lock updater with a default lock info represents the state of a unlocked lock\n+    LockUpdater updater = new LockUpdater(LockInfo.defaultLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "586f717340751420594750a17dfcfca16781865c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNjgzMw==", "bodyText": "What if the path does not exists?", "url": "https://github.com/apache/helix/pull/718#discussion_r380916833", "createdAt": "2020-02-18T20:28:31Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKHelixNonblockingLock.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.util.Date;\n+\n+import org.I0Itec.zkclient.DataUpdater;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.BaseDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.lock.HelixLock;\n+import org.apache.helix.lock.LockInfo;\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.log4j.Logger;\n+\n+\n+/**\n+ * Helix nonblocking lock implementation based on Zookeeper\n+ */\n+public class ZKHelixNonblockingLock implements HelixLock {\n+\n+  private static final Logger LOG = Logger.getLogger(ZKHelixNonblockingLock.class);\n+\n+  private final String _lockPath;\n+  private final String _userId;\n+  private final long _timeout;\n+  private final String _lockMsg;\n+  private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  public ZKHelixNonblockingLock(LockScope scope, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    this(scope.getPath(), zkAddress, timeout, lockMsg, userId);\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * @param lockPath the path of the lock under Zookeeper\n+   * @param zkAddress the zk address of the cluster\n+   * @param timeout the timeout period of the lcok\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   */\n+  private ZKHelixNonblockingLock(String lockPath, String zkAddress, Long timeout, String lockMsg,\n+      String userId) {\n+    _lockPath = lockPath;\n+    if (timeout < 0) {\n+      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    }\n+    _timeout = timeout;\n+    _lockMsg = lockMsg;\n+    _userId = userId;\n+    _baseDataAccessor = new ZkBaseDataAccessor<>(zkAddress);\n+  }\n+\n+  @Override\n+  public boolean acquireLock() {\n+\n+    // Set lock information fields\n+    long deadline;\n+    // Prevent value overflow\n+    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n+      deadline = Long.MAX_VALUE;\n+    } else {\n+      deadline = System.currentTimeMillis() + _timeout;\n+    }\n+    LockUpdater updater = new LockUpdater(new LockInfo(_userId, _lockMsg, deadline));\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public boolean releaseLock() {\n+    // Initialize the lock updater with a default lock info represents the state of a unlocked lock\n+    LockUpdater updater = new LockUpdater(LockInfo.defaultLockInfo);\n+    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+  }\n+\n+  @Override\n+  public LockInfo getCurrentLockInfo() {\n+    ZNRecord curLockInfo = _baseDataAccessor.get(_lockPath, null, AccessOption.PERSISTENT);\n+    return new LockInfo(curLockInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "586f717340751420594750a17dfcfca16781865c"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdc7d3474099071dbd30ecf57f76aae31e197a8f", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/cdc7d3474099071dbd30ecf57f76aae31e197a8f", "committedDate": "2020-02-18T22:21:15Z", "message": "Remove dependency of LockInfo on HelixProperty"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzg5NjA4", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-360789608", "createdAt": "2020-02-19T01:32:11Z", "commit": {"oid": "cdc7d3474099071dbd30ecf57f76aae31e197a8f"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTozMjoxMVrOFrYViA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTozNToyNlrOFrYY0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMTgxNg==", "bodyText": "Let's have the interface as DistributedLock or something. Name it HelixLock still seemed to be sticking to Helix.", "url": "https://github.com/apache/helix/pull/718#discussion_r381031816", "createdAt": "2020-02-19T01:32:11Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/HelixLock.java", "diffHunk": "@@ -22,7 +22,7 @@\n /**\n  * Generic interface for Helix distributed lock\n  */\n-public interface HelixLock<T> {\n+public interface HelixLock {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc7d3474099071dbd30ecf57f76aae31e197a8f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMTg3MQ==", "bodyText": "Make one element per line.", "url": "https://github.com/apache/helix/pull/718#discussion_r381031871", "createdAt": "2020-02-19T01:32:24Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,106 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo =\n+      new LockInfo(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+\n+  private ZNRecord record;\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc7d3474099071dbd30ecf57f76aae31e197a8f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMjAxMQ==", "bodyText": "Make \"LOCK\" to be a constant instead of hard coding here.", "url": "https://github.com/apache/helix/pull/718#discussion_r381032011", "createdAt": "2020-02-19T01:32:56Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,106 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo =\n+      new LockInfo(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+\n+  private ZNRecord record;\n+\n+  /**\n+   * The keys to lock information\n+   */\n+  public enum LockInfoAttribute {\n+    OWNER, MESSAGE, TIMEOUT\n+  }\n+\n+  /**\n+   * Initialize a default LockInfo instance\n+   */\n+  private LockInfo() {\n+    record = new ZNRecord(\"LOCK\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc7d3474099071dbd30ecf57f76aae31e197a8f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMjY1OQ==", "bodyText": "naming convention: _record;", "url": "https://github.com/apache/helix/pull/718#discussion_r381032659", "createdAt": "2020-02-19T01:35:26Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,28 +19,106 @@\n \n package org.apache.helix.lock;\n \n-import java.util.Map;\n+import org.apache.helix.ZNRecord;\n \n \n /**\n- * Generic interface for a map contains the Helix lock information\n- * @param <T> The type of the LockInfo value\n+ * Structure represents a lock node information, implemented using ZNRecord\n  */\n-public interface LockInfo<T> {\n+public class LockInfo {\n \n-  //TODO: add specific setter and getter for any field that is determined to be universal for all implementations of HelixLock\n+  // Default values for each attribute if there are no current values set by user\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+\n+  // default lock info represents the status of a unlocked lock\n+  public static final LockInfo defaultLockInfo =\n+      new LockInfo(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+\n+  private ZNRecord record;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc7d3474099071dbd30ecf57f76aae31e197a8f"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "790845a8dfccd7f08fe9b2ced263684dfdf4f580", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/790845a8dfccd7f08fe9b2ced263684dfdf4f580", "committedDate": "2020-02-19T23:56:28Z", "message": "Rename interface HelixLock to DistributedLock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMTkzNjg0", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-362193684", "createdAt": "2020-02-20T20:00:23Z", "commit": {"oid": "790845a8dfccd7f08fe9b2ced263684dfdf4f580"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjYzNTQw", "url": "https://github.com/apache/helix/pull/718#pullrequestreview-362263540", "createdAt": "2020-02-20T21:57:36Z", "commit": {"oid": "790845a8dfccd7f08fe9b2ced263684dfdf4f580"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4914, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}