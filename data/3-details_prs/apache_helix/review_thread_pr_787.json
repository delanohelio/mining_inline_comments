{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3OTg2NjE2", "number": 787, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMTo0ODo0NFrODhsMKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMTo0ODo0NFrODhsMKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NjUzNjA4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMTo0ODo0NVrOFskTwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMTo1MjowNlrOFskZzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3NjU0NA==", "bodyText": "If we are catching concurrent modification exception, I think it is better to just catch this exception, instead of the general Exception.", "url": "https://github.com/apache/helix/pull/787#discussion_r382276544", "createdAt": "2020-02-20T21:48:45Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1043,23 +1043,40 @@ public static void purgeExpiredJobs(String workflow, WorkflowConfig workflowConf\n    * @param dataProvider\n    * @param manager\n    */\n-  public static void workflowGarbageCollection(WorkflowControllerDataProvider dataProvider,\n+  public static void workflowGarbageCollection(final WorkflowControllerDataProvider dataProvider,\n       final HelixManager manager) {\n     // Garbage collections for conditions where workflow context exists but config is missing.\n-    Map<String, ZNRecord> contexts = dataProvider.getContexts();\n-    HelixDataAccessor accessor = manager.getHelixDataAccessor();\n-    HelixPropertyStore<ZNRecord> propertyStore = manager.getHelixPropertyStore();\n \n+    Set<String> existingContexts;\n+    /*\n+     * Here try-catch is used to avoid concurrent modification exception while doing deep copy.\n+     * Map.keySet() can produce concurrent modification exception.\n+     * Reason: If the map is modified while an iteration over the set is in progress, concurrent\n+     * modification exception will be thrown.\n+     */\n+    try {\n+      existingContexts = new HashSet<>(dataProvider.getContexts().keySet());\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a8e83f4511b14537e31d483b43d4443d8ebef74"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3ODA5NA==", "bodyText": "Please create a separate issue tracking that item. In my opinion, catching ConcurrentModificationException is awkward and I personally prefer catching a general Exception.", "url": "https://github.com/apache/helix/pull/787#discussion_r382278094", "createdAt": "2020-02-20T21:52:06Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1043,23 +1043,40 @@ public static void purgeExpiredJobs(String workflow, WorkflowConfig workflowConf\n    * @param dataProvider\n    * @param manager\n    */\n-  public static void workflowGarbageCollection(WorkflowControllerDataProvider dataProvider,\n+  public static void workflowGarbageCollection(final WorkflowControllerDataProvider dataProvider,\n       final HelixManager manager) {\n     // Garbage collections for conditions where workflow context exists but config is missing.\n-    Map<String, ZNRecord> contexts = dataProvider.getContexts();\n-    HelixDataAccessor accessor = manager.getHelixDataAccessor();\n-    HelixPropertyStore<ZNRecord> propertyStore = manager.getHelixPropertyStore();\n \n+    Set<String> existingContexts;\n+    /*\n+     * Here try-catch is used to avoid concurrent modification exception while doing deep copy.\n+     * Map.keySet() can produce concurrent modification exception.\n+     * Reason: If the map is modified while an iteration over the set is in progress, concurrent\n+     * modification exception will be thrown.\n+     */\n+    try {\n+      existingContexts = new HashSet<>(dataProvider.getContexts().keySet());\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3NjU0NA=="}, "originalCommit": {"oid": "5a8e83f4511b14537e31d483b43d4443d8ebef74"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1650, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}