{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MjE3MDQx", "number": 1035, "title": "Fix leaking Zk path watch and Callbackhandler issue", "bodyText": "Short term fix #1034. Get rid of dangling CallbackHandlers and its\nrelated current state parent path in Zookeeper. Get rid of leaking\nof current state znode path due to async nature of deletion of\ncurrent state znode path to installatio of watcher in various\nthread in Helix.\nIssues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nShort term fix #1034\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n.\nGet rid of dangling CallbackHandlers and its\nrelated current state parent path in Zookeeper. Get rid of leaking\nof current state znode path due to async nature of deletion of\ncurrent state znode path to installatio of watcher in various\nthread in Helix.\n\nTests\n\n\n The following tests are written for this issue:\n\n\nTestZkCallbackHandlerLeak_testCurrentStatePathLeakingByAsycRemoval\n\n\nTestZkCallbackHandlerLeak_testDanglingCallbackHanlderFix\n\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n\n(Copy & paste the result of \"mvn test\")\n[INFO]\n[INFO] Results:\n[INFO]\n[ERROR] Failures:\n[ERROR]   TestEnableCompression.testEnableCompressionResource:116 \u00bb ThreadTimeout Method...\n[ERROR]   TestZkCallbackHandlerLeak.testRemoveUserCbHandlerOnPathRemoval:610 Should have 2 exist-watches: CURRENTSTATE/{oldSessionId} and CURRENTSTATE/{oldSessionId}/TestDB0 expected:<2> but was:<1>\n[ERROR]   TestWagedRebalanceTopologyAware.testAddZone:112->TestWagedRebalanceFaultZone.testAddZone:269->TestWagedRebalanceFaultZone.validate:315->TestWagedRebalanceFaultZone.validateZoneAndTagIsolation:339 expected:<3> but was:<2>\n[INFO]\n[ERROR] Tests run: 1149, Failures: 3, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary for Apache Helix 1.0.1-SNAPSHOT:\n[INFO]\n[INFO] Apache Helix ....................................... SUCCESS [  0.644 s]\n[INFO] Apache Helix :: Metrics Common ..................... SUCCESS [  2.058 s]\n[INFO] Apache Helix :: Metadata Store Directory Common .... SUCCESS [  1.539 s]\n[INFO] Apache Helix :: ZooKeeper API ...................... SUCCESS [  8.231 s]\n[INFO] Apache Helix :: Helix Common ....................... SUCCESS [  1.319 s]\n[INFO] Apache Helix :: Core ............................... FAILURE [  01:29 h]\n[INFO] Apache Helix :: Admin Webapp ....................... SKIPPED\n[INFO] Apache Helix :: Restful Interface .................. SKIPPED\n[INFO] Apache Helix :: Distributed Lock ................... SKIPPED\n[INFO] Apache Helix :: HelixAgent ......................... SKIPPED\n[INFO] Apache Helix :: Recipes ............................ SKIPPED\n[INFO] Apache Helix :: Recipes :: Rabbitmq Consumer Group . SKIPPED\n[INFO] Apache Helix :: Recipes :: Rsync Replicated File Store SKIPPED\n[INFO] Apache Helix :: Recipes :: distributed lock manager  SKIPPED\n[INFO] Apache Helix :: Recipes :: distributed task execution SKIPPED\n[INFO] Apache Helix :: Recipes :: service discovery ....... SKIPPED\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:29 h\n[INFO] Finished at: 2020-06-03T15:29:36-07:00\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M3:test (default-test) on project helix-core: There are test failures.\n[ERROR]\n[ERROR] Please refer to /home/ksun/helix_kaisun2000/helix/helix-core/target/surefire-reports for the individual test results.\n[ERROR] Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.\n[ERROR] -> [Help 1]\n[ERROR]\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR]\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\n[ERROR]\n[ERROR] After correcting the problems, you can resume the build with the command\n[ERROR]   mvn  -rf :helix-core\n[ksun@ksun-ld1 helix]$ pwd\n/home/ksun/helix_kaisun2000/helix\n[ksun@ksun-ld1 helix]$ mvn test\n------------------------- 2nd time ----------\n[ERROR] Tests run: 1149, Failures: 3, Errors: 0, Skipped: 0, Time elapsed: 5,396.812 s <<< FAILURE! - in TestSuite\n[ERROR] testRemoveUserCbHandlerOnPathRemoval(org.apache.helix.integration.TestZkCallbackHandlerLeak)  Time elapsed: 3.75 s  <<< FAILURE!\njava.lang.AssertionError: Should have 2 exist-watches: CURRENTSTATE/{oldSessionId} and CURRENTSTATE/{oldSessionId}/TestDB0 expected:<2> but was:<1>\nat org.apache.helix.integration.TestZkCallbackHandlerLeak.testRemoveUserCbHandlerOnPathRemoval(TestZkCallbackHandlerLeak.java:610)\n[ERROR] testEnableCompressionResource(org.apache.helix.integration.TestEnableCompression)  Time elapsed: 300.777 s  <<< FAILURE!\norg.testng.internal.thread.ThreadTimeoutException: Method org.testng.internal.TestNGMethod.testEnableCompressionResource() didn't finish within the time-out 300000\nat org.apache.helix.integration.TestEnableCompression.testEnableCompressionResource(TestEnableCompression.java:116)\n[ERROR] testBasic(org.apache.helix.integration.TestDrop)  Time elapsed: 300.142 s  <<< FAILURE!\norg.testng.internal.thread.ThreadTimeoutException: Method org.testng.internal.TestNGMethod.testBasic() didn't finish within the time-out 300000\nat org.apache.helix.integration.TestDrop.testBasic(TestDrop.java:103)\n[INFO]\n[INFO] Results:\n[INFO]\n[ERROR] Failures:\n[ERROR]   TestDrop.testBasic:103 \u00bb ThreadTimeout Method org.testng.internal.TestNGMethod...\n[ERROR]   TestEnableCompression.testEnableCompressionResource:116 \u00bb ThreadTimeout Method...\n[ERROR]   TestZkCallbackHandlerLeak.testRemoveUserCbHandlerOnPathRemoval:610 Should have 2 exist-watches: CURRENTSTATE/{oldSessionId} and CURRENTSTATE/{oldSessionId}/TestDB0 expected:<2> but was:<1>\n[INFO]\n[ERROR] Tests run: 1149, Failures: 3, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:30 h\n[INFO] Finished at: 2020-06-03T17:08:13-07:00\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M3:test (default-test) on project helix-core: There are test failures.\n[ERROR]\n[ERROR] Please refer to /home/ksun/helix_kaisun2000/helix/helix-core/target/surefire-reports for the individual test results.\n[ERROR] Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.\n[ERROR] -> [Help 1]\n[ERROR]\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR]\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\n[ksun@ksun-ld1 helix-core]$ mvn test\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation (Optional)\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-05-28T02:55:54Z", "url": "https://github.com/apache/helix/pull/1035", "merged": true, "mergeCommit": {"oid": "4ed6433b922f914e0ca82eaac041ca0987edd632"}, "closed": true, "closedAt": "2020-06-06T02:55:06Z", "author": {"login": "kaisun2000"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclkXOlAH2gAyNDI0MjE3MDQxOmUxYzliMWIyMGZiODRkYjRjZDk5OTE3ZTM2OTdkMDEwOGYxZmEyNWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcobSdRgH2gAyNDI0MjE3MDQxOjM0MDNkNTAwZTlmZWY0MjcyNWI2ZjIwOWVmMmQ0MjM2MjFlOTA5Y2I=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/e1c9b1b20fb84db4cd99917e3697d0108f1fa25b", "committedDate": "2020-05-28T02:23:14Z", "message": "Fix leaking Zk path watch and Callbackhandler issue\n\nShort term fix #1034. Get rid of dangling CallbackHandlers and its\nrelated current state parent path in Zookeeper. Get rid of leaking\nof current state znode path due to async nature of deletion of\ncurrent state znode path to installatio of watcher in various\nthread in Helix."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NzczOTE2", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-419773916", "createdAt": "2020-05-28T04:46:59Z", "commit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo0Njo1OVrOGblfJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo0Njo1OVrOGblfJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3ODkxOQ==", "bodyText": "be careful here since this changes not only the subscribe but also the current behavior, i,e, it won't handle the event at all.", "url": "https://github.com/apache/helix/pull/1035#discussion_r431578919", "createdAt": "2020-05-28T04:46:59Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -752,6 +756,10 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           changeContext.setType(NotificationContext.Type.CALLBACK);\n           changeContext.setPathChanged(parentPath);\n           changeContext.setChangeType(_changeType);\n+          if (!isReady()) {\n+            // avoid leaking CallbackHandler\n+            return;\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5Nzc0MzE1", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-419774315", "createdAt": "2020-05-28T04:48:24Z", "commit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo0ODoyNFrOGblggg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo0ODoyNFrOGblggg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3OTI2Ng==", "bodyText": "Can we add some java doc here to explain the parameters and the differences between two methods with same name?", "url": "https://github.com/apache/helix/pull/1035#discussion_r431579266", "createdAt": "2020-05-28T04:48:24Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -71,10 +71,14 @@\n   // listener subscription\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  List<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);\n+\n   void unsubscribeChildChanges(String path, IZkChildListener listener);\n \n   void subscribeDataChanges(String path, IZkDataListener listener);\n \n+  void subscribeDataChanges(String path, IZkDataListener listener, boolean skipWatchingNodeNotExist);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5Nzc1MDc1", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-419775075", "createdAt": "2020-05-28T04:51:05Z", "commit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo1MTowNVrOGbli6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo1MTowNVrOGbli6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3OTg4MA==", "bodyText": "Can we use a better name than getStat2?", "url": "https://github.com/apache/helix/pull/1035#discussion_r431579880", "createdAt": "2020-05-28T04:51:05Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1074,6 +1101,34 @@ private Stat getStat(final String path, final boolean watch) {\n     }\n   }\n \n+  /*\n+   * Install watch if there is such node and return the stat\n+   * Don't install watch if there is no such node and return null\n+   *\n+   * Use ZooKeeper native api getData() as underlying method\n+   */\n+  private Stat getStat2(final String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5Nzc1ODc0", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-419775874", "createdAt": "2020-05-28T04:53:39Z", "commit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo1MzozOVrOGbllWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo1MzozOVrOGbllWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4MDUwNQ==", "bodyText": "Does this return empty list (instead of null) if the path exists, but no children?", "url": "https://github.com/apache/helix/pull/1035#discussion_r431580505", "createdAt": "2020-05-28T04:53:39Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1858,24 +1923,47 @@ public Object call() throws Exception {\n     });\n   }\n \n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();\n+        retryUntilConnected(() -> (((ZkConnection) getConnection()).getZookeeper().getData(path, true, stat)));\n+      } else {\n+        retryUntilConnected(() -> (((ZkConnection) getConnection()).getZookeeper().exists(path, true)));\n+      }\n+    } catch (ZkNoNodeException e) {\n+      // Do nothing, this is what we want as this is not going to leak watch in ZooKeeepr server.\n+      LOG.info(\"watchForData path not existing: \" + path);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n   /**\n    * Installs a child watch for the given path.\n    * @param path\n    * @return the current children of the path or null if the zk node with the given path doesn't\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {\n     if (_zookeeperEventThread != null && Thread.currentThread() == _zookeeperEventThread) {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n     return retryUntilConnected(new Callable<List<String>>() {\n       @Override\n       public List<String> call() throws Exception {\n-        exists(path, true);\n+        if (!skipWatchingNodeNotExist) {\n+          exists(path, true);\n+        }\n         try {\n           return getChildren(path, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 181}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5Nzc2MTc3", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-419776177", "createdAt": "2020-05-28T04:54:44Z", "commit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo1NDo0NVrOGblmOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNDo1NDo0NVrOGblmOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4MDcyOA==", "bodyText": "I think we did not discuss the performance impact here, now most of the time we are using getData() instead of exist(), which could increase read traffic.", "url": "https://github.com/apache/helix/pull/1035#discussion_r431580728", "createdAt": "2020-05-28T04:54:45Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1858,24 +1923,47 @@ public Object call() throws Exception {\n     });\n   }\n \n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();\n+        retryUntilConnected(() -> (((ZkConnection) getConnection()).getZookeeper().getData(path, true, stat)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5ODEwODQ3", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-419810847", "createdAt": "2020-05-28T06:29:11Z", "commit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNjoyOToxMVrOGbnTHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNzowNTo1MVrOGboO8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODYwNw==", "bodyText": "This is mostly duplicate with ClusterControllerManager. I think we can create a parent class for both classes so as to avoid duplicate code.", "url": "https://github.com/apache/helix/pull/1035#discussion_r431608607", "createdAt": "2020-05-28T06:29:11Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterSpectatorManager.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.apache.helix.integration.manager;\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.manager.zk.CallbackHandler;\n+import org.apache.helix.manager.zk.ZKHelixManager;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusterSpectatorManager extends ZKHelixManager implements Runnable, ZkTestManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMDI5NA==", "bodyText": "You can avoid this awkwardly named method by modifying the exiting private getStat() method.\nJust add a parameter to indicate if it should do getData() or exists() internally. That will also help to reduce duplicate code.", "url": "https://github.com/apache/helix/pull/1035#discussion_r431620294", "createdAt": "2020-05-28T06:57:42Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1074,6 +1101,34 @@ private Stat getStat(final String path, final boolean watch) {\n     }\n   }\n \n+  /*\n+   * Install watch if there is such node and return the stat\n+   * Don't install watch if there is no such node and return null\n+   *\n+   * Use ZooKeeper native api getData() as underlying method\n+   */\n+  private Stat getStat2(final String path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU3OTg4MA=="}, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMjkwMg==", "bodyText": "I don't think we can switch this order here. Immediately after the watcher is installed, the event might come. If it happens before _dataListener put is done, then we miss that event.", "url": "https://github.com/apache/helix/pull/1035#discussion_r431622902", "createdAt": "2020-05-28T07:03:42Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -257,12 +274,22 @@ public void subscribeDataChanges(String path, IZkDataListener listener) {\n         }\n       }\n     }\n-    watchForData(path);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMzkyMg==", "bodyText": "code style-wise, we should implement the original watchForData method using this new one to avoid duplicate logic.", "url": "https://github.com/apache/helix/pull/1035#discussion_r431623922", "createdAt": "2020-05-28T07:05:51Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1858,24 +1923,47 @@ public Object call() throws Exception {\n     });\n   }\n \n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5OTA1NjI3", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-419905627", "createdAt": "2020-05-28T08:51:33Z", "commit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwODo1MTozM1rOGbrwEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwOTowNjo1OVrOGbsT7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4MTU1Mg==", "bodyText": "This is a public interface And HelixZkClient also extends it, do we need a default implementation for backward compatibility?", "url": "https://github.com/apache/helix/pull/1035#discussion_r431681552", "createdAt": "2020-05-28T08:51:33Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -71,10 +71,14 @@\n   // listener subscription\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  List<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4NjA1MA==", "bodyText": "No need to get stat? Passing null is enough.", "url": "https://github.com/apache/helix/pull/1035#discussion_r431686050", "createdAt": "2020-05-28T08:58:58Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1858,24 +1923,47 @@ public Object call() throws Exception {\n     });\n   }\n \n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4Nzk4NQ==", "bodyText": "Is this log necessary? May pollute the logs?", "url": "https://github.com/apache/helix/pull/1035#discussion_r431687985", "createdAt": "2020-05-28T09:02:15Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1270,6 +1325,9 @@ public void deleteRecursively(String path) throws ZkClientException {\n   private void processDataOrChildChange(WatchedEvent event, long notificationTime) {\n     final String path = event.getPath();\n     final boolean pathExists = event.getType() != EventType.NodeDeleted;\n+    if (EventType.NodeDeleted == event.getType()) {\n+      LOG.info(\"event delelete:\" + event.getPath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5MDczNQ==", "bodyText": "Agreed. Maybe we could do this: add listeners first. If watch fails, we remove listeners?", "url": "https://github.com/apache/helix/pull/1035#discussion_r431690735", "createdAt": "2020-05-28T09:06:59Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -257,12 +274,22 @@ public void subscribeDataChanges(String path, IZkDataListener listener) {\n         }\n       }\n     }\n-    watchForData(path);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMjkwMg=="}, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/3a4d157f5a30a92f64c876ec19aa4ec1ff132739", "committedDate": "2020-05-29T00:09:41Z", "message": "first round of revise. Mainly subscribeData/ChildChange would add listener\nfirst to zkclient, then add watch. if adding watch failed due to path not\nexisting in Zookeeper server, remove the listner from Zkclient."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e0c4c65e4c1d06590d2bbd41c06d69578c20ae2", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/0e0c4c65e4c1d06590d2bbd41c06d69578c20ae2", "committedDate": "2020-05-29T01:16:00Z", "message": "added the reasoning about how to use getData() to install watch that simulates\nexist() call, but not leak watch in Zookeeper server in case path is deleted"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTk3NzQw", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-420597740", "createdAt": "2020-05-29T01:33:46Z", "commit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMTozMzo0NlrOGcMCEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTozMzo0MVrOGcPUSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMDQ0OA==", "bodyText": "This should be the first line in the else block right?", "url": "https://github.com/apache/helix/pull/1035#discussion_r432210448", "createdAt": "2020-05-29T01:33:46Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -752,6 +756,10 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           changeContext.setType(NotificationContext.Type.CALLBACK);\n           changeContext.setPathChanged(parentPath);\n           changeContext.setChangeType(_changeType);\n+          if (!isReady()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMjE1NQ==", "bodyText": "Why we need to handle INIT differently?", "url": "https://github.com/apache/helix/pull/1035#discussion_r432212155", "createdAt": "2020-05-29T01:41:27Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -539,7 +539,11 @@ private void subscribeChildChange(String path, NotificationContext.Type callback\n         logger.debug(_manager.getInstanceName() + \" subscribes child-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeChildChanges(path, this);\n+      if (callbackType == Type.INIT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMjU2MQ==", "bodyText": "I think merging spectator and controller managers is simple work. Better than the current change.\nAnd if you prefer to separate the work, then I would prefer to finish that change first. Otherwise, this class is purely thrown away work.", "url": "https://github.com/apache/helix/pull/1035#discussion_r432212561", "createdAt": "2020-05-29T01:43:15Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterSpectatorManager.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.apache.helix.integration.manager;\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.manager.zk.CallbackHandler;\n+import org.apache.helix.manager.zk.ZKHelixManager;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusterSpectatorManager extends ZKHelixManager implements Runnable, ZkTestManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODYwNw=="}, "originalCommit": {"oid": "e1c9b1b20fb84db4cd99917e3697d0108f1fa25b"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzYwOA==", "bodyText": "The old methods can be deprecated since the new one completely covers the older ones.\nMoreover, for this interface, please specify the return value, since it might be confusing.\n\nif null, then the subscribe was skipped.\nif empty list, then the path has no children node.", "url": "https://github.com/apache/helix/pull/1035#discussion_r432213608", "createdAt": "2020-05-29T01:47:37Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,44 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.\n+   */\n+  List<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzcyNw==", "bodyText": "How does the caller know if the watcher has been done or not?", "url": "https://github.com/apache/helix/pull/1035#discussion_r432213727", "createdAt": "2020-05-29T01:48:04Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,44 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.\n+   */\n+  List<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);\n+\n   void unsubscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle data events of the path\n+   * Add the exists watch to Zookeeper server even if the path does not exists in zookeeper server\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   void subscribeDataChanges(String path, IZkDataListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle data events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.\n+   */\n+  void subscribeDataChanges(String path, IZkDataListener listener, boolean skipWatchingNodeNotExist);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzkyOQ==", "bodyText": "I feel this API need to be designed carefully.", "url": "https://github.com/apache/helix/pull/1035#discussion_r432213929", "createdAt": "2020-05-29T01:48:51Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,44 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.\n+   */\n+  List<String> subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);\n+\n   void unsubscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle data events of the path\n+   * Add the exists watch to Zookeeper server even if the path does not exists in zookeeper server\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   void subscribeDataChanges(String path, IZkDataListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle data events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.\n+   */\n+  void subscribeDataChanges(String path, IZkDataListener listener, boolean skipWatchingNodeNotExist);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzcyNw=="}, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjQ1MQ==", "bodyText": "It would be easier to understand that we wrap the getData() call with this try catch.\nFor the exists() call, it will never throw ZkNoNodeException, right?\nIn this case, I guess this try catch branch is not necessary here?", "url": "https://github.com/apache/helix/pull/1035#discussion_r432216451", "createdAt": "2020-05-29T01:59:45Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1078,40 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        Stat finalStat = stat;\n+        retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().getData(path, true, finalStat));\n+        LOG.debug(\"getstat() invoked with useGetData() with path: \" + path);\n+      }\n       record(path, null, startT, ZkClientMonitor.AccessType.READ);\n       return stat;\n     } catch (ZkNoNodeException e) {\n+      LOG.debug(\"getstat() invoked path: \" + path + \" null\" + \" useGetData:\" + useGetData);\n       record(path, null, startT, ZkClientMonitor.AccessType.READ);\n-      throw e;\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjc2OQ==", "bodyText": "Put the getStat call inside the recordPathStat parameter list is no longer clean.\nPlease create a local var for the state and pass it to the record method.", "url": "https://github.com/apache/helix/pull/1035#discussion_r432216769", "createdAt": "2020-05-29T02:01:01Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1304,7 +1356,11 @@ private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry>\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n               // getStat will re-install watcher only when the path exists\n-              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n+              if (!pathExists) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjgwMg==", "bodyText": "Same here.", "url": "https://github.com/apache/helix/pull/1035#discussion_r432216802", "createdAt": "2020-05-29T02:01:09Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1341,8 +1397,11 @@ private void fireChildChangedEvents(final String path, Set<IZkChildListener> chi\n           @Override\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists),\n-                  OptionalLong.empty());\n+              if (!pathExists) {\n+                pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists), OptionalLong.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjg4Mg==", "bodyText": "If no listener, still need to watch? Why?", "url": "https://github.com/apache/helix/pull/1035#discussion_r432216882", "createdAt": "2020-05-29T02:01:35Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1341,8 +1397,11 @@ private void fireChildChangedEvents(final String path, Set<IZkChildListener> chi\n           @Override\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists),\n-                  OptionalLong.empty());\n+              if (!pathExists) {\n+                pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists), OptionalLong.empty());\n+              } else {\n+                pathStatRecord.recordPathStat(getStat(path, true, true), OptionalLong.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNzAxNg==", "bodyText": "Same here, if path does not exists, the old logic is skip watching, right?", "url": "https://github.com/apache/helix/pull/1035#discussion_r432217016", "createdAt": "2020-05-29T02:02:10Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1304,7 +1356,11 @@ private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry>\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n               // getStat will re-install watcher only when the path exists\n-              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n+              if (!pathExists) {\n+                pathStatRecord.recordPathStat(getStat(path, false), notificationTime);\n+              } else {\n+                pathStatRecord.recordPathStat(getStat(path, true, true), notificationTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA==", "bodyText": "If skipWatchingNodeNotExist, then we don't watch the root path? This change the behavior, right?", "url": "https://github.com/apache/helix/pull/1035#discussion_r432263628", "createdAt": "2020-05-29T05:31:03Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1865,17 +1934,24 @@ public Object call() throws Exception {\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {\n     if (_zookeeperEventThread != null && Thread.currentThread() == _zookeeperEventThread) {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n     return retryUntilConnected(new Callable<List<String>>() {\n       @Override\n       public List<String> call() throws Exception {\n-        exists(path, true);\n+        if (!skipWatchingNodeNotExist) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDI2NA==", "bodyText": "I feel this boolean is not straightforward to understand. Shall we add an opposite boolean, watchNonExistPath? That is easier to understand, IMO.", "url": "https://github.com/apache/helix/pull/1035#discussion_r432264264", "createdAt": "2020-05-29T05:33:41Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,44 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist Ture means not installing any watch if path does not exist.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a29063095b79a06c7c4bbaf0237b304593814547", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/a29063095b79a06c7c4bbaf0237b304593814547", "committedDate": "2020-05-30T00:34:06Z", "message": "interface change to return subscription success status. And\nsome small modification."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjUwMDE1", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-422250015", "createdAt": "2020-06-01T23:39:31Z", "commit": {"oid": "a29063095b79a06c7c4bbaf0237b304593814547"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzozOTozMVrOGddb-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzozOTozMVrOGddb-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NDE4Ng==", "bodyText": "Can we make it more OO?", "url": "https://github.com/apache/helix/pull/1035#discussion_r433544186", "createdAt": "2020-06-01T23:39:31Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -68,13 +68,55 @@\n   int DEFAULT_CONNECTION_TIMEOUT = 60 * 1000;\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n+  class ChildrenSubscribeResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a29063095b79a06c7c4bbaf0237b304593814547"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjUwNzU0", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-422250754", "createdAt": "2020-06-01T23:41:51Z", "commit": {"oid": "a29063095b79a06c7c4bbaf0237b304593814547"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzo0MTo1MVrOGddeUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzo0MTo1MVrOGddeUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NDc4NA==", "bodyText": "Let's make ChildrenSubscribeResult a standalone class.", "url": "https://github.com/apache/helix/pull/1035#discussion_r433544784", "createdAt": "2020-06-01T23:41:51Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -212,6 +213,11 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n   }\n \n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    RealmAwareZkClient.ChildrenSubscribeResult result = subscribeChildChanges(path, listener, false);\n+    return result.children;\n+  }\n+\n+  public RealmAwareZkClient.ChildrenSubscribeResult subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a29063095b79a06c7c4bbaf0237b304593814547"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fd34f366718560c5bc634f487ac46c6b38c08a3", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/6fd34f366718560c5bc634f487ac46c6b38c08a3", "committedDate": "2020-06-02T01:02:17Z", "message": "interface refactor and test class refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8adc0932330f9636b607c23c43885d9578e8ee9", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/e8adc0932330f9636b607c23c43885d9578e8ee9", "committedDate": "2020-06-02T05:06:09Z", "message": "minor fix for null case."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjI2ODEy", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-420626812", "createdAt": "2020-05-29T03:19:11Z", "commit": {"oid": "0e0c4c65e4c1d06590d2bbd41c06d69578c20ae2"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMzoxOToxMVrOGcNflg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNToyODozNVrOGdikRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNDM5MA==", "bodyText": "Is this variable unnecessary?", "url": "https://github.com/apache/helix/pull/1035#discussion_r432234390", "createdAt": "2020-05-29T03:19:11Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1078,46 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        Stat finalStat = stat;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e0c4c65e4c1d06590d2bbd41c06d69578c20ae2"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzAwNw==", "bodyText": "@kaisun2000 Typo. And could you change the logging to parameterized logging: LOG.debug(\"Event delete: {}\", event.getPath());? There is performance advantage over the concatenation. The fully formatted message text is NOT created unless the DEBUG level is enabled for the logger. It is like\nif (logger.isDebugEnabled()) {\n  LOG.debug(\"event delete: \" + event.getPath());\n}\n\nBut the one you use will still create the message. We would like optimal performance, right?", "url": "https://github.com/apache/helix/pull/1035#discussion_r432237007", "createdAt": "2020-05-29T03:31:41Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1270,6 +1325,9 @@ public void deleteRecursively(String path) throws ZkClientException {\n   private void processDataOrChildChange(WatchedEvent event, long notificationTime) {\n     final String path = event.getPath();\n     final boolean pathExists = event.getType() != EventType.NodeDeleted;\n+    if (EventType.NodeDeleted == event.getType()) {\n+      LOG.debug(\"event delelete:\" + event.getPath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e0c4c65e4c1d06590d2bbd41c06d69578c20ae2"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNjYwMA==", "bodyText": "Why is this finaStat necessary?", "url": "https://github.com/apache/helix/pull/1035#discussion_r433626600", "createdAt": "2020-06-02T05:23:03Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,47 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"getstat() invoked with useGetData() with path: \" + path);\n+          Stat finalStat = stat;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8adc0932330f9636b607c23c43885d9578e8ee9"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNzgwMw==", "bodyText": "Apache license.", "url": "https://github.com/apache/helix/pull/1035#discussion_r433627803", "createdAt": "2020-06-02T05:27:23Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.apache.helix.zookeeper.api.client;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8adc0932330f9636b607c23c43885d9578e8ee9"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyODA5MA==", "bodyText": "Apache license.", "url": "https://github.com/apache/helix/pull/1035#discussion_r433628090", "createdAt": "2020-06-02T05:28:10Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.apache.helix.integration.manager;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8adc0932330f9636b607c23c43885d9578e8ee9"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyODIyOQ==", "bodyText": "Apache license.", "url": "https://github.com/apache/helix/pull/1035#discussion_r433628229", "createdAt": "2020-06-02T05:28:35Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterSpectatorManager.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.apache.helix.integration.manager;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8adc0932330f9636b607c23c43885d9578e8ee9"}, "originalPosition": 2}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56f9de9e79c432494d0bfaec3168a6dde5bc15d8", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/56f9de9e79c432494d0bfaec3168a6dde5bc15d8", "committedDate": "2020-06-02T08:17:40Z", "message": "bring subscribeData on par with subscribeChildren. Namely INIT time\nallow no-existing path, CALLBACK time, will not."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8466c2c41e648baf1ef6a3d50a54c75d8e86b89a", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/8466c2c41e648baf1ef6a3d50a54c75d8e86b89a", "committedDate": "2020-06-02T10:06:06Z", "message": "revert logging."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34eb69f799931fac89f146f87427aa8d7675062a", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/34eb69f799931fac89f146f87427aa8d7675062a", "committedDate": "2020-06-03T21:49:24Z", "message": "add apache license"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/a1d39c7f0347dee5004bb603495ecafa7da3d487", "committedDate": "2020-06-03T23:20:44Z", "message": "fix logging to improve performance when debug is not on."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MDg3MjQy", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-424087242", "createdAt": "2020-06-04T04:06:18Z", "commit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDowNjoxOFrOGe1GjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDoxNTowMlrOGe1ORQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MDQ5Mw==", "bodyText": "Shall we print some logs here? Since there are some other info log printed before", "url": "https://github.com/apache/helix/pull/1035#discussion_r434980493", "createdAt": "2020-06-04T04:06:18Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -748,6 +756,10 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           // removeListener will call handler.reset(), which in turn call invoke() on FINALIZE type\n           _manager.removeListener(_propertyKey, _listener);\n         } else {\n+          if (!isReady()) {\n+            // avoid leaking CallbackHandler", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MjQ2OQ==", "bodyText": "But if skipWatchingNodeNotExist is true, so we skip install watcher on parent path. Then do we still need to install watcher on childs? Shall we directly return here?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434982469", "createdAt": "2020-06-04T04:15:02Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1865,17 +1934,24 @@ public Object call() throws Exception {\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {\n     if (_zookeeperEventThread != null && Thread.currentThread() == _zookeeperEventThread) {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n     return retryUntilConnected(new Callable<List<String>>() {\n       @Override\n       public List<String> call() throws Exception {\n-        exists(path, true);\n+        if (!skipWatchingNodeNotExist) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzUzNDg1", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-422353485", "createdAt": "2020-06-02T05:32:41Z", "commit": {"oid": "e8adc0932330f9636b607c23c43885d9578e8ee9"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNTozMjo0MVrOGdioww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDoxNToxNlrOGe1Oig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyOTM3OQ==", "bodyText": "Change it to isSubscribed?", "url": "https://github.com/apache/helix/pull/1035#discussion_r433629379", "createdAt": "2020-06-02T05:32:41Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.apache.helix.zookeeper.api.client;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+public class ChildrenSubscribeResult {\n+  private List<String> _children;\n+  private boolean _isInstalled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8adc0932330f9636b607c23c43885d9578e8ee9"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NTI4NQ==", "bodyText": "@kaisun2000 null is acceptable for the param stat. It would not throw exception. See here So no need to get the stat here for this api.\n    public void testBadAuthThenSendOtherCommands() throws Exception {\n        ZooKeeper zk = createClient();     \n        try {        \n            zk.addAuthInfo(\"INVALID\", \"BAR\".getBytes());\n            zk.exists(\"/foobar\", false);             \n            zk.getData(\"/path1\", false, null);\n            Assert.fail(\"Should get auth state error\");", "url": "https://github.com/apache/helix/pull/1035#discussion_r434945285", "createdAt": "2020-06-04T01:41:26Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1849,13 +1924,23 @@ private void checkDataSizeLimit(byte[] data) {\n   }\n \n   public void watchForData(final String path) {\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        getConnection().exists(path, true);\n-        return null;\n+    watchForData(path, false);\n+  }\n+\n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjA5Ng==", "bodyText": "Typo: delelete -> delete\nAnd also may be a good idea to make it clearer? \"Event NodeDeleted, path: {}\"", "url": "https://github.com/apache/helix/pull/1035#discussion_r434946096", "createdAt": "2020-06-04T01:44:28Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1270,6 +1330,9 @@ public void deleteRecursively(String path) throws ZkClientException {\n   private void processDataOrChildChange(WatchedEvent event, long notificationTime) {\n     final String path = event.getPath();\n     final boolean pathExists = event.getType() != EventType.NodeDeleted;\n+    if (EventType.NodeDeleted == event.getType()) {\n+      LOG.debug(\"event delelete: {}\", event.getPath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0ODYyMQ==", "bodyText": "Maybe could we add a log here for such case?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434948621", "createdAt": "2020-06-04T01:54:47Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -748,6 +756,10 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           // removeListener will call handler.reset(), which in turn call invoke() on FINALIZE type\n           _manager.removeListener(_propertyKey, _listener);\n         } else {\n+          if (!isReady()) {\n+            // avoid leaking CallbackHandler", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NDQ5NQ==", "bodyText": "Could we add an empty line before the new test method? And add some comments what this test does?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434954495", "createdAt": "2020-06-04T02:18:10Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTA0Nw==", "bodyText": "Boolean -> boolean?\nAnd style. It doesn't seem this line is formatted.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434955047", "createdAt": "2020-06-04T02:20:39Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTE5Mw==", "bodyText": "If we don't need these lines, we remove them, instead of commenting out.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434955193", "createdAt": "2020-06-04T02:21:17Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw==", "bodyText": "Why does it need to sleep 5 seconds? Is it deterministic?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434955557", "createdAt": "2020-06-04T02:22:42Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NjU1Nw==", "bodyText": "No need to use this extra variable zkAddr? We don't want to over use variables.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434956557", "createdAt": "2020-06-04T02:26:37Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3MzUzMw==", "bodyText": "Is this line redundant?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434973533", "createdAt": "2020-06-04T03:36:00Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB\n+    LOG.info(\"expire rp manager session:\", rpManager.getSessionId());\n+    ZkTestHelper.expireSession(rpManager.getZkClient());\n+    LOG.info(\"rp manager new session:\", rpManager.getSessionId());\n+\n+    Thread.sleep(5000);\n+\n+    MockParticipantManager participantToExpire = participants[0];\n+    String oldSessionId = participantToExpire.getSessionId();\n+    PropertyKey.Builder keyBuilder = new PropertyKey.Builder(clusterName);\n+\n+    // expire participant session; leaked callback handler used to be not reset() and be removed from ZkClient\n+    LOG.info(\n+        \"Expire participant: \" + participantToExpire.getInstanceName() + \", session: \"\n+            + participantToExpire.getSessionId());\n+    ZkTestHelper.expireSession(participantToExpire.getZkClient());\n+    String newSessionId = participantToExpire.getSessionId();\n+    LOG.info(participantToExpire.getInstanceName() + \" oldSessionId: \" + oldSessionId\n+        + \", newSessionId: \" + newSessionId);\n+\n+    Thread.sleep(5000);\n+    Map<String, Set<IZkChildListener>> childListeners = ZkTestHelper.getZkChildListener(rpManager.getZkClient());\n+    for (String path : childListeners.keySet()) {\n+      Assert.assertTrue(childListeners.get(path).size() <= 1);\n+    }\n+\n+    Map<String, List<String>> rpWatchPaths = ZkTestHelper.getZkWatch(rpManager.getZkClient());\n+    List<String> existWatches = rpWatchPaths.get(\"existWatches\");\n+    Assert.assertTrue(existWatches.isEmpty());\n+  }\n+\n+  @Test\n+  public void testCurrentStatePathLeakingByAsycRemoval() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    final int mJobUpdateCnt = 500;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // HelixManager rpManager  = HelixManagerFactory.getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    // rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    LOG.info(\"add job\");\n+    MockParticipantManager jobParticipant = participants[0];\n+    String jobSessionId = jobParticipant.getSessionId();\n+    HelixDataAccessor jobAccesor = jobParticipant.getHelixDataAccessor();\n+    PropertyKey.Builder jobKeyBuilder = new PropertyKey.Builder(clusterName);\n+    PropertyKey db0key = jobKeyBuilder.currentState(jobParticipant.getInstanceName(), jobSessionId, \"TestDB0\");\n+    CurrentState db0 = jobAccesor.getProperty(db0key);\n+    PropertyKey jobKey = jobKeyBuilder.currentState(jobParticipant.getInstanceName(), jobSessionId, \"BackupQueue\");\n+    CurrentState cs = new CurrentState(\"BackupQueue\");\n+    cs.setSessionId(jobSessionId);\n+    cs.setStateModelDefRef(db0.getStateModelDefRef());\n+\n+    LOG.info(\"add job\");\n+    boolean rtJob = jobAccesor.setProperty(jobKey, cs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NDg3Mg==", "bodyText": "Your test method is AsyncRemoval. Is this async?\nShall we also verify the watches before removal, to make sure the watches are really added and removed?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434974872", "createdAt": "2020-06-04T03:41:54Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB\n+    LOG.info(\"expire rp manager session:\", rpManager.getSessionId());\n+    ZkTestHelper.expireSession(rpManager.getZkClient());\n+    LOG.info(\"rp manager new session:\", rpManager.getSessionId());\n+\n+    Thread.sleep(5000);\n+\n+    MockParticipantManager participantToExpire = participants[0];\n+    String oldSessionId = participantToExpire.getSessionId();\n+    PropertyKey.Builder keyBuilder = new PropertyKey.Builder(clusterName);\n+\n+    // expire participant session; leaked callback handler used to be not reset() and be removed from ZkClient\n+    LOG.info(\n+        \"Expire participant: \" + participantToExpire.getInstanceName() + \", session: \"\n+            + participantToExpire.getSessionId());\n+    ZkTestHelper.expireSession(participantToExpire.getZkClient());\n+    String newSessionId = participantToExpire.getSessionId();\n+    LOG.info(participantToExpire.getInstanceName() + \" oldSessionId: \" + oldSessionId\n+        + \", newSessionId: \" + newSessionId);\n+\n+    Thread.sleep(5000);\n+    Map<String, Set<IZkChildListener>> childListeners = ZkTestHelper.getZkChildListener(rpManager.getZkClient());\n+    for (String path : childListeners.keySet()) {\n+      Assert.assertTrue(childListeners.get(path).size() <= 1);\n+    }\n+\n+    Map<String, List<String>> rpWatchPaths = ZkTestHelper.getZkWatch(rpManager.getZkClient());\n+    List<String> existWatches = rpWatchPaths.get(\"existWatches\");\n+    Assert.assertTrue(existWatches.isEmpty());\n+  }\n+\n+  @Test\n+  public void testCurrentStatePathLeakingByAsycRemoval() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    final int mJobUpdateCnt = 500;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // HelixManager rpManager  = HelixManagerFactory.getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    // rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    LOG.info(\"add job\");\n+    MockParticipantManager jobParticipant = participants[0];\n+    String jobSessionId = jobParticipant.getSessionId();\n+    HelixDataAccessor jobAccesor = jobParticipant.getHelixDataAccessor();\n+    PropertyKey.Builder jobKeyBuilder = new PropertyKey.Builder(clusterName);\n+    PropertyKey db0key = jobKeyBuilder.currentState(jobParticipant.getInstanceName(), jobSessionId, \"TestDB0\");\n+    CurrentState db0 = jobAccesor.getProperty(db0key);\n+    PropertyKey jobKey = jobKeyBuilder.currentState(jobParticipant.getInstanceName(), jobSessionId, \"BackupQueue\");\n+    CurrentState cs = new CurrentState(\"BackupQueue\");\n+    cs.setSessionId(jobSessionId);\n+    cs.setStateModelDefRef(db0.getStateModelDefRef());\n+\n+    LOG.info(\"add job\");\n+    boolean rtJob = jobAccesor.setProperty(jobKey, cs);\n+    for (int i = 0; i < mJobUpdateCnt; i++) {\n+      rtJob = jobAccesor.setProperty(jobKey, cs);\n+    }\n+\n+    LOG.info(\"remove job\");\n+    rtJob =jobParticipant.getZkClient().delete(jobKey.getPath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NTQwMQ==", "bodyText": "Could we add a comment why constructing this RoutingTableProvider is necessary as the variable is not used?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434975401", "createdAt": "2020-06-04T03:44:12Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NjA3Mg==", "bodyText": "You have a fix, would expiring helix manager would still create dangling CB?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434976072", "createdAt": "2020-06-04T03:46:53Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3Nzk0Mg==", "bodyText": "I meant parameterized logging for all logging you are adding. Here this is a debug level, usually we would only enable info or warn level, but this string is still concatenated. But if you use parameterized logging, at info/warn level, we could eliminate such string concatenation overhead, right? I strongly suggest changing all loggings you are adding.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434977942", "createdAt": "2020-06-04T03:55:02Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,47 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"getstat() invoked with useGetData() with path: \" + path);\n+          Stat finalStat = stat;\n+          retryUntilConnected(() -> ((ZkConnection) getConnection()).getZookeeper().getData(path, true, finalStat));\n+        } catch (ZkNoNodeException e) {\n+          LOG.debug(\"getstat() invoked path: \" + path + \" null\" + \" useGetData:\" + useGetData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4MjUzOA==", "bodyText": "@kaisun2000 This is not yet resolved. The reason why Intellij complains it is, the variable used in lamda should be final but you initialize stat to null before try block. So stat is not final.\nTo avoid the finalStat, you could remove the variable init to null. So lamda/intellij won't complain. Then it is fine to remove finalStat. We don't over use variables, right? Thanks.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434982538", "createdAt": "2020-06-04T04:15:16Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,47 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    Stat stat = null;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"getstat() invoked with useGetData() with path: \" + path);\n+          Stat finalStat = stat;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTAzOTU2", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-424103956", "createdAt": "2020-06-04T05:03:04Z", "commit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNTowMzowNVrOGe163A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNToyNzozM1rOGe2TNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5Mzg4NA==", "bodyText": "Why not check the result here? If subscribe fails, shall we just ignore it?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434993884", "createdAt": "2020-06-04T05:03:05Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -539,7 +539,15 @@ private void subscribeChildChange(String path, NotificationContext.Type callback\n         logger.debug(_manager.getInstanceName() + \" subscribes child-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeChildChanges(path, this);\n+      // In the lifecycle of CallbackHandler, INIT is the first stage of registration of watch.\n+      // For some usage case such as current state, the path can be created later. Thus we would\n+      // install watch anyway event the path is not yet created.\n+      // Later, CALLBACK type, the CallbackHandler already registered the watch and knows the\n+      // path was created. Here, to avoid leaking path in ZooKeeper server, we would not let\n+      // CallbackHandler to install exists watch, namely watch for path not existing.\n+      // Note when path is removed, the CallbackHanler would remove itself from ZkHelixManager too\n+      // to avoid leaking a CallbackHandler.\n+      _zkClient.subscribeChildChanges(path, this, callbackType != Type.INIT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NDEwMA==", "bodyText": "Same here, we are not checking the result.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434994100", "createdAt": "2020-06-04T05:03:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -555,7 +563,7 @@ private void subscribeDataChange(String path, NotificationContext.Type callbackT\n         logger.debug(_manager.getInstanceName() + \" subscribe data-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeDataChanges(path, this);\n+      _zkClient.subscribeDataChanges(path, this, callbackType != Type.INIT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NDc1MA==", "bodyText": "We agreed on not adding more magic numbers as the sleep time before.\nPlease use wait or verifier which loop and wait until the expected condition matches.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434994750", "createdAt": "2020-06-04T05:06:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NDk5NA==", "bodyText": "This is not necessary, I think.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434994994", "createdAt": "2020-06-04T05:07:47Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterManager.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.apache.helix.integration.manager;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.manager.zk.CallbackHandler;\n+import org.apache.helix.manager.zk.ZKHelixManager;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusterManager extends ZKHelixManager implements Runnable, ZkTestManager {\n+  private static Logger LOG = LoggerFactory.getLogger(ClusterControllerManager.class);\n+\n+  protected CountDownLatch _startCountDown = new CountDownLatch(1);\n+  protected CountDownLatch _stopCountDown = new CountDownLatch(1);\n+  protected CountDownLatch _waitStopFinishCountDown = new CountDownLatch(1);\n+\n+  protected boolean _started = false;\n+\n+  public ClusterManager(String zkAddr, String clusterName, InstanceType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NTQyNw==", "bodyText": "roleName -> instanceName?\nAnd this constructor can be protected, only called in the children.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434995427", "createdAt": "2020-06-04T05:09:37Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/integration/manager/ClusterManager.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.apache.helix.integration.manager;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.manager.zk.CallbackHandler;\n+import org.apache.helix.manager.zk.ZKHelixManager;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusterManager extends ZKHelixManager implements Runnable, ZkTestManager {\n+  private static Logger LOG = LoggerFactory.getLogger(ClusterControllerManager.class);\n+\n+  protected CountDownLatch _startCountDown = new CountDownLatch(1);\n+  protected CountDownLatch _stopCountDown = new CountDownLatch(1);\n+  protected CountDownLatch _waitStopFinishCountDown = new CountDownLatch(1);\n+\n+  protected boolean _started = false;\n+\n+  public ClusterManager(String zkAddr, String clusterName, InstanceType type) {\n+    this(zkAddr, clusterName, \"role\", type);\n+  }\n+\n+  public ClusterManager(String zkAddr, String clusterName, String roleName, InstanceType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NTU5OA==", "bodyText": "Add some Java doc to describe this new class please.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434995598", "createdAt": "2020-06-04T05:10:17Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+public class ChildrenSubscribeResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NTcyMQ==", "bodyText": "final for both fields", "url": "https://github.com/apache/helix/pull/1035#discussion_r434995721", "createdAt": "2020-06-04T05:10:47Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+public class ChildrenSubscribeResult {\n+  private List<String> _children;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjA0NA==", "bodyText": "@return ....", "url": "https://github.com/apache/helix/pull/1035#discussion_r434996044", "createdAt": "2020-06-04T05:12:03Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,49 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * The method return null if the path does not exists. Otherwise, return a list of children\n+   * under the path. The list can be empty if there is no children.\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist True means not installing any watch if path does not exist.\n+   * The method return ChildrentSubsribeResult. If the path does not exists, the isInstalled field", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjY4Nw==", "bodyText": "skipWatchingNonExistNode?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434996687", "createdAt": "2020-06-04T05:14:36Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,49 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * The method return null if the path does not exists. Otherwise, return a list of children\n+   * under the path. The list can be empty if there is no children.\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist True means not installing any watch if path does not exist.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NzMwMQ==", "bodyText": "Deprecate\uff1f", "url": "https://github.com/apache/helix/pull/1035#discussion_r434997301", "createdAt": "2020-06-04T05:16:56Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,49 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * The method return null if the path does not exists. Otherwise, return a list of children\n+   * under the path. The list can be empty if there is no children.\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NzM3Ng==", "bodyText": "Deprecate\uff1f", "url": "https://github.com/apache/helix/pull/1035#discussion_r434997376", "createdAt": "2020-06-04T05:17:11Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,49 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * The method return null if the path does not exists. Otherwise, return a list of children\n+   * under the path. The list can be empty if there is no children.\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist True means not installing any watch if path does not exist.\n+   * The method return ChildrentSubsribeResult. If the path does not exists, the isInstalled field\n+   * is false. Otherwise, it is true and list of children are returned.\n+   */\n+  ChildrenSubscribeResult subscribeChildChanges(String path, IZkChildListener listener, boolean skipWatchingNodeNotExist);\n+\n   void unsubscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle data events of the path\n+   * Add the exists watch to Zookeeper server even if the path does not exists in zookeeper server\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   */\n   void subscribeDataChanges(String path, IZkDataListener listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5ODQ5MQ==", "bodyText": "Just curious, why we need this debug?\nAnd nit, if (LOG.isDebugEnabled() && ventType.NodeDeleted == event.getType())\nJust want to save some unnecessary computation.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434998491", "createdAt": "2020-06-04T05:21:18Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1270,6 +1330,9 @@ public void deleteRecursively(String path) throws ZkClientException {\n   private void processDataOrChildChange(WatchedEvent event, long notificationTime) {\n     final String path = event.getPath();\n     final boolean pathExists = event.getType() != EventType.NodeDeleted;\n+    if (EventType.NodeDeleted == event.getType()) {\n+      LOG.debug(\"event delelete: {}\", event.getPath());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjA5Ng=="}, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5ODgyNg==", "bodyText": "I the current way, code readers may still not following. Please add some comments here for the logic.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434998826", "createdAt": "2020-06-04T05:22:41Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1304,7 +1356,11 @@ private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry>\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n               // getStat will re-install watcher only when the path exists\n-              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n+              if (!pathExists) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxNjc2OQ=="}, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTIxMQ==", "bodyText": "Will it be cleaner if we put this condition into the retryUntilConnected lamda?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434999211", "createdAt": "2020-06-04T05:24:16Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1849,13 +1924,23 @@ private void checkDataSizeLimit(byte[] data) {\n   }\n \n   public void watchForData(final String path) {\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        getConnection().exists(path, true);\n-        return null;\n+    watchForData(path, false);\n+  }\n+\n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTM1NA==", "bodyText": "This one is not used anyway, just new a Stat in the lamda.", "url": "https://github.com/apache/helix/pull/1035#discussion_r434999354", "createdAt": "2020-06-04T05:24:56Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1849,13 +1924,23 @@ private void checkDataSizeLimit(byte[] data) {\n   }\n \n   public void watchForData(final String path) {\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        getConnection().exists(path, true);\n-        return null;\n+    watchForData(path, false);\n+  }\n+\n+  private boolean watchForData(final String path, boolean skipWatchingNodeNotExist) {\n+    try {\n+      if (skipWatchingNodeNotExist) {\n+        Stat stat = new Stat();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMDExOA==", "bodyText": "1/ skipWatchingNodeNotExist true, if the parent path is not there. We will not install watch.\n\nWhat you are doing is, if skipWatchingNodeNotExist is true, then not install the watch no matter the parent path exists or not. Please double check.", "url": "https://github.com/apache/helix/pull/1035#discussion_r435000118", "createdAt": "2020-06-04T05:27:33Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1865,17 +1934,24 @@ public Object call() throws Exception {\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {\n     if (_zookeeperEventThread != null && Thread.currentThread() == _zookeeperEventThread) {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n     return retryUntilConnected(new Callable<List<String>>() {\n       @Override\n       public List<String> call() throws Exception {\n-        exists(path, true);\n+        if (!skipWatchingNodeNotExist) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MzYyOA=="}, "originalCommit": {"oid": "3a4d157f5a30a92f64c876ec19aa4ec1ff132739"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MDk2NzY4", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-424096768", "createdAt": "2020-06-04T04:39:31Z", "commit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDozOTozMVrOGe1kww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNTowMDoxOFrOGe14cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4ODIyNw==", "bodyText": "Why are we making it unmodifiable? It seems to me unnecessary. If no this wrap, we could just assign _children = children;", "url": "https://github.com/apache/helix/pull/1035#discussion_r434988227", "createdAt": "2020-06-04T04:39:31Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+public class ChildrenSubscribeResult {\n+  private List<String> _children;\n+  private boolean _isInstalled;\n+\n+  public ChildrenSubscribeResult(List<String> children, boolean isInstalled) {\n+    if (children != null) {\n+      _children = Collections.unmodifiableList(children);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MzI2Nw==", "bodyText": "From the logic, skipWatchingNodeNotExist indicates whether or not exists watch should be installed for parent, right? I feel it is not that easy to understand. Shall we use skipWatchingParent which seems much easier to understand?", "url": "https://github.com/apache/helix/pull/1035#discussion_r434993267", "createdAt": "2020-06-04T05:00:18Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1865,17 +1950,24 @@ public Object call() throws Exception {\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 218}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6fd57c018a9ee5cd8c7ec21a2866111e3d057e9", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/e6fd57c018a9ee5cd8c7ec21a2866111e3d057e9", "committedDate": "2020-06-04T05:56:19Z", "message": "address some further comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/76d519e8dd3f71520cb7902e42c7fec21b29382a", "committedDate": "2020-06-04T08:47:13Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NjUxODU0", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-424651854", "createdAt": "2020-06-04T17:01:24Z", "commit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzowMToyNFrOGfPYFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzoxNjozOVrOGfP6YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMDk2Nw==", "bodyText": "Not trying to be buggy, but usually no empty space between comments and class signature.", "url": "https://github.com/apache/helix/pull/1035#discussion_r435410967", "createdAt": "2020-06-04T17:01:24Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+\n+\n+/** Represents return type of {@link org.apache.helix.zookeeper.api.client.RealmAwareZkClient#subscribeChildChanges(String, IZkChildListener, boolean)}\n+ *  The returned value would signal if watch installation to ZooKeeper server succeeded\n+ *  or not using field _isInstalled. The _children field would contains the list of child names\n+ *  of the watched path. It would be null if the parent path does not exist at the time of watch\n+ *  installation.\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMjE0OA==", "bodyText": "Could have been better to use java style naming? A clearer variable name would be appreciated.", "url": "https://github.com/apache/helix/pull/1035#discussion_r435412148", "createdAt": "2020-06-04T17:03:24Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -555,7 +569,11 @@ private void subscribeDataChange(String path, NotificationContext.Type callbackT\n         logger.debug(_manager.getInstanceName() + \" subscribe data-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeDataChanges(path, this);\n+      boolean rt = _zkClient.subscribeDataChanges(path, this, callbackType != Type.INIT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMzc3MA==", "bodyText": "\" all these verification does not guarantee you anything\" What kind of verification did you mean? You meant verifier? But how do you guarantee sleeping 5 secs would be 100% correct: it would return expected result?", "url": "https://github.com/apache/helix/pull/1035#discussion_r435413770", "createdAt": "2020-06-04T17:06:11Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -317,6 +324,150 @@ public boolean verify() throws Exception {\n \n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    //HelixManager rpManager  = HelixManagerFactory\n+    //    .getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    //rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTU1Nw=="}, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNDE5OQ==", "bodyText": "Could you remove the unused code instead of commenting out?", "url": "https://github.com/apache/helix/pull/1035#discussion_r435414199", "createdAt": "2020-06-04T17:06:59Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -318,6 +325,151 @@ public boolean verify() throws Exception {\n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n \n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(ZK_ADDR,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // Routing provider is a spectator in Helix. Currentstate based RP listens on all the\n+    // currentstate changes of all the clusters. They are a source of leaking of watch in\n+    // Zookeeper server.\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB\n+    LOG.info(\"expire rp manager session:\", rpManager.getSessionId());\n+    ZkTestHelper.expireSession(rpManager.getZkClient());\n+    LOG.info(\"rp manager new session:\", rpManager.getSessionId());\n+\n+    Thread.sleep(5000);\n+\n+    MockParticipantManager participantToExpire = participants[0];\n+    String oldSessionId = participantToExpire.getSessionId();\n+    PropertyKey.Builder keyBuilder = new PropertyKey.Builder(clusterName);\n+\n+    // expire participant session; leaked callback handler used to be not reset() and be removed from ZkClient\n+    LOG.info(\n+        \"Expire participant: \" + participantToExpire.getInstanceName() + \", session: \"\n+            + participantToExpire.getSessionId());\n+    ZkTestHelper.expireSession(participantToExpire.getZkClient());\n+    String newSessionId = participantToExpire.getSessionId();\n+    LOG.info(participantToExpire.getInstanceName() + \" oldSessionId: \" + oldSessionId\n+        + \", newSessionId: \" + newSessionId);\n+\n+    Thread.sleep(5000);\n+    Map<String, Set<IZkChildListener>> childListeners = ZkTestHelper.getZkChildListener(rpManager.getZkClient());\n+    for (String path : childListeners.keySet()) {\n+      Assert.assertTrue(childListeners.get(path).size() <= 1);\n+    }\n+\n+    Map<String, List<String>> rpWatchPaths = ZkTestHelper.getZkWatch(rpManager.getZkClient());\n+    List<String> existWatches = rpWatchPaths.get(\"existWatches\");\n+    Assert.assertTrue(existWatches.isEmpty());\n+  }\n+\n+  @Test\n+  public void testCurrentStatePathLeakingByAsycRemoval() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    final int mJobUpdateCnt = 500;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // HelixManager rpManager  = HelixManagerFactory.getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNDU0Mw==", "bodyText": "Still a good idea to use helix style to format the code", "url": "https://github.com/apache/helix/pull/1035#discussion_r435414543", "createdAt": "2020-06-04T17:07:34Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkCallbackHandlerLeak.java", "diffHunk": "@@ -318,6 +325,151 @@ public boolean verify() throws Exception {\n     System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n   }\n \n+  @Test\n+  public void testDanglingCallbackHanlderFix() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(ZK_ADDR,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // Routing provider is a spectator in Helix. Currentstate based RP listens on all the\n+    // currentstate changes of all the clusters. They are a source of leaking of watch in\n+    // Zookeeper server.\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");\n+    rpManager.syncStart();\n+    RoutingTableProvider rp = new RoutingTableProvider(rpManager, PropertyType.CURRENTSTATES);\n+\n+    Thread.sleep(5000);\n+\n+    // expire RoutingProvider would create dangling CB\n+    LOG.info(\"expire rp manager session:\", rpManager.getSessionId());\n+    ZkTestHelper.expireSession(rpManager.getZkClient());\n+    LOG.info(\"rp manager new session:\", rpManager.getSessionId());\n+\n+    Thread.sleep(5000);\n+\n+    MockParticipantManager participantToExpire = participants[0];\n+    String oldSessionId = participantToExpire.getSessionId();\n+    PropertyKey.Builder keyBuilder = new PropertyKey.Builder(clusterName);\n+\n+    // expire participant session; leaked callback handler used to be not reset() and be removed from ZkClient\n+    LOG.info(\n+        \"Expire participant: \" + participantToExpire.getInstanceName() + \", session: \"\n+            + participantToExpire.getSessionId());\n+    ZkTestHelper.expireSession(participantToExpire.getZkClient());\n+    String newSessionId = participantToExpire.getSessionId();\n+    LOG.info(participantToExpire.getInstanceName() + \" oldSessionId: \" + oldSessionId\n+        + \", newSessionId: \" + newSessionId);\n+\n+    Thread.sleep(5000);\n+    Map<String, Set<IZkChildListener>> childListeners = ZkTestHelper.getZkChildListener(rpManager.getZkClient());\n+    for (String path : childListeners.keySet()) {\n+      Assert.assertTrue(childListeners.get(path).size() <= 1);\n+    }\n+\n+    Map<String, List<String>> rpWatchPaths = ZkTestHelper.getZkWatch(rpManager.getZkClient());\n+    List<String> existWatches = rpWatchPaths.get(\"existWatches\");\n+    Assert.assertTrue(existWatches.isEmpty());\n+  }\n+\n+  @Test\n+  public void testCurrentStatePathLeakingByAsycRemoval() throws Exception {\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    final int n = 3;\n+    final String zkAddr = ZK_ADDR;\n+    final int mJobUpdateCnt = 500;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, zkAddr, 12918, \"localhost\", \"TestDB\", 1, // resource\n+        32, // partitions\n+        n, // nodes\n+        2, // replicas\n+        \"MasterSlave\", true);\n+\n+    final ClusterControllerManager controller =\n+        new ClusterControllerManager(zkAddr, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+      participants[i] = new MockParticipantManager(zkAddr, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    Boolean result =\n+        ClusterStateVerifier\n+            .verifyByZkCallback(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(zkAddr,\n+                clusterName));\n+    Assert.assertTrue(result);\n+\n+    // HelixManager rpManager  = HelixManagerFactory.getZKHelixManager(clusterName, \"\", InstanceType.SPECTATOR, ZK_ADDR);\n+    // rpManager.connect();\n+    ClusterSpectatorManager rpManager  = new ClusterSpectatorManager(ZK_ADDR, clusterName, \"router\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNTMwMg==", "bodyText": "What is this null representing? :)", "url": "https://github.com/apache/helix/pull/1035#discussion_r435415302", "createdAt": "2020-06-04T17:08:55Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,46 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {\n     long startT = System.currentTimeMillis();\n+    final Stat stat;\n     try {\n-      Stat stat = retryUntilConnected(\n-          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      if (!useGetData) {\n+        stat = retryUntilConnected(\n+            () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      } else {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"getstat() invoked with useGetData() with path: {} \", path);\n+          retryUntilConnected(() -> ((ZkConnection) getConnection()).getZookeeper().getData(path, true, stat));\n+        } catch (ZkNoNodeException e) {\n+          LOG.debug(\"getstat() invoked path: {}  null  useGetData: {}\", path, useGetData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxODEyNg==", "bodyText": "I am wondering if info or warn level for this message. If it may potentially cause problems maybe warn is expected. But if just regular message, info is good enough.", "url": "https://github.com/apache/helix/pull/1035#discussion_r435418126", "createdAt": "2020-06-04T17:13:44Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -555,7 +569,11 @@ private void subscribeDataChange(String path, NotificationContext.Type callbackT\n         logger.debug(_manager.getInstanceName() + \" subscribe data-change. path: \" + path\n             + \", listener: \" + _listener);\n       }\n-      _zkClient.subscribeDataChanges(path, this);\n+      boolean rt = _zkClient.subscribeDataChanges(path, this, callbackType != Type.INIT);\n+      logger.debug(\"CallbackHandler {} subscribe data path {} result {}\", this, path, rt);\n+      if (!rt) {\n+        logger.info(\"CallbackHandler {} subscribe data path {} failed!\", this, path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTMzMg==", "bodyText": "I still think isSubscribe() is more consistent with the concepts in subscribeChildChange() and easier to understand. Someone would wonder what is installed?", "url": "https://github.com/apache/helix/pull/1035#discussion_r435419332", "createdAt": "2020-06-04T17:15:53Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ChildrenSubscribeResult.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.apache.helix.zookeeper.api.client;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+\n+\n+/** Represents return type of {@link org.apache.helix.zookeeper.api.client.RealmAwareZkClient#subscribeChildChanges(String, IZkChildListener, boolean)}\n+ *  The returned value would signal if watch installation to ZooKeeper server succeeded\n+ *  or not using field _isInstalled. The _children field would contains the list of child names\n+ *  of the watched path. It would be null if the parent path does not exist at the time of watch\n+ *  installation.\n+ */\n+\n+public class ChildrenSubscribeResult {\n+  private final List<String> _children;\n+  private final boolean _isInstalled;\n+\n+  public ChildrenSubscribeResult(List<String> children, boolean isInstalled) {\n+    if (children != null) {\n+      _children = Collections.unmodifiableList(children);\n+    } else {\n+      _children = null;\n+    }\n+    _isInstalled = isInstalled;\n+  }\n+\n+  public List<String> getChildren() {\n+    return _children;\n+  }\n+\n+  public boolean isInstalled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxOTc0NA==", "bodyText": "parameterized logging.", "url": "https://github.com/apache/helix/pull/1035#discussion_r435419744", "createdAt": "2020-06-04T17:16:39Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1865,17 +1955,24 @@ public Object call() throws Exception {\n    *         exist.\n    */\n   public List<String> watchForChilds(final String path) {\n+    return watchForChilds(path, false);\n+  }\n+\n+  private List<String> watchForChilds(final String path, boolean skipWatchingNodeNotExist) {\n     if (_zookeeperEventThread != null && Thread.currentThread() == _zookeeperEventThread) {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n     return retryUntilConnected(new Callable<List<String>>() {\n       @Override\n       public List<String> call() throws Exception {\n-        exists(path, true);\n+        if (!skipWatchingNodeNotExist) {\n+          exists(path, true);\n+        }\n         try {\n           return getChildren(path, true);\n         } catch (ZkNoNodeException e) {\n           // ignore, the \"exists\" watch will listen for the parent node to appear\n+          LOG.info(\"watchForChilds path not existing:\" + path + \" skipWatchingNodeNoteExist:\" + skipWatchingNodeNotExist);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 238}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NjY1Njgw", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-424665680", "createdAt": "2020-06-04T17:19:37Z", "commit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzoxOTozN1rOGfQBKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzoxOTozN1rOGfQBKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyMTQ4MA==", "bodyText": "This api is run frequently. A good idea to use parameterize logging to save some string concatenation overhead.", "url": "https://github.com/apache/helix/pull/1035#discussion_r435421480", "createdAt": "2020-06-04T17:19:37Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -220,7 +227,15 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n       }\n       listeners.add(listener);\n     }\n-    return watchForChilds(path);\n+\n+    List<String> children = watchForChilds(path, skipWatchingNodeNotExist);\n+    if (children == null && skipWatchingNodeNotExist) {\n+      unsubscribeChildChanges(path, listener);\n+      LOG.info(\"watchForChilds failed to install no-existing watch and add listener. Path:\" + path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDA2MDQ5", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-425006049", "createdAt": "2020-06-05T05:31:36Z", "commit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNTozMTozNlrOGfg51A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNTozNzozMVrOGfg_mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5ODEzMg==", "bodyText": "nit, could you please rephrase this? I think we need to mention the re-subscribe is skipped because of the CH end of life.", "url": "https://github.com/apache/helix/pull/1035#discussion_r435698132", "createdAt": "2020-06-05T05:31:36Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java", "diffHunk": "@@ -748,6 +766,12 @@ public void handleChildChange(String parentPath, List<String> currentChilds) {\n           // removeListener will call handler.reset(), which in turn call invoke() on FINALIZE type\n           _manager.removeListener(_propertyKey, _listener);\n         } else {\n+          if (!isReady()) {\n+            // avoid leaking CallbackHandler\n+            logger.info(\"Callbackhandler {} with path {} end of life as not ready to avoid leak\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5OTYxMA==", "bodyText": "@kaisun2000 If you agree on the name changing, please change all the other parameter names of this option. They are not consistent now.", "url": "https://github.com/apache/helix/pull/1035#discussion_r435699610", "createdAt": "2020-06-05T05:37:31Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -69,12 +69,49 @@\n   int DEFAULT_SESSION_TIMEOUT = 30 * 1000;\n \n   // listener subscription\n+  /**\n+   * Subscribe the path and the listener will handle child events of the path.\n+   * Add exists watch to path if the path does not exist in ZooKeeper server.\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * The method return null if the path does not exists. Otherwise, return a list of children\n+   * under the path. The list can be empty if there is no children.\n+   */\n   List<String> subscribeChildChanges(String path, IZkChildListener listener);\n \n+  /**\n+   * Subscribe the path and the listener will handle child events of the path\n+   * WARNING: if the path is created after deletion, users need to re-subscribe the path\n+   * @param path The zookeeper path\n+   * @param listener Instance of {@link IZkDataListener}\n+   * @param skipWatchingNodeNotExist True means not installing any watch if path does not exist.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjY4Nw=="}, "originalCommit": {"oid": "a1d39c7f0347dee5004bb603495ecafa7da3d487"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDIzNTc2", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-425023576", "createdAt": "2020-06-05T06:21:21Z", "commit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNjoyMToyMVrOGfhwlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNjoyMToyMVrOGfhwlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxMjE1MQ==", "bodyText": "I thought about this method, I think instead of having this \"useGetData\" option, we just make it explicitly getData(final String path, final boolean watch) method. The caller know which one to all. And then there won't be any confusion.", "url": "https://github.com/apache/helix/pull/1035#discussion_r435712151", "createdAt": "2020-06-05T06:21:21Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1054,15 +1082,46 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n+    return getStat(path, watch, false);\n+  }\n+\n+  /*\n+   * Install watch if there is such node and return the stat\n+   *\n+   * If useGetData false, use exist(). @param watch would determine if adding watch\n+   * to ZooKeeper server or not.\n+   * Note, if @param path does not exist in ZooKeeper server, watch would still be installed\n+   * if @param watch is true.\n+   *\n+   * If useGetData true, use getData() to add watch. ignore @param watch in this case.\n+   * Note, if @param path does not exist in ZooKeeper server, no watch would be added.\n+   */\n+  private Stat getStat(final String path, final boolean watch, final boolean useGetData) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjE1MTc4", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-425615178", "createdAt": "2020-06-05T20:45:59Z", "commit": {"oid": "76d519e8dd3f71520cb7902e42c7fec21b29382a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4be6d554eaa73033e34c936793b7327b8cd8d35", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/a4be6d554eaa73033e34c936793b7327b8cd8d35", "committedDate": "2020-06-05T21:19:34Z", "message": "address further commit."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26851fa10b8344678f5460f514a1e4a4ee2fce14", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/26851fa10b8344678f5460f514a1e4a4ee2fce14", "committedDate": "2020-06-05T22:56:32Z", "message": "split getStat() into two different branch in two methods."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db3a882d62ecb8affc9886782d5ffa0742b696ff", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/db3a882d62ecb8affc9886782d5ffa0742b696ff", "committedDate": "2020-06-05T23:05:16Z", "message": "remove refactored code."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Njc3MTc0", "url": "https://github.com/apache/helix/pull/1035#pullrequestreview-425677174", "createdAt": "2020-06-05T23:22:30Z", "commit": {"oid": "26851fa10b8344678f5460f514a1e4a4ee2fce14"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzoyMjozMFrOGf_y6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzoyMjozMFrOGf_y6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDI2Nw==", "bodyText": "nit, getdata", "url": "https://github.com/apache/helix/pull/1035#discussion_r436204267", "createdAt": "2020-06-05T23:22:30Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1082,7 +1082,51 @@ public Stat getStat(final String path) {\n   }\n \n   private Stat getStat(final String path, final boolean watch) {\n-    return getStat(path, watch, false);\n+    long startT = System.currentTimeMillis();\n+    final Stat stat;\n+    try {\n+      stat = retryUntilConnected(\n+          () -> ((ZkConnection) getConnection()).getZookeeper().exists(path, watch));\n+      record(path, null, startT, ZkClientMonitor.AccessType.READ);\n+      return stat;\n+    } catch (Exception e) {\n+      recordFailure(path, ZkClientMonitor.AccessType.READ);\n+      throw e;\n+    } finally {\n+      long endT = System.currentTimeMillis();\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"exists, path: \" + path + \", time: \" + (endT - startT) + \" ms\");\n+      }\n+    }\n+  }\n+\n+  /*\n+   * This one installs watch only if path is there. Meant to avoid leaking watch in Zk server.\n+   */\n+  private Stat installWatchOnlyPathExist(final String path) {\n+    long startT = System.currentTimeMillis();\n+    final Stat stat;\n+    try {\n+        stat = new Stat();\n+        try {\n+          LOG.debug(\"installWatchOnlyPathExist with path: {} \", path);\n+          retryUntilConnected(() -> ((ZkConnection) getConnection()).getZookeeper().getData(path, true, stat));\n+        } catch (ZkNoNodeException e) {\n+          LOG.debug(\"installWatchOnlyPathExist path not existing: {}\", path);\n+          record(path, null, startT, ZkClientMonitor.AccessType.READ);\n+          return null;\n+        }\n+      record(path, null, startT, ZkClientMonitor.AccessType.READ);\n+      return stat;\n+    } catch (Exception e) {\n+      recordFailure(path, ZkClientMonitor.AccessType.READ);\n+      throw e;\n+    } finally {\n+      long endT = System.currentTimeMillis();\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"exists, path: \" + path + \", time: \" + (endT - startT) + \" ms\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26851fa10b8344678f5460f514a1e4a4ee2fce14"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3403d500e9fef42725b6f209ef2d423621e909cb", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/3403d500e9fef42725b6f209ef2d423621e909cb", "committedDate": "2020-06-05T23:30:39Z", "message": "fix a logging."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4409, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}