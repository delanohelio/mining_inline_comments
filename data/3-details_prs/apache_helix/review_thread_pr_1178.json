{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NzA3NzU2", "number": 1178, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzo1MDozN1rOES7Bdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTozNzoyMFrOEVLUJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mjc2ODU1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzo1MDozN1rOG4X1rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNjoyNjo0MVrOG4qTIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NDAxMw==", "bodyText": "Any reason to remove IOException?", "url": "https://github.com/apache/helix/pull/1178#discussion_r461764013", "createdAt": "2020-07-28T17:50:37Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java", "diffHunk": "@@ -83,7 +82,7 @@ protected RealmAwareZkClient createZkClient(RealmAwareZkClient.RealmMode realmMo\n       case MULTI_REALM:\n         try {\n           zkClient = new FederatedZkClient(connectionConfig, clientConfig);\n-        } catch (IOException | InvalidRoutingDataException e) {\n+        } catch (InvalidRoutingDataException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NjQ2NA==", "bodyText": "It was removed from the signature. We don't throw it anymore. It will be thrown in the form of a MultiZkException, and will be a RuntimeException, not a typed exception.", "url": "https://github.com/apache/helix/pull/1178#discussion_r462066464", "createdAt": "2020-07-29T06:26:41Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java", "diffHunk": "@@ -83,7 +82,7 @@ protected RealmAwareZkClient createZkClient(RealmAwareZkClient.RealmMode realmMo\n       case MULTI_REALM:\n         try {\n           zkClient = new FederatedZkClient(connectionConfig, clientConfig);\n-        } catch (IOException | InvalidRoutingDataException e) {\n+        } catch (InvalidRoutingDataException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NDAxMw=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mjc4NjA1OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzo1NDo1N1rOG4YAdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMzowNjowNlrOHAgmlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ==", "bodyText": "Does that mean if we dont set both, it fall backs to single realm?", "url": "https://github.com/apache/helix/pull/1178#discussion_r461766775", "createdAt": "2020-07-28T17:54:57Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -486,6 +500,13 @@ private void validate() {\n           throw new IllegalArgumentException(\n               \"RealmAwareZkConnectionConfig.Builder: ZK sharding key must be set on single-realm mode!\");\n         }\n+        if ((_routingDataSourceEndpoint == null && _routingDataSourceType != null) || (\n+            _routingDataSourceEndpoint != null && _routingDataSourceType == null)) {\n+          // For routing data source type and endpoint, if one is set and not the other, it is invalid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NjkxNQ==", "bodyText": "If nothing is set, it will try to use the default MSDS endpoint, which is provided in System Properties.", "url": "https://github.com/apache/helix/pull/1178#discussion_r462066915", "createdAt": "2020-07-29T06:27:49Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -486,6 +500,13 @@ private void validate() {\n           throw new IllegalArgumentException(\n               \"RealmAwareZkConnectionConfig.Builder: ZK sharding key must be set on single-realm mode!\");\n         }\n+        if ((_routingDataSourceEndpoint == null && _routingDataSourceType != null) || (\n+            _routingDataSourceEndpoint != null && _routingDataSourceType == null)) {\n+          // For routing data source type and endpoint, if one is set and not the other, it is invalid", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzNzUwMA==", "bodyText": "What if some other customer they dont set up the default MSDS? They are using our module for ZKClient use case. So will path ZK address still work?", "url": "https://github.com/apache/helix/pull/1178#discussion_r465337500", "createdAt": "2020-08-04T21:21:22Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -486,6 +500,13 @@ private void validate() {\n           throw new IllegalArgumentException(\n               \"RealmAwareZkConnectionConfig.Builder: ZK sharding key must be set on single-realm mode!\");\n         }\n+        if ((_routingDataSourceEndpoint == null && _routingDataSourceType != null) || (\n+            _routingDataSourceEndpoint != null && _routingDataSourceType == null)) {\n+          // For routing data source type and endpoint, if one is set and not the other, it is invalid", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NTgyMg==", "bodyText": "Then they shouldn't be using RealmAwareZkClient in that case since they aren't using multiple zookeepers.", "url": "https://github.com/apache/helix/pull/1178#discussion_r470285822", "createdAt": "2020-08-13T22:34:55Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -486,6 +500,13 @@ private void validate() {\n           throw new IllegalArgumentException(\n               \"RealmAwareZkConnectionConfig.Builder: ZK sharding key must be set on single-realm mode!\");\n         }\n+        if ((_routingDataSourceEndpoint == null && _routingDataSourceType != null) || (\n+            _routingDataSourceEndpoint != null && _routingDataSourceType == null)) {\n+          // For routing data source type and endpoint, if one is set and not the other, it is invalid", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4OTcxMA==", "bodyText": "But even for dedicated zkclient is using RealmAwareZkClient interface, right? I am OK to have this check. But we need to clarify the boundaries.", "url": "https://github.com/apache/helix/pull/1178#discussion_r470289710", "createdAt": "2020-08-13T22:46:12Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -486,6 +500,13 @@ private void validate() {\n           throw new IllegalArgumentException(\n               \"RealmAwareZkConnectionConfig.Builder: ZK sharding key must be set on single-realm mode!\");\n         }\n+        if ((_routingDataSourceEndpoint == null && _routingDataSourceType != null) || (\n+            _routingDataSourceEndpoint != null && _routingDataSourceType == null)) {\n+          // For routing data source type and endpoint, if one is set and not the other, it is invalid", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5NjIxNA==", "bodyText": "DedicatedZkClientFactory gives 2 methods - one for RealmAwareZkClient, and another for HelixZkClient. The former should be used when you plan on using ZooKeeper in a multi-zk way, the latter is for when you only have one ZK (and therefore need to provide a valid ZkAddress). Or the user can use Raw zkClient as well.", "url": "https://github.com/apache/helix/pull/1178#discussion_r470296214", "createdAt": "2020-08-13T23:06:06Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -486,6 +500,13 @@ private void validate() {\n           throw new IllegalArgumentException(\n               \"RealmAwareZkConnectionConfig.Builder: ZK sharding key must be set on single-realm mode!\");\n         }\n+        if ((_routingDataSourceEndpoint == null && _routingDataSourceType != null) || (\n+            _routingDataSourceEndpoint != null && _routingDataSourceType == null)) {\n+          // For routing data source type and endpoint, if one is set and not the other, it is invalid", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mjc5MzcwOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/RoutingSystemPropertyKeys.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzo1Njo1M1rOG4YFKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNjoyODoxNlrOG4qVbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Nzk3Ng==", "bodyText": "If it is routing related property, shall we have consistent naming system starting with \"routing\"?", "url": "https://github.com/apache/helix/pull/1178#discussion_r461767976", "createdAt": "2020-07-28T17:56:53Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/RoutingSystemPropertyKeys.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.apache.helix.zookeeper.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * This class contains various routing-related system property keys for multi-zk clients.\n+ */\n+public class RoutingSystemPropertyKeys {\n+\n+  /**\n+   * If enabled, FederatedZkClient (multiZkClient) will invalidate the cached routing data and\n+   * re-read the routing data from the routing data source upon ZK path sharding key cache miss.\n+   */\n+  public static final String UPDATE_ROUTING_DATA_ON_CACHE_MISS =\n+      \"update.routing.data.on.cache.miss.enabled\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NzA1NA==", "bodyText": "I can rename this and put \"routing\" in front.", "url": "https://github.com/apache/helix/pull/1178#discussion_r462067054", "createdAt": "2020-07-29T06:28:16Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/RoutingSystemPropertyKeys.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.apache.helix.zookeeper.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * This class contains various routing-related system property keys for multi-zk clients.\n+ */\n+public class RoutingSystemPropertyKeys {\n+\n+  /**\n+   * If enabled, FederatedZkClient (multiZkClient) will invalidate the cached routing data and\n+   * re-read the routing data from the routing data source upon ZK path sharding key cache miss.\n+   */\n+  public static final String UPDATE_ROUTING_DATA_ON_CACHE_MISS =\n+      \"update.routing.data.on.cache.miss.enabled\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Nzk3Ng=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjgxNzcwOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/ZkRoutingDataReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODowMzoxM1rOG4YUEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNjozNDoxMFrOG4qecw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3MTc5Mw==", "bodyText": "Do we want to move this into try? Is that possible any exception happening in build zkClient?", "url": "https://github.com/apache/helix/pull/1178#discussion_r461771793", "createdAt": "2020-07-28T18:03:13Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/ZkRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+\n+\n+/**\n+ * Zk-based RoutingDataReader that establishes a ZK connection to the routing ZK to fetch routing\n+ * data.\n+ * The reading of routing data by nature should only be performed in cases of a Helix client\n+ * initialization or routing data reset. That means we do not have to maintain an active ZK\n+ * connection. To minimize the number of client-side ZK connections, ZkRoutingDataReader establishes\n+ * a ZK session temporarily only to read from ZK afresh and closes sessions upon read completion.\n+ */\n+public class ZkRoutingDataReader implements RoutingDataReader {\n+\n+  /**\n+   * Returns a map form of metadata store routing data.\n+   * The map fields stand for metadata store realm address (key), and a corresponding list of ZK\n+   * path sharding keys (key).\n+   * @param endpoint\n+   * @return\n+   */\n+  @Override\n+  public Map<String, List<String>> getRawRoutingData(String endpoint) {\n+    ZkClient zkClient =\n+        new ZkClient.Builder().setZkServer(endpoint).setZkSerializer(new ZNRecordSerializer())\n+            .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2OTM2Mw==", "bodyText": "If this throws an exception, we should let it throw the exception and not proceed. We should fail early.", "url": "https://github.com/apache/helix/pull/1178#discussion_r462069363", "createdAt": "2020-07-29T06:34:10Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/ZkRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+\n+\n+/**\n+ * Zk-based RoutingDataReader that establishes a ZK connection to the routing ZK to fetch routing\n+ * data.\n+ * The reading of routing data by nature should only be performed in cases of a Helix client\n+ * initialization or routing data reset. That means we do not have to maintain an active ZK\n+ * connection. To minimize the number of client-side ZK connections, ZkRoutingDataReader establishes\n+ * a ZK session temporarily only to read from ZK afresh and closes sessions upon read completion.\n+ */\n+public class ZkRoutingDataReader implements RoutingDataReader {\n+\n+  /**\n+   * Returns a map form of metadata store routing data.\n+   * The map fields stand for metadata store realm address (key), and a corresponding list of ZK\n+   * path sharding keys (key).\n+   * @param endpoint\n+   * @return\n+   */\n+  @Override\n+  public Map<String, List<String>> getRawRoutingData(String endpoint) {\n+    ZkClient zkClient =\n+        new ZkClient.Builder().setZkServer(endpoint).setZkSerializer(new ZNRecordSerializer())\n+            .build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3MTc5Mw=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjgzMDE4OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/HttpZkFallbackRoutingDataReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODowNjozOFrOG4Ybwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNjozMToxN1rOG4qaRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3Mzc2Mg==", "bodyText": "Why not let this read extends the one of the Reader instead of creating a Reader object? This will create ZkRoutingDataReader/HttpRoutingDataReader every time if continuously calling the method.\nOr can we just have make a check wither we check whether we created them as members? If yes, use it. If not, create a new one and keep it.", "url": "https://github.com/apache/helix/pull/1178#discussion_r461773762", "createdAt": "2020-07-28T18:06:38Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/HttpZkFallbackRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.zookeeper.constant.RoutingDataReaderType;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * HTTP and ZK-based RoutingDataReader that first tries an HTTP call to MSDS and upon failure,\n+ * falls back to ZK for routing data.\n+ * HttpZkFallbackRoutingDataReader does not maintain a ZK connection - it establishes for reading\n+ * and closes it right away.\n+ */\n+public class HttpZkFallbackRoutingDataReader implements RoutingDataReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2ODI5NA==", "bodyText": "The implementations of RoutingDataReader are supposed to be stateless and to be garbage-collected after use. So we should not maintain states. The Javadoc makes that clear.\nFor example, we don't want to hold onto a ZkFallbackRoutingDataReader since that would mean we hold onto an active ZK connection. We only want a RoutingDataReader instance at initialization, once.\nExtending it complicates the design, and you can ask a question of which one it should extend, and you can never do so consistently for other implementations. For that reason, I prefer composition over inheritance.", "url": "https://github.com/apache/helix/pull/1178#discussion_r462068294", "createdAt": "2020-07-29T06:31:17Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/HttpZkFallbackRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.zookeeper.constant.RoutingDataReaderType;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * HTTP and ZK-based RoutingDataReader that first tries an HTTP call to MSDS and upon failure,\n+ * falls back to ZK for routing data.\n+ * HttpZkFallbackRoutingDataReader does not maintain a ZK connection - it establishes for reading\n+ * and closes it right away.\n+ */\n+public class HttpZkFallbackRoutingDataReader implements RoutingDataReader {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3Mzc2Mg=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjM4MDYyOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToyNzoxNlrOG7yHKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjo0NDoyM1rOHAgKtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MDIwMA==", "bodyText": "Can we simplify the code here?\nFundamentally, it is check path in _metadataStoreRoutingData -> get exception -> update _metadataStoreRoutingData from different level.\nThere are several comment code. we can have a loop to wrap of it and based on the retried times to do different level update.", "url": "https://github.com/apache/helix/pull/1178#discussion_r465340200", "createdAt": "2020-08-04T21:27:16Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -550,17 +546,71 @@ private ZkClient getZkClient(String path) {\n   }\n \n   private String getZkRealm(String path) {\n+    if (_routingDataUpdateOnCacheMissEnabled) {\n+      try {\n+        return updateRoutingDataOnCacheMiss(path);\n+      } catch (InvalidRoutingDataException e) {\n+        LOG.error(\n+            \"FederatedZkClient::getZkRealm: Failed to update routing data due to invalid routing \"\n+                + \"data!\", e);\n+        throw new MultiZkException(e);\n+      }\n+    }\n+    return _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+  }\n+\n+  /**\n+   * Perform a 2-tier routing data cache update:\n+   * 1. Do an in-memory update from the singleton RoutingDataManager\n+   * 2. Do an I/O based read from the routing data source by resetting RoutingDataManager\n+   * @param path\n+   * @return\n+   * @throws InvalidRoutingDataException\n+   */\n+  private String updateRoutingDataOnCacheMiss(String path) throws InvalidRoutingDataException {\n     String zkRealm;\n     try {\n       zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n-    } catch (NoSuchElementException ex) {\n-      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n-    }\n-\n-    if (zkRealm == null || zkRealm.isEmpty()) {\n-      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    } catch (NoSuchElementException e1) {\n+      synchronized (this) {\n+        try {\n+          zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+        } catch (NoSuchElementException e2) {\n+          // Try 1) Refresh MetadataStoreRoutingData from RoutingDataManager\n+          // This is an in-memory refresh from the Singleton RoutingDataManager - other\n+          // FederatedZkClient objects may have triggered a cache refresh, so we first update the\n+          // in-memory reference. This refresh only affects this object/thread, so we synchronize\n+          // on \"this\".\n+          _metadataStoreRoutingData =\n+              RealmAwareZkClient.getMetadataStoreRoutingData(_connectionConfig);\n+          try {\n+            zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+          } catch (NoSuchElementException e3) {\n+            synchronized (FederatedZkClient.class) {\n+              try {\n+                zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+              } catch (NoSuchElementException e4) {\n+                if (shouldThrottleRead()) {\n+                  // If routing data update from routing data source has taken place recently,\n+                  // then just skip the update and throw the exception\n+                  throw e4;\n+                }\n+                // Try 2) Reset RoutingDataManager and re-read the routing data from routing data\n+                // source via I/O. Since RoutingDataManager's cache doesn't have it either, so we\n+                // synchronize on all threads by locking on FederatedZkClient.class.\n+                RoutingDataManager.getInstance().reset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4OTA3OA==", "bodyText": "I'm not sure if that's feasible. Each update has different logic if you look closely. Also, I think if we change the structure, it runs the risk of making it harder to read/understand. Do you have a more concrete suggestion?\nTying it to the number of tries isn't a good idea since this isn't about how many times you try the same logic. In other words, this logic is not a retry (although it looks like one).", "url": "https://github.com/apache/helix/pull/1178#discussion_r470289078", "createdAt": "2020-08-13T22:44:23Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -550,17 +546,71 @@ private ZkClient getZkClient(String path) {\n   }\n \n   private String getZkRealm(String path) {\n+    if (_routingDataUpdateOnCacheMissEnabled) {\n+      try {\n+        return updateRoutingDataOnCacheMiss(path);\n+      } catch (InvalidRoutingDataException e) {\n+        LOG.error(\n+            \"FederatedZkClient::getZkRealm: Failed to update routing data due to invalid routing \"\n+                + \"data!\", e);\n+        throw new MultiZkException(e);\n+      }\n+    }\n+    return _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+  }\n+\n+  /**\n+   * Perform a 2-tier routing data cache update:\n+   * 1. Do an in-memory update from the singleton RoutingDataManager\n+   * 2. Do an I/O based read from the routing data source by resetting RoutingDataManager\n+   * @param path\n+   * @return\n+   * @throws InvalidRoutingDataException\n+   */\n+  private String updateRoutingDataOnCacheMiss(String path) throws InvalidRoutingDataException {\n     String zkRealm;\n     try {\n       zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n-    } catch (NoSuchElementException ex) {\n-      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n-    }\n-\n-    if (zkRealm == null || zkRealm.isEmpty()) {\n-      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    } catch (NoSuchElementException e1) {\n+      synchronized (this) {\n+        try {\n+          zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+        } catch (NoSuchElementException e2) {\n+          // Try 1) Refresh MetadataStoreRoutingData from RoutingDataManager\n+          // This is an in-memory refresh from the Singleton RoutingDataManager - other\n+          // FederatedZkClient objects may have triggered a cache refresh, so we first update the\n+          // in-memory reference. This refresh only affects this object/thread, so we synchronize\n+          // on \"this\".\n+          _metadataStoreRoutingData =\n+              RealmAwareZkClient.getMetadataStoreRoutingData(_connectionConfig);\n+          try {\n+            zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+          } catch (NoSuchElementException e3) {\n+            synchronized (FederatedZkClient.class) {\n+              try {\n+                zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+              } catch (NoSuchElementException e4) {\n+                if (shouldThrottleRead()) {\n+                  // If routing data update from routing data source has taken place recently,\n+                  // then just skip the update and throw the exception\n+                  throw e4;\n+                }\n+                // Try 2) Reset RoutingDataManager and re-read the routing data from routing data\n+                // source via I/O. Since RoutingDataManager's cache doesn't have it either, so we\n+                // synchronize on all threads by locking on FederatedZkClient.class.\n+                RoutingDataManager.getInstance().reset();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MDIwMA=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjQwOTM0OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/RoutingDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTozNzoyMFrOG7yYeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjozODo0NVrOHAgC9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDYzNA==", "bodyText": "error log here?", "url": "https://github.com/apache/helix/pull/1178#discussion_r465344634", "createdAt": "2020-08-04T21:37:20Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/RoutingDataManager.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.constant.RoutingDataReaderType;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+\n+\n+/**\n+ * RoutingDataManager is a Singleton that\n+ * 1. resolves RoutingDataReader based on the system config given\n+ * 2. caches routing data\n+ * 3. provides public methods for reading routing data from various sources (configurable)\n+ */\n+public class RoutingDataManager {\n+  /** HTTP call to MSDS is used to fetch routing data by default */\n+  private String _defaultMsdsEndpoint =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+\n+  /** Double-checked locking requires that the following fields be final (volatile) */\n+  // The following map stands for (RoutingDataReaderType_endpoint ID, Raw Routing Data)\n+  private final Map<String, Map<String, List<String>>> _rawRoutingDataMap =\n+      new ConcurrentHashMap<>();\n+  // The following map stands for (RoutingDataReaderType_endpoint ID, MetadataStoreRoutingData)\n+  private final Map<String, MetadataStoreRoutingData> _metadataStoreRoutingDataMap =\n+      new ConcurrentHashMap<>();\n+\n+  // Tracks the time at which reset() was called last. Used to throttle reset()\n+  private volatile long _lastResetTimestamp;\n+\n+  // Singleton instance\n+  private static RoutingDataManager _instance;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private RoutingDataManager() {\n+    // Private constructor for Singleton\n+  }\n+\n+  /**\n+   * Lazy initialization with double-checked locking.\n+   * @return\n+   */\n+  public static RoutingDataManager getInstance() {\n+    if (_instance == null) {\n+      synchronized (RoutingDataManager.class) {\n+        if (_instance == null) {\n+          _instance = new RoutingDataManager();\n+        }\n+      }\n+    }\n+    return _instance;\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP by querying the MSDS configured in the JVM\n+   * config.\n+   * @return\n+   */\n+  public Map<String, List<String>> getRawRoutingData() {\n+    if (_defaultMsdsEndpoint == null || _defaultMsdsEndpoint.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System \"\n+              + \"Properties!\");\n+    }\n+    return getRawRoutingData(RoutingDataReaderType.HTTP, _defaultMsdsEndpoint);\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned.\n+   * @param routingDataReaderType\n+   * @param endpoint\n+   */\n+  public Map<String, List<String>> getRawRoutingData(RoutingDataReaderType routingDataReaderType,\n+      String endpoint) {\n+    String routingDataCacheKey = getRoutingDataCacheKey(routingDataReaderType, endpoint);\n+    Map<String, List<String>> rawRoutingData = _rawRoutingDataMap.get(routingDataCacheKey);\n+    if (rawRoutingData == null) {\n+      synchronized (RoutingDataManager.class) {\n+        rawRoutingData = _rawRoutingDataMap.get(routingDataCacheKey);\n+        if (rawRoutingData == null) {\n+          RoutingDataReader reader = resolveRoutingDataReader(routingDataReaderType);\n+          rawRoutingData = reader.getRawRoutingData(endpoint);\n+          _rawRoutingDataMap.put(routingDataCacheKey, rawRoutingData);\n+        }\n+      }\n+    }\n+    return rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format by querying the\n+   * MSDS configured in the JVM config.\n+   * @return MetadataStoreRoutingData\n+   */\n+  public MetadataStoreRoutingData getMetadataStoreRoutingData() throws InvalidRoutingDataException {\n+    if (_defaultMsdsEndpoint == null || _defaultMsdsEndpoint.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System \"\n+              + \"Properties!\");\n+    }\n+    return getMetadataStoreRoutingData(RoutingDataReaderType.HTTP, _defaultMsdsEndpoint);\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS as a MetadataStoreRoutingData object.\n+   * @param routingDataReaderType\n+   * @param endpoint\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public MetadataStoreRoutingData getMetadataStoreRoutingData(\n+      RoutingDataReaderType routingDataReaderType, String endpoint)\n+      throws InvalidRoutingDataException {\n+    String routingDataCacheKey = getRoutingDataCacheKey(routingDataReaderType, endpoint);\n+    MetadataStoreRoutingData metadataStoreRoutingData =\n+        _metadataStoreRoutingDataMap.get(routingDataCacheKey);\n+    if (metadataStoreRoutingData == null) {\n+      synchronized (RoutingDataManager.class) {\n+        metadataStoreRoutingData = _metadataStoreRoutingDataMap.get(routingDataCacheKey);\n+        if (metadataStoreRoutingData == null) {\n+          metadataStoreRoutingData =\n+              new TrieRoutingData(getRawRoutingData(routingDataReaderType, endpoint));\n+          _metadataStoreRoutingDataMap.put(routingDataCacheKey, metadataStoreRoutingData);\n+        }\n+      }\n+    }\n+    return metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Clears the statically-cached routing data and private fields.\n+   */\n+  public synchronized void reset() {\n+    _rawRoutingDataMap.clear();\n+    _metadataStoreRoutingDataMap.clear();\n+    _defaultMsdsEndpoint =\n+        System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+    _lastResetTimestamp = System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * Returns the timestamp for the last reset().\n+   * @return\n+   */\n+  public long getLastResetTimestamp() {\n+    return _lastResetTimestamp;\n+  }\n+\n+  /**\n+   * Returns an appropriate instance of RoutingDataReader given the type.\n+   * @param routingDataReaderType\n+   * @return\n+   */\n+  private RoutingDataReader resolveRoutingDataReader(RoutingDataReaderType routingDataReaderType) {\n+    // Instantiate an instance of routing data reader using the type\n+    try {\n+      return (RoutingDataReader) Class.forName(routingDataReaderType.getClassName()).newInstance();\n+    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {\n+      throw new MultiZkException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NzA5Mg==", "bodyText": "Added.", "url": "https://github.com/apache/helix/pull/1178#discussion_r470287092", "createdAt": "2020-08-13T22:38:45Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/RoutingDataManager.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.constant.RoutingDataReaderType;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+\n+\n+/**\n+ * RoutingDataManager is a Singleton that\n+ * 1. resolves RoutingDataReader based on the system config given\n+ * 2. caches routing data\n+ * 3. provides public methods for reading routing data from various sources (configurable)\n+ */\n+public class RoutingDataManager {\n+  /** HTTP call to MSDS is used to fetch routing data by default */\n+  private String _defaultMsdsEndpoint =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+\n+  /** Double-checked locking requires that the following fields be final (volatile) */\n+  // The following map stands for (RoutingDataReaderType_endpoint ID, Raw Routing Data)\n+  private final Map<String, Map<String, List<String>>> _rawRoutingDataMap =\n+      new ConcurrentHashMap<>();\n+  // The following map stands for (RoutingDataReaderType_endpoint ID, MetadataStoreRoutingData)\n+  private final Map<String, MetadataStoreRoutingData> _metadataStoreRoutingDataMap =\n+      new ConcurrentHashMap<>();\n+\n+  // Tracks the time at which reset() was called last. Used to throttle reset()\n+  private volatile long _lastResetTimestamp;\n+\n+  // Singleton instance\n+  private static RoutingDataManager _instance;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private RoutingDataManager() {\n+    // Private constructor for Singleton\n+  }\n+\n+  /**\n+   * Lazy initialization with double-checked locking.\n+   * @return\n+   */\n+  public static RoutingDataManager getInstance() {\n+    if (_instance == null) {\n+      synchronized (RoutingDataManager.class) {\n+        if (_instance == null) {\n+          _instance = new RoutingDataManager();\n+        }\n+      }\n+    }\n+    return _instance;\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP by querying the MSDS configured in the JVM\n+   * config.\n+   * @return\n+   */\n+  public Map<String, List<String>> getRawRoutingData() {\n+    if (_defaultMsdsEndpoint == null || _defaultMsdsEndpoint.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System \"\n+              + \"Properties!\");\n+    }\n+    return getRawRoutingData(RoutingDataReaderType.HTTP, _defaultMsdsEndpoint);\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned.\n+   * @param routingDataReaderType\n+   * @param endpoint\n+   */\n+  public Map<String, List<String>> getRawRoutingData(RoutingDataReaderType routingDataReaderType,\n+      String endpoint) {\n+    String routingDataCacheKey = getRoutingDataCacheKey(routingDataReaderType, endpoint);\n+    Map<String, List<String>> rawRoutingData = _rawRoutingDataMap.get(routingDataCacheKey);\n+    if (rawRoutingData == null) {\n+      synchronized (RoutingDataManager.class) {\n+        rawRoutingData = _rawRoutingDataMap.get(routingDataCacheKey);\n+        if (rawRoutingData == null) {\n+          RoutingDataReader reader = resolveRoutingDataReader(routingDataReaderType);\n+          rawRoutingData = reader.getRawRoutingData(endpoint);\n+          _rawRoutingDataMap.put(routingDataCacheKey, rawRoutingData);\n+        }\n+      }\n+    }\n+    return rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format by querying the\n+   * MSDS configured in the JVM config.\n+   * @return MetadataStoreRoutingData\n+   */\n+  public MetadataStoreRoutingData getMetadataStoreRoutingData() throws InvalidRoutingDataException {\n+    if (_defaultMsdsEndpoint == null || _defaultMsdsEndpoint.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System \"\n+              + \"Properties!\");\n+    }\n+    return getMetadataStoreRoutingData(RoutingDataReaderType.HTTP, _defaultMsdsEndpoint);\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS as a MetadataStoreRoutingData object.\n+   * @param routingDataReaderType\n+   * @param endpoint\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public MetadataStoreRoutingData getMetadataStoreRoutingData(\n+      RoutingDataReaderType routingDataReaderType, String endpoint)\n+      throws InvalidRoutingDataException {\n+    String routingDataCacheKey = getRoutingDataCacheKey(routingDataReaderType, endpoint);\n+    MetadataStoreRoutingData metadataStoreRoutingData =\n+        _metadataStoreRoutingDataMap.get(routingDataCacheKey);\n+    if (metadataStoreRoutingData == null) {\n+      synchronized (RoutingDataManager.class) {\n+        metadataStoreRoutingData = _metadataStoreRoutingDataMap.get(routingDataCacheKey);\n+        if (metadataStoreRoutingData == null) {\n+          metadataStoreRoutingData =\n+              new TrieRoutingData(getRawRoutingData(routingDataReaderType, endpoint));\n+          _metadataStoreRoutingDataMap.put(routingDataCacheKey, metadataStoreRoutingData);\n+        }\n+      }\n+    }\n+    return metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Clears the statically-cached routing data and private fields.\n+   */\n+  public synchronized void reset() {\n+    _rawRoutingDataMap.clear();\n+    _metadataStoreRoutingDataMap.clear();\n+    _defaultMsdsEndpoint =\n+        System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+    _lastResetTimestamp = System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * Returns the timestamp for the last reset().\n+   * @return\n+   */\n+  public long getLastResetTimestamp() {\n+    return _lastResetTimestamp;\n+  }\n+\n+  /**\n+   * Returns an appropriate instance of RoutingDataReader given the type.\n+   * @param routingDataReaderType\n+   * @return\n+   */\n+  private RoutingDataReader resolveRoutingDataReader(RoutingDataReaderType routingDataReaderType) {\n+    // Instantiate an instance of routing data reader using the type\n+    try {\n+      return (RoutingDataReader) Class.forName(routingDataReaderType.getClassName()).newInstance();\n+    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {\n+      throw new MultiZkException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDYzNA=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 191}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1262, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}