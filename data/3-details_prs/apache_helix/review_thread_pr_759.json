{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MDQ4MzIx", "number": 759, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoxOTowMFrODfr21g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0MjoxNlrODfwYQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTUwOTk4OnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoxOTowMFrOFpiNHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToxNjoxMFrOFqA9qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5NjM1MA==", "bodyText": "The name for this method is a little confusing. Do you think something like findClosestParentNode or findClosetShardingKeyNode or findClosestTerminalNode would be easier to understand?", "url": "https://github.com/apache/helix/pull/759#discussion_r379096350", "createdAt": "2020-02-13T20:19:00Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided\n+   * path (meaning the traversal ended before the last node of the path is reached), the provided\n+   * path is not associated with any sharding key and can be added as a sharding key without\n+   * creating ambiguity cases among sharding keys.\n    * @param path - the path where the search is conducted\n-   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n-   * @return the node pointed by the path or a leaf node along the path\n-   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n-   *           found\n+   * @return a TrieNode that represents the longest prefix of the path\n    */\n-  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n-      throws NoSuchElementException {\n+  private TrieNode getLongestPrefixNodeAlongPath(String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwNzIwMA==", "bodyText": "Appreciate the feedback on naming - it's something that I wish to discuss.\nMy original naming is along the line of \"findClosestNode\", however I find myself have to explain the definition of \"closest\". For example, given \"/a/b/c\", why is \"/a\" the closer than \"/a/x/c\" (if \"/a/b\" doesn't exist)?  Also, saying \"closest node\" when path sometimes doesn't point to a node is strange.\nI found that \"longest prefix\" is the most accurate definition of what this method is doing - it finds the longest prefix of path that exists in this trie.", "url": "https://github.com/apache/helix/pull/759#discussion_r379107200", "createdAt": "2020-02-13T20:41:39Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided\n+   * path (meaning the traversal ended before the last node of the path is reached), the provided\n+   * path is not associated with any sharding key and can be added as a sharding key without\n+   * creating ambiguity cases among sharding keys.\n    * @param path - the path where the search is conducted\n-   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n-   * @return the node pointed by the path or a leaf node along the path\n-   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n-   *           found\n+   * @return a TrieNode that represents the longest prefix of the path\n    */\n-  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n-      throws NoSuchElementException {\n+  private TrieNode getLongestPrefixNodeAlongPath(String path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5NjM1MA=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExMDYyNg==", "bodyText": "To add to my last comment, \"longest prefix\" is very fitting of an explanation. Given \"/a/b/c\", this method will attempt to return a node that represents \"/a/b/c\"; if that doesn't exist, it tries \"/a/b\"; if not, \"/a\"; if everything else fails, return \"/\".\nIMO it's easier to say \"longest prefix\" then explaining \"node that is closest to path and is a parent to path\".", "url": "https://github.com/apache/helix/pull/759#discussion_r379110626", "createdAt": "2020-02-13T20:49:14Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided\n+   * path (meaning the traversal ended before the last node of the path is reached), the provided\n+   * path is not associated with any sharding key and can be added as a sharding key without\n+   * creating ambiguity cases among sharding keys.\n    * @param path - the path where the search is conducted\n-   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n-   * @return the node pointed by the path or a leaf node along the path\n-   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n-   *           found\n+   * @return a TrieNode that represents the longest prefix of the path\n    */\n-  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n-      throws NoSuchElementException {\n+  private TrieNode getLongestPrefixNodeAlongPath(String path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5NjM1MA=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMzkyNw==", "bodyText": "Longest prefix is still confusing. When I read the code, I had to think about what you meant by \"longest prefix\". Because the word \"prefix' could mean a host of different things depending on the context.\nI believe I'm pretty familiar with the logic and if I found it a little confusing even with the understanding, wouldn't that be an indication that perhaps you could find a better, more intuitive name? :)", "url": "https://github.com/apache/helix/pull/759#discussion_r379133927", "createdAt": "2020-02-13T21:40:41Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided\n+   * path (meaning the traversal ended before the last node of the path is reached), the provided\n+   * path is not associated with any sharding key and can be added as a sharding key without\n+   * creating ambiguity cases among sharding keys.\n    * @param path - the path where the search is conducted\n-   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n-   * @return the node pointed by the path or a leaf node along the path\n-   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n-   *           found\n+   * @return a TrieNode that represents the longest prefix of the path\n    */\n-  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n-      throws NoSuchElementException {\n+  private TrieNode getLongestPrefixNodeAlongPath(String path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5NjM1MA=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0Mjk5MA==", "bodyText": "Thank you for the feedback. If you know the logic but still find it confusing, then that definitely is an indication. I coded this so I can't possibly have an objective view on it.\nWhile I agree that the current naming isn't the best, I'm not very keen about \"closest node\" either. Let me keep the discussion open so that there may be some second opinions coming in. I'll make sure to update the name before the PR is checked in. Thanks!", "url": "https://github.com/apache/helix/pull/759#discussion_r379142990", "createdAt": "2020-02-13T21:59:43Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided\n+   * path (meaning the traversal ended before the last node of the path is reached), the provided\n+   * path is not associated with any sharding key and can be added as a sharding key without\n+   * creating ambiguity cases among sharding keys.\n    * @param path - the path where the search is conducted\n-   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n-   * @return the node pointed by the path or a leaf node along the path\n-   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n-   *           found\n+   * @return a TrieNode that represents the longest prefix of the path\n    */\n-  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n-      throws NoSuchElementException {\n+  private TrieNode getLongestPrefixNodeAlongPath(String path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5NjM1MA=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwMDI5OQ==", "bodyText": "As @pkuwm mentioned to me privately, he's able to understand the logic from the name. The method name will be kept as is without strong objections.", "url": "https://github.com/apache/helix/pull/759#discussion_r379600299", "createdAt": "2020-02-14T19:16:10Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided\n+   * path (meaning the traversal ended before the last node of the path is reached), the provided\n+   * path is not associated with any sharding key and can be added as a sharding key without\n+   * creating ambiguity cases among sharding keys.\n    * @param path - the path where the search is conducted\n-   * @param findLeafAlongPath - whether the search is for a leaf node on the path\n-   * @return the node pointed by the path or a leaf node along the path\n-   * @throws NoSuchElementException - when the path points to nothing or when no leaf node is\n-   *           found\n+   * @return a TrieNode that represents the longest prefix of the path\n    */\n-  private TrieNode findTrieNode(String path, boolean findLeafAlongPath)\n-      throws NoSuchElementException {\n+  private TrieNode getLongestPrefixNodeAlongPath(String path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5NjM1MA=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTUyNTk3OnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoyNDoxMVrOFpiW5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjowMDoyNlrOFplEmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5ODg1Mg==", "bodyText": "\"longest prefix\"? Could we just call it the closest existing sharding key node?", "url": "https://github.com/apache/helix/pull/759#discussion_r379098852", "createdAt": "2020-02-13T20:24:11Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwNzM3Ng==", "bodyText": "Ditto my explanation above.", "url": "https://github.com/apache/helix/pull/759#discussion_r379107376", "createdAt": "2020-02-13T20:41:59Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5ODg1Mg=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMjczNw==", "bodyText": "Explain what the longest prefix is: The longest prefix means the closest existing terminal node (sharding key).", "url": "https://github.com/apache/helix/pull/759#discussion_r379132737", "createdAt": "2020-02-13T21:38:04Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5ODg1Mg=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0MzMyMA==", "bodyText": "Related to the previous conversation and will be updated along the previous part.", "url": "https://github.com/apache/helix/pull/759#discussion_r379143320", "createdAt": "2020-02-13T22:00:26Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5ODg1Mg=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTUyOTgxOnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoyNTozOVrOFpiZYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjo1Njo1NlrOFpmdPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5OTQ5MQ==", "bodyText": "Is this scenario possible (assuming that the existing routing data is valid)?", "url": "https://github.com/apache/helix/pull/759#discussion_r379099491", "createdAt": "2020-02-13T20:25:39Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMTYxMA==", "bodyText": "Oh, never mind. This is the case where it's \"successful\".", "url": "https://github.com/apache/helix/pull/759#discussion_r379101610", "createdAt": "2020-02-13T20:29:56Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5OTQ5MQ=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwOTE1Mw==", "bodyText": "Yes it is. This scenario is when path is a sharding key that could be added to the trie. Consider a trie that only has \"/a/b/c\" in it:\n\ngetLongestPrefixNodeAlongPath(\"/a/b/c/x\") is the first case (typically used during realm lookups), which returns \"/a/b/c\";\ngetLongestPrefixNodeAlongPath(\"/a/b\") is the second case (typically used during key scanning), which returns \"/a/b\";\ngetLongestPrefixNodeAlongPath(\"/a/b/d\") is the last case, which returns \"/a/b\". Note that \"/a/b/d\" is a valid sharding key to add.", "url": "https://github.com/apache/helix/pull/759#discussion_r379109153", "createdAt": "2020-02-13T20:45:55Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5OTQ5MQ=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NjAxNQ==", "bodyText": "@NealSun96 Let's add this in the Javadoc :)\n\nYes it is. This scenario is when path is a sharding key that could be added to the trie. Consider a trie that only has \"/a/b/c\" in it:\n\ngetLongestPrefixNodeAlongPath(\"/a/b/c/x\") is the first case (typically used during realm lookups), which returns \"/a/b/c\";\ngetLongestPrefixNodeAlongPath(\"/a/b\") is the second case (typically used during key scanning), which returns \"/a/b\";\ngetLongestPrefixNodeAlongPath(\"/a/b/d\") is the last case, which returns \"/a/b\". Note that \"/a/b/d\" is a valid sharding key to add.", "url": "https://github.com/apache/helix/pull/759#discussion_r379166015", "createdAt": "2020-02-13T22:56:56Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.\n+   * Note:\n+   * 1. When the returned TrieNode is a sharding key, it is the only sharding key along the\n+   * provided path (the path points to this sharding key);\n+   * 2. When the returned TrieNode is not a sharding key but it represents the provided path, the\n+   * provided path is a prefix(parent) to a sharding key;\n+   * 3. When the returned TrieNode is not a sharding key and it does not represent the provided", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5OTQ5MQ=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTczNTM4OnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTozNzoxOFrOFpkaBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjowMToxNFrOFplGMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMjQyMA==", "bodyText": "last-seen existing node?", "url": "https://github.com/apache/helix/pull/759#discussion_r379132420", "createdAt": "2020-02-13T21:37:18Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0MzczMA==", "bodyText": "Sure.", "url": "https://github.com/apache/helix/pull/759#discussion_r379143730", "createdAt": "2020-02-13T22:01:14Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**\n-   * If findLeafAlongPath is false, then starting from the root node, find the trie node that the\n-   * given path is pointing to and return it; raise NoSuchElementException if the path does\n-   * not point to any node. If findLeafAlongPath is true, then starting from the root node, find the\n-   * leaf node along the provided path; raise NoSuchElementException if the path does not\n-   * point to any node or if there is no leaf node along the path.\n+   * Given a path, find a trie node that represents the longest prefix of the path. For example,\n+   * given \"/a/b/c\", the method starts at \"/\", and attempts to reach \"/a\", then attempts to reach\n+   * \"/a/b\", then ends on \"/a/b/c\"; if any of the node doesn't exist, the traversal terminates and\n+   * the last existing node is returned.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMjQyMA=="}, "originalCommit": {"oid": "9f0886dcb893527696c7ad0ada56be10c028cab2"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjIzNTAxOnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTozMjoxMFrOFppMjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyMjo1NVrOFqBI6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMDg5Mg==", "bodyText": "/** is for Javadoc. I don't think Javadoc should be added to a private method, as end users don't have access to private fields or logic. I suggest you change /** to /* for regular comments.", "url": "https://github.com/apache/helix/pull/759#discussion_r379210892", "createdAt": "2020-02-14T01:32:10Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11dc9a6d14290802cbc6e65a5e6cea9abf11adb0"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwMzE3Nw==", "bodyText": "Interesting point. I have converted the javadoc to block comments.", "url": "https://github.com/apache/helix/pull/759#discussion_r379603177", "createdAt": "2020-02-14T19:22:55Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/TrieRoutingData.java", "diffHunk": "@@ -89,49 +87,55 @@ public String getMetadataStoreRealm(String path)\n           + DELIMITER + \"\\\" character: \" + path);\n     }\n \n-    TrieNode leafNode = findTrieNode(path, true);\n-    return leafNode.getRealmAddress();\n+    TrieNode node = getLongestPrefixNodeAlongPath(path);\n+    if (!node.isShardingKey()) {\n+      throw new NoSuchElementException(\n+          \"No sharding key found within the provided path. Path: \" + path);\n+    }\n+    return node.getRealmAddress();\n+  }\n+\n+  public boolean isShardingKeyInsertionValid(String shardingKey) {\n+    if (shardingKey.isEmpty() || !shardingKey.substring(0, 1).equals(DELIMITER)) {\n+      throw new IllegalArgumentException(\n+          \"Provided shardingKey is empty or does not have a leading \\\"\" + DELIMITER\n+              + \"\\\" character: \" + shardingKey);\n+    }\n+\n+    TrieNode node = getLongestPrefixNodeAlongPath(shardingKey);\n+    return !node.isShardingKey() && !node.getPath().equals(shardingKey);\n   }\n \n   /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMDg5Mg=="}, "originalCommit": {"oid": "11dc9a6d14290802cbc6e65a5e6cea9abf11adb0"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjI1MDkxOnYy", "diffSide": "RIGHT", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/TestTrieRoutingData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMTo0MjoxNlrOFppWCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyOTowNVrOFqBTmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzMyMw==", "bodyText": "Are below cases valid?\n\n/x/y/z/\n/x//y/z", "url": "https://github.com/apache/helix/pull/759#discussion_r379213323", "createdAt": "2020-02-14T01:42:16Z", "author": {"login": "huizhilu"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/TestTrieRoutingData.java", "diffHunk": "@@ -249,7 +251,44 @@ public void testGetMetadataStoreRealmNoLeaf() {\n       _trie.getMetadataStoreRealm(\"/b/c\");\n       Assert.fail(\"Expecting NoSuchElementException\");\n     } catch (NoSuchElementException e) {\n-      Assert.assertTrue(e.getMessage().contains(\"No leaf node found along the path. Path: /b/c\"));\n+      Assert.assertTrue(\n+          e.getMessage().contains(\"No sharding key found within the provided path. Path: /b/c\"));\n     }\n   }\n+\n+  @Test(dependsOnMethods = \"testConstructionNormal\")\n+  public void testIsShardingKeyInsertionValidNoSlash() {\n+    try {\n+      _trie.isShardingKeyInsertionValid(\"x/y/z\");\n+      Assert.fail(\"Expecting IllegalArgumentException\");\n+    } catch (IllegalArgumentException e) {\n+      Assert.assertTrue(e.getMessage().contains(\n+          \"Provided shardingKey is empty or does not have a leading \\\"/\\\" character: x/y/z\"));\n+    }\n+  }\n+\n+  @Test(dependsOnMethods = \"testConstructionNormal\")\n+  public void testIsShardingKeyInsertionValidSlashOnly() {\n+    Assert.assertFalse(_trie.isShardingKeyInsertionValid(\"/\"));\n+  }\n+\n+  @Test(dependsOnMethods = \"testConstructionNormal\")\n+  public void testIsShardingKeyInsertionValidNormal() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11dc9a6d14290802cbc6e65a5e6cea9abf11adb0"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNTkxNQ==", "bodyText": "Good catch, I'll add validation for sharding key formats.", "url": "https://github.com/apache/helix/pull/759#discussion_r379605915", "createdAt": "2020-02-14T19:29:05Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/TestTrieRoutingData.java", "diffHunk": "@@ -249,7 +251,44 @@ public void testGetMetadataStoreRealmNoLeaf() {\n       _trie.getMetadataStoreRealm(\"/b/c\");\n       Assert.fail(\"Expecting NoSuchElementException\");\n     } catch (NoSuchElementException e) {\n-      Assert.assertTrue(e.getMessage().contains(\"No leaf node found along the path. Path: /b/c\"));\n+      Assert.assertTrue(\n+          e.getMessage().contains(\"No sharding key found within the provided path. Path: /b/c\"));\n     }\n   }\n+\n+  @Test(dependsOnMethods = \"testConstructionNormal\")\n+  public void testIsShardingKeyInsertionValidNoSlash() {\n+    try {\n+      _trie.isShardingKeyInsertionValid(\"x/y/z\");\n+      Assert.fail(\"Expecting IllegalArgumentException\");\n+    } catch (IllegalArgumentException e) {\n+      Assert.assertTrue(e.getMessage().contains(\n+          \"Provided shardingKey is empty or does not have a leading \\\"/\\\" character: x/y/z\"));\n+    }\n+  }\n+\n+  @Test(dependsOnMethods = \"testConstructionNormal\")\n+  public void testIsShardingKeyInsertionValidSlashOnly() {\n+    Assert.assertFalse(_trie.isShardingKeyInsertionValid(\"/\"));\n+  }\n+\n+  @Test(dependsOnMethods = \"testConstructionNormal\")\n+  public void testIsShardingKeyInsertionValidNormal() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzMyMw=="}, "originalCommit": {"oid": "11dc9a6d14290802cbc6e65a5e6cea9abf11adb0"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1624, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}