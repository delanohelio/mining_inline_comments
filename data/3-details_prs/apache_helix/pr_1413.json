{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzMzg1OTYz", "number": 1413, "title": "Feature: Offline Node Timeout During Maintenance Mode", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #1412\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nAs described in the issue, we would like to avoid the scenario where nodes that have been offline for a while come back to life during maintenance mode. Solution: if a node has been offline for a certain period of time, the maintenance mode rebalancer will not assign partitions to it.\nTo accomplish this, two aspects of changes are necessary:\n\nA new customer-defined value is required to enable this feature: MAINTENANCE_NODE_TIME_OUT. This value represents \"how long a node has been offline such that it should be timed out\". This value is set in ClusterConfig, similar to DELAY_REBALANCE_TIME.\nA new logic should be added to the refreshLiveInstances() function of BaseControllerDataProvider. When the maintenance mode is enabled, find the new live nodes, and filter out the timed-out nodes; the timed-out nodes are treated as not live throughout the pipeline.\n\nTests\n\n The following tests are written for this issue:\n\nEverything under: TestParticipantHistory.java, TestOfflineNodeTimeoutDuringMaintenanceMode.java\ntestGetMaintenanceOfflineNodeTimeOut(), testSetMaintenanceOfflineNodeTimeOut()\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[WARNING] Tests run: 1222, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 3,963.658 s - in TestSuite\n[INFO] \n[INFO] Results:\n[INFO] \n[WARNING] Tests run: 1222, Failures: 0, Errors: 0, Skipped: 1\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:06 h\n[INFO] Finished at: 2020-10-07T12:10:45-07:00\n[INFO] ------------------------------------------------------------------------\n\n\nDocumentation (Optional)\n\nIn case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCommits\n\nMy commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\nMy diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-09-25T21:43:48Z", "url": "https://github.com/apache/helix/pull/1413", "merged": true, "mergeCommit": {"oid": "e52eaf19dec3475d4783fcea91f449e167cd730b"}, "closed": true, "closedAt": "2020-10-12T23:31:03Z", "author": {"login": "NealSun96"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMd-zJAFqTQ5NjkwNDY3Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQ966jgH2gAyNDkzMzg1OTYzOjU4ODg4Y2ExNDJjMzIzMzYxNWIyMDdmYzcwZDZkNzkzY2M0MGNiNmE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTA0Njc2", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-496904676", "createdAt": "2020-09-25T22:57:21Z", "commit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMjo1NzoyMVrOHYWsdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMjo1NzoyMVrOHYWsdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5OTcwMQ==", "bodyText": "I think it may not be the place to do that. We can do it in maintenance recovery stage. I cannot remember the details of how to move the last offline time to history and set -1. It happened at cache refresh as well. So I think it is better to make it after cache refresh fully complete.", "url": "https://github.com/apache/helix/pull/1413#discussion_r495299701", "createdAt": "2020-09-25T22:57:21Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -253,9 +254,34 @@ private void refreshIdealState(final HelixDataAccessor accessor,\n   private void refreshLiveInstances(final HelixDataAccessor accessor,\n       Set<HelixConstants.ChangeType> refreshedType) {\n     if (_propertyDataChangedMap.get(HelixConstants.ChangeType.LIVE_INSTANCE).getAndSet(false)) {\n+      // Keep a copy of old live instances in case of maintenance mode\n+      Map<String, LiveInstance> oldLiveInstances = getLiveInstances();\n       _liveInstanceCache.refresh(accessor);\n       _updateInstanceOfflineTime = true;\n       refreshedType.add(HelixConstants.ChangeType.LIVE_INSTANCE);\n+\n+      // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+      // for timed-out nodes\n+      long timeOutWindow = _clusterConfig.getMaintenanceOfflineNodeTimeOut();\n+      if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+        for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+          // For every 'new' live node, check if it's timed-out\n+          if (!oldLiveInstances.containsKey(instance) && isInstanceTimedOutDuringMaintenance(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Nzc0OTQx", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-497774941", "createdAt": "2020-09-28T18:05:41Z", "commit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODowNTo0MVrOHZJ40Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToyMTowNVrOHZMVsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzODQ0OQ==", "bodyText": "It's better to ensure the cache has all the facts. Removing the timedout instances from the cache might be suboptimal since after this, no one tracking the real alive nodes anymore.\nIt would be easier to keep tracking the whole list and the timedout list, then if the filter option is turned on, we filter in the get method. In this way, we still have the capability to return the full list.", "url": "https://github.com/apache/helix/pull/1413#discussion_r496138449", "createdAt": "2020-09-28T18:05:41Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -253,9 +254,34 @@ private void refreshIdealState(final HelixDataAccessor accessor,\n   private void refreshLiveInstances(final HelixDataAccessor accessor,\n       Set<HelixConstants.ChangeType> refreshedType) {\n     if (_propertyDataChangedMap.get(HelixConstants.ChangeType.LIVE_INSTANCE).getAndSet(false)) {\n+      // Keep a copy of old live instances in case of maintenance mode\n+      Map<String, LiveInstance> oldLiveInstances = getLiveInstances();\n       _liveInstanceCache.refresh(accessor);\n       _updateInstanceOfflineTime = true;\n       refreshedType.add(HelixConstants.ChangeType.LIVE_INSTANCE);\n+\n+      // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+      // for timed-out nodes\n+      long timeOutWindow = _clusterConfig.getMaintenanceOfflineNodeTimeOut();\n+      if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+        for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+          // For every 'new' live node, check if it's timed-out\n+          if (!oldLiveInstances.containsKey(instance) && isInstanceTimedOutDuringMaintenance(\n+              accessor, instance, timeOutWindow)) {\n+            _timedOutInstanceDuringMaintenance.add(instance);\n+          }\n+        }\n+\n+        // Remove all timed-out nodes that were recorded in this maintenance duration\n+        for (String instance : _timedOutInstanceDuringMaintenance) {\n+          _liveInstanceCache.deletePropertyByName(instance);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MDY0MA==", "bodyText": "If there is a leadership switch, the oldLiveInstances list will be empty. So the behavior would rely on isInstanceTimedOutDuringMaintenance() only. My guess is that we don't need oldLiveInstances list, since it won't be able to cover leadership switch case anyway.\nIf isInstanceTimedOutDuringMaintenance() has anything missed, so you have to relies on the oldLiveInstances list, then we need to fix it within the scope of isInstanceTimedOutDuringMaintenance().", "url": "https://github.com/apache/helix/pull/1413#discussion_r496140640", "createdAt": "2020-09-28T18:09:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -253,9 +254,34 @@ private void refreshIdealState(final HelixDataAccessor accessor,\n   private void refreshLiveInstances(final HelixDataAccessor accessor,\n       Set<HelixConstants.ChangeType> refreshedType) {\n     if (_propertyDataChangedMap.get(HelixConstants.ChangeType.LIVE_INSTANCE).getAndSet(false)) {\n+      // Keep a copy of old live instances in case of maintenance mode\n+      Map<String, LiveInstance> oldLiveInstances = getLiveInstances();\n       _liveInstanceCache.refresh(accessor);\n       _updateInstanceOfflineTime = true;\n       refreshedType.add(HelixConstants.ChangeType.LIVE_INSTANCE);\n+\n+      // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+      // for timed-out nodes\n+      long timeOutWindow = _clusterConfig.getMaintenanceOfflineNodeTimeOut();\n+      if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+        for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+          // For every 'new' live node, check if it's timed-out\n+          if (!oldLiveInstances.containsKey(instance) && isInstanceTimedOutDuringMaintenance(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MjI5NQ==", "bodyText": "nit, this calculation does not need to be bound with the maintenance mode, let's don't mention \"maintenance mode\" in the log.", "url": "https://github.com/apache/helix/pull/1413#discussion_r496142295", "createdAt": "2020-09-28T18:12:59Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +756,41 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey = keyBuilder.participantHistory(instance);\n+    ParticipantHistory history = accessor.getProperty(propertyKey);\n+\n+    // Cannot use _instanceOfflineTimeMap. _instanceOfflineTimeMap is last updated in the previous\n+    // pipeline execution; it is possible a new offline timestamp is updated after the previous\n+    // pipeline execution, so we need the most updated timestamp.\n+    long lastOfflineTime = history.getLastTimeInOfflineHistory();\n+    // lastOfflineTime is only negative if there is no offline history or the time format is wrong.\n+    // Since this instance is a 'new' live instance, not having offline history = first time created\n+    // instance; during maintenance mode, no partition will be assigned to such a new instance,\n+    // therefore it's okay to no time it out. The wrong format case shouldn't happen at all and will\n+    // not be handled either.\n+    if (lastOfflineTime < 0) {\n+      return false;\n+    }\n+\n+    long currentTime = System.currentTimeMillis();\n+    if (currentTime - lastOfflineTime > timeOutWindow) {\n+      LogUtil.logWarn(logger, getClusterEventId(), String.format(\n+          \"During maintenance mode, instance %s is timed-out due to its offline time. Current time: \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NDYwMg==", "bodyText": "Strictly check for ONLINE? Of course, keeping the < 0 checks for safe is still good here, but optional. I suggest adding \"lastOfflineTime == ONLINE\" to make the logic easier for the reader to understand.", "url": "https://github.com/apache/helix/pull/1413#discussion_r496144602", "createdAt": "2020-09-28T18:17:17Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +756,41 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey = keyBuilder.participantHistory(instance);\n+    ParticipantHistory history = accessor.getProperty(propertyKey);\n+\n+    // Cannot use _instanceOfflineTimeMap. _instanceOfflineTimeMap is last updated in the previous\n+    // pipeline execution; it is possible a new offline timestamp is updated after the previous\n+    // pipeline execution, so we need the most updated timestamp.\n+    long lastOfflineTime = history.getLastTimeInOfflineHistory();\n+    // lastOfflineTime is only negative if there is no offline history or the time format is wrong.\n+    // Since this instance is a 'new' live instance, not having offline history = first time created\n+    // instance; during maintenance mode, no partition will be assigned to such a new instance,\n+    // therefore it's okay to no time it out. The wrong format case shouldn't happen at all and will\n+    // not be handled either.\n+    if (lastOfflineTime < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjQ4MA==", "bodyText": "There is a chance that we failed to record the offlinetime, or if pipeline runs slower, the offline time is not accurately recorded. I don't think there is a solution for it, but let's mention in the comment.", "url": "https://github.com/apache/helix/pull/1413#discussion_r496146480", "createdAt": "2020-09-28T18:20:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +756,41 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey = keyBuilder.participantHistory(instance);\n+    ParticipantHistory history = accessor.getProperty(propertyKey);\n+\n+    // Cannot use _instanceOfflineTimeMap. _instanceOfflineTimeMap is last updated in the previous\n+    // pipeline execution; it is possible a new offline timestamp is updated after the previous\n+    // pipeline execution, so we need the most updated timestamp.\n+    long lastOfflineTime = history.getLastTimeInOfflineHistory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NzY5Mg==", "bodyText": "Due to the same reason, we might want to limit the timeout setup to be more than 5 mins (for example). A very small number does not make sense, and it won't work as expected anyway.", "url": "https://github.com/apache/helix/pull/1413#discussion_r496147692", "createdAt": "2020-09-28T18:23:07Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +756,41 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey = keyBuilder.participantHistory(instance);\n+    ParticipantHistory history = accessor.getProperty(propertyKey);\n+\n+    // Cannot use _instanceOfflineTimeMap. _instanceOfflineTimeMap is last updated in the previous\n+    // pipeline execution; it is possible a new offline timestamp is updated after the previous\n+    // pipeline execution, so we need the most updated timestamp.\n+    long lastOfflineTime = history.getLastTimeInOfflineHistory();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjQ4MA=="}, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0ODgwMw==", "bodyText": "nit, OFFLINE_NODE_TIME_OUT_FOR_MAINTENANCE_MODE?", "url": "https://github.com/apache/helix/pull/1413#discussion_r496148803", "createdAt": "2020-09-28T18:25:10Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -122,7 +122,13 @@\n     // don't specify their individual pool sizes, this value will be used for all participants; if\n     // none of participants or the cluster define pool sizes,\n     // TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE will be used to create pool sizes.\n-    GLOBAL_TARGET_TASK_THREAD_POOL_SIZE\n+    GLOBAL_TARGET_TASK_THREAD_POOL_SIZE,\n+\n+    // The time out window for offline nodes during maintenance mode; if an offline node has been\n+    // offline for more than this specified time period, it's treated as offline for the rest of\n+    // the maintenance mode's duration even when it comes online.\n+    // The unit is milliseconds.\n+    MAINTENANCE_OFFLINE_NODE_TIME_OUT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NzMzNA==", "bodyText": "We need a test to cover the get default value case.\nMight be easier for you to combine the 2 new tests.", "url": "https://github.com/apache/helix/pull/1413#discussion_r496177334", "createdAt": "2020-09-28T19:18:42Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/model/TestClusterConfig.java", "diffHunk": "@@ -298,6 +298,26 @@ public void testAsyncGlobalRebalanceOption() {\n             false), true);\n   }\n \n+  @Test\n+  public void testGetMaintenanceOfflineNodeTimeOut() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NzgwNQ==", "bodyText": "private?", "url": "https://github.com/apache/helix/pull/1413#discussion_r496177805", "createdAt": "2020-09-28T19:19:35Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -40,7 +41,9 @@\n   private static Logger LOG = LoggerFactory.getLogger(ParticipantHistory.class);\n \n   private final static int HISTORY_SIZE = 20;\n-  private enum ConfigProperty {\n+  final static String HISTORY_DATE_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss:SSS\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3ODYwOA==", "bodyText": "If required in the test, then either put it in HelixConstants or redefine a string in the test case (this helps to prevent if anyone changes the format that breaks the compatibility)", "url": "https://github.com/apache/helix/pull/1413#discussion_r496178608", "createdAt": "2020-09-28T19:21:05Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -40,7 +41,9 @@\n   private static Logger LOG = LoggerFactory.getLogger(ParticipantHistory.class);\n \n   private final static int HISTORY_SIZE = 20;\n-  private enum ConfigProperty {\n+  final static String HISTORY_DATE_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss:SSS\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NzgwNQ=="}, "originalCommit": {"oid": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "17d0764f49d7cb8046368008451a8cdc2ef90133", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/17d0764f49d7cb8046368008451a8cdc2ef90133", "committedDate": "2020-09-30T01:37:26Z", "message": "Attempt to stabilize tests"}, "afterCommit": {"oid": "79ae83b100b296fb2a7bb2e871090c755b9bd472", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/79ae83b100b296fb2a7bb2e871090c755b9bd472", "committedDate": "2020-09-30T01:49:28Z", "message": "Attempt to stabilize tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5MDQ3MDI4", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-499047028", "createdAt": "2020-09-30T02:38:31Z", "commit": {"oid": "172e7cbefeb76fe947d3cd8bd9d1a862cd85dbe2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDM5NzU5", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-501439759", "createdAt": "2020-10-02T20:50:45Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDo1MDo0NVrOHb7Qag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDo1MDo0NVrOHb7Qag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NDQ1OA==", "bodyText": "It has the edge case for first interval. It is the interval online time just before maintenance mode, but somehow we dont check whether the offline time is before maintenance.\nLet's say if the instance is offline before maintenance we need the potential timeout = online time - Math.max(offlinetimestamp, maintenance entering time);", "url": "https://github.com/apache/helix/pull/1413#discussion_r499044458", "createdAt": "2020-10-02T20:50:45Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +782,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {\n+      // Node is a new node in this maintenance mode, no need to time out since no partitions are\n+      // assigned to it\n+      return false;\n+    }\n+\n+    // Parse offline timestamps from offline list\n+    List<Long> offlineTimestamps = new ArrayList<>();\n+    List<String> historyOfflineList = history.getOffline();\n+    if (historyOfflineList != null) {\n+      long tailOfflineTime;\n+      for (int i = historyOfflineList.size() - 1; i >= 0; i--) {\n+        tailOfflineTime =\n+            ParticipantHistory.parseHistoryDateStringToLong(historyOfflineList.get(i));\n+        // Ignore bad format case\n+        if (tailOfflineTime != -1) {\n+          if (tailOfflineTime <= onlineTimestamps.get(0)) {\n+            break;\n+          }\n+          offlineTimestamps.add(0, tailOfflineTime);\n+        }\n+      }\n+    }\n+\n+    // At this point, onlineTimestamps contains at least 1 timestamp that's before maintenance mode;\n+    // offlineTimestamps contains 0+ timestamp that's > the first online timestamp.\n+    if (!offlineTimestamps.isEmpty()\n+        && offlineTimestamps.get(offlineTimestamps.size() - 1) > onlineTimestamps\n+        .get(onlineTimestamps.size() - 1)) {\n+      // Make sure for each offline timestamp, 2 online timestamps creates a range around it;\n+      // this is usually true unless the timestamps are malformed (missing online timestamps)\n+      onlineTimestamps.add(currentTime);\n+    }\n+\n+    // Hop between each pair of online timestamps and find the maximum offline window\n+    for (int onlineTimestampIndex = 1, offlineTimestampIndex = 0;\n+        onlineTimestampIndex < onlineTimestamps.size() && offlineTimestampIndex < offlineTimestamps\n+            .size(); onlineTimestampIndex++) {\n+      long onlineTimestamp = onlineTimestamps.get(onlineTimestampIndex);\n+      long offlineTimeStamp = offlineTimestamps.get(offlineTimestampIndex);\n+\n+      // If the offline timestamp isn't within this pair of online timestamp, continue\n+      if (offlineTimeStamp > onlineTimestamp) {\n+        continue;\n+      }\n+\n+      // Check the largest offline window against the timeout window\n+      if (onlineTimestamp - offlineTimeStamp > timeOutWindow) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 185}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjQ2ODAw", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502246800", "createdAt": "2020-10-05T16:55:58Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjo1NTo1OFrOHclwbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjo1NTo1OFrOHclwbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MDc4MA==", "bodyText": "What is difference this w/ getLastOfflineTime?", "url": "https://github.com/apache/helix/pull/1413#discussion_r499740780", "createdAt": "2020-10-05T16:55:58Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -112,6 +129,22 @@ public long getLastOfflineTime() {\n     return offlineTime;\n   }\n \n+  /**\n+   * Get the time when this node last goes offline in history. If the node does not have offline\n+   * history or contains invalid date as the last element, return -1.\n+   *\n+   * @return\n+   */\n+  public long getLastTimeInOfflineHistory() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjQ3NzM2", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502247736", "createdAt": "2020-10-05T16:57:10Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjo1NzoxMFrOHclzNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjo1NzoxMFrOHclzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MTQ5NA==", "bodyText": "minor:  -> historyDateStringToLong?", "url": "https://github.com/apache/helix/pull/1413#discussion_r499741494", "createdAt": "2020-10-05T16:57:10Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +183,73 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(parseHistoryDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /**\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  public static long parseHistoryDateStringToLong(String dateString) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjUyMjM0", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502252234", "createdAt": "2020-10-05T17:03:07Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzowMzowN1rOHcmABA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzowMzowN1rOHcmABA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0NDc3Mg==", "bodyText": "filterTimedOutInstances is a bit confusing, it could mean either the result contains only Timeouted Instances or the other way. Suggest to rename it as:  excludeTimeoutInstances.", "url": "https://github.com/apache/helix/pull/1413#discussion_r499744772", "createdAt": "2020-10-05T17:03:07Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +463,32 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n    * @return\n    */\n   public Map<String, LiveInstance> getLiveInstances() {\n-    return _liveInstanceCache.getPropertyMap();\n+    return getLiveInstances(false);\n+  }\n+\n+  /**\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n+   * @param filterTimedOutInstances - Only set true during maintenance mode. If true, filter out\n+   *                                instances that are timed-out during maintenance mode; instances\n+   *                                are timed-out if they have been offline for a while before going\n+   *                                live during maintenance mode.\n+   * @return\n+   */\n+  public Map<String, LiveInstance> getLiveInstances(boolean filterTimedOutInstances) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjU3MTY3", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502257167", "createdAt": "2020-10-05T17:10:04Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoxMDowNFrOHcmOmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoxMDowNFrOHcmOmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODUwNQ==", "bodyText": "There could be some issue with this if a long-offline instance (say InstanceA) came back just after the cluster enter maintenance mode and before the next pipeline started.  InstanceA will be in the _liveInstanceSnapshotForMaintenance set (see line 261), so it will skip the timeout check here.", "url": "https://github.com/apache/helix/pull/1413#discussion_r499748505", "createdAt": "2020-10-05T17:10:04Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -299,6 +306,33 @@ private void updateMaintenanceInfo(final HelixDataAccessor accessor) {\n     // The following flag is to guarantee that there's only one update per pineline run because we\n     // check for whether maintenance recovery could happen twice every pipeline\n     _hasMaintenanceSignalChanged = false;\n+\n+    // If maintenance mode has exited, clear cached timed-out nodes\n+    if (!_isMaintenanceModeEnabled) {\n+      _timedOutInstanceDuringMaintenance.clear();\n+    }\n+  }\n+\n+  private void timeoutNodesDuringMaintenance(final HelixDataAccessor accessor) {\n+    // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+    // for timed-out nodes\n+    long timeOutWindow = -1;\n+    if (_clusterConfig != null) {\n+      timeOutWindow = _clusterConfig.getOfflineNodeTimeOutForMaintenanceMode();\n+    }\n+    if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+      for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+        // 1. Check timed-out cache and don't do repeated work;\n+        // 2. Check for nodes that didn't exist in the last iteration, because it has been checked;\n+        // 3. For all other nodes, check if it's timed-out.\n+        // When maintenance mode is first entered, all nodes will be checked as a result.\n+        if (!_timedOutInstanceDuringMaintenance.contains(instance)\n+            && !_liveInstanceSnapshotForMaintenance.containsKey(instance)\n+            && isInstanceTimedOutDuringMaintenance(accessor, instance, timeOutWindow)) {\n+          _timedOutInstanceDuringMaintenance.add(instance);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjU4ODIx", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502258821", "createdAt": "2020-10-05T17:12:22Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoxMjoyMlrOHcmTdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoxMjoyMlrOHcmTdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0OTc0OQ==", "bodyText": "Can we cache the results somewhere (we may already have it?) instead of recomputing every time this method is called?  I think getLiveInstances are called in many places during one pipeline.", "url": "https://github.com/apache/helix/pull/1413#discussion_r499749749", "createdAt": "2020-10-05T17:12:22Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +463,32 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n    * @return\n    */\n   public Map<String, LiveInstance> getLiveInstances() {\n-    return _liveInstanceCache.getPropertyMap();\n+    return getLiveInstances(false);\n+  }\n+\n+  /**\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n+   * @param filterTimedOutInstances - Only set true during maintenance mode. If true, filter out\n+   *                                instances that are timed-out during maintenance mode; instances\n+   *                                are timed-out if they have been offline for a while before going\n+   *                                live during maintenance mode.\n+   * @return\n+   */\n+  public Map<String, LiveInstance> getLiveInstances(boolean filterTimedOutInstances) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjU5NzA2", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502259706", "createdAt": "2020-10-05T17:13:33Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoxMzozNFrOHcmWBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoxMzozNFrOHcmWBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MDQwNw==", "bodyText": "In which places we will need  LiveInstances containing timeouted instance?", "url": "https://github.com/apache/helix/pull/1413#discussion_r499750407", "createdAt": "2020-10-05T17:13:34Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +463,32 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n    * @return\n    */\n   public Map<String, LiveInstance> getLiveInstances() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzE1NTg0", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502315584", "createdAt": "2020-10-05T18:31:16Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODozMToxNlrOHco5oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODozMToxNlrOHco5oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5MjI4OQ==", "bodyText": "Could this create inconsistency since LivInstances used by all other places in the pipeline are different from here?", "url": "https://github.com/apache/helix/pull/1413#discussion_r499792289", "createdAt": "2020-10-05T18:31:16Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java", "diffHunk": "@@ -89,7 +89,7 @@ protected void processEvent(ClusterEvent event, ResourcesStateMap resourcesState\n           + \". Requires HelixManager|DataCache|RESOURCES|CURRENT_STATE|INTERMEDIATE_STATE\");\n     }\n \n-    Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n+    Map<String, LiveInstance> liveInstances = cache.getLiveInstances(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzUzNjE1", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502353615", "createdAt": "2020-10-05T19:25:59Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToyNTo1OVrOHcqqIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToyNTo1OVrOHcqqIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTA4OA==", "bodyText": "Can we wrap up the logic here into a method in ParticipantHistory, such as getAllOnlineHistory()?", "url": "https://github.com/apache/helix/pull/1413#discussion_r499821088", "createdAt": "2020-10-05T19:25:59Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +782,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzU0MTE5", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502354119", "createdAt": "2020-10-05T19:26:44Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToyNjo0NFrOHcqrlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToyNjo0NFrOHcqrlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTQ2Mw==", "bodyText": "Similar here, the logic should belong to ParticipantHistory, such as getAllOfflineHistory().", "url": "https://github.com/apache/helix/pull/1413#discussion_r499821463", "createdAt": "2020-10-05T19:26:44Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +782,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {\n+      // Node is a new node in this maintenance mode, no need to time out since no partitions are\n+      // assigned to it\n+      return false;\n+    }\n+\n+    // Parse offline timestamps from offline list\n+    List<Long> offlineTimestamps = new ArrayList<>();\n+    List<String> historyOfflineList = history.getOffline();\n+    if (historyOfflineList != null) {\n+      long tailOfflineTime;\n+      for (int i = historyOfflineList.size() - 1; i >= 0; i--) {\n+        tailOfflineTime =\n+            ParticipantHistory.parseHistoryDateStringToLong(historyOfflineList.get(i));\n+        // Ignore bad format case\n+        if (tailOfflineTime != -1) {\n+          if (tailOfflineTime <= onlineTimestamps.get(0)) {\n+            break;\n+          }\n+          offlineTimestamps.add(0, tailOfflineTime);\n+        }\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzU1MzA5", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-502355309", "createdAt": "2020-10-05T19:28:28Z", "commit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToyODoyOVrOHcqvJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToyODoyOVrOHcqvJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMjM3Mg==", "bodyText": "This may not be true, for example, a newly added host?  (I.e, our code should be able to handle these corner cases properly).", "url": "https://github.com/apache/helix/pull/1413#discussion_r499822372", "createdAt": "2020-10-05T19:28:29Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +782,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {\n+      // Node is a new node in this maintenance mode, no need to time out since no partitions are\n+      // assigned to it\n+      return false;\n+    }\n+\n+    // Parse offline timestamps from offline list\n+    List<Long> offlineTimestamps = new ArrayList<>();\n+    List<String> historyOfflineList = history.getOffline();\n+    if (historyOfflineList != null) {\n+      long tailOfflineTime;\n+      for (int i = historyOfflineList.size() - 1; i >= 0; i--) {\n+        tailOfflineTime =\n+            ParticipantHistory.parseHistoryDateStringToLong(historyOfflineList.get(i));\n+        // Ignore bad format case\n+        if (tailOfflineTime != -1) {\n+          if (tailOfflineTime <= onlineTimestamps.get(0)) {\n+            break;\n+          }\n+          offlineTimestamps.add(0, tailOfflineTime);\n+        }\n+      }\n+    }\n+\n+    // At this point, onlineTimestamps contains at least 1 timestamp that's before maintenance mode;\n+    // offlineTimestamps contains 0+ timestamp that's > the first online timestamp.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 163}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMjE0MjY4", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-503214268", "createdAt": "2020-10-06T17:47:53Z", "commit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzo1ODo1MFrOHdTkPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxOTo1NTowNVrOHdXpFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MTMyNg==", "bodyText": "I suggest making it explicit.\nOne method getAllLiveInstances(), another one something like getActiveLiveInstance().\nIn the future, the later one can be extended to return different lists according to the conditions (maintenance mode is the first example).", "url": "https://github.com/apache/helix/pull/1413#discussion_r500491326", "createdAt": "2020-10-06T17:58:50Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +471,30 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n    * @return\n    */\n   public Map<String, LiveInstance> getLiveInstances() {\n+    return getLiveInstances(true);\n+  }\n+\n+  /**\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n+   * @param excludeTimeoutInstances - Only effective during maintenance mode. If true, filter out\n+   *                                instances that are timed-out during maintenance mode; instances\n+   *                                are timed-out if they have been offline for a while before going\n+   *                                live during maintenance mode.\n+   * @return\n+   */\n+  public Map<String, LiveInstance> getLiveInstances(boolean excludeTimeoutInstances) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNTc3OQ==", "bodyText": "Just put the logic into a non-static method getOnlineTimestamp()? Which directly returns List.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500505779", "createdAt": "2020-10-06T18:22:03Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNzU0Nw==", "bodyText": "nit, I think you need all the online timestamp before the _maintenanceSignal create time. Otherwise, you don't need this list. So the comment is not accurate.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500507547", "createdAt": "2020-10-06T18:24:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxMDk5NQ==", "bodyText": "I agree these nodes shall be excluded. But we are actually doing this for a different reason.\nNote that the logic is a node is offline for a long time and back online during the M mode. In this case, the new node previous offline time is 0. So it is definitely timed out. So we don't need this logic here. The later logic shall be able to cover this case.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500510995", "createdAt": "2020-10-06T18:29:53Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxMTkzOA==", "bodyText": "As I mentioned above, the current logic is too complicated than it needs to be. For a newly added node, the offline time is timestamp 0. So it is definitely timeout.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500511938", "createdAt": "2020-10-06T18:31:24Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +782,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {\n+      // Node is a new node in this maintenance mode, no need to time out since no partitions are\n+      // assigned to it\n+      return false;\n+    }\n+\n+    // Parse offline timestamps from offline list\n+    List<Long> offlineTimestamps = new ArrayList<>();\n+    List<String> historyOfflineList = history.getOffline();\n+    if (historyOfflineList != null) {\n+      long tailOfflineTime;\n+      for (int i = historyOfflineList.size() - 1; i >= 0; i--) {\n+        tailOfflineTime =\n+            ParticipantHistory.parseHistoryDateStringToLong(historyOfflineList.get(i));\n+        // Ignore bad format case\n+        if (tailOfflineTime != -1) {\n+          if (tailOfflineTime <= onlineTimestamps.get(0)) {\n+            break;\n+          }\n+          offlineTimestamps.add(0, tailOfflineTime);\n+        }\n+      }\n+    }\n+\n+    // At this point, onlineTimestamps contains at least 1 timestamp that's before maintenance mode;\n+    // offlineTimestamps contains 0+ timestamp that's > the first online timestamp.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMjM3Mg=="}, "originalCommit": {"oid": "ceff69d774c1c2a9149ae090e231df8c499ff125"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxMzEwNQ==", "bodyText": "Same here, getOfflineTimestamp", "url": "https://github.com/apache/helix/pull/1413#discussion_r500513105", "createdAt": "2020-10-06T18:33:15Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {\n+      // Node is a new node in this maintenance mode, no need to time out since no partitions are\n+      // assigned to it\n+      return false;\n+    }\n+\n+    // Parse offline timestamps from offline list\n+    List<Long> offlineTimestamps = new ArrayList<>();\n+    List<String> historyOfflineList = history.getOffline();\n+    if (historyOfflineList != null) {\n+      long tailOfflineTime;\n+      for (int i = historyOfflineList.size() - 1; i >= 0; i--) {\n+        tailOfflineTime =\n+            ParticipantHistory.historyDateStringToLong(historyOfflineList.get(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU0NjA3NQ==", "bodyText": "nit, the logic might be clearer for the readers if you just subtract the list and then read the last one. Otherwise, you have multiple lists with different orders. And get(0) in the following code could be a mystery for others.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500546075", "createdAt": "2020-10-06T19:32:00Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MTM5OQ==", "bodyText": "I guess this one is corresponding to the _liveInstanceSnapshotForMaintenance check. I prefer not to add this.\n\nIf the cache update fails due to ZK issue, then we might have the _liveInstanceSnapshotForMaintenance updated but _timedOutInstanceDuringMaintenance is not fully calculated.\nThe performance enhancement of using this map is not significant. Let's ensure it works fine first.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500551399", "createdAt": "2020-10-06T19:42:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -299,6 +307,40 @@ private void updateMaintenanceInfo(final HelixDataAccessor accessor) {\n     // The following flag is to guarantee that there's only one update per pineline run because we\n     // check for whether maintenance recovery could happen twice every pipeline\n     _hasMaintenanceSignalChanged = false;\n+\n+    // If maintenance mode has exited, clear cached timed-out nodes\n+    if (!_isMaintenanceModeEnabled) {\n+      _timedOutInstanceDuringMaintenance.clear();\n+      _liveInstanceSnapshotForMaintenance.clear();\n+    }\n+  }\n+\n+  private void timeoutNodesDuringMaintenance(final HelixDataAccessor accessor) {\n+    // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+    // for timed-out nodes\n+    long timeOutWindow = -1;\n+    if (_clusterConfig != null) {\n+      timeOutWindow = _clusterConfig.getOfflineNodeTimeOutForMaintenanceMode();\n+    }\n+    if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+      for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+        // 1. Check timed-out cache and don't do repeated work;\n+        // 2. Check for nodes that didn't exist in the last iteration, because it has been checked;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MzU4NA==", "bodyText": "Please be careful about the cache update order. refreshLiveInstances is called before updateMaintenanceInfo. So I guess this map never works as expected. As I suggested, just remove this map to reduce the potential risk. ROI is low.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500553584", "createdAt": "2020-10-06T19:46:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -253,6 +257,10 @@ private void refreshIdealState(final HelixDataAccessor accessor,\n   private void refreshLiveInstances(final HelixDataAccessor accessor,\n       Set<HelixConstants.ChangeType> refreshedType) {\n     if (_propertyDataChangedMap.get(HelixConstants.ChangeType.LIVE_INSTANCE).getAndSet(false)) {\n+      // Keep a snapshot of old live instances for maintenance mode\n+      if (isMaintenanceModeEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1NDYzNA==", "bodyText": "To reduce the implicit dependencies between the refresh/update methods, please input the isMaintenanceModeEnabled as a parameter. So the caller is more likely to pass the refreshed value.\nOverall, we shall reduce referring to the private field directly to decouple methods and prevent potential bugs.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500554634", "createdAt": "2020-10-06T19:48:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -299,6 +307,40 @@ private void updateMaintenanceInfo(final HelixDataAccessor accessor) {\n     // The following flag is to guarantee that there's only one update per pineline run because we\n     // check for whether maintenance recovery could happen twice every pipeline\n     _hasMaintenanceSignalChanged = false;\n+\n+    // If maintenance mode has exited, clear cached timed-out nodes\n+    if (!_isMaintenanceModeEnabled) {\n+      _timedOutInstanceDuringMaintenance.clear();\n+      _liveInstanceSnapshotForMaintenance.clear();\n+    }\n+  }\n+\n+  private void timeoutNodesDuringMaintenance(final HelixDataAccessor accessor) {\n+    // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+    // for timed-out nodes\n+    long timeOutWindow = -1;\n+    if (_clusterConfig != null) {\n+      timeOutWindow = _clusterConfig.getOfflineNodeTimeOutForMaintenanceMode();\n+    }\n+    if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1NzY3Mg==", "bodyText": "As commented above, these 2 methods can be private if we directly return the lists of Long", "url": "https://github.com/apache/helix/pull/1413#discussion_r500557672", "createdAt": "2020-10-06T19:54:17Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +183,73 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /**\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  public static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /**\n+   * Parses a history date in millisecond to string.\n+   */\n+  public static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1ODEwMQ==", "bodyText": "nit, warning in these abnormal case for debugging.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500558101", "createdAt": "2020-10-06T19:55:05Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +183,73 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /**\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  public static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /**\n+   * Parses a history date in millisecond to string.\n+   */\n+  public static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {\n+    sessionHistoryString = sessionHistoryString.substring(1, sessionHistoryString.length() - 1);\n+    Map<String, String> sessionHistoryMap = new HashMap<>();\n+\n+    for (String sessionHistoryKeyValuePair : sessionHistoryString.split(\", \")) {\n+      String[] keyValuePair = sessionHistoryKeyValuePair.split(\"=\");\n+      if (keyValuePair.length < 2) {\n+        continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDQ2NDM3", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-503446437", "createdAt": "2020-10-07T00:24:04Z", "commit": {"oid": "f2badf5808d5a0a86af52b38058fdc7bed7c02c4"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoyNDowNFrOHdeX3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoyNzowMVrOHdebMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODM4Mg==", "bodyText": "I think you don't need these 2 methods to be public?", "url": "https://github.com/apache/helix/pull/1413#discussion_r500668382", "createdAt": "2020-10-07T00:24:04Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -64,6 +69,20 @@ public ParticipantHistory(ZNRecord znRecord) {\n     super(znRecord);\n   }\n \n+  /**\n+   * @return The list field for HISTORY\n+   */\n+  public List<String> getHistory() {\n+    return _record.getListField(ConfigProperty.HISTORY.name());\n+  }\n+\n+  /**\n+   * @return The list field for OFFLINE\n+   */\n+  public List<String> getOffline() {\n+    return _record.getListField(ConfigProperty.OFFLINE.name());\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2badf5808d5a0a86af52b38058fdc7bed7c02c4"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODg0OA==", "bodyText": "Log the error here.", "url": "https://github.com/apache/helix/pull/1413#discussion_r500668848", "createdAt": "2020-10-07T00:25:32Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +185,99 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /*\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  private static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /*\n+   * Parses a history date in millisecond to string.\n+   */\n+  private static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {\n+    sessionHistoryString = sessionHistoryString.substring(1, sessionHistoryString.length() - 1);\n+    Map<String, String> sessionHistoryMap = new HashMap<>();\n+\n+    for (String sessionHistoryKeyValuePair : sessionHistoryString.split(\", \")) {\n+      String[] keyValuePair = sessionHistoryKeyValuePair.split(\"=\");\n+      if (keyValuePair.length < 2) {\n+        LOG.warn(\"Ignore key value pair while parsing session history due to missing '=': \" +\n+            sessionHistoryKeyValuePair);\n+        continue;\n+      }\n+      sessionHistoryMap.put(keyValuePair[0], keyValuePair[1]);\n+    }\n+\n+    return sessionHistoryMap;\n+  }\n+\n+  /*\n+   * Take a string session history entry and extract the TIME field out of it. Return -1 if the TIME\n+   * field doesn't exist or if the TIME field cannot be parsed to a long.\n+   */\n+  private static long extractTimeFromSessionHistoryString(String sessionHistoryString) {\n+    Map<String, String> sessionHistoryMap = parseSessionHistoryStringToMap(sessionHistoryString);\n+    if (!sessionHistoryMap.containsKey(ConfigProperty.TIME.name())) {\n+      return -1;\n+    }\n+    try {\n+      return Long.parseLong(sessionHistoryMap.get(ConfigProperty.TIME.name()));\n+    } catch (NumberFormatException e) {\n+      return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2badf5808d5a0a86af52b38058fdc7bed7c02c4"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2OTIzNQ==", "bodyText": "Shall we just call it getOnlineTimestampsAsMilliseconds?", "url": "https://github.com/apache/helix/pull/1413#discussion_r500669235", "createdAt": "2020-10-07T00:27:01Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +185,99 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /*\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  private static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /*\n+   * Parses a history date in millisecond to string.\n+   */\n+  private static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {\n+    sessionHistoryString = sessionHistoryString.substring(1, sessionHistoryString.length() - 1);\n+    Map<String, String> sessionHistoryMap = new HashMap<>();\n+\n+    for (String sessionHistoryKeyValuePair : sessionHistoryString.split(\", \")) {\n+      String[] keyValuePair = sessionHistoryKeyValuePair.split(\"=\");\n+      if (keyValuePair.length < 2) {\n+        LOG.warn(\"Ignore key value pair while parsing session history due to missing '=': \" +\n+            sessionHistoryKeyValuePair);\n+        continue;\n+      }\n+      sessionHistoryMap.put(keyValuePair[0], keyValuePair[1]);\n+    }\n+\n+    return sessionHistoryMap;\n+  }\n+\n+  /*\n+   * Take a string session history entry and extract the TIME field out of it. Return -1 if the TIME\n+   * field doesn't exist or if the TIME field cannot be parsed to a long.\n+   */\n+  private static long extractTimeFromSessionHistoryString(String sessionHistoryString) {\n+    Map<String, String> sessionHistoryMap = parseSessionHistoryStringToMap(sessionHistoryString);\n+    if (!sessionHistoryMap.containsKey(ConfigProperty.TIME.name())) {\n+      return -1;\n+    }\n+    try {\n+      return Long.parseLong(sessionHistoryMap.get(ConfigProperty.TIME.name()));\n+    } catch (NumberFormatException e) {\n+      return -1;\n+    }\n+  }\n+\n+  /**\n+   * For each entry in History, return its millisecond timestamp; for timestamps that cannot be\n+   * parsed, skip them.\n+   */\n+  public List<Long> getHistoryTimestampsAsMilliseconds() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2badf5808d5a0a86af52b38058fdc7bed7c02c4"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTQyMzM4", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-503542338", "createdAt": "2020-10-07T05:50:03Z", "commit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1MDowM1rOHdjeow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1MDowM1rOHdjeow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1MjAzNQ==", "bodyText": "Any specific reason we do not put this into refreshLiveInstances()?", "url": "https://github.com/apache/helix/pull/1413#discussion_r500752035", "createdAt": "2020-10-07T05:50:03Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -333,6 +370,7 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     _stateModelDefinitionCache.refresh(accessor);\n     _clusterConstraintsCache.refresh(accessor);\n     updateMaintenanceInfo(accessor);\n+    timeoutNodesDuringMaintenance(accessor, _clusterConfig, _isMaintenanceModeEnabled);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTQ0Mzc0", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-503544374", "createdAt": "2020-10-07T05:54:57Z", "commit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1NDo1N1rOHdjlaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1NDo1N1rOHdjlaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1Mzc3MQ==", "bodyText": "These two methods (getLiveInstances() and getAllLiveInstances() are very confusing to each other.  We would need a better naming here.  We have four type of instances:  All Instances, Live Instances, enabled/disabled Instances, timeout-ed instances.  We have a method called getEnabledLiveInstances(), maybe we can name this new method getNonTimeoutLiveInstances()?", "url": "https://github.com/apache/helix/pull/1413#discussion_r500753771", "createdAt": "2020-10-07T05:54:57Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +466,37 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n-   * @return\n+   * Returns the LiveInstances for each of the instances that are currently up and running,\n+   * excluding the instances that are considered offline during maintenance mode. Instances\n+   * are timed-out if they have been offline for a while before going live during maintenance mode.\n    */\n   public Map<String, LiveInstance> getLiveInstances() {\n+    return getLiveInstances(true);\n+  }\n+\n+  /**\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n+   */\n+  public Map<String, LiveInstance> getAllLiveInstances() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTQ0ODMz", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-503544833", "createdAt": "2020-10-07T05:56:01Z", "commit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1NjowMVrOHdjm8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1NjowMVrOHdjm8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NDE2MQ==", "bodyText": "minor:  isInstanceTimeout... -> shouldInstanceTimeout...", "url": "https://github.com/apache/helix/pull/1413#discussion_r500754161", "createdAt": "2020-10-07T05:56:01Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +790,58 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTQ1NDEw", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-503545410", "createdAt": "2020-10-07T05:57:26Z", "commit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1NzoyNlrOHdjo0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1NzoyNlrOHdjo0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NDY0Mg==", "bodyText": "Let us follow the name convention of another method, such as sessionHistoryStringToMap()?", "url": "https://github.com/apache/helix/pull/1413#discussion_r500754642", "createdAt": "2020-10-07T05:57:26Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +185,101 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /*\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  private static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /*\n+   * Parses a history date in millisecond to string.\n+   */\n+  private static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTQ1NjAw", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-503545600", "createdAt": "2020-10-07T05:57:53Z", "commit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1Nzo1M1rOHdjpXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1Nzo1M1rOHdjpXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NDc4Mg==", "bodyText": "getTimeFromSessionHistory", "url": "https://github.com/apache/helix/pull/1413#discussion_r500754782", "createdAt": "2020-10-07T05:57:53Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +185,101 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /*\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  private static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /*\n+   * Parses a history date in millisecond to string.\n+   */\n+  private static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {\n+    sessionHistoryString = sessionHistoryString.substring(1, sessionHistoryString.length() - 1);\n+    Map<String, String> sessionHistoryMap = new HashMap<>();\n+\n+    for (String sessionHistoryKeyValuePair : sessionHistoryString.split(\", \")) {\n+      String[] keyValuePair = sessionHistoryKeyValuePair.split(\"=\");\n+      if (keyValuePair.length < 2) {\n+        LOG.warn(\"Ignore key value pair while parsing session history due to missing '=': \" +\n+            sessionHistoryKeyValuePair);\n+        continue;\n+      }\n+      sessionHistoryMap.put(keyValuePair[0], keyValuePair[1]);\n+    }\n+\n+    return sessionHistoryMap;\n+  }\n+\n+  /*\n+   * Take a string session history entry and extract the TIME field out of it. Return -1 if the TIME\n+   * field doesn't exist or if the TIME field cannot be parsed to a long.\n+   */\n+  private static long extractTimeFromSessionHistoryString(String sessionHistoryString) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTQ2NDc0", "url": "https://github.com/apache/helix/pull/1413#pullrequestreview-503546474", "createdAt": "2020-10-07T05:59:59Z", "commit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1OTo1OVrOHdjsDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1OTo1OVrOHdjsDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NTQ2OA==", "bodyText": "Do we have an end-to-end integration test here, such as verify that a timeout-ed instance during maintenance mode will not get assigned any partitions (received any state transition messages)?", "url": "https://github.com/apache/helix/pull/1413#discussion_r500755468", "createdAt": "2020-10-07T05:59:59Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/test/java/org/apache/helix/integration/controller/TestOfflineNodeTimeoutDuringMaintenanceMode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.apache.helix.integration.controller;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf4d8ce322c9cb1861539692a046d74464fea49"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ea7fc885a672f6db965bb33e0472c20821f2aa7", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/8ea7fc885a672f6db965bb33e0472c20821f2aa7", "committedDate": "2020-10-07T18:02:08Z", "message": "Feature: Offline Node Timeout During Maintenance Mode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ecc7eb5a8d0d9758cc804f5df3b9e8d1a4e678b", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/0ecc7eb5a8d0d9758cc804f5df3b9e8d1a4e678b", "committedDate": "2020-10-07T18:02:08Z", "message": "Format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4fc5897a25783bf6f4a85f90064be76828e1484", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/a4fc5897a25783bf6f4a85f90064be76828e1484", "committedDate": "2020-10-07T18:02:08Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79064498a04261c2ad50dd81e3a2edfd4e826216", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/79064498a04261c2ad50dd81e3a2edfd4e826216", "committedDate": "2020-10-07T18:02:08Z", "message": "Attempt to stabilize tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc7c3e8d93def39e9b250d52c97747c824e4efcc", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/fc7c3e8d93def39e9b250d52c97747c824e4efcc", "committedDate": "2020-10-07T18:02:08Z", "message": "Fix broken mock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d6889881589c3d71fe355aa4c90a8204b376a32", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/9d6889881589c3d71fe355aa4c90a8204b376a32", "committedDate": "2020-10-07T18:02:08Z", "message": "New algorithm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e73f8c4533006b3435e3ae6c981c25172edf896f", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/e73f8c4533006b3435e3ae6c981c25172edf896f", "committedDate": "2020-10-07T18:02:08Z", "message": "Added additional subtest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3282b63fbedc0a36b7bdd3e5d2b9fd144f3ae634", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/3282b63fbedc0a36b7bdd3e5d2b9fd144f3ae634", "committedDate": "2020-10-07T18:02:09Z", "message": "Add new instance subtest case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecea2bdbc2d530ef1e4ad4a6314c315f5cdb2ebe", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/ecea2bdbc2d530ef1e4ad4a6314c315f5cdb2ebe", "committedDate": "2020-10-07T18:02:09Z", "message": "Renaming changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdcf0a5309410bbe7ffdc8da9460d9b4e3bd6fb1", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/bdcf0a5309410bbe7ffdc8da9460d9b4e3bd6fb1", "committedDate": "2020-10-07T18:02:09Z", "message": "Change default behavior"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b7b2cef4aef1dcc0a913f9bfbd5f8a1b18b8fe6", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/0b7b2cef4aef1dcc0a913f9bfbd5f8a1b18b8fe6", "committedDate": "2020-10-07T18:02:09Z", "message": "Clear liveinstance snapshot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1342619f0cb603fcb3029b250f12b235d9d3ecc1", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/1342619f0cb603fcb3029b250f12b235d9d3ecc1", "committedDate": "2020-10-07T18:02:09Z", "message": "Remove unnecessary snapshot, simplify algo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1448e99dd2dab0495fb70f803b431b0d3d4baf4", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/c1448e99dd2dab0495fb70f803b431b0d3d4baf4", "committedDate": "2020-10-07T18:02:09Z", "message": "Add 1 line to javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d649a17a056f73049db89352e5ef0c4c7cc331d2", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/d649a17a056f73049db89352e5ef0c4c7cc331d2", "committedDate": "2020-10-07T18:02:09Z", "message": "reduce diff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d5e77a8270be4bf79c837dd732a25b10eed8796", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/0d5e77a8270be4bf79c837dd732a25b10eed8796", "committedDate": "2020-10-07T18:02:09Z", "message": "Add log line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5775343d450cc39eb3aeba05b1d2e43e85039df7", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/5775343d450cc39eb3aeba05b1d2e43e85039df7", "committedDate": "2020-10-07T18:02:09Z", "message": "Renames"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1b29ed8ce50a6cc1377e81e34afaad5858649232", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/1b29ed8ce50a6cc1377e81e34afaad5858649232", "committedDate": "2020-10-07T16:58:46Z", "message": "Renames"}, "afterCommit": {"oid": "5775343d450cc39eb3aeba05b1d2e43e85039df7", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/5775343d450cc39eb3aeba05b1d2e43e85039df7", "committedDate": "2020-10-07T18:02:09Z", "message": "Renames"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7f8ee55777fcfbffb8be7e090cac3f867e03e8f", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/f7f8ee55777fcfbffb8be7e090cac3f867e03e8f", "committedDate": "2020-10-09T01:51:37Z", "message": "Function rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58888ca142c3233615b207fc70d6d793cc40cb6a", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/58888ca142c3233615b207fc70d6d793cc40cb6a", "committedDate": "2020-10-09T22:28:35Z", "message": "Changed integration test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4296, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}