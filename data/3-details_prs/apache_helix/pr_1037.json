{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0Nzg0OTUw", "number": 1037, "title": "Add ExcessiveTopStateResolver to gracefully fix the double-masters situation.", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\n#1028\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nAlthough the rebalancer will fix the additional master eventually, the default operations are arbitrary and it may cause an older master to survive. This may cause serious application logic issues since many applications require the master to have the latest data.\nWith this state resolver, the rebalancer will change the default behavior to reset all the master replicas so as to ensure the remaining one is the youngest one. Then the double-masters situation is gracefully resolved.\nTests\n\n The following tests are written for this issue:\n\nTestAbnormalStatesResolver.testExcessiveTopStateResolver()\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\nN/A, the newly added logic is only used in the new test case. The other tests won't touch the new logic.\nWill run the whole test before merging the branch to master.\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation (Optional)\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-05-28T23:10:22Z", "url": "https://github.com/apache/helix/pull/1037", "merged": true, "mergeCommit": {"oid": "f8bc5fd15976a9820d92fa5818292aa1f3c13589"}, "closed": true, "closedAt": "2020-06-04T18:50:24Z", "author": {"login": "jiajunwang"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcl2HTkAH2gAyNDI0Nzg0OTUwOjhkMGIwYzA5MWRlNWZlOTA4Mjg2ODllOTk0NDg0N2VhZmMwMGUzZDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoCoSWAH2gAyNDI0Nzg0OTUwOmM0NzhlYWU5ZDNkNjhhOGY3NDJkZjAzOWQwMmJiMjRlZjI0NmZlZWM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/8d0b0c091de5fe90828689e9944847eafc00e3d1", "committedDate": "2020-05-28T23:04:08Z", "message": "Add ExcessiveTopStateResolver to gracefully fix the double-masters situation.\n\nAlthough the rebalancer will fix the additional master eventually, the default operations are arbitrary and it may cause an older master to survive. This may cause serious application logic issues since many applications require the master to have the latest data.\nWith this state resolver, the rebalancer will change the default behavior to reset all the master replicas so as to ensure the remaining one is the youngest one. Then the double-masters situation is gracefully resolved."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTUwNjI1", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421150625", "createdAt": "2020-05-29T17:29:10Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoyOToxMFrOGcl2Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoyOToxMFrOGcl2Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMzQ0Mg==", "bodyText": "Use a constant instead of 5000? TestHelper has a constant value built-in.", "url": "https://github.com/apache/helix/pull/1037#discussion_r432633442", "createdAt": "2020-05-29T17:29:10Z", "author": {"login": "narendly"}, "path": "helix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAbnormalStatesResolver.java", "diffHunk": "@@ -64,4 +80,101 @@ public void testConfigureResolver() {\n     clusterConfig.setAbnormalStateResolverMap(Collections.emptyMap());\n     configAccessor.setClusterConfig(CLUSTER_NAME, clusterConfig);\n   }\n+\n+  @Test(dependsOnMethods = \"testConfigureResolver\")\n+  public void testExcessiveTopStateResolver() {\n+    BestPossibleExternalViewVerifier verifier =\n+        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkClient(_gZkClient).build();\n+    Assert.assertTrue(verifier.verify(5000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTUxMzc0", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421151374", "createdAt": "2020-05-29T17:30:13Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozMDoxM1rOGcl4sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozMDoxM1rOGcl4sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNDAzNA==", "bodyText": "gracefully\nAlso, it would be great if you could explain what the issue is instead of calling a \"double-topstates issue\" as this might not make much sense for readers without context.", "url": "https://github.com/apache/helix/pull/1037#discussion_r432634034", "createdAt": "2020-05-29T17:30:13Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTUyNDY4", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421152468", "createdAt": "2020-05-29T17:31:53Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozMTo1M1rOGcl8Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozMTo1M1rOGcl8Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNDk1OA==", "bodyText": "I think what you want to say here is:\n\"Note that Helix controller will eventually correct the fact that there are two top state replicas, but it may not happen immediately. This resolver exists to ensure that such cases are resolved right away.\"", "url": "https://github.com/apache/helix/pull/1037#discussion_r432634958", "createdAt": "2020-05-29T17:31:53Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTUzNTEy", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421153512", "createdAt": "2020-05-29T17:33:26Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozMzoyNlrOGcl_XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozMzoyNlrOGcl_XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNTc0MA==", "bodyText": "checkCurrentStates I think is a better name for this method. or isCurrentStateValid\nor checkForCurrentStateViolation()", "url": "https://github.com/apache/helix/pull/1037#discussion_r432635740", "createdAt": "2020-05-29T17:33:26Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTU0OTcz", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421154973", "createdAt": "2020-05-29T17:35:47Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozNTo0N1rOGcmDrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozNTo0N1rOGcmDrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNjg0Nw==", "bodyText": "computeCorrectedAssignment is clearer?", "url": "https://github.com/apache/helix/pull/1037#discussion_r432636847", "createdAt": "2020-05-29T17:35:47Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTU2MTMz", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421156133", "createdAt": "2020-05-29T17:37:33Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozNzozM1rOGcmHGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozNzozM1rOGcmHGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNzcyMw==", "bodyText": "I wonder if this would be too much of an overhead for each pipeline run?\nDo you think it would be better to try to come up with a way to cache currentState mappings and compare diffs (going from O(n) -> O(1) check by storing results across pipelines).\nFor heavy users, this O(n) computation might become a significant bottleneck if done every pipeline.", "url": "https://github.com/apache/helix/pull/1037#discussion_r432637723", "createdAt": "2020-05-29T17:37:33Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTU3MTk1", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421157195", "createdAt": "2020-05-29T17:39:08Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozOTowOFrOGcmKQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozOTowOFrOGcmKQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzODUyOA==", "bodyText": "recoverMap -> correctedStateMap?", "url": "https://github.com/apache/helix/pull/1037#discussion_r432638528", "createdAt": "2020-05-29T17:39:08Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTU3NzYy", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421157762", "createdAt": "2020-05-29T17:39:57Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozOTo1N1rOGcmL_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozOTo1N1rOGcmL_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzODk3NQ==", "bodyText": "What is the potential data issue? It would be good to explain this somewhere.", "url": "https://github.com/apache/helix/pull/1037#discussion_r432638975", "createdAt": "2020-05-29T17:39:57Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);\n+    String recoveryState = stateModelDef\n+        .getNextStateForTransition(stateModelDef.getTopState(), stateModelDef.getInitialState());\n+\n+    // 1. We have to reset the expected top state replica host if it is hosting the top state\n+    // replica. Otherwise, the potential data issue will never be fixed there.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTU4ODk5", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421158899", "createdAt": "2020-05-29T17:41:39Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo0MTozOVrOGcmPkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo0MTozOVrOGcmPkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzOTg4OQ==", "bodyText": "no need for \"the\" in the variable name", "url": "https://github.com/apache/helix/pull/1037#discussion_r432639889", "createdAt": "2020-05-29T17:41:39Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);\n+    String recoveryState = stateModelDef\n+        .getNextStateForTransition(stateModelDef.getTopState(), stateModelDef.getInitialState());\n+\n+    // 1. We have to reset the expected top state replica host if it is hosting the top state\n+    // replica. Otherwise, the potential data issue will never be fixed there.\n+    if (preferenceList != null && !preferenceList.isEmpty()) {\n+      String expectedTopStateHost = preferenceList.get(0);\n+      if (recoverMap.get(expectedTopStateHost).equals(stateModelDef.getTopState())) {\n+        recoverMap.put(expectedTopStateHost, recoveryState);\n+      }\n+    }\n+\n+    // 2. To minimize the impact of the resolution, we want to reserve one top state replica even\n+    // during the recovery process.\n+    boolean hasReservedTheTopState = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTYxNjEz", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421161613", "createdAt": "2020-05-29T17:45:41Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo0NTo0MVrOGcmYAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo0NTo0MVrOGcmYAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MjA0OQ==", "bodyText": "You mean the rebalancer will continue to run this for all N resources until everything has been resolved?\nOr will it check for each resource, say, resource N, I check isValid() and correctCurrentStates() until isValid() returns true?\nWhat I am not too unsure about is what you said about \"new current state\" being \"still invalid\". Is it possible that the result is invalid after correction?", "url": "https://github.com/apache/helix/pull/1037#discussion_r432642049", "createdAt": "2020-05-29T17:45:41Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);\n+    String recoveryState = stateModelDef\n+        .getNextStateForTransition(stateModelDef.getTopState(), stateModelDef.getInitialState());\n+\n+    // 1. We have to reset the expected top state replica host if it is hosting the top state\n+    // replica. Otherwise, the potential data issue will never be fixed there.\n+    if (preferenceList != null && !preferenceList.isEmpty()) {\n+      String expectedTopStateHost = preferenceList.get(0);\n+      if (recoverMap.get(expectedTopStateHost).equals(stateModelDef.getTopState())) {\n+        recoverMap.put(expectedTopStateHost, recoveryState);\n+      }\n+    }\n+\n+    // 2. To minimize the impact of the resolution, we want to reserve one top state replica even\n+    // during the recovery process.\n+    boolean hasReservedTheTopState = false;\n+    for (String instance : recoverMap.keySet()) {\n+      if (recoverMap.get(instance).equals(stateModelDef.getTopState())) {\n+        if (hasReservedTheTopState) {\n+          recoverMap.put(instance, recoveryState);\n+        } else {\n+          hasReservedTheTopState = true;\n+        }\n+      }\n+    }\n+    // Here's what we expect to happen next:\n+    // 1. The partition assignment is changed to the proposed recovery state. Or it may be halfway\n+    // there.\n+    // 2. If the new current state is still invalid, then continue fixing it with the same logic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjgzMTkw", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-421283190", "createdAt": "2020-05-29T20:58:26Z", "commit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo1ODoyNlrOGcr3Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo1ODoyNlrOGcr3Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTk2Mg==", "bodyText": "I would suggest to put more comments here. I can understand the reason that leave a top state for the host not for first in preference list can help reduce the resetting work. But may be other people may confused with your statement in description that resetting all top state.", "url": "https://github.com/apache/helix/pull/1037#discussion_r432731962", "createdAt": "2020-05-29T20:58:26Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);\n+    String recoveryState = stateModelDef\n+        .getNextStateForTransition(stateModelDef.getTopState(), stateModelDef.getInitialState());\n+\n+    // 1. We have to reset the expected top state replica host if it is hosting the top state\n+    // replica. Otherwise, the potential data issue will never be fixed there.\n+    if (preferenceList != null && !preferenceList.isEmpty()) {\n+      String expectedTopStateHost = preferenceList.get(0);\n+      if (recoverMap.get(expectedTopStateHost).equals(stateModelDef.getTopState())) {\n+        recoverMap.put(expectedTopStateHost, recoveryState);\n+      }\n+    }\n+\n+    // 2. To minimize the impact of the resolution, we want to reserve one top state replica even", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f79a5bf21be94a945edee44faee5b69e2a2e234c", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/f79a5bf21be94a945edee44faee5b69e2a2e234c", "committedDate": "2020-05-29T23:49:08Z", "message": "Address comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc", "committedDate": "2020-05-30T00:18:56Z", "message": "Address more comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODQ1NjM1", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-423845635", "createdAt": "2020-06-03T19:03:40Z", "commit": {"oid": "4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxOTowMzo0MFrOGepcnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxOTowMzo0MFrOGepcnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4OTUzMw==", "bodyText": "Just a question. Now we only support single top state. Are we gonna support user defined number of top states? Say not all replicas are top state but 2 masters or something.\nWhy I am asking this is because  maybe sometimes there could be non-top state requires to be resolved as well.", "url": "https://github.com/apache/helix/pull/1037#discussion_r434789533", "createdAt": "2020-06-03T19:03:40Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that gracefully fixes the abnormality of excessive top states for\n+ * single-topstate state model. For example, two replcias of a MasterSlave partition are assigned\n+ * with the Master state at the same time. This could be caused by a network partitioning or the\n+ * other unexpected issues.\n+ *\n+ * The resolver checks for the abnormality and computes recovery assignment which triggers the\n+ * rebalancer to eventually reset all the top state replias for once. After the resets, only one\n+ * replica will be assigned the top state.\n+ *\n+ * Note that without using this resolver, the regular Helix rebalance pipeline also removes the\n+ * excessive top state replicas. However, the default logic does not force resetting ALL the top\n+ * state replicas. Since the multiple top states situation may break application data, the default\n+ * resolution won't be enough to fix the potential problem.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean checkCurrentStates(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTQ0NjQy", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-424144642", "createdAt": "2020-06-04T06:45:19Z", "commit": {"oid": "4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTYyOTQ2", "url": "https://github.com/apache/helix/pull/1037#pullrequestreview-424162946", "createdAt": "2020-06-04T07:16:05Z", "commit": {"oid": "4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzoxNjowNVrOGe4yGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzo0ODozMVrOGe510g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA0MDc5Mg==", "bodyText": "More than 1 top state?\n\"a single top state model\"?", "url": "https://github.com/apache/helix/pull/1037#discussion_r435040792", "createdAt": "2020-06-04T07:16:05Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that gracefully fixes the abnormality of excessive top states for\n+ * single-topstate state model. For example, two replcias of a MasterSlave partition are assigned\n+ * with the Master state at the same time. This could be caused by a network partitioning or the\n+ * other unexpected issues.\n+ *\n+ * The resolver checks for the abnormality and computes recovery assignment which triggers the\n+ * rebalancer to eventually reset all the top state replias for once. After the resets, only one\n+ * replica will be assigned the top state.\n+ *\n+ * Note that without using this resolver, the regular Helix rebalance pipeline also removes the\n+ * excessive top state replicas. However, the default logic does not force resetting ALL the top\n+ * state replicas. Since the multiple top states situation may break application data, the default\n+ * resolution won't be enough to fix the potential problem.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1ODEzMA==", "bodyText": "@jiajunwang In CurrentStateOutput, could we add a top state counter map so we could cache the top state counter, like below? Then we could avoid that stream filter computation? Tradeoff is we need a bit more memory for the cache. But most of them are just references.\n  public void setCurrentState(String resourceName, Partition partition, String instanceName,\n      String state) {\n    (...... current code ......)\n    // Counter number of top state replicas for a single top state model. \n    if (state.equals(stateModelDef.getTopState())) {\n      Map<String, Integer> counterMap =\n          _topStateCounter.computeIfAbsent(resourceName, k -> new HashMap<>())\n              .computeIfAbsent(partition, k -> new HashMap<>());\n      counterMap.put(state, counterMap.getOrDefault(state, 0) + 1);\n    }\n  }\n\nNot sure if we need to optimize this. Maybe you could test it. It seems for this part, the time complexity is down from O(n) to O(1), but I am not sure what the actual time saving is, considering the whole pipeline. If the whole pipeline complexity is O(N^2), with this optimization, it is O(N), that may help. If the whole pipeline is O(2 * N), with this optimization, still O(N).", "url": "https://github.com/apache/helix/pull/1037#discussion_r435058130", "createdAt": "2020-06-04T07:48:31Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNzcyMw=="}, "originalCommit": {"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c478eae9d3d68a8f742df039d02bb24ef246feec", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/c478eae9d3d68a8f742df039d02bb24ef246feec", "committedDate": "2020-06-04T18:46:52Z", "message": "Address comments."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4412, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}