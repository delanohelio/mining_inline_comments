{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5Njk1NDQ5", "number": 1564, "title": "Implement Helix lock priority and notification", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixed #1563\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nCurrent version of Helix lock does not support priority or preemption, meaning that if a client acquires a lock, no other client can grab it until it's timed out or released. This restricts the usage of Helix lock. In many occasions, priority and preemption is needed for lock, and preferably, when the lower priority client is preempted, it could be notified and given some time to bring the system back to stable state, e.g. do some rollback, etc.\nIn this PR, we define a few concepts of the lock, like priority, different timeout, and whether the lock is forceful. These parameters of a lock will determine how Helix would handle the acquire request.\nWe also leverage Zookeeper to perform the notification and client would need to implement the cleanup callback if it is preempted.\nTests\n\n\n The following tests are written for this issue:\nTestZKHelixNonblockingLockWithPriority\n\n\n The following is the result of the \"mvn test\" command on the appropriate module:\nhelix-core:\n[INFO] Tests run: 1253, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5,070.423 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 1253, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:24 h\n[INFO] Finished at: 2020-12-14T13:37:09-08:00\n[INFO] ------------------------------------------------------------------------\n\n\nhelix-rest:\n[INFO] Tests run: 171, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 239.077 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 171, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  04:03 min\n[INFO] Finished at: 2020-12-14T12:19:14-08:00\n[INFO] -------------------------------------------\n\nIn case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCommits\n\nMy commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\nMy diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-11-30T17:22:04Z", "url": "https://github.com/apache/helix/pull/1564", "merged": true, "mergeCommit": {"oid": "94758c833a37210ca51db7bf8c52a3b3dadf79d7"}, "closed": true, "closedAt": "2020-12-14T21:59:27Z", "author": {"login": "zhangmeng916"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdhq3tgABqjQwNTM2ODYzOTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmLfg0ABqjQxMTExMjg4MjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "181da2a87d051c9c0d66e50e65976acfae5e966b", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/181da2a87d051c9c0d66e50e65976acfae5e966b", "committedDate": "2020-11-30T02:12:14Z", "message": "Implement lock priority and notification"}, "afterCommit": {"oid": "7cce68c3817e0e46feca3d34f0b09bbb8480b946", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/7cce68c3817e0e46feca3d34f0b09bbb8480b946", "committedDate": "2020-11-30T19:53:22Z", "message": "Implement lock priority and notification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMjE2Mzg0", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-542216384", "createdAt": "2020-12-01T19:14:45Z", "commit": {"oid": "7cce68c3817e0e46feca3d34f0b09bbb8480b946"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxNDo0NVrOH877wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxOTo1MFrOH88HNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1ODU2Mg==", "bodyText": "Shall we have a LockConstant class to hold them? Seemed they are too many in same class with logic code.", "url": "https://github.com/apache/helix/pull/1564#discussion_r533658562", "createdAt": "2020-12-01T19:14:45Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -30,13 +30,23 @@\n   // Default values for each attribute if there are no current values set by user\n   public static final String DEFAULT_OWNER_TEXT = \"\";\n   public static final String DEFAULT_MESSAGE_TEXT = \"\";\n-  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n+  public static final long DEFAULT_TIMEOUT_LONG = -1;\n+  public static final int DEFAULT_PRIORITY_INT = -1;\n+  public static final long DEFAULT_WAITING_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_CLEANUP_TIMEOUT_LONG = -1;\n+  public static final String DEFAULT_REQUESTOR_ID = \"\";\n+  public static final int DEFAULT_REQUESTOR_PRIORITY_INT = -1;\n+  public static final long DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cce68c3817e0e46feca3d34f0b09bbb8480b946"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTk2Nw==", "bodyText": "Usually, if we are waiting for something, we should use while to do the checks here.", "url": "https://github.com/apache/helix/pull/1564#discussion_r533659967", "createdAt": "2020-12-01T19:17:12Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,162 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.DEFAULT_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_ID;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cce68c3817e0e46feca3d34f0b09bbb8480b946"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MDU5NQ==", "bodyText": "Are we just waiting until timeout and do a check? Shall we periodically wake up and check whether the lock has been released or not?", "url": "https://github.com/apache/helix/pull/1564#discussion_r533660595", "createdAt": "2020-12-01T19:18:21Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,162 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.DEFAULT_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_ID;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {\n+      try {\n+        wait(_pendingTimeout);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cce68c3817e0e46feca3d34f0b09bbb8480b946"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MTQ5Mg==", "bodyText": "Can we leverage this handleDataChange to notify the waiting thread? Then we can use some Java internal lock.", "url": "https://github.com/apache/helix/pull/1564#discussion_r533661492", "createdAt": "2020-12-01T19:19:50Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +218,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cce68c3817e0e46feca3d34f0b09bbb8480b946"}, "originalPosition": 190}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMTMyNjI3", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-543132627", "createdAt": "2020-12-02T18:41:18Z", "commit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODo0MToxOFrOH9pBnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxOTowOTowOVrOH9qFow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NzM0MQ==", "bodyText": "Should be new LockInfo(); ?", "url": "https://github.com/apache/helix/pull/1564#discussion_r534397341", "createdAt": "2020-12-02T18:41:18Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -19,24 +19,24 @@\n  * under the License.\n  */\n \n+import org.apache.helix.lock.helix.LockConstants;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n \n \n /**\n  * Structure represents a lock node information, implemented using ZNRecord\n  */\n public class LockInfo {\n-\n-  // Default values for each attribute if there are no current values set by user\n-  public static final String DEFAULT_OWNER_TEXT = \"\";\n-  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n-  public static final long DEFAULT_TIMEOUT_LONG = -1L;\n-\n   // default lock info represents the status of a unlocked lock\n   public static final LockInfo defaultLockInfo =\n-      new LockInfo(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n-\n-  private static final String ZNODE_ID = \"LOCK\";\n+      new LockInfo(LockConstants.DEFAULT_OWNER_TEXT, LockConstants.DEFAULT_MESSAGE_TEXT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5ODM3Mw==", "bodyText": "nit, since you will go through the whole list anyway here, the \"this()\" call is not necessary.\nThe current code will set all the fields twice, which is not necessary at all.", "url": "https://github.com/apache/helix/pull/1564#discussion_r534398373", "createdAt": "2020-12-02T18:43:01Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -65,34 +77,70 @@ public LockInfo(ZNRecord znRecord) {\n     if (znRecord != null) {\n       String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n       String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n-      long timeout = znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n-      setLockInfoFields(ownerId, message, timeout);\n+      long timeout = znRecord", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5ODg1OA==", "bodyText": "this() means set all fields 2 times.\nIt could be as simple as \"_record = new ZNRecord(ZNODE_ID);\"", "url": "https://github.com/apache/helix/pull/1564#discussion_r534398858", "createdAt": "2020-12-02T18:43:52Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -65,34 +77,70 @@ public LockInfo(ZNRecord znRecord) {\n     if (znRecord != null) {\n       String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n       String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n-      long timeout = znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n-      setLockInfoFields(ownerId, message, timeout);\n+      long timeout = znRecord\n+          .getLongField(LockInfoAttribute.TIMEOUT.name(), LockConstants.DEFAULT_TIMEOUT_LONG);\n+      int priority = znRecord\n+          .getIntField(LockInfoAttribute.PRIORITY.name(), LockConstants.DEFAULT_PRIORITY_INT);\n+      long waitingTimeout = znRecord.getLongField(LockInfoAttribute.WAITING_TIMEOUT.name(),\n+          LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+      long cleanupTimeout = znRecord.getLongField(LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+          LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+      String requestorId = znRecord.getSimpleField(LockInfoAttribute.REQUESTOR_ID.name());\n+      int requestorPriority = znRecord.getIntField(LockInfoAttribute.REQUESTOR_PRIORITY.name(),\n+          LockConstants.DEFAULT_REQUESTOR_PRIORITY_INT);\n+      long requestorWaitingTimeout = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG);\n+      long requestorRequestingTimestamp = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_REQUESTING_TIMESTAMP.name(),\n+              LockConstants.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG);\n+      setLockInfoFields(ownerId, message, timeout, priority, waitingTimeout, cleanupTimeout,\n+          requestorId, requestorPriority, requestorWaitingTimeout, requestorRequestingTimestamp);\n     }\n   }\n \n   /**\n-   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data.\n    * @param ownerId value of OWNER attribute\n    * @param message value of MESSAGE attribute\n    * @param timeout value of TIMEOUT attribute\n+   * @param priority value of PRIORITY attribute\n+   * @param waitingTimout value of WAITING_TIMEOUT attribute\n+   * @param cleanupTimeout value of CLEANUP_TIMEOUT attribute\n+   * @param requestorId value of REQUESTOR_ID attribute\n+   * @param requestorPriority value of REQUESTOR_PRIORITY attribute\n+   * @param requestorWaitingTimeout value of REQUESTOR_WAITING_TIMEOUT attribute\n+   * @param requestorRequestingTimestamp value of REQUESTOR_REQUESTING_TIMESTAMP attribute\n    */\n-  public LockInfo(String ownerId, String message, long timeout) {\n+  public LockInfo(String ownerId, String message, long timeout, int priority, long waitingTimout,\n+      long cleanupTimeout, String requestorId, int requestorPriority, long requestorWaitingTimeout,\n+      long requestorRequestingTimestamp) {\n     this();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDEzMQ==", "bodyText": "For the lock requestor that is going to enforce the lock, there is no requestor information. So what should they put for the requestor fields?\nI suggest either we change to builder pattern, or we make those parameters optional.", "url": "https://github.com/apache/helix/pull/1564#discussion_r534400131", "createdAt": "2020-12-02T18:45:49Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -65,34 +77,70 @@ public LockInfo(ZNRecord znRecord) {\n     if (znRecord != null) {\n       String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n       String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n-      long timeout = znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n-      setLockInfoFields(ownerId, message, timeout);\n+      long timeout = znRecord\n+          .getLongField(LockInfoAttribute.TIMEOUT.name(), LockConstants.DEFAULT_TIMEOUT_LONG);\n+      int priority = znRecord\n+          .getIntField(LockInfoAttribute.PRIORITY.name(), LockConstants.DEFAULT_PRIORITY_INT);\n+      long waitingTimeout = znRecord.getLongField(LockInfoAttribute.WAITING_TIMEOUT.name(),\n+          LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+      long cleanupTimeout = znRecord.getLongField(LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+          LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+      String requestorId = znRecord.getSimpleField(LockInfoAttribute.REQUESTOR_ID.name());\n+      int requestorPriority = znRecord.getIntField(LockInfoAttribute.REQUESTOR_PRIORITY.name(),\n+          LockConstants.DEFAULT_REQUESTOR_PRIORITY_INT);\n+      long requestorWaitingTimeout = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG);\n+      long requestorRequestingTimestamp = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_REQUESTING_TIMESTAMP.name(),\n+              LockConstants.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG);\n+      setLockInfoFields(ownerId, message, timeout, priority, waitingTimeout, cleanupTimeout,\n+          requestorId, requestorPriority, requestorWaitingTimeout, requestorRequestingTimestamp);\n     }\n   }\n \n   /**\n-   * Initialize a LockInfo with data for each field, set all null info fields to default data\n+   * Initialize a LockInfo with data for each field, set all null info fields to default data.\n    * @param ownerId value of OWNER attribute\n    * @param message value of MESSAGE attribute\n    * @param timeout value of TIMEOUT attribute\n+   * @param priority value of PRIORITY attribute\n+   * @param waitingTimout value of WAITING_TIMEOUT attribute\n+   * @param cleanupTimeout value of CLEANUP_TIMEOUT attribute\n+   * @param requestorId value of REQUESTOR_ID attribute\n+   * @param requestorPriority value of REQUESTOR_PRIORITY attribute\n+   * @param requestorWaitingTimeout value of REQUESTOR_WAITING_TIMEOUT attribute\n+   * @param requestorRequestingTimestamp value of REQUESTOR_REQUESTING_TIMESTAMP attribute\n    */\n-  public LockInfo(String ownerId, String message, long timeout) {\n+  public LockInfo(String ownerId, String message, long timeout, int priority, long waitingTimout,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMTcxNQ==", "bodyText": "Empty strings are not self-explainable. I suggest using something like \"NONE\", or \"NA\", or \"UNKNOWN\"", "url": "https://github.com/apache/helix/pull/1564#discussion_r534401715", "createdAt": "2020-12-02T18:48:16Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/LockConstants.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.apache.helix.lock.helix;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+/*\n+ * Default values for each attribute if there are no current values set by user\n+ */\n+public class LockConstants {\n+  public static final String DEFAULT_OWNER_TEXT = \"\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1;\n+  public static final int DEFAULT_PRIORITY_INT = -1;\n+  public static final long DEFAULT_WAITING_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_CLEANUP_TIMEOUT_LONG = -1;\n+  public static final String DEFAULT_REQUESTOR_ID = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNTA2NA==", "bodyText": "If it is an empty callback, why not just pass null? So the lock won't trigger the callback at all.", "url": "https://github.com/apache/helix/pull/1564#discussion_r534405064", "createdAt": "2020-12-02T18:53:30Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,155 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNzQ5MA==", "bodyText": "Why not refer to the DEFAULT lock values in the constant class?", "url": "https://github.com/apache/helix/pull/1564#discussion_r534407490", "createdAt": "2020-12-02T18:57:18Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(), \"\");\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(), \"\");\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(), -1);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(), -1);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(), -1);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(), -1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwOTgyOQ==", "bodyText": "I didn't see when this subscription is removed. Did I miss anything?", "url": "https://github.com/apache/helix/pull/1564#discussion_r534409829", "createdAt": "2020-12-02T19:00:53Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,155 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n+    }\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMzI2NA==", "bodyText": "Not related to this PR directly, but the isCurrentOwner() call inside the LockUpdater.update() triggers one more ZK call which is not necessary since you already have the current ZNRecord input. Please refine that logic.\nThe logic is not only suboptimal but also buggy since the update logic is not purely relying on the input current znode. This potentially fails when some race condition happens.", "url": "https://github.com/apache/helix/pull/1564#discussion_r534413264", "createdAt": "2020-12-02T19:06:39Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,155 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n+    }\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMzg5OQ==", "bodyText": "If update() fails, it throws Exception, right? Shall we try-catch it and return false instead?", "url": "https://github.com/apache/helix/pull/1564#discussion_r534413899", "createdAt": "2020-12-02T19:07:41Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,155 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n+    }\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxNDc1NQ==", "bodyText": "The reason to put wait in the while loop is to prevent if anyone else updates the content after the notification and before the current thread regains the lock. I think what Junkai said is a valid comment.", "url": "https://github.com/apache/helix/pull/1564#discussion_r534414755", "createdAt": "2020-12-02T19:09:09Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,162 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.DEFAULT_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_ID;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTk2Nw=="}, "originalCommit": {"oid": "7cce68c3817e0e46feca3d34f0b09bbb8480b946"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMTU5MDI3", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-543159027", "createdAt": "2020-12-02T19:16:11Z", "commit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxOToxNjoxMVrOH9qWBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxOTozMjo0MFrOH9q8CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxODk1MQ==", "bodyText": "Verbose log. debug?", "url": "https://github.com/apache/helix/pull/1564#discussion_r534418951", "createdAt": "2020-12-02T19:16:11Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMTQyMw==", "bodyText": "The Default ID is \"\" in this version, right? I guess we should check == null || .isEmpty() ?", "url": "https://github.com/apache/helix/pull/1564#discussion_r534421423", "createdAt": "2020-12-02T19:20:22Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw==", "bodyText": "Not about code, but this means we don't have control on when the cleanup starts.\nWould it be possible that the cleaner lock holder also updates the node so we are sure that cleaning up has been started?", "url": "https://github.com/apache/helix/pull/1564#discussion_r534422643", "createdAt": "2020-12-02T19:22:27Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNTAyOA==", "bodyText": "Could you please elaborate on this part? I didn't get the necessity of reading again.\nYou can relies on the updater to check the ownership for you, right? If the owner has been changed in between, then the update fails and that is OK.", "url": "https://github.com/apache/helix/pull/1564#discussion_r534425028", "createdAt": "2020-12-02T19:26:35Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNjM1OA==", "bodyText": "I cannot match it easily with the if condition above, but they look like the same : )", "url": "https://github.com/apache/helix/pull/1564#discussion_r534426358", "createdAt": "2020-12-02T19:28:46Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(), \"\");\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(), \"\");\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(), -1);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(), -1);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(), -1);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(), -1);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyODY4MA==", "bodyText": "Same here, I'm concerned about the isCurrentOwner usage inside the update method.", "url": "https://github.com/apache/helix/pull/1564#discussion_r534428680", "createdAt": "2020-12-02T19:32:40Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +303,88 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 263}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMTUxMzM2", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-543151336", "createdAt": "2020-12-02T19:05:54Z", "commit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxOTowNTo1NVrOH9p-KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxOTowNzowMlrOH9qApQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMjg0MA==", "bodyText": "Can we avoid the sleep here? Maybe it is better to use TestHelper methods.", "url": "https://github.com/apache/helix/pull/1564#discussion_r534412840", "createdAt": "2020-12-02T19:05:55Z", "author": {"login": "alirezazamani"}, "path": "helix-lock/src/test/java/org/apache/helix/lock/helix/TestZKHelixNonblockingLockWithPriority.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestZKHelixNonblockingLockWithPriority extends ZkTestBase {\n+\n+  private final String _clusterName = TestHelper.getTestClassName();\n+  private String _lockPath;\n+  private HelixLockScope _participantScope;\n+  private AtomicBoolean _isCleanupNotified;\n+\n+  private final LockListener _lockListener = new LockListener() {\n+    @Override\n+    public void onCleanupNotification() {\n+      _isCleanupNotified.set(true);\n+      try {\n+        Thread.sleep(20000);\n+      } catch (Exception e) {\n+\n+      }\n+    }\n+  };\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    System.out.println(\"START \" + _clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(_clusterName, ZK_ADDR, 12918, \"localhost\", \"TestDB\", 1, 10, 5, 3,\n+        \"MasterSlave\", true);\n+\n+    List<String> pathKeys = new ArrayList<>();\n+    pathKeys.add(_clusterName);\n+    pathKeys.add(_clusterName);\n+    _participantScope = new HelixLockScope(HelixLockScope.LockScopeProperty.CLUSTER, pathKeys);\n+    _lockPath = _participantScope.getPath();\n+\n+    _isCleanupNotified = new AtomicBoolean(false);\n+  }\n+\n+  @BeforeMethod\n+  public void beforeMethod() {\n+    _gZkClient.delete(_lockPath);\n+    Assert.assertFalse(_gZkClient.exists(_lockPath));\n+  }\n+\n+  @AfterSuite\n+  public void afterSuite() throws IOException {\n+    super.afterSuite();\n+  }\n+\n+  @Test\n+  public void testLowerPriorityRequestRejected() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    ZKDistributedNonblockingLock lowerLock = new ZKDistributedNonblockingLock(_participantScope,\n+        ZK_ADDR, 3600000L,\n+        \"lower priority lock\", \"low_lock\", 0, 1000, 2000, false, createLockListener());\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(lowerLock);\n+    Thread threadLow = new Thread(lockHelper);\n+    threadLow.start();\n+    threadLow.join();\n+    boolean lowResult = lockHelper.getResult();\n+\n+    Assert.assertFalse(_isCleanupNotified.get());\n+    Assert.assertFalse(lowerLock.isCurrentOwner());\n+    Assert.assertFalse(lowResult);\n+    lock.unlock();\n+    lock.close();\n+    lowerLock.close();\n+  }\n+\n+  @Test\n+  public void testHigherPriorityRequestAcquired() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    // The waitingTimeout of higher priority request is larger than cleanup time of current owner\n+    ZKDistributedNonblockingLock higherLock = new ZKDistributedNonblockingLock(_participantScope,\n+        ZK_ADDR, 3600000L,\n+        \"higher priority lock\", \"high_lock\", 2, 30000, 10000, false, createLockListener());\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(higherLock);\n+    Thread t_higher = new Thread(lockHelper);\n+    t_higher.start();\n+    t_higher.join();\n+    boolean higherResult = lockHelper.getResult();\n+\n+    Assert.assertTrue(_isCleanupNotified.get());\n+    Assert.assertTrue(higherLock.isCurrentOwner());\n+    Assert.assertTrue(higherResult);\n+    _isCleanupNotified.set(false);\n+    higherLock.unlock();\n+    higherLock.close();\n+    lock.close();\n+  }\n+\n+  @Test\n+  public void testHigherPriorityRequestFailedAsCleanupHasNotDone() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    // The waitingTimeout of higher priority request is shorter than cleanup time of current\n+    // owner, and the higher priority request is not forceful.\n+    ZKDistributedNonblockingLock higherLock_short =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L,\n+            \"higher priority lock short\", \"high_lock_short\", 2, 2000, 10000, false, createLockListener());\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(higherLock_short);\n+    Thread t_higher = new Thread(lockHelper);\n+\n+    t_higher.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n+      @Override\n+      public void uncaughtException(Thread th, Throwable ex) {\n+        Assert.assertTrue(ex.getMessage().contains(\"Clean up has not finished by lock owner\"));\n+      }\n+    });\n+    t_higher.start();\n+    t_higher.join();\n+    boolean higherResult = lockHelper.getResult();\n+\n+    Assert.assertTrue(_isCleanupNotified.get());\n+    Assert.assertFalse(higherLock_short.isCurrentOwner());\n+    Assert.assertFalse(higherResult);\n+    _isCleanupNotified.set(false);\n+\n+    Assert.assertTrue(lock.unlock());\n+    Assert.assertFalse(lock.isCurrentOwner());\n+    lock.close();\n+    higherLock_short.close();\n+  }\n+\n+  @Test\n+  public void testHigherPriorityRequestForcefulAcquired() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    // The waitingTimeout of higher priority request is shorter than cleanup time of current\n+    // owner, but the higher priority request is forceful.\n+    ZKDistributedNonblockingLock higherLock_force =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L,\n+            \"higher priority lock force\", \"high_lock_force\", 2, 2000, 10000, true,\n+            new LockListener() {\n+              @Override\n+              public void onCleanupNotification() {\n+              }\n+            });\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(higherLock_force);\n+    Thread t_higher = new Thread(lockHelper);\n+\n+    t_higher.start();\n+    t_higher.join();\n+    boolean higherResult = lockHelper.getResult();\n+\n+    boolean res = TestHelper.verify(() -> {\n+      return _isCleanupNotified.get();\n+    }, TestHelper.WAIT_DURATION);\n+    Assert.assertTrue(res);\n+    Assert.assertTrue(higherLock_force.isCurrentOwner());\n+    Assert.assertTrue(higherResult);\n+    _isCleanupNotified.set(false);\n+\n+    higherLock_force.unlock();\n+    higherLock_force.close();\n+    lock.close();\n+  }\n+\n+  @Test\n+  public void testHigherPriorityRequestPreemptedByAnother() throws Exception {\n+    ZKDistributedNonblockingLock lock =\n+        new ZKDistributedNonblockingLock(_participantScope, ZK_ADDR, 3600000L, \"original \"\n+            + \"lock\", \"original_lock\", 1, 1000, 25000, false, _lockListener);\n+\n+    ZKDistributedNonblockingLock higherLock = new ZKDistributedNonblockingLock(_participantScope,\n+        ZK_ADDR, 3600000L,\n+        \"higher priority lock\", \"high_lock\", 2, 30000, 10000, false, createLockListener());\n+\n+    ZKDistributedNonblockingLock highestLock = new ZKDistributedNonblockingLock(_participantScope\n+        , ZK_ADDR, 3600000L,\n+        \"highest priority lock\", \"highest_lock\", 3, 30000, 20000, false, createLockListener());\n+\n+    Thread t = new Thread() {\n+      @Override\n+      public void run() {\n+        lock.tryLock();\n+      }\n+    };\n+\n+    Thread t_highest = new Thread() {\n+      @Override\n+      public void run() {\n+        highestLock.tryLock();\n+      }\n+    };\n+\n+    t.start();\n+    t.join();\n+    Assert.assertTrue(lock.isCurrentOwner());\n+\n+    LockHelper lockHelper = new LockHelper(higherLock);\n+    Thread t_higher = new Thread(lockHelper);\n+    t_higher.start();\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxMzQ3Nw==", "bodyText": "Can this sleep be avoided?", "url": "https://github.com/apache/helix/pull/1564#discussion_r534413477", "createdAt": "2020-12-02T19:07:02Z", "author": {"login": "alirezazamani"}, "path": "helix-lock/src/test/java/org/apache/helix/lock/helix/TestZKHelixNonblockingLockWithPriority.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix.lock.helix;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestZKHelixNonblockingLockWithPriority extends ZkTestBase {\n+\n+  private final String _clusterName = TestHelper.getTestClassName();\n+  private String _lockPath;\n+  private HelixLockScope _participantScope;\n+  private AtomicBoolean _isCleanupNotified;\n+\n+  private final LockListener _lockListener = new LockListener() {\n+    @Override\n+    public void onCleanupNotification() {\n+      _isCleanupNotified.set(true);\n+      try {\n+        Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NTU0OTU4", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-544554958", "createdAt": "2020-12-03T23:48:14Z", "commit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzo0ODoxNFrOH-6YUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwMDoxMjo0M1rOH-6-6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMDI1Ng==", "bodyText": "This else seems to be unnecessary.\nAnd we need to comment that the order there is important and shall not be changed.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535730256", "createdAt": "2020-12-03T23:48:14Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        null, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {\n+      try {\n+        wait(_pendingTimeout);\n+      } catch (InterruptedException e) {\n+        throw new HelixException(\n+            String.format(\"Interruption happened while %s is waiting for the \" + \"lock\", _userId),\n+            e);\n+      }\n+      // We have not acquired the lock yet.\n+      if (!_isLocked) {\n+        // If the reason for not being able to acquire the lock is due to high priority lock\n+        // preemption, directly return false.\n+        if (_isPreempted) {\n+          _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n+          return false;\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMTA3Ng==", "bodyText": "As discussed, please double check if the logic is complete here since if islocked == false, it will return in any case without checking the updateResult.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535731076", "createdAt": "2020-12-03T23:50:08Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        null, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {\n+      try {\n+        wait(_pendingTimeout);\n+      } catch (InterruptedException e) {\n+        throw new HelixException(\n+            String.format(\"Interruption happened while %s is waiting for the \" + \"lock\", _userId),\n+            e);\n+      }\n+      // We have not acquired the lock yet.\n+      if (!_isLocked) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMTU2MA==", "bodyText": "Here we have isLocked == true and updateResult == false, is it possible?", "url": "https://github.com/apache/helix/pull/1564#discussion_r535731560", "createdAt": "2020-12-03T23:51:11Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        null, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {\n+      try {\n+        wait(_pendingTimeout);\n+      } catch (InterruptedException e) {\n+        throw new HelixException(\n+            String.format(\"Interruption happened while %s is waiting for the \" + \"lock\", _userId),\n+            e);\n+      }\n+      // We have not acquired the lock yet.\n+      if (!_isLocked) {\n+        // If the reason for not being able to acquire the lock is due to high priority lock\n+        // preemption, directly return false.\n+        if (_isPreempted) {\n+          _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n+          return false;\n+        } else {\n+          // Forceful lock request will grab the lock even the current owner has not finished\n+          // cleanup work, while non forceful lock request will get an exception.\n+          if (_isForceful) {\n+            ZNRecord znRecord = composeNewOwnerRecord();\n+            LOG.info(\"Updating Zookeeper with new owner {} information\", _userId);\n+            _baseDataAccessor\n+                .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+            return true;\n+          } else {\n+            _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n+            throw new HelixException(\"Cleanup has not been finished by lock owner\");\n+          }\n+        }\n+      }\n     }\n-    LockUpdater updater = new LockUpdater(new LockInfo(_userId, _lockMsg, deadline));\n-    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+    if (!updateResult) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMjIxNw==", "bodyText": "Can we change to isCurrentOwner(...)", "url": "https://github.com/apache/helix/pull/1564#discussion_r535732217", "createdAt": "2020-12-03T23:52:42Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczNTAyMA==", "bodyText": "As discussed, there is still a chance that we hit a race condition here. So I will suggest we check it in the updater.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535735020", "createdAt": "2020-12-03T23:59:29Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNTAyOA=="}, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczODI2Nw==", "bodyText": "I think _isPending would be better to be updated here.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535738267", "createdAt": "2020-12-04T00:07:49Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _isPending) {\n+      onDeniedPendingLockNotification();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the lock is acquired\n+   */\n+  public void onAcquiredLockNotification() {\n+    synchronized (ZKDistributedNonblockingLock.this) {\n+      _isLocked = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczODY1MQ==", "bodyText": "Looks like a lock can only be in one state at a time. I suggest merging these 2 booleans into an enum for the cleanness of the code and the logic.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535738651", "createdAt": "2020-12-04T00:08:59Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _isPending) {\n+      onDeniedPendingLockNotification();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the lock is acquired\n+   */\n+  public void onAcquiredLockNotification() {\n+    synchronized (ZKDistributedNonblockingLock.this) {\n+      _isLocked = true;\n+      ZKDistributedNonblockingLock.this.notify();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the pending request is denied due to another higher priority request\n+   */\n+  public void onDeniedPendingLockNotification() {\n+    synchronized (ZKDistributedNonblockingLock.this) {\n+      _isLocked = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MDEzOA==", "bodyText": "As mentioned above, I think this would be better to set in the notification method.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535740138", "createdAt": "2020-12-04T00:12:43Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +314,91 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n+\n+      // higher priority lock request will preempt current lock owner that is with lower priority\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && curLockInfo\n+          .getRequestorId().equals(\"NONE\")) {\n+        // update lock Znode with requestor information\n+        ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+        _isPending = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 289}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NTU3MTA1", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-544557105", "createdAt": "2020-12-03T23:53:13Z", "commit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzo1MzoxM1rOH-6g3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwMDoxODoxOFrOH-7HjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMjQ0Nw==", "bodyText": "Java actually has spurious wake up. If you dont have while, then you may not wait until timeout reaches and failed to acquire the lock. That's the reason of using while.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535732447", "createdAt": "2020-12-03T23:53:13Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,162 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.DEFAULT_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_ID;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_PRIORITY_INT;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_REQUESTING_TIMESTAMP_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_REQUESTOR_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.DEFAULT_WAITING_TIMEOUT_LONG;\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        new LockListener() {\n+          @Override\n+          public void onCleanupNotification() {\n+          }\n+        }, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n    * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n   }\n \n   @Override\n-  public boolean tryLock() {\n+  public synchronized boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Check whether the lock request is still pending. If yes, we will wait for the period\n+    // recorded in _pendingTimeout.\n+    if (_isPending) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTk2Nw=="}, "originalCommit": {"oid": "7cce68c3817e0e46feca3d34f0b09bbb8480b946"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczMzY2OA==", "bodyText": "We can just put synchronized (this)", "url": "https://github.com/apache/helix/pull/1564#discussion_r535733668", "createdAt": "2020-12-03T23:56:08Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _isPending) {\n+      onDeniedPendingLockNotification();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the lock is acquired\n+   */\n+  public void onAcquiredLockNotification() {\n+    synchronized (ZKDistributedNonblockingLock.this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczNDMzNQ==", "bodyText": "Are we notifying them or we give them callback and process clean up here?", "url": "https://github.com/apache/helix/pull/1564#discussion_r535734335", "createdAt": "2020-12-03T23:57:41Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw=="}, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczNTIwOQ==", "bodyText": "Can we combine the logic with composeRecordOwner? Let it can pass arguments. Then we can simplify the code. Otherwise, too many places setting the fields.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535735209", "createdAt": "2020-12-03T23:59:56Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczOTIzMA==", "bodyText": "The message could be confusing here. We can say the user has failed to acquire the lock.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535739230", "createdAt": "2020-12-04T00:10:32Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +314,91 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n+\n+      // higher priority lock request will preempt current lock owner that is with lower priority\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && curLockInfo\n+          .getRequestorId().equals(\"NONE\")) {\n+        // update lock Znode with requestor information\n+        ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+        _isPending = true;\n+        _pendingTimeout = _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                : _waitingTimeout;\n+        return newRecord;\n+      }\n+\n+      // If the requestor field is not empty, and the coming lock request has a even higher\n+      // priority. The new request will replace current requestor field of the lock\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && !curLockInfo\n+          .getRequestorId().equals(\"NONE\") && _priority > curLockInfo.getRequestorPriority()) {\n+        ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+        _isPending = true;\n+        long remainingCleanupTime =\n+            curLockInfo.getCleanupTimeout() - (System.currentTimeMillis() - curLockInfo\n+                .getRequestorRequestingTimestamp());\n+        _pendingTimeout =\n+            _waitingTimeout > remainingCleanupTime ? remainingCleanupTime : _waitingTimeout;\n+        return newRecord;\n+      }\n+\n+      // For users who are not the lock owner and the priority is not higher than current lock\n+      // owner, throw an exception. The exception will be caught by data accessor, and return\n+      // false for the update\n       LOG.error(\n           \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n               + \". Lock path: \" + _lockPath);\n+\n       throw new HelixException(\"User is not authorized to perform this operation.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MDE0Ng==", "bodyText": "This could be a sub branch of previous one since the previous two checks are same. Can we combine them?", "url": "https://github.com/apache/helix/pull/1564#discussion_r535740146", "createdAt": "2020-12-04T00:12:44Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +314,91 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n+\n+      // higher priority lock request will preempt current lock owner that is with lower priority\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && curLockInfo\n+          .getRequestorId().equals(\"NONE\")) {\n+        // update lock Znode with requestor information\n+        ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+        _isPending = true;\n+        _pendingTimeout = _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                : _waitingTimeout;\n+        return newRecord;\n+      }\n+\n+      // If the requestor field is not empty, and the coming lock request has a even higher\n+      // priority. The new request will replace current requestor field of the lock\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority() && !curLockInfo\n+          .getRequestorId().equals(\"NONE\") && _priority > curLockInfo.getRequestorPriority()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MTEzNw==", "bodyText": "What if there is no owner at first beginning? Even no ZNode exist?", "url": "https://github.com/apache/helix/pull/1564#discussion_r535741137", "createdAt": "2020-12-04T00:15:19Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +314,91 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MTgyMw==", "bodyText": "Do we need to check this _isPending? I think we can notify anyway if it is pending or not pending.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535741823", "createdAt": "2020-12-04T00:17:01Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,9 +210,91 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\")|| lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        // read the lock information again to avoid stale data\n+        readData = _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+        // If we are still the lock owner, clean the lock owner field.\n+        if (lockInfo.getOwner().equals(_userId)) {\n+          ZNRecord znRecord = new ZNRecord(readData);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(),\n+              LockConstants.DEFAULT_OWNER_TEXT);\n+          znRecord.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+              LockConstants.DEFAULT_MESSAGE_TEXT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+              LockConstants.DEFAULT_TIMEOUT_LONG);\n+          znRecord.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+              LockConstants.DEFAULT_PRIORITY_INT);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+          znRecord.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+              LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+          _baseDataAccessor\n+              .update(_lockPath, new ZNRecordUpdater(znRecord), AccessOption.PERSISTENT);\n+        } else {\n+          LOG.info(\"We are not current lock owner\");\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _isPending) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0MjM0OA==", "bodyText": "I would suggest use an enum to represent its current state:\nLOCKED, PENDING, PREEMPTED. Otherwise, three flags can be confusing for mutual usage to present the lock state.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535742348", "createdAt": "2020-12-04T00:18:18Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0Njc5NjQy", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-544679642", "createdAt": "2020-12-04T06:08:35Z", "commit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNjowODozNVrOH_CPoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNjowODozNVrOH_CPoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1OTEwNA==", "bodyText": "It seems leaseTimeout does not need Long boxing. long is fine?\nAnd, by seeing the list of params, just wow... So many params :)\nCan we encapsulate some of the params into an object, eg. ZkDistributedLockProperties or ZkDistributedLockConfig.", "url": "https://github.com/apache/helix/pull/1564#discussion_r535859104", "createdAt": "2020-12-04T06:08:35Z", "author": {"login": "huizhilu"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -31,69 +31,157 @@\n import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.ZNRecordUpdater;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.lock.LockInfo.ZNODE_ID;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private boolean _isLocked;\n+  private boolean _isPending;\n+  private boolean _isPreempted;\n+  private long _pendingTimeout;\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false,\n+        null, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb899dd46b4417ffe93821e1a2953312905a31d"}, "originalPosition": 73}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25ed3e1ec743dec7b66de37aae86b932b5eb2bd2", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/25ed3e1ec743dec7b66de37aae86b932b5eb2bd2", "committedDate": "2020-12-04T06:59:16Z", "message": "Fix part of comments"}, "afterCommit": {"oid": "1013f1bc87e42cc6be9aab2d03ca83713c2098b7", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/1013f1bc87e42cc6be9aab2d03ca83713c2098b7", "committedDate": "2020-12-05T06:49:16Z", "message": "fix more comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1013f1bc87e42cc6be9aab2d03ca83713c2098b7", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/1013f1bc87e42cc6be9aab2d03ca83713c2098b7", "committedDate": "2020-12-05T06:49:16Z", "message": "fix more comments"}, "afterCommit": {"oid": "8d54c2ec4ac4828ef5e1c0de3007b9b9019ebdce", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/8d54c2ec4ac4828ef5e1c0de3007b9b9019ebdce", "committedDate": "2020-12-06T04:41:39Z", "message": "fix more comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8d54c2ec4ac4828ef5e1c0de3007b9b9019ebdce", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/8d54c2ec4ac4828ef5e1c0de3007b9b9019ebdce", "committedDate": "2020-12-06T04:41:39Z", "message": "fix more comments"}, "afterCommit": {"oid": "53faea1d8ebfd2a98d7d9e8a7eb52a226f2e32bf", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/53faea1d8ebfd2a98d7d9e8a7eb52a226f2e32bf", "committedDate": "2020-12-06T05:01:45Z", "message": "fix more comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3ODY1OTg0", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-547865984", "createdAt": "2020-12-09T06:07:04Z", "commit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjowNzowNFrOICEDzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjowNzowNFrOICEDzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNDU3Mw==", "bodyText": "nit, combine this with line 71, then we can call the constructor directly instead of 2 lines.", "url": "https://github.com/apache/helix/pull/1564#discussion_r539034573", "createdAt": "2020-12-09T06:07:04Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/LockInfo.java", "diffHunk": "@@ -45,54 +40,105 @@\n   public enum LockInfoAttribute {\n     OWNER,\n     MESSAGE,\n-    TIMEOUT\n+    TIMEOUT,\n+    PRIORITY,\n+    WAITING_TIMEOUT,\n+    CLEANUP_TIMEOUT,\n+    REQUESTOR_ID,\n+    REQUESTOR_PRIORITY,\n+    REQUESTOR_WAITING_TIMEOUT,\n+    REQUESTING_TIMESTAMP\n   }\n \n   /**\n    * Initialize a default LockInfo instance\n    */\n   private LockInfo() {\n     _record = new ZNRecord(ZNODE_ID);\n-    setLockInfoFields(DEFAULT_OWNER_TEXT, DEFAULT_MESSAGE_TEXT, DEFAULT_TIMEOUT_LONG);\n+    setLockInfoFields(LockConstants.DEFAULT_USER_ID, LockConstants.DEFAULT_MESSAGE_TEXT,\n+        LockConstants.DEFAULT_TIMEOUT_LONG, LockConstants.DEFAULT_PRIORITY_INT,\n+        LockConstants.DEFAULT_WAITING_TIMEOUT_LONG, LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG,\n+        LockConstants.DEFAULT_USER_ID, LockConstants.DEFAULT_PRIORITY_INT,\n+        LockConstants.DEFAULT_WAITING_TIMEOUT_LONG,\n+        LockConstants.DEFAULT_REQUESTING_TIMESTAMP_LONG);\n   }\n \n   /**\n    * Initialize a LockInfo with a ZNRecord, set all info fields to default data\n    * @param znRecord The ZNRecord contains lock node data that used to initialize the LockInfo\n    */\n   public LockInfo(ZNRecord znRecord) {\n-    this();\n-    if (znRecord != null) {\n-      String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n-      String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n-      long timeout = znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), DEFAULT_TIMEOUT_LONG);\n-      setLockInfoFields(ownerId, message, timeout);\n+    _record = new ZNRecord(ZNODE_ID);\n+    if (znRecord == null) {\n+      znRecord = new ZNRecord(ZNODE_ID);\n     }\n+    String ownerId = znRecord.getSimpleField(LockInfoAttribute.OWNER.name()) == null\n+        ? LockConstants.DEFAULT_USER_ID : znRecord.getSimpleField(LockInfoAttribute.OWNER.name());\n+    String message = znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name()) == null\n+        ? LockConstants.DEFAULT_MESSAGE_TEXT\n+        : znRecord.getSimpleField(LockInfoAttribute.MESSAGE.name());\n+    long timeout =\n+        znRecord.getLongField(LockInfoAttribute.TIMEOUT.name(), LockConstants.DEFAULT_TIMEOUT_LONG);\n+    int priority =\n+        znRecord.getIntField(LockInfoAttribute.PRIORITY.name(), LockConstants.DEFAULT_PRIORITY_INT);\n+      long waitingTimeout = znRecord.getLongField(LockInfoAttribute.WAITING_TIMEOUT.name(),\n+          LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+      long cleanupTimeout = znRecord.getLongField(LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+          LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+      String requestorId = znRecord.getSimpleField(LockInfoAttribute.REQUESTOR_ID.name());\n+      int requestorPriority = znRecord.getIntField(LockInfoAttribute.REQUESTOR_PRIORITY.name(),\n+          LockConstants.DEFAULT_PRIORITY_INT);\n+      long requestorWaitingTimeout = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTOR_WAITING_TIMEOUT.name(),\n+              LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+      long requestingTimestamp = znRecord\n+          .getLongField(LockInfoAttribute.REQUESTING_TIMESTAMP.name(),\n+              LockConstants.DEFAULT_REQUESTING_TIMESTAMP_LONG);\n+      setLockInfoFields(ownerId, message, timeout, priority, waitingTimeout, cleanupTimeout,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3ODY3MjI5", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-547867229", "createdAt": "2020-12-09T06:10:21Z", "commit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjoxMDoyMVrOICEIvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjoxMDoyMVrOICEIvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNTgzNg==", "bodyText": "nit, please comment on the meaning of these statuses, especially PREEMPTED : )", "url": "https://github.com/apache/helix/pull/1564#discussion_r539035836", "createdAt": "2020-12-09T06:10:21Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/LockConstants.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.apache.helix.lock.helix;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+/*\n+ * Default values for each attribute if there are no current values set by user\n+ */\n+public class LockConstants {\n+  public static final String DEFAULT_USER_ID = \"NONE\";\n+  public static final String DEFAULT_MESSAGE_TEXT = \"NONE\";\n+  public static final long DEFAULT_TIMEOUT_LONG = -1;\n+  public static final int DEFAULT_PRIORITY_INT = -1;\n+  public static final long DEFAULT_WAITING_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_CLEANUP_TIMEOUT_LONG = -1;\n+  public static final long DEFAULT_REQUESTING_TIMESTAMP_LONG = -1;\n+\n+  public enum LockStatus {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3ODY4MDEy", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-547868012", "createdAt": "2020-12-09T06:12:27Z", "commit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjoxMjoyN1rOICEL7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjozOTo0MlrOICE1ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNjY1NA==", "bodyText": "I just noticed that there is zkAddress input. So this is not multi zk supported API, right? Will that be a concern?", "url": "https://github.com/apache/helix/pull/1564#discussion_r539036654", "createdAt": "2020-12-09T06:12:27Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -32,68 +33,167 @@\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private LockConstants.LockStatus _lockStatus;\n+  private long _pendingTimeout;\n+  private CountDownLatch _countDownLatch = new CountDownLatch(1);\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzODc3NA==", "bodyText": "nit,\n\nthe \" + \"lock\"\n\nI assume you want to add something in between?", "url": "https://github.com/apache/helix/pull/1564#discussion_r539038774", "createdAt": "2020-12-09T06:18:22Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -32,68 +33,167 @@\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private LockConstants.LockStatus _lockStatus;\n+  private long _pendingTimeout;\n+  private CountDownLatch _countDownLatch = new CountDownLatch(1);\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false, null,\n+        new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n-   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * Initialize the lock with ZKLockConfig. This is the preferred way to construct the lock.\n+   */\n+  public ZKDistributedNonblockingLock(ZKLockConfig zkLockConfig) {\n+    this(zkLockConfig.getLockScope(), zkLockConfig.getZkAddress(), zkLockConfig.getLeaseTimeout(),\n+        zkLockConfig.getLockMsg(), zkLockConfig.getUserId(), zkLockConfig.getPriority(),\n+        zkLockConfig.getWaitingTimeout(), zkLockConfig.getCleanupTimeout(),\n+        zkLockConfig.getIsForceful(), zkLockConfig.getLockListener());\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, priority,\n+   * different kinds of timeout, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Internal construction of the lock with user provided information, e.g., lock path under\n+   * zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n+    validateInput();\n   }\n \n   @Override\n   public boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Immediately return if the lock statue is not PENDING.\n+    if (_lockStatus != LockConstants.LockStatus.PENDING) {\n+      if (!updateResult) {\n+        _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n+      }\n+      return updateResult;\n     }\n-    LockUpdater updater = new LockUpdater(new LockInfo(_userId, _lockMsg, deadline));\n-    return _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // When the lock status is still pending, wait for the period recorded in _pendingTimeout.\n+    try {\n+      _countDownLatch.await(_pendingTimeout, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException e) {\n+      throw new HelixException(\n+          String.format(\"Interruption happened while %s is waiting for the \" + \"lock\", _userId), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MTgyMA==", "bodyText": "The proposal is that the waiting time should start once cleanup starts. But that could be too complicated. So let's just add a TODO here. We shall only do this when it is proved to be required.", "url": "https://github.com/apache/helix/pull/1564#discussion_r539041820", "createdAt": "2020-12-09T06:26:12Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -125,6 +211,79 @@ public void close() {\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (lockInfo.getOwner().equals(_userId)) {\n+      if (lockInfo.getRequestorId() == null || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.info(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyMjY0Mw=="}, "originalCommit": {"oid": "ede0898440288324c6f687de64852f9bb5b28a30"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MjczNA==", "bodyText": "Once we support LOCK node cleanup, then we need to add some logic here, right?\nMaybe some TODO comments would be helpful.", "url": "https://github.com/apache/helix/pull/1564#discussion_r539042734", "createdAt": "2020-12-09T06:28:25Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -122,11 +222,72 @@ public void close() {\n     if (isCurrentOwner()) {\n       throw new HelixException(\"Please unlock the lock before closing it.\");\n     }\n+    _baseDataAccessor.unsubscribeDataChanges(_lockPath, this);\n     _baseDataAccessor.close();\n   }\n \n+  @Override\n+  public void handleDataChange(String dataPath, Object data) throws Exception {\n+    Stat stat = new Stat();\n+    ZNRecord readData =\n+        _baseDataAccessor.get(dataPath, stat, AccessOption.THROW_EXCEPTION_IFNOTEXIST);\n+    LockInfo lockInfo = new LockInfo(readData);\n+    // We are the current owner\n+    if (isCurrentOwner(lockInfo)) {\n+      if (lockInfo.getRequestorId().equals(\"NONE\") || lockInfo.getPriority() > lockInfo\n+          .getRequestorPriority()) {\n+        LOG.debug(\"We do not need to handle this data change\");\n+      } else {\n+        _lockListener.onCleanupNotification();\n+        CleanupUpdater cleanupUpdater = new CleanupUpdater();\n+        boolean res = _baseDataAccessor.update(_lockPath, cleanupUpdater, AccessOption.PERSISTENT);\n+        if (!res) {\n+          throw new HelixException(\n+              String.format(\"User %s failed to update lock path %s\", _userId, _lockPath));\n+        }\n+      }\n+    } // We are the current requestor\n+    else if (lockInfo.getRequestorId().equals(_userId)) {\n+      // In case the owner field is empty, it means previous owner has finished cleanup work.\n+      if (lockInfo.getOwner().equals(\"NONE\")) {\n+        ZNRecord znRecord = composeNewOwnerRecord();\n+        LockUpdater updater = new LockUpdater(new LockInfo(znRecord));\n+        _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+        onAcquiredLockNotification();\n+      } else {\n+        LOG.info(\"We do not need to handle this data change\");\n+      }\n+    } // If we are waiting for the lock, but find we are not the requestor any more, meaning we\n+    // are preempted by an even higher priority request\n+    else if (!lockInfo.getRequestorId().equals(\"NONE\") && !lockInfo.getRequestorId().equals(_userId)\n+        && _lockStatus == LockConstants.LockStatus.PENDING) {\n+      onDeniedPendingLockNotification();\n+    }\n+  }\n+\n+  /**\n+   * call back called when the lock is acquired\n+   */\n+  public void onAcquiredLockNotification() {\n+    _lockStatus = LockConstants.LockStatus.LOCKED;\n+    _countDownLatch.countDown();\n+  }\n+\n   /**\n-   * Class that specifies how a lock node should be updated with another lock node\n+   * call back called when the pending request is denied due to another higher priority request\n+   */\n+  public void onDeniedPendingLockNotification() {\n+    _lockStatus = LockConstants.LockStatus.PREEMPTED;\n+    _countDownLatch.countDown();\n+  }\n+\n+  @Override\n+  public void handleDataDeleted(String dataPath) throws Exception {\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0Mjk1OQ==", "bodyText": "Can we avoid hardcode NONE but refer to the default ID?", "url": "https://github.com/apache/helix/pull/1564#discussion_r539042959", "createdAt": "2020-12-09T06:29:02Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +305,143 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n-      LOG.error(\n-          \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n-              + \". Lock path: \" + _lockPath);\n-      throw new HelixException(\"User is not authorized to perform this operation.\");\n+\n+      // higher priority lock request will try to  preempt current lock owner\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority()) {\n+        if (curLockInfo.getRequestorId().equals(\"NONE\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NDUyNw==", "bodyText": "There is some duplicate code, can we do this?\nif (curLockInfo.getRequestorId().equals(\"NONE\")) {\n_pendingTimeout = .....\n} else if (_priority > curLockInfo.getRequestorPriority()) {\n_pendingTimeout = ......\n}\nZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\nthrow new HelixException(\"User is not authorized to perform this operation.\");\n_lockStatus = LockConstants.LockStatus.PENDING;\nreturn newRecord;", "url": "https://github.com/apache/helix/pull/1564#discussion_r539044527", "createdAt": "2020-12-09T06:33:01Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +305,143 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n-      LOG.error(\n-          \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n-              + \". Lock path: \" + _lockPath);\n-      throw new HelixException(\"User is not authorized to perform this operation.\");\n+\n+      // higher priority lock request will try to  preempt current lock owner\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority()) {\n+        if (curLockInfo.getRequestorId().equals(\"NONE\")) {\n+          // update lock Znode with requestor information\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          _pendingTimeout =\n+              _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                  : _waitingTimeout;\n+          return newRecord;\n+        } // If the requestor field is not empty, and the coming lock request has a even higher\n+        // priority. The new request will replace current requestor field of the lock\n+        else if (_priority > curLockInfo.getRequestorPriority()) {\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          long remainingCleanupTime =\n+              curLockInfo.getCleanupTimeout() - (System.currentTimeMillis() - curLockInfo\n+                  .getRequestingTimestamp());\n+          _pendingTimeout = _waitingTimeout > remainingCleanupTime ? remainingCleanupTime :\n+           _waitingTimeout;\n+          return newRecord;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NTUwNQ==", "bodyText": "If I just create a new LockInfo(null) object, then I get the same result, right?\nI guess maybe you want to make the LockInfo() constructor public.", "url": "https://github.com/apache/helix/pull/1564#discussion_r539045505", "createdAt": "2020-12-09T06:35:31Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +305,143 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n-      LOG.error(\n-          \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n-              + \". Lock path: \" + _lockPath);\n-      throw new HelixException(\"User is not authorized to perform this operation.\");\n+\n+      // higher priority lock request will try to  preempt current lock owner\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority()) {\n+        if (curLockInfo.getRequestorId().equals(\"NONE\")) {\n+          // update lock Znode with requestor information\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          _pendingTimeout =\n+              _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                  : _waitingTimeout;\n+          return newRecord;\n+        } // If the requestor field is not empty, and the coming lock request has a even higher\n+        // priority. The new request will replace current requestor field of the lock\n+        else if (_priority > curLockInfo.getRequestorPriority()) {\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          long remainingCleanupTime =\n+              curLockInfo.getCleanupTimeout() - (System.currentTimeMillis() - curLockInfo\n+                  .getRequestingTimestamp());\n+          _pendingTimeout = _waitingTimeout > remainingCleanupTime ? remainingCleanupTime :\n+           _waitingTimeout;\n+          return newRecord;\n+        }\n+      }\n+\n+      // For users who are not the lock owner and the priority is not higher than current lock\n+      // owner, or the priority is higher than current lock, but lower than the requestor, throw\n+      // an exception. The exception will be caught by data accessor, and return false for the\n+      // update operation.\n+      LOG.error(\"User {} failed to acquire lock at Lock path {}.\", _userId, _lockPath);\n+      throw new HelixException(\n+          String.format(\"User %s failed to acquire lock at Lock path %s.\", _userId, _lockPath));\n     }\n   }\n \n+  /**\n+   * Class that specifies how a lock node should be updated after the previous owner finishes the\n+   * cleanup work\n+   */\n+  private class CleanupUpdater implements DataUpdater<ZNRecord> {\n+    public CleanupUpdater() {\n+    }\n+\n+    @Override\n+    public ZNRecord update(ZNRecord current) {\n+      // If we are still the lock owner, clean owner field.\n+      LockInfo curLockInfo = new LockInfo(current);\n+      if (isCurrentOwner(curLockInfo)) {\n+        ZNRecord record = current;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NTY4OQ==", "bodyText": "Or even better, just define a static empty LockInfo object for this usage.", "url": "https://github.com/apache/helix/pull/1564#discussion_r539045689", "createdAt": "2020-12-09T06:36:00Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +305,143 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n-      LOG.error(\n-          \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n-              + \". Lock path: \" + _lockPath);\n-      throw new HelixException(\"User is not authorized to perform this operation.\");\n+\n+      // higher priority lock request will try to  preempt current lock owner\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority()) {\n+        if (curLockInfo.getRequestorId().equals(\"NONE\")) {\n+          // update lock Znode with requestor information\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          _pendingTimeout =\n+              _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                  : _waitingTimeout;\n+          return newRecord;\n+        } // If the requestor field is not empty, and the coming lock request has a even higher\n+        // priority. The new request will replace current requestor field of the lock\n+        else if (_priority > curLockInfo.getRequestorPriority()) {\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          long remainingCleanupTime =\n+              curLockInfo.getCleanupTimeout() - (System.currentTimeMillis() - curLockInfo\n+                  .getRequestingTimestamp());\n+          _pendingTimeout = _waitingTimeout > remainingCleanupTime ? remainingCleanupTime :\n+           _waitingTimeout;\n+          return newRecord;\n+        }\n+      }\n+\n+      // For users who are not the lock owner and the priority is not higher than current lock\n+      // owner, or the priority is higher than current lock, but lower than the requestor, throw\n+      // an exception. The exception will be caught by data accessor, and return false for the\n+      // update operation.\n+      LOG.error(\"User {} failed to acquire lock at Lock path {}.\", _userId, _lockPath);\n+      throw new HelixException(\n+          String.format(\"User %s failed to acquire lock at Lock path %s.\", _userId, _lockPath));\n     }\n   }\n \n+  /**\n+   * Class that specifies how a lock node should be updated after the previous owner finishes the\n+   * cleanup work\n+   */\n+  private class CleanupUpdater implements DataUpdater<ZNRecord> {\n+    public CleanupUpdater() {\n+    }\n+\n+    @Override\n+    public ZNRecord update(ZNRecord current) {\n+      // If we are still the lock owner, clean owner field.\n+      LockInfo curLockInfo = new LockInfo(current);\n+      if (isCurrentOwner(curLockInfo)) {\n+        ZNRecord record = current;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NTUwNQ=="}, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NjYwMQ==", "bodyText": "nit,\noldLockInfo => existingLockInfo, and newLockZNRecord => requestorLockZNRecord ?", "url": "https://github.com/apache/helix/pull/1564#discussion_r539046601", "createdAt": "2020-12-09T06:37:59Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -144,19 +305,143 @@ public ZNRecord update(ZNRecord current) {\n       // If no one owns the lock, allow the update\n       // If the user is the current lock owner, allow the update\n       LockInfo curLockInfo = new LockInfo(current);\n-      if (!(System.currentTimeMillis() < curLockInfo.getTimeout()) || isCurrentOwner()) {\n+      if (System.currentTimeMillis() > curLockInfo.getTimeout() || isCurrentOwner(curLockInfo)) {\n         return _record;\n       }\n-      // For users who are not the lock owner and try to do an update on a lock that is held by\n-      // someone else, exception thrown is to be caught by data accessor, and return false for\n-      // the update\n-      LOG.error(\n-          \"User \" + _userId + \" tried to update the lock at \" + new Date(System.currentTimeMillis())\n-              + \". Lock path: \" + _lockPath);\n-      throw new HelixException(\"User is not authorized to perform this operation.\");\n+\n+      // higher priority lock request will try to  preempt current lock owner\n+      if (!isCurrentOwner(curLockInfo) && _priority > curLockInfo.getPriority()) {\n+        if (curLockInfo.getRequestorId().equals(\"NONE\")) {\n+          // update lock Znode with requestor information\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          _pendingTimeout =\n+              _waitingTimeout > curLockInfo.getCleanupTimeout() ? curLockInfo.getCleanupTimeout()\n+                  : _waitingTimeout;\n+          return newRecord;\n+        } // If the requestor field is not empty, and the coming lock request has a even higher\n+        // priority. The new request will replace current requestor field of the lock\n+        else if (_priority > curLockInfo.getRequestorPriority()) {\n+          ZNRecord newRecord = composeNewRequestorRecord(curLockInfo, _record);\n+          _lockStatus = LockConstants.LockStatus.PENDING;\n+          long remainingCleanupTime =\n+              curLockInfo.getCleanupTimeout() - (System.currentTimeMillis() - curLockInfo\n+                  .getRequestingTimestamp());\n+          _pendingTimeout = _waitingTimeout > remainingCleanupTime ? remainingCleanupTime :\n+           _waitingTimeout;\n+          return newRecord;\n+        }\n+      }\n+\n+      // For users who are not the lock owner and the priority is not higher than current lock\n+      // owner, or the priority is higher than current lock, but lower than the requestor, throw\n+      // an exception. The exception will be caught by data accessor, and return false for the\n+      // update operation.\n+      LOG.error(\"User {} failed to acquire lock at Lock path {}.\", _userId, _lockPath);\n+      throw new HelixException(\n+          String.format(\"User %s failed to acquire lock at Lock path %s.\", _userId, _lockPath));\n     }\n   }\n \n+  /**\n+   * Class that specifies how a lock node should be updated after the previous owner finishes the\n+   * cleanup work\n+   */\n+  private class CleanupUpdater implements DataUpdater<ZNRecord> {\n+    public CleanupUpdater() {\n+    }\n+\n+    @Override\n+    public ZNRecord update(ZNRecord current) {\n+      // If we are still the lock owner, clean owner field.\n+      LockInfo curLockInfo = new LockInfo(current);\n+      if (isCurrentOwner(curLockInfo)) {\n+        ZNRecord record = current;\n+        record\n+            .setSimpleField(LockInfo.LockInfoAttribute.OWNER.name(), LockConstants.DEFAULT_USER_ID);\n+        record.setSimpleField(LockInfo.LockInfoAttribute.MESSAGE.name(),\n+            LockConstants.DEFAULT_MESSAGE_TEXT);\n+        record.setLongField(LockInfo.LockInfoAttribute.TIMEOUT.name(),\n+            LockConstants.DEFAULT_TIMEOUT_LONG);\n+        record.setIntField(LockInfo.LockInfoAttribute.PRIORITY.name(),\n+            LockConstants.DEFAULT_PRIORITY_INT);\n+        record.setLongField(LockInfo.LockInfoAttribute.WAITING_TIMEOUT.name(),\n+            LockConstants.DEFAULT_WAITING_TIMEOUT_LONG);\n+        record.setLongField(LockInfo.LockInfoAttribute.CLEANUP_TIMEOUT.name(),\n+            LockConstants.DEFAULT_CLEANUP_TIMEOUT_LONG);\n+        return record;\n+      }\n+      LOG.error(\"User {} is not current lock owner, and does not need to unlock {}\", _userId,\n+          _lockPath);\n+      throw new HelixException(String\n+          .format(\"User %s is not current lock owner, and does not need\" + \" to unlock %s\", _userId,\n+              _lockPath));\n+    }\n+  }\n+\n+  /**\n+   * Class that specifies how a lock node should be updated during a forceful get lock operation\n+   */\n+  private class ForcefulUpdater implements DataUpdater<ZNRecord> {\n+    final ZNRecord _record;\n+\n+    /**\n+     * Initialize a structure for lock user to update a lock node value\n+     * @param lockInfo the lock node value will be used to update the lock\n+     */\n+    public ForcefulUpdater(LockInfo lockInfo) {\n+      _record = lockInfo.getRecord();\n+    }\n+\n+    @Override\n+    public ZNRecord update(ZNRecord current) {\n+      // If we are still the lock requestor, change ourselves to be lock owner.\n+      LockInfo curLockInfo = new LockInfo(current);\n+      if (curLockInfo.getRequestorId().equals(_userId)) {\n+        return _record;\n+      }\n+      LOG.error(\"User {} is not current lock requestor, and cannot forcefully acquire the lock at \"\n+          + \"{}\", _userId, _lockPath);\n+      throw new HelixException(String.format(\"User %s is not current lock requestor, and cannot \"\n+          + \"forcefully acquire the lock at %s\", _userId, _lockPath));\n+    }\n+  }\n+\n+  private ZNRecord composeNewRequestorRecord(LockInfo oldLockInfo, ZNRecord newLockZNRecord) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NzI3NA==", "bodyText": "I do have some concerns about this direct ZkAddress parameter. This won't support multi-zk usage.\nIt might be OK, but the LOCK API will be treated as a special case, I guess.", "url": "https://github.com/apache/helix/pull/1564#discussion_r539047274", "createdAt": "2020-12-09T06:39:42Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKLockConfig.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package org.apache.helix.lock.helix;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.lock.LockScope;\n+import org.apache.helix.manager.zk.GenericZkHelixApiBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Hold configs used for a ZK distributed nonblocking lock.\n+ */\n+public class ZKLockConfig {\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(org.apache.helix.lock.helix.ZKLockConfig.class.getName());\n+  private LockScope _lockScope;\n+  private String _zkAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NjAwNDAw", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-548600400", "createdAt": "2020-12-09T20:54:49Z", "commit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDo1NDo0OVrOICpCdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDo1NDo0OVrOICpCdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0MDQzNw==", "bodyText": "I think we want users to use zooscalibility features as far as they can. So shall we hide this constructor? The above one with zkAddress is left because we want to ensure backward compatibility. But this one is newly added. So make it private or get rid of it?", "url": "https://github.com/apache/helix/pull/1564#discussion_r539640437", "createdAt": "2020-12-09T20:54:49Z", "author": {"login": "jiajunwang"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -32,68 +33,167 @@\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private LockConstants.LockStatus _lockStatus;\n+  private long _pendingTimeout;\n+  private CountDownLatch _countDownLatch = new CountDownLatch(1);\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false, null,\n+        new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n-   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * Initialize the lock with ZKLockConfig. This is the preferred way to construct the lock.\n+   */\n+  public ZKDistributedNonblockingLock(ZKLockConfig zkLockConfig) {\n+    this(zkLockConfig.getLockScope(), zkLockConfig.getZkAddress(), zkLockConfig.getLeaseTimeout(),\n+        zkLockConfig.getLockMsg(), zkLockConfig.getUserId(), zkLockConfig.getPriority(),\n+        zkLockConfig.getWaitingTimeout(), zkLockConfig.getCleanupTimeout(),\n+        zkLockConfig.getIsForceful(), zkLockConfig.getLockListener());\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, priority,\n+   * different kinds of timeout, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e11f56f3bfaad96310f5731afd43fd6c65a7386"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5Njg3NzIz", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-549687723", "createdAt": "2020-12-10T23:16:04Z", "commit": {"oid": "81168cfcea02098f8d8a035543dbcfd07de8ce91"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoxNjowNVrOIDh12w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoxNjowNVrOIDh12w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MTA5OQ==", "bodyText": "Following lockStatus was protected by latch down. But this check could happening parallel to following lockStatus update. Do we need some synchronization?", "url": "https://github.com/apache/helix/pull/1564#discussion_r540571099", "createdAt": "2020-12-10T23:16:05Z", "author": {"login": "junkaixue"}, "path": "helix-lock/src/main/java/org/apache/helix/lock/helix/ZKDistributedNonblockingLock.java", "diffHunk": "@@ -32,68 +33,167 @@\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n-import org.apache.log4j.Logger;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * Helix nonblocking lock implementation based on Zookeeper.\n  * NOTE: do NOT use ephemeral nodes in this implementation because ephemeral mode is not supported\n  * in ZooScalability mode.\n  */\n-public class ZKDistributedNonblockingLock implements DistributedLock {\n-  private static final Logger LOG = Logger.getLogger(ZKDistributedNonblockingLock.class);\n+public class ZKDistributedNonblockingLock implements DistributedLock, IZkDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKDistributedNonblockingLock.class);\n \n   private final String _lockPath;\n   private final String _userId;\n-  private final long _timeout;\n   private final String _lockMsg;\n+  private final long _leaseTimeout;\n+  private final long _waitingTimeout;\n+  private final long _cleanupTimeout;\n+  private final int _priority;\n+  private final boolean _isForceful;\n+  private final LockListener _lockListener;\n   private final BaseDataAccessor<ZNRecord> _baseDataAccessor;\n+  private LockConstants.LockStatus _lockStatus;\n+  private long _pendingTimeout;\n+  private CountDownLatch _countDownLatch = new CountDownLatch(1);\n \n   /**\n    * Initialize the lock with user provided information, e.g.,cluster, scope, etc.\n    * @param scope the scope to lock\n    * @param zkAddress the zk address the cluster connects to\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n    */\n-  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long timeout,\n+  public ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n       String lockMsg, String userId) {\n-    this(scope.getPath(), timeout, lockMsg, userId, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, 0, Integer.MAX_VALUE, 0, false, null,\n+        new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n   }\n \n   /**\n-   * Initialize the lock with user provided information, e.g., lock path under zookeeper, etc.\n+   * Initialize the lock with ZKLockConfig. This is the preferred way to construct the lock.\n+   */\n+  public ZKDistributedNonblockingLock(ZKLockConfig zkLockConfig) {\n+    this(zkLockConfig.getLockScope(), zkLockConfig.getZkAddress(), zkLockConfig.getLeaseTimeout(),\n+        zkLockConfig.getLockMsg(), zkLockConfig.getUserId(), zkLockConfig.getPriority(),\n+        zkLockConfig.getWaitingTimeout(), zkLockConfig.getCleanupTimeout(),\n+        zkLockConfig.getIsForceful(), zkLockConfig.getLockListener());\n+  }\n+\n+  /**\n+   * Initialize the lock with user provided information, e.g.,cluster, scope, priority,\n+   * different kinds of timeout, etc.\n+   * @param scope the scope to lock\n+   * @param zkAddress the zk address the cluster connects to\n+   * @param leaseTimeout the leasing timeout period of the lock\n+   * @param lockMsg the reason for having this lock\n+   * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n+   */\n+  private ZKDistributedNonblockingLock(LockScope scope, String zkAddress, Long leaseTimeout,\n+      String lockMsg, String userId, int priority, long waitingTimeout, long cleanupTimeout,\n+      boolean isForceful, LockListener lockListener) {\n+    this(scope.getPath(), leaseTimeout, lockMsg, userId, priority, waitingTimeout, cleanupTimeout,\n+        isForceful, lockListener, new ZkBaseDataAccessor<ZNRecord>(zkAddress));\n+  }\n+\n+  /**\n+   * Internal construction of the lock with user provided information, e.g., lock path under\n+   * zookeeper, etc.\n    * @param lockPath the path of the lock under Zookeeper\n-   * @param timeout the timeout period of the lock\n+   * @param leaseTimeout the leasing timeout period of the lock\n    * @param lockMsg the reason for having this lock\n    * @param userId a universal unique userId for lock owner identity\n+   * @param priority the priority of the lock\n+   * @param waitingTimeout the waiting timeout period of the lock when the tryLock request is issued\n+   * @param cleanupTimeout the time period needed to finish the cleanup work by the lock when it\n+   *                      is preempted\n+   * @param isForceful whether the lock is a forceful one. This determines the behavior when the\n+   *                   lock encountered an exception during preempting lower priority lock\n+   * @param lockListener the listener associated to the lock\n    * @param baseDataAccessor baseDataAccessor instance to do I/O against ZK with\n    */\n-  private ZKDistributedNonblockingLock(String lockPath, Long timeout, String lockMsg, String userId,\n-      BaseDataAccessor<ZNRecord> baseDataAccessor) {\n+  private ZKDistributedNonblockingLock(String lockPath, Long leaseTimeout, String lockMsg,\n+      String userId, int priority, long waitingTimeout, long cleanupTimeout, boolean isForceful,\n+      LockListener lockListener, BaseDataAccessor<ZNRecord> baseDataAccessor) {\n     _lockPath = lockPath;\n-    if (timeout < 0) {\n-      throw new IllegalArgumentException(\"The expiration time cannot be negative.\");\n+    if (leaseTimeout < 0 || waitingTimeout < 0 || cleanupTimeout < 0) {\n+      throw new IllegalArgumentException(\"Timeout cannot be negative.\");\n+    }\n+    if (priority < 0) {\n+      throw new IllegalArgumentException(\"Priority cannot be negative.\");\n     }\n-    _timeout = timeout;\n+    _leaseTimeout = leaseTimeout;\n     _lockMsg = lockMsg;\n     _userId = userId;\n     _baseDataAccessor = baseDataAccessor;\n+    _priority = priority;\n+    _waitingTimeout = waitingTimeout;\n+    _cleanupTimeout = cleanupTimeout;\n+    _lockListener = lockListener;\n+    _isForceful = isForceful;\n+    validateInput();\n   }\n \n   @Override\n   public boolean tryLock() {\n     // Set lock information fields\n-    long deadline;\n-    // Prevent value overflow\n-    if (_timeout > Long.MAX_VALUE - System.currentTimeMillis()) {\n-      deadline = Long.MAX_VALUE;\n-    } else {\n-      deadline = System.currentTimeMillis() + _timeout;\n+    _baseDataAccessor.subscribeDataChanges(_lockPath, this);\n+    LockUpdater updater = new LockUpdater(\n+        new LockInfo(_userId, _lockMsg, getNonOverflowTimestamp(_leaseTimeout), _priority,\n+            _waitingTimeout, _cleanupTimeout, null, 0, 0, 0));\n+    boolean updateResult = _baseDataAccessor.update(_lockPath, updater, AccessOption.PERSISTENT);\n+\n+    // Immediately return if the lock statue is not PENDING.\n+    if (_lockStatus != LockConstants.LockStatus.PENDING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81168cfcea02098f8d8a035543dbcfd07de8ce91"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNjYyNDAx", "url": "https://github.com/apache/helix/pull/1564#pullrequestreview-550662401", "createdAt": "2020-12-12T00:33:15Z", "commit": {"oid": "81168cfcea02098f8d8a035543dbcfd07de8ce91"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0c1aff3c382e5f12f7b92c52557ac1ca8f3e3d0", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/e0c1aff3c382e5f12f7b92c52557ac1ca8f3e3d0", "committedDate": "2020-12-14T20:09:28Z", "message": "Implement lock priority and notification"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2387deab9ff591635fab7b386ba1688922591b6f", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/2387deab9ff591635fab7b386ba1688922591b6f", "committedDate": "2020-12-14T20:09:28Z", "message": "add Lock constants"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bf3b8119746cf0b7136e1e79a2c11109ea2fcc3", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/7bf3b8119746cf0b7136e1e79a2c11109ea2fcc3", "committedDate": "2020-12-14T20:09:28Z", "message": "fix comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57e932bdb87ccb422a2d592d396cc6aa61f84d2f", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/57e932bdb87ccb422a2d592d396cc6aa61f84d2f", "committedDate": "2020-12-14T20:09:28Z", "message": "fix more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfafd44346bbaae65d78bc23addef41b8c1a3444", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/cfafd44346bbaae65d78bc23addef41b8c1a3444", "committedDate": "2020-12-14T20:09:28Z", "message": "add validation etc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae927a3a8f7cf48965fc32f06d81eef54a1e3dba", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/ae927a3a8f7cf48965fc32f06d81eef54a1e3dba", "committedDate": "2020-12-14T20:09:28Z", "message": "add comments and refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "854f48c22869e417367f9d3525c07faa0eead451", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/854f48c22869e417367f9d3525c07faa0eead451", "committedDate": "2020-12-14T20:09:28Z", "message": "simplify code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e821424d14e3e269ecd2b7cd4a70819c1a50edf6", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/e821424d14e3e269ecd2b7cd4a70819c1a50edf6", "committedDate": "2020-12-14T20:09:28Z", "message": "change constructor to private"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "81168cfcea02098f8d8a035543dbcfd07de8ce91", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/81168cfcea02098f8d8a035543dbcfd07de8ce91", "committedDate": "2020-12-09T22:59:06Z", "message": "change constructor to private"}, "afterCommit": {"oid": "e821424d14e3e269ecd2b7cd4a70819c1a50edf6", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/e821424d14e3e269ecd2b7cd4a70819c1a50edf6", "committedDate": "2020-12-14T20:09:28Z", "message": "change constructor to private"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4152, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}