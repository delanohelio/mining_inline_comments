{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMwODcwMTk2", "number": 1072, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjozMToyOFrOEDpisQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1OTo1NlrOExSYLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjYxODA5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjozMToyOFrOGgyojg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo1NjoxOVrOGg0O6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNzE5OA==", "bodyText": "Thanks for adding this test! One favor to ask - we are actually in the process of moving this class to zookeeper-api (#1070).\nDo you think we could hold off on this change until that is committed first to avoid merge conflicts?", "url": "https://github.com/apache/helix/pull/1072#discussion_r437037198", "createdAt": "2020-06-08T22:31:28Z", "author": {"login": "narendly"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -819,4 +820,45 @@ public void testAsyncWriteOperations() {\n       zkClient.delete(\"/tmp/asyncOversize\");\n     }\n   }\n+\n+  @Test(expectedExceptions = ZkMarshallingError.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b133cb349a4e6df655a7d1f5574338637920276"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MzQwMw==", "bodyText": "That's fine. Once the PR is committed, I will resolve the conflicts.", "url": "https://github.com/apache/helix/pull/1072#discussion_r437063403", "createdAt": "2020-06-08T23:56:19Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -819,4 +820,45 @@ public void testAsyncWriteOperations() {\n       zkClient.delete(\"/tmp/asyncOversize\");\n     }\n   }\n+\n+  @Test(expectedExceptions = ZkMarshallingError.class,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNzE5OA=="}, "originalCommit": {"oid": "8b133cb349a4e6df655a7d1f5574338637920276"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjYyNzIyOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjozNToyOVrOGgyt7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxODoxODoyMFrOGhWsbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzODU3NA==", "bodyText": "I agree that this is the right thing to do. Thanks for catching this and fixing this.\nOne concern I have is with the change of the exception type. I am not sure if changing it to ZkMarshallingError is the right thing to do because\n\nZkMarshallingError is usually thrown in and reserved for use in ZkSerializer implementations.\nChanging Exception types may cause backward-compatibility issues.\n\nWhat do you think?", "url": "https://github.com/apache/helix/pull/1072#discussion_r437038574", "createdAt": "2020-06-08T22:35:29Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1839,12 +1848,15 @@ protected void doRetry() {\n     });\n   }\n \n-  private void checkDataSizeLimit(byte[] data) {\n-    if (data != null && data.length > ZNRecord.SIZE_LIMIT) {\n-      LOG.error(\n-          \"Data size larger than 1M, will not write to zk. Data (first 1k): \" + new String(data)\n-              .substring(0, 1024));\n-      throw new ZkClientException(\"Data size larger than 1M\");\n+  private void checkDataSizeLimit(String path, byte[] data) {\n+    if (data == null) {\n+      return;\n+    }\n+\n+    int sizeLimit = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    if (data.length > sizeLimit) {\n+      throw new ZkMarshallingError(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b133cb349a4e6df655a7d1f5574338637920276"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MDQwMQ==", "bodyText": "These questions are valid and natural ones which I also thought about.\n\nThe reason I change it is I would like to make it consistent with serializer. In helix zkclient, the data size check is right after serializing. ZkMarshallingError could also indicate the serialized data still exceeds the limit. So I feel ZkMarshallingError is more accurate than ZkClientException.\nActually before version 1.0.0, the exception type is HelixException. So changing to ZkClientException already breaks backward-compatibility if it breaks. Considering recent 1.0.0 zookeeper-api module users(helix-core 1.0.0 is deprecated), if a user explicitly uses this raw zkclient and catches this runtime exception, that may break. But I am not sure if that really exists in 1.0.0 usage, considering the APIs don't explicitly signature ZkClientException.\n\nThough having these thoughts, I don't have a strong preference: we could keep the original exception type. If we would like to change the type, may be it is a good idea to do it in 1.0.1 to avoid future backward compatibility issue.", "url": "https://github.com/apache/helix/pull/1072#discussion_r437070401", "createdAt": "2020-06-09T00:23:04Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1839,12 +1848,15 @@ protected void doRetry() {\n     });\n   }\n \n-  private void checkDataSizeLimit(byte[] data) {\n-    if (data != null && data.length > ZNRecord.SIZE_LIMIT) {\n-      LOG.error(\n-          \"Data size larger than 1M, will not write to zk. Data (first 1k): \" + new String(data)\n-              .substring(0, 1024));\n-      throw new ZkClientException(\"Data size larger than 1M\");\n+  private void checkDataSizeLimit(String path, byte[] data) {\n+    if (data == null) {\n+      return;\n+    }\n+\n+    int sizeLimit = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    if (data.length > sizeLimit) {\n+      throw new ZkMarshallingError(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzODU3NA=="}, "originalCommit": {"oid": "8b133cb349a4e6df655a7d1f5574338637920276"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA5NzMzNA==", "bodyText": "To give you more context, ZkMarshallingError is something that was inherited from 101tec.zkclient library and explicitly thrown for ZkSerializer implementations. Since this is our ZkClient API-level check outside the serializer, I think ZkClientException.\nAlso, we've decided to convert all HelixExceptions to ZkClientException, so I think ZkClientException would be more appropriate for consistency.", "url": "https://github.com/apache/helix/pull/1072#discussion_r437097334", "createdAt": "2020-06-09T02:08:10Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1839,12 +1848,15 @@ protected void doRetry() {\n     });\n   }\n \n-  private void checkDataSizeLimit(byte[] data) {\n-    if (data != null && data.length > ZNRecord.SIZE_LIMIT) {\n-      LOG.error(\n-          \"Data size larger than 1M, will not write to zk. Data (first 1k): \" + new String(data)\n-              .substring(0, 1024));\n-      throw new ZkClientException(\"Data size larger than 1M\");\n+  private void checkDataSizeLimit(String path, byte[] data) {\n+    if (data == null) {\n+      return;\n+    }\n+\n+    int sizeLimit = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    if (data.length > sizeLimit) {\n+      throw new ZkMarshallingError(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzODU3NA=="}, "originalCommit": {"oid": "8b133cb349a4e6df655a7d1f5574338637920276"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYxMzM4NA==", "bodyText": "+1. Let's not change the exception type of this.", "url": "https://github.com/apache/helix/pull/1072#discussion_r437613384", "createdAt": "2020-06-09T17:52:56Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1839,12 +1848,15 @@ protected void doRetry() {\n     });\n   }\n \n-  private void checkDataSizeLimit(byte[] data) {\n-    if (data != null && data.length > ZNRecord.SIZE_LIMIT) {\n-      LOG.error(\n-          \"Data size larger than 1M, will not write to zk. Data (first 1k): \" + new String(data)\n-              .substring(0, 1024));\n-      throw new ZkClientException(\"Data size larger than 1M\");\n+  private void checkDataSizeLimit(String path, byte[] data) {\n+    if (data == null) {\n+      return;\n+    }\n+\n+    int sizeLimit = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    if (data.length > sizeLimit) {\n+      throw new ZkMarshallingError(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzODU3NA=="}, "originalCommit": {"oid": "8b133cb349a4e6df655a7d1f5574338637920276"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYyODAxNA==", "bodyText": "Thanks for the input. Resolved.", "url": "https://github.com/apache/helix/pull/1072#discussion_r437628014", "createdAt": "2020-06-09T18:18:20Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1839,12 +1848,15 @@ protected void doRetry() {\n     });\n   }\n \n-  private void checkDataSizeLimit(byte[] data) {\n-    if (data != null && data.length > ZNRecord.SIZE_LIMIT) {\n-      LOG.error(\n-          \"Data size larger than 1M, will not write to zk. Data (first 1k): \" + new String(data)\n-              .substring(0, 1024));\n-      throw new ZkClientException(\"Data size larger than 1M\");\n+  private void checkDataSizeLimit(String path, byte[] data) {\n+    if (data == null) {\n+      return;\n+    }\n+\n+    int sizeLimit = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    if (data.length > sizeLimit) {\n+      throw new ZkMarshallingError(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzODU3NA=="}, "originalCommit": {"oid": "8b133cb349a4e6df655a7d1f5574338637920276"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAwODcxOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzozMDo1MFrOGjT5XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNzoxMjo1MFrOG1-rmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTMyNA==", "bodyText": "I'm not sure if we can directly use the value ClientCnxn.packetLen. It is public and static.", "url": "https://github.com/apache/helix/pull/1072#discussion_r439679324", "createdAt": "2020-06-12T23:30:50Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -73,6 +84,10 @@\n   private static Logger LOG = LoggerFactory.getLogger(ZkClient.class);\n   private static long MAX_RECONNECT_INTERVAL_MS = 30000; // 30 seconds\n \n+  // Default value for system property jute.maxbuffer\n+  // It specifies the maximum size of the data that can be stored in a znode.\n+  private static final int DEFAULT_JUTE_MAXBUFFER = 0xfffff;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzExMjI0NQ==", "bodyText": "Answer is no. That one is different: it's for the response packet size and it's 4 MB. We are looking at server side jute.maxbuffer that is by default 1 MB in BinaryInputArchive. It does no harm to define our own private constant and the default value 1 MB is known.", "url": "https://github.com/apache/helix/pull/1072#discussion_r443112245", "createdAt": "2020-06-20T08:13:12Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -73,6 +84,10 @@\n   private static Logger LOG = LoggerFactory.getLogger(ZkClient.class);\n   private static long MAX_RECONNECT_INTERVAL_MS = 30000; // 30 seconds\n \n+  // Default value for system property jute.maxbuffer\n+  // It specifies the maximum size of the data that can be stored in a znode.\n+  private static final int DEFAULT_JUTE_MAXBUFFER = 0xfffff;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTMyNA=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxMjkzMQ==", "bodyText": "What if ZK changes the default max buffer in some new versions? Are we going to change this number accordingly? So my suggestion is that,\n\nWe fine the default value in Zookeeper code.\nif 1 is not possible, then we can just use the current SIZE_LIMIT for the default value.", "url": "https://github.com/apache/helix/pull/1072#discussion_r447212931", "createdAt": "2020-06-29T19:48:46Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -73,6 +84,10 @@\n   private static Logger LOG = LoggerFactory.getLogger(ZkClient.class);\n   private static long MAX_RECONNECT_INTERVAL_MS = 30000; // 30 seconds\n \n+  // Default value for system property jute.maxbuffer\n+  // It specifies the maximum size of the data that can be stored in a znode.\n+  private static final int DEFAULT_JUTE_MAXBUFFER = 0xfffff;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTMyNA=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3NDk1OA==", "bodyText": "@jiajunwang Rethinking about this, I don't think we need this margin. Eg. if we set jute.maxbuffer=1024KB, with the margin=24KB, when we write a znode 1023KB, it fails because 1023KB > 1000KB. This is confusing. So I don't think we should bring in the 24KB margin into custom jute.maxbuffer. Same as ZNRecord serializer write size limit, if we set it, we use the number directly without subtracting the margin.\nSo I think it is clear and transparent to use the configured value without subtracting the margin. What do you think?", "url": "https://github.com/apache/helix/pull/1072#discussion_r449374958", "createdAt": "2020-07-03T04:54:48Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -73,6 +84,10 @@\n   private static Logger LOG = LoggerFactory.getLogger(ZkClient.class);\n   private static long MAX_RECONNECT_INTERVAL_MS = 30000; // 30 seconds\n \n+  // Default value for system property jute.maxbuffer\n+  // It specifies the maximum size of the data that can be stored in a znode.\n+  private static final int DEFAULT_JUTE_MAXBUFFER = 0xfffff;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTMyNA=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDEwNTkwNQ==", "bodyText": "Then you run into the ZK server side buffer issue. The write might be done successfully, but the read will fail.\nI think we agreed to keep the margin until we bump up the ZK version to a newer one and the buffer issue should be fixed in that version.", "url": "https://github.com/apache/helix/pull/1072#discussion_r454105905", "createdAt": "2020-07-14T05:14:08Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -73,6 +84,10 @@\n   private static Logger LOG = LoggerFactory.getLogger(ZkClient.class);\n   private static long MAX_RECONNECT_INTERVAL_MS = 30000; // 30 seconds\n \n+  // Default value for system property jute.maxbuffer\n+  // It specifies the maximum size of the data that can be stored in a znode.\n+  private static final int DEFAULT_JUTE_MAXBUFFER = 0xfffff;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTMyNA=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI1NDY4MA==", "bodyText": "@jiajunwang For default value 1000KB in ZNRecord SIZE_LIMIT, we still leave a margin that is 24 KB. But for the value that users config jute.maxbuffer, we should honor it as what is done in ZNRecordSerializer. We don't leave a margin in ZNRecordSerializer, right? So if user configs jute.maxbuffer, we expect them to understand it well. Say they already consider a margin in the value jute.maxbuffer, we should not(users don't expect that, either) leave another redundant margin.\nSay a user sets jute.maxbuff to 975KB that they think it already leaves enough room as margin, we don't want to deduct it again 975 - 24 = 951KB as the real value. It would also surprise user: if data is 960KB that user expects it to be written successfully, but it actually fails because of the extra margin.\nSo for the custom value if a user setsjute.maxbuff, I don't think we should deduct the value with the 24KB margin.", "url": "https://github.com/apache/helix/pull/1072#discussion_r459254680", "createdAt": "2020-07-23T07:12:50Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -73,6 +84,10 @@\n   private static Logger LOG = LoggerFactory.getLogger(ZkClient.class);\n   private static long MAX_RECONNECT_INTERVAL_MS = 30000; // 30 seconds\n \n+  // Default value for system property jute.maxbuffer\n+  // It specifies the maximum size of the data that can be stored in a znode.\n+  private static final int DEFAULT_JUTE_MAXBUFFER = 0xfffff;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTMyNA=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAxMTYzOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzozMzo0N1rOGjT7Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDo1NTozN1rOGsjrpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTgxMQ==", "bodyText": "This is awkward. How about just create a constant for margin and deprecate the SIZE_LIMIT?", "url": "https://github.com/apache/helix/pull/1072#discussion_r439679811", "createdAt": "2020-06-12T23:33:47Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2216,4 +2236,24 @@ private void validateCurrentThread() {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    int zkClientSize = getWriteSizeLimit();\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient\n+    if (serializerSize > zkClientSize) {\n+      throw new IllegalStateException(\"ZNRecord serializer write size limit: \" + serializerSize\n+          + \" is greater than size limit in ZkClient: \" + zkClientSize);\n+    }\n+  }\n+\n+  private int getWriteSizeLimit() {\n+    // The size margin left in default SIZE_LIMIT\n+    int sizeMargin = DEFAULT_JUTE_MAXBUFFER - ZNRecord.SIZE_LIMIT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzExMTgzNw==", "bodyText": "ZNRecordSerializer is also using the SIZE_LIMIT to determine the actual size limit. Maybe we still need it. Otherwise, we still have sizeLimit = JUTE_MAXBUFFER - MARGIN. I understand this calculation is awkward, but just it is just a local variable. Or we could add one more constant for margin so we don't have to calculate it again here.", "url": "https://github.com/apache/helix/pull/1072#discussion_r443111837", "createdAt": "2020-06-20T08:06:02Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2216,4 +2236,24 @@ private void validateCurrentThread() {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    int zkClientSize = getWriteSizeLimit();\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient\n+    if (serializerSize > zkClientSize) {\n+      throw new IllegalStateException(\"ZNRecord serializer write size limit: \" + serializerSize\n+          + \" is greater than size limit in ZkClient: \" + zkClientSize);\n+    }\n+  }\n+\n+  private int getWriteSizeLimit() {\n+    // The size margin left in default SIZE_LIMIT\n+    int sizeMargin = DEFAULT_JUTE_MAXBUFFER - ZNRecord.SIZE_LIMIT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTgxMQ=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIwODU4NA==", "bodyText": "The main concern is that you introduced some internal logic that is not configurable or commented directly where the variables are defined. Who will be able to tell the margin is derived by the default max buffer size and the default size limit?\nFirst, this logic is not reasonable, why the margin is based on the default configs? Secondly, it introduces more chaos to our code.", "url": "https://github.com/apache/helix/pull/1072#discussion_r447208584", "createdAt": "2020-06-29T19:40:44Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2216,4 +2236,24 @@ private void validateCurrentThread() {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    int zkClientSize = getWriteSizeLimit();\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient\n+    if (serializerSize > zkClientSize) {\n+      throw new IllegalStateException(\"ZNRecord serializer write size limit: \" + serializerSize\n+          + \" is greater than size limit in ZkClient: \" + zkClientSize);\n+    }\n+  }\n+\n+  private int getWriteSizeLimit() {\n+    // The size margin left in default SIZE_LIMIT\n+    int sizeMargin = DEFAULT_JUTE_MAXBUFFER - ZNRecord.SIZE_LIMIT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTgxMQ=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxMDk2Nw==", "bodyText": "Just add a MARGIN value please.", "url": "https://github.com/apache/helix/pull/1072#discussion_r447210967", "createdAt": "2020-06-29T19:44:57Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2216,4 +2236,24 @@ private void validateCurrentThread() {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    int zkClientSize = getWriteSizeLimit();\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient\n+    if (serializerSize > zkClientSize) {\n+      throw new IllegalStateException(\"ZNRecord serializer write size limit: \" + serializerSize\n+          + \" is greater than size limit in ZkClient: \" + zkClientSize);\n+    }\n+  }\n+\n+  private int getWriteSizeLimit() {\n+    // The size margin left in default SIZE_LIMIT\n+    int sizeMargin = DEFAULT_JUTE_MAXBUFFER - ZNRecord.SIZE_LIMIT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTgxMQ=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3NTE0Mw==", "bodyText": "Same reply above: @jiajunwang Rethinking about this, I don't think we need this margin. Eg. if we set jute.maxbuffer=1024KB, with the margin=24KB, when we write a znode 1023KB, it fails because 1023KB > 1000KB. This is confusing. So I think we should not bring in the 24KB into custom jute.maxbuffer. Same as ZNRecord serializer write size limit, if we set it, we use the number directly without subtracting the margin.\nSo I think it is clear and transparent to use the configured value without subtracting the margin. What do you think?\nLet's use the thread above to discuss.", "url": "https://github.com/apache/helix/pull/1072#discussion_r449375143", "createdAt": "2020-07-03T04:55:37Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2216,4 +2236,24 @@ private void validateCurrentThread() {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    int zkClientSize = getWriteSizeLimit();\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient\n+    if (serializerSize > zkClientSize) {\n+      throw new IllegalStateException(\"ZNRecord serializer write size limit: \" + serializerSize\n+          + \" is greater than size limit in ZkClient: \" + zkClientSize);\n+    }\n+  }\n+\n+  private int getWriteSizeLimit() {\n+    // The size margin left in default SIZE_LIMIT\n+    int sizeMargin = DEFAULT_JUTE_MAXBUFFER - ZNRecord.SIZE_LIMIT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTgxMQ=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAxNDc4OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzozNjoyMlrOGjT9Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOTo1MjoxOFrOGqf08Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MDI4Mw==", "bodyText": "With compression on, the serializer may always return a much smaller package than the input size.\nSo do we have to fail it here?\nIt is debatable.", "url": "https://github.com/apache/helix/pull/1072#discussion_r439680283", "createdAt": "2020-06-12T23:36:22Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2216,4 +2236,24 @@ private void validateCurrentThread() {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    int zkClientSize = getWriteSizeLimit();\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient\n+    if (serializerSize > zkClientSize) {\n+      throw new IllegalStateException(\"ZNRecord serializer write size limit: \" + serializerSize", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzExMjc0Mw==", "bodyText": "In this case, we could add one more check for compression on/off. If compression is turned on, we allow serializerSize > zkClientSize. Agreed?", "url": "https://github.com/apache/helix/pull/1072#discussion_r443112743", "createdAt": "2020-06-20T08:19:33Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2216,4 +2236,24 @@ private void validateCurrentThread() {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    int zkClientSize = getWriteSizeLimit();\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient\n+    if (serializerSize > zkClientSize) {\n+      throw new IllegalStateException(\"ZNRecord serializer write size limit: \" + serializerSize", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MDI4Mw=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDgzMw==", "bodyText": "Let's just keep it strict for now.", "url": "https://github.com/apache/helix/pull/1072#discussion_r447214833", "createdAt": "2020-06-29T19:52:18Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2216,4 +2236,24 @@ private void validateCurrentThread() {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    int zkClientSize = getWriteSizeLimit();\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient\n+    if (serializerSize > zkClientSize) {\n+      throw new IllegalStateException(\"ZNRecord serializer write size limit: \" + serializerSize", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MDI4Mw=="}, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NzE4NTE4OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOTo1MDo1OFrOGqfyQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOTo1MDo1OFrOGqfyQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDE0NQ==", "bodyText": "So according to what I comment before, the logic here can be,\nif (value of ZkSystemPropertyKeys.JUTE_MAXBUFFER exits) {\nreturn value of ZkSystemPropertyKeys.JUTE_MAXBUFFER - MARGIN;\n} else {\nreturn SIZE_LIMIT;\n}", "url": "https://github.com/apache/helix/pull/1072#discussion_r447214145", "createdAt": "2020-06-29T19:50:58Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2216,4 +2236,24 @@ private void validateCurrentThread() {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    int zkClientSize = getWriteSizeLimit();\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient\n+    if (serializerSize > zkClientSize) {\n+      throw new IllegalStateException(\"ZNRecord serializer write size limit: \" + serializerSize\n+          + \" is greater than size limit in ZkClient: \" + zkClientSize);\n+    }\n+  }\n+\n+  private int getWriteSizeLimit() {\n+    // The size margin left in default SIZE_LIMIT\n+    int sizeMargin = DEFAULT_JUTE_MAXBUFFER - ZNRecord.SIZE_LIMIT;\n+\n+    // jute.maxbuffer is not directly used as size limit in ZkClient.\n+    // Instead, leave some margin as ZNRecord.SIZE_LIMIT and use (jute.maxbuffer - sizeMargin)\n+    return Integer.getInteger(ZkSystemPropertyKeys.JUTE_MAXBUFFER, DEFAULT_JUTE_MAXBUFFER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77e0198c0f371a34b716a3df5b95da9e44ef1b80"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTE1NTE0OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/ZkSystemPropertyKeys.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1NjowOVrOHnV80w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1NjowOVrOHnV80w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNjE0Nw==", "bodyText": "Zookeeper has this String def since 3.5.2. It is in class ZKConfig.java. Please add a TODO here so we can use this one after we bump up the ZK version.", "url": "https://github.com/apache/helix/pull/1072#discussion_r511016147", "createdAt": "2020-10-23T16:56:09Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/ZkSystemPropertyKeys.java", "diffHunk": "@@ -60,4 +60,7 @@\n    */\n   public static final String ZK_AUTOSYNC_ENABLED =\n       \"zk.zkclient.autosync.enabled\";\n+\n+  /** System property key for jute.maxbuffer */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deef5f04141035ef1ff836f09af93cf1195a7222"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTE2NzgzOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1OTo1NlrOHnWExQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1OTo1NlrOHnWExQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxODE4MQ==", "bodyText": "nit, but I prefer not to repeat the message that has been mentioned in the exception in the code comment.", "url": "https://github.com/apache/helix/pull/1072#discussion_r511018181", "createdAt": "2020-10-23T16:59:56Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2492,4 +2500,15 @@ private void checkNumChildrenLimit(String path) throws KeeperException {\n           stat.getNumChildren(), NUM_CHILDREN_LIMIT);\n     }\n   }\n+\n+  private void validateWriteSizeLimitConfig() {\n+    int serializerSize = ZNRecordUtil.getSerializerWriteSizeLimit();\n+    LOG.info(\"ZNRecord serializer write size limit: {}; ZkClient write size limit: {}\",\n+        serializerSize, WRITE_SIZE_LIMIT);\n+    // ZNRecord serializer write size limit should not be set greater than size limit in ZkClient", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deef5f04141035ef1ff836f09af93cf1195a7222"}, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1142, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}