{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MDA2MjMz", "number": 789, "title": "Add FederatedZkClient", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nImplements #779\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nFederatedZkClient (One FederatedZkClient, multiple Zookeeper sessions inside)\n\nSome Helix Java APIs such as HelixAdmin can only perform CRUD operations.\nIn order to enable such Java APIs to operate against multiple Zookeeper realms, we will create FederatedZkClient, which is a new version of ZkClient that could replace the existing HelixZkClient used by CRUD-only Java APIs.\nFederatedZkClient will internally maintain multiple ZooKeeper sessions connecting to different ZooKeeper realms on an as-needed basis.\nBy creating and maintaining multiple ZooKeeper sessions, FederatedZkClient will route incoming ZooKeeper requests to the appropriate ZooKeeper sessions based on the ZK path sharding key.\n\nFederatedZkClient (implements RealmAwareZkClient)\n\nAn implementation of RealmAwareZkClient that connects to multiple ZK realms.\nSupports CRUD + change subscription.\n\nTests\n\n\n The following tests are written for this issue:\n\n\nTestFederatedZkClient\n\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n\n[INFO] --- maven-surefire-plugin:3.0.0-M3:test (default-test) @ zookeeper-api ---\n[INFO]\n[INFO] -------------------------------------------------------\n[INFO]  T E S T S\n[INFO] -------------------------------------------------------\n[INFO] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.024 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO]\n[INFO] --- maven-surefire-plugin:3.0.0-M3:test (multi-zk) @ zookeeper-api ---\n[INFO]\n[INFO] -------------------------------------------------------\n[INFO]  T E S T S\n[INFO] -------------------------------------------------------\n\n[INFO] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.032 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  6.370 s\n[INFO] Finished at: 2020-02-22T18:01:25-08:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-20T22:26:03Z", "url": "https://github.com/apache/helix/pull/789", "merged": true, "mergeCommit": {"oid": "6b1ff7945c197c97fef8ba08137598c920d6fbd5"}, "closed": true, "closedAt": "2020-02-29T17:45:23Z", "author": {"login": "huizhilu"}, "timelineItems": {"totalCount": 48, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGS3lfAFqTM2MjI4MDcxOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcI_8eYgH2gAyMzc4MDA2MjMzOjc5YmU1NDUyNDlmNWI1NzFiNDg4ZmY0NjU3YmE1MWZmNGY1OTVlOWU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjgwNzE4", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-362280718", "createdAt": "2020-02-20T22:28:37Z", "commit": {"oid": "0657a6c5c083b74941f821cc482f3bdcef22d808"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyODozN1rOFslYew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyODozN1rOFslYew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDEzOQ==", "bodyText": "Let's try to have changes like this in a separate PR. Or you could create an issue and we could batch process them later.", "url": "https://github.com/apache/helix/pull/789#discussion_r382294139", "createdAt": "2020-02-20T22:28:37Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -65,6 +66,11 @@ private void postConstruct() {\n     buildMetadataStoreDirectory(_namespace, helixRestNamespace.getMetadataStoreAddress());\n   }\n \n+  @PreDestroy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0657a6c5c083b74941f821cc482f3bdcef22d808"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0657a6c5c083b74941f821cc482f3bdcef22d808", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/0657a6c5c083b74941f821cc482f3bdcef22d808", "committedDate": "2020-02-20T22:22:56Z", "message": "Implement FederatedZkClient."}, "afterCommit": {"oid": "d7667b3ac39e303ea56d400cee03513ebcedb9c1", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/d7667b3ac39e303ea56d400cee03513ebcedb9c1", "committedDate": "2020-02-20T22:38:20Z", "message": "Add FederatedZkClient."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7667b3ac39e303ea56d400cee03513ebcedb9c1", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/d7667b3ac39e303ea56d400cee03513ebcedb9c1", "committedDate": "2020-02-20T22:38:20Z", "message": "Add FederatedZkClient."}, "afterCommit": {"oid": "ebdb7b631e4b693c9a938138ba88582786db7bcc", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/ebdb7b631e4b693c9a938138ba88582786db7bcc", "committedDate": "2020-02-20T22:41:02Z", "message": "Add FederatedZkClient."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ebdb7b631e4b693c9a938138ba88582786db7bcc", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/ebdb7b631e4b693c9a938138ba88582786db7bcc", "committedDate": "2020-02-20T22:41:02Z", "message": "Add FederatedZkClient."}, "afterCommit": {"oid": "0abb6dfd8a5e74b2234029d31ccb219bc98d16d3", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/0abb6dfd8a5e74b2234029d31ccb219bc98d16d3", "committedDate": "2020-02-21T01:19:35Z", "message": "Add FederatedZkClient."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0abb6dfd8a5e74b2234029d31ccb219bc98d16d3", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/0abb6dfd8a5e74b2234029d31ccb219bc98d16d3", "committedDate": "2020-02-21T01:19:35Z", "message": "Add FederatedZkClient."}, "afterCommit": {"oid": "54e5b5ace21e0ad807e14c2094672d2824dbc901", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/54e5b5ace21e0ad807e14c2094672d2824dbc901", "committedDate": "2020-02-21T01:42:49Z", "message": "Add FederatedZkClient."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "54e5b5ace21e0ad807e14c2094672d2824dbc901", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/54e5b5ace21e0ad807e14c2094672d2824dbc901", "committedDate": "2020-02-21T01:42:49Z", "message": "Add FederatedZkClient."}, "afterCommit": {"oid": "33b6d21115de8abc8038384d717b563c74ae8c63", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/33b6d21115de8abc8038384d717b563c74ae8c63", "committedDate": "2020-02-21T02:43:40Z", "message": "Add FederatedZkClient."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10929a3ab4124beea4fdae7aa88e0501c159c0fb", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/10929a3ab4124beea4fdae7aa88e0501c159c0fb", "committedDate": "2020-02-21T08:11:31Z", "message": "Add FederatedZkClient."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33b6d21115de8abc8038384d717b563c74ae8c63", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/33b6d21115de8abc8038384d717b563c74ae8c63", "committedDate": "2020-02-21T02:43:40Z", "message": "Add FederatedZkClient."}, "afterCommit": {"oid": "10929a3ab4124beea4fdae7aa88e0501c159c0fb", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/10929a3ab4124beea4fdae7aa88e0501c159c0fb", "committedDate": "2020-02-21T08:11:31Z", "message": "Add FederatedZkClient."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19cb6d10d71e204193305f85fe4ed59aca4eebc3", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/19cb6d10d71e204193305f85fe4ed59aca4eebc3", "committedDate": "2020-02-21T08:32:12Z", "message": "Polish close()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyOTkzNTU4", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-362993558", "createdAt": "2020-02-22T00:54:58Z", "commit": {"oid": "19cb6d10d71e204193305f85fe4ed59aca4eebc3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMDo1NDo1OVrOFtIcqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMDo1NDo1OVrOFtIcqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2ODY1MA==", "bodyText": "We will remove this metadata store routing data in param once http routing data reader is ready.", "url": "https://github.com/apache/helix/pull/789#discussion_r382868650", "createdAt": "2020-02-22T00:54:59Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,486 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cb6d10d71e204193305f85fe4ed59aca4eebc3"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDQ3Mjg0", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-363047284", "createdAt": "2020-02-22T19:47:45Z", "commit": {"oid": "19cb6d10d71e204193305f85fe4ed59aca4eebc3"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOTo0Nzo0NVrOFtMmeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOTo1NjowN1rOFtMorg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNjY5Ng==", "bodyText": "Nit: Should we tell people to use DedicatdZkClient instead of DedicatedZkClientFactory?", "url": "https://github.com/apache/helix/pull/789#discussion_r382936696", "createdAt": "2020-02-22T19:47:45Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,486 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;\n+    try {\n+      zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+    } catch (NoSuchElementException ex) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    if (zkRealm == null || zkRealm.isEmpty()) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    return zkRealm;\n+  }\n+\n+  private ZkClient createZkClient(String zkAddress) {\n+    LOG.debug(\"Creating ZkClient for realm: {}.\", zkAddress);\n+    return new ZkClient(new ZkConnection(zkAddress), (int) _clientConfig.getConnectInitTimeout(),\n+        _clientConfig.getOperationRetryTimeout(), _pathBasedZkSerializer,\n+        _clientConfig.getMonitorType(), _clientConfig.getMonitorKey(),\n+        _clientConfig.getMonitorInstanceName(), _clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  private void throwUnsupportedOperationException() {\n+    throw new UnsupportedOperationException(\n+        \"Session-aware operation is not supported by \" + FEDERATED_ZK_CLIENT\n+            + \". Instead, please use \" + DEDICATED_ZK_CLIENT_FACTORY + \" for this operation\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cb6d10d71e204193305f85fe4ed59aca4eebc3"}, "originalPosition": 551}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNzI2Mg==", "bodyText": "Great job on writing tests cases to cover all unsupported operations! This test looks great.\nOne more test case if I may suggest adding for FederatedZkClient is doing two writes to two different paths (path A and path B) where the two paths map to different ZK realms.\nFirst, instrument the MetadataStoreRoutingData so that paths A and B have sharding keys that map to two different ZK realms. Then use the same FederatedZkClient to write to paths A and B.\nThen create two single-realm ZkClients connected to the two realms respectively, and check that the data/ZNode you wrote to path A is in one ZK realm and not in the other, and vice versa.\nDo you think that would be a good test case that tests FederatedZkClient's multi-realm functionality? :)", "url": "https://github.com/apache/helix/pull/789#discussion_r382937262", "createdAt": "2020-02-22T19:56:07Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestFederatedZkClient.java", "diffHunk": "@@ -0,0 +1,252 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestFederatedZkClient extends ZkTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cb6d10d71e204193305f85fe4ed59aca4eebc3"}, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e297080761a1622c319185e9a694993bc788a02b", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/e297080761a1622c319185e9a694993bc788a02b", "committedDate": "2020-02-22T23:04:25Z", "message": "Test multi realm"}, "afterCommit": {"oid": "d0395a77e2e6feae854278253737470e48266896", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/d0395a77e2e6feae854278253737470e48266896", "committedDate": "2020-02-23T00:00:16Z", "message": "Test multi realm"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0395a77e2e6feae854278253737470e48266896", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/d0395a77e2e6feae854278253737470e48266896", "committedDate": "2020-02-23T00:00:16Z", "message": "Test multi realm"}, "afterCommit": {"oid": "8c73e3baf79bb5869626a93e023a830fc1b67305", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/8c73e3baf79bb5869626a93e023a830fc1b67305", "committedDate": "2020-02-23T00:12:17Z", "message": "Test multi realm"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c73e3baf79bb5869626a93e023a830fc1b67305", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/8c73e3baf79bb5869626a93e023a830fc1b67305", "committedDate": "2020-02-23T00:12:17Z", "message": "Test multi realm"}, "afterCommit": {"oid": "f8ebe9d1e38fca6c95a568448a290ad8f6b0f944", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/f8ebe9d1e38fca6c95a568448a290ad8f6b0f944", "committedDate": "2020-02-23T00:23:51Z", "message": "Test multi realm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5c0213723dc88e8d14061a886ea6fbc72b3ddec", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/f5c0213723dc88e8d14061a886ea6fbc72b3ddec", "committedDate": "2020-02-23T00:28:30Z", "message": "Test multi realm"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f8ebe9d1e38fca6c95a568448a290ad8f6b0f944", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/f8ebe9d1e38fca6c95a568448a290ad8f6b0f944", "committedDate": "2020-02-23T00:23:51Z", "message": "Test multi realm"}, "afterCommit": {"oid": "f5c0213723dc88e8d14061a886ea6fbc72b3ddec", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/f5c0213723dc88e8d14061a886ea6fbc72b3ddec", "committedDate": "2020-02-23T00:28:30Z", "message": "Test multi realm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDU5Mjk2", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-363059296", "createdAt": "2020-02-23T01:02:10Z", "commit": {"oid": "f5c0213723dc88e8d14061a886ea6fbc72b3ddec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QwMTowMjoxMFrOFtNqWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QwMTowMjoxMFrOFtNqWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NDA3NA==", "bodyText": "This is not necessary when the tests are being run by maven's surefire-plugin (what runs your mvn test's). Writing this block of code would be just for IntelliJ, so I wouldn't bother creating logic like this in your future tests.\nYou can have 2 or more ZKs in your tests, but we have two runs for a reason - we want to test it in a single ZK environment and also test it in a multi-ZK environment.", "url": "https://github.com/apache/helix/pull/789#discussion_r382954074", "createdAt": "2020-02-23T01:02:10Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestFederatedZkClient.java", "diffHunk": "@@ -0,0 +1,310 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.ZkServer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestFederatedZkClient extends ZkTestBase {\n+  private static final String TEST_SHARDING_KEY_PREFIX = \"/test_sharding_key_\";\n+  private static final String TEST_REALM_ONE_VALID_PATH = TEST_SHARDING_KEY_PREFIX + \"1/a/b/c\";\n+  private static final String TEST_REALM_TWO_VALID_PATH = TEST_SHARDING_KEY_PREFIX + \"2/x/y/z\";\n+  private static final String TEST_INVALID_PATH = TEST_SHARDING_KEY_PREFIX + \"invalid/a/b/c\";\n+  private static final String UNSUPPORTED_OPERATION_MESSAGE =\n+      \"Session-aware operation is not supported by FederatedZkClient.\";\n+\n+  private RealmAwareZkClient _realmAwareZkClient;\n+  // Need to start an extra ZK server for multi-realm test, if only one ZK server is running.\n+  private String _extraZkRealm;\n+  private ZkServer _extraZkServer;\n+\n+  @BeforeClass\n+  public void beforeClass() throws InvalidRoutingDataException {\n+    System.out.println(\"Starting \" + TestFederatedZkClient.class.getSimpleName());\n+\n+    // Populate rawRoutingData\n+    // <Realm, List of sharding keys> Mapping\n+    Map<String, List<String>> rawRoutingData = new HashMap<>();\n+    for (int i = 0; i < _numZk; i++) {\n+      List<String> shardingKeyList = Collections.singletonList(TEST_SHARDING_KEY_PREFIX + (i + 1));\n+      String realmName = ZK_PREFIX + (ZK_START_PORT + i);\n+      rawRoutingData.put(realmName, shardingKeyList);\n+    }\n+\n+    if (rawRoutingData.size() < 2) {\n+      System.out.println(\"There is only one ZK realm. Starting one more ZK to test multi-realm.\");\n+      _extraZkRealm = ZK_PREFIX + (ZK_START_PORT + 1);\n+      _extraZkServer = startZkServer(_extraZkRealm);\n+      // RealmTwo's sharding key: /test_sharding_key_2\n+      List<String> shardingKeyList = Collections.singletonList(TEST_SHARDING_KEY_PREFIX + \"2\");\n+      rawRoutingData.put(_extraZkRealm, shardingKeyList);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5c0213723dc88e8d14061a886ea6fbc72b3ddec"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDU5MzQ4", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-363059348", "createdAt": "2020-02-23T01:04:23Z", "commit": {"oid": "f5c0213723dc88e8d14061a886ea6fbc72b3ddec"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "committedDate": "2020-02-23T02:03:26Z", "message": "Make _numZk static"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjgwOTYw", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-362280960", "createdAt": "2020-02-20T22:29:04Z", "commit": {"oid": "0657a6c5c083b74941f821cc482f3bdcef22d808"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyOTowNFrOFslZPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyOTowNFrOFslZPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDMzNQ==", "bodyText": "Could the _metadataStoreDirectory to be null?", "url": "https://github.com/apache/helix/pull/789#discussion_r382294335", "createdAt": "2020-02-20T22:29:04Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -65,6 +66,11 @@ private void postConstruct() {\n     buildMetadataStoreDirectory(_namespace, helixRestNamespace.getMetadataStoreAddress());\n   }\n \n+  @PreDestroy\n+  private void preDestroy() {\n+    _metadataStoreDirectory.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0657a6c5c083b74941f821cc482f3bdcef22d808"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NDgwOTEx", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-364480911", "createdAt": "2020-02-25T22:00:21Z", "commit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjoxNzoxOVrOFuXSTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjoyNzo0M1rOFuXkGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MDMzMw==", "bodyText": "initialize this variable.\nmaybe to null?", "url": "https://github.com/apache/helix/pull/789#discussion_r384160333", "createdAt": "2020-02-25T22:17:19Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 526}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjI3NA==", "bodyText": "concurrentMap, we should use  PutIfAbsent(), no need to reinvent the wheel, which may not be right.\nSee here. https://stackoverflow.com/questions/10743622/concurrenthashmap-avoid-extra-object-creation-with-putifabsent", "url": "https://github.com/apache/helix/pull/789#discussion_r384162274", "createdAt": "2020-02-25T22:21:36Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 513}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NDg5MQ==", "bodyText": "Is this _metadataStoreRoutingData query thread safe?\n@narendly, @dasahcc.\nThis need to be validated.", "url": "https://github.com/apache/helix/pull/789#discussion_r384164891", "createdAt": "2020-02-25T22:27:43Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;\n+    try {\n+      zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 528}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTAwMjMz", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-364500233", "createdAt": "2020-02-25T22:35:05Z", "commit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozNTowNlrOFuXw2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozNTowNlrOFuXw2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODE1NA==", "bodyText": "Nit, this can be done in the declaration place and make the _zkRealmToZkClientMap final.", "url": "https://github.com/apache/helix/pull/789#discussion_r384168154", "createdAt": "2020-02-25T22:35:06Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTAyMDUy", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-364502052", "createdAt": "2020-02-25T22:38:28Z", "commit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozODoyOFrOFuX2zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozODoyOFrOFuX2zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2OTY3Nw==", "bodyText": "Using this way to collect stats, we have individual internal dedicated zkclient stats. We can't have aggregated stats.\nThe question is that do we want to have collective status for one federatedZkClient?", "url": "https://github.com/apache/helix/pull/789#discussion_r384169677", "createdAt": "2020-02-25T22:38:28Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;\n+    try {\n+      zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+    } catch (NoSuchElementException ex) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    if (zkRealm == null || zkRealm.isEmpty()) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    return zkRealm;\n+  }\n+\n+  private ZkClient createZkClient(String zkAddress) {\n+    LOG.debug(\"Creating ZkClient for realm: {}.\", zkAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 541}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NjQwMDQy", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-364640042", "createdAt": "2020-02-26T06:02:11Z", "commit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNjowMjoxMVrOFufI7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNzoxMTo0OFrOFugQ9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4OTAwNg==", "bodyText": "Like @narendly said, It is final.", "url": "https://github.com/apache/helix/pull/789#discussion_r384289006", "createdAt": "2020-02-26T06:02:11Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODE1NA=="}, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MDA4OQ==", "bodyText": "Initializing it with null is redundant.", "url": "https://github.com/apache/helix/pull/789#discussion_r384290089", "createdAt": "2020-02-26T06:06:20Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MDMzMw=="}, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 526}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MDk5NQ==", "bodyText": "Like @narendly said, _metadataStoreRoutingData does not allow modification/write once it is built. So multi-threading read is safe.", "url": "https://github.com/apache/helix/pull/789#discussion_r384290995", "createdAt": "2020-02-26T06:10:06Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;\n+    try {\n+      zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NDg5MQ=="}, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 528}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MTY5OA==", "bodyText": "Issue is created for tracking: #812", "url": "https://github.com/apache/helix/pull/789#discussion_r384291698", "createdAt": "2020-02-26T06:12:52Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          _zkRealmToZkClientMap.put(zkRealm, createZkClient(zkRealm));\n+        }\n+      }\n+    }\n+\n+    return _zkRealmToZkClientMap.get(zkRealm);\n+  }\n+\n+  private String getZkRealm(String path) {\n+    String zkRealm;\n+    try {\n+      zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+    } catch (NoSuchElementException ex) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    if (zkRealm == null || zkRealm.isEmpty()) {\n+      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    }\n+\n+    return zkRealm;\n+  }\n+\n+  private ZkClient createZkClient(String zkAddress) {\n+    LOG.debug(\"Creating ZkClient for realm: {}.\", zkAddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2OTY3Nw=="}, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 541}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwNzQ0Nw==", "bodyText": "@kaisun2000 Thanks for the suggestion. I am glad we got to this point.\n\nDid you mean putIfAbsent(zkRealm, createZkClient(zkRealm))? I did thought about it. However, it actually does not satisfy my expectation. putIfAbsent(zkRealm, createZkClient(zkRealm)) runs createZkClient(zkRealm) every time, no matter if zkRealm presents or not. As you already know, creating a zkclient costs a lot of overhead: creating native zk instance, zk event thread, wait until connected, etc.. We definitely don't want to create a zkclient every time even one is already available, right?\nThen is there another API that could solve the pain we have above so no new zkclient is created if there is already one? Yes, that is computeIfAbsent(). We can make one time init and get() together as clean as map.computeIfAbsent(zkRealm, zkclient -> createZkClient()). This looks pretty good, right? But my only concern is that the get performance of computeIfAbsent() is not as good as simply a get(zkRealm). Because internally in ConcurrentHashMap's implementation, computeIfAbsent() always synchronized the node/table, while get() directly reads the transient volatile table without synchonized/lock, which has a better performance over computeIfAbsent().\n'get()' + synchronized. Back to our use case, read is much much more than create/write because creation is only one time for each ZkClient. And I think the synchronized code block here is correct. This way makes sure creation/put is thread-safe, one time initialization does not hurt too much performance because read much heavier than write in our case.\n\nSo I believe get() + synchronized satisfy us better. What do you think?", "url": "https://github.com/apache/helix/pull/789#discussion_r384307447", "createdAt": "2020-02-26T07:11:48Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    if (isClosed()) {\n+      throw new IllegalStateException(FEDERATED_ZK_CLIENT + \" is closed!\");\n+    }\n+\n+    String zkRealm = getZkRealm(path);\n+    if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjI3NA=="}, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 513}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8099905aaac6b1993aedbac0701b4ceb65269c88", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/8099905aaac6b1993aedbac0701b4ceb65269c88", "committedDate": "2020-02-26T22:22:07Z", "message": "Use computeIfAbsent() to create zkclient and add to map."}, "afterCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/05c65577efd6f38ecc578713e8e9d3b26f1e26e1", "committedDate": "2020-02-23T02:03:26Z", "message": "Make _numZk static"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzU3ODI1", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-365357825", "createdAt": "2020-02-27T01:19:29Z", "commit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMToxOTozMFrOFvCMxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMToxOTozMFrOFvCMxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2MzQzMQ==", "bodyText": "Document the threading model change here. Namely that listeners (data/children) for ZKpath in different realm potentially can be invoked concurrently.  This means user should take care of currency issue in the listener implementation.", "url": "https://github.com/apache/helix/pull/789#discussion_r384863431", "createdAt": "2020-02-27T01:19:30Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzYzOTQx", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-365363941", "createdAt": "2020-02-27T01:39:57Z", "commit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTozOTo1N1rOFvCheQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTozOTo1N1rOFvCheQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODcyOQ==", "bodyText": "Nit: usually we put the log at the very end. So move to the end of this method and say FederatedZkClient closed successfully?", "url": "https://github.com/apache/helix/pull/789#discussion_r384868729", "createdAt": "2020-02-27T01:39:57Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 447}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzY0ODcy", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-365364872", "createdAt": "2020-02-27T01:43:17Z", "commit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTo0MzoxOFrOFvCk8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTo0MzoxOFrOFvCk8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTYxOA==", "bodyText": "This is not thread safe way to closing. As discussed. We need to fix it.", "url": "https://github.com/apache/helix/pull/789#discussion_r384869618", "createdAt": "2020-02-27T01:43:18Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,487 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c65577efd6f38ecc578713e8e9d3b26f1e26e1"}, "originalPosition": 443}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a373edc786324cbfc917fe8d51f8b28718c08b90", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/a373edc786324cbfc917fe8d51f8b28718c08b90", "committedDate": "2020-02-27T02:23:01Z", "message": "Make close() and getZkClient() thread safe."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Mzg4Mjk5", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-365388299", "createdAt": "2020-02-27T03:06:02Z", "commit": {"oid": "a373edc786324cbfc917fe8d51f8b28718c08b90"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzowNjowMlrOFvD21Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzowNjowMlrOFvD21Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MDU4MQ==", "bodyText": "Nit. remove empty line", "url": "https://github.com/apache/helix/pull/789#discussion_r384890581", "createdAt": "2020-02-27T03:06:02Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,506 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);\n+\n+    if (zkClient == null) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        // Check closed state again to avoid race condition and creating a new ZkClient\n+        // after FederatedZkClient is already closed.\n+        checkClosedState();\n+\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          zkClient = createZkClient(zkRealm);\n+          _zkRealmToZkClientMap.put(zkRealm, zkClient);\n+        }\n+      }\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a373edc786324cbfc917fe8d51f8b28718c08b90"}, "originalPosition": 534}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Mzg4NTg2", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-365388586", "createdAt": "2020-02-27T03:07:12Z", "commit": {"oid": "a373edc786324cbfc917fe8d51f8b28718c08b90"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzowNzoxM1rOFvD34w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzowNzoxM1rOFvD34w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MDg1MQ==", "bodyText": "This is good. Makes sense. This will help us avoid zkClient leaks. Good work!", "url": "https://github.com/apache/helix/pull/789#discussion_r384890851", "createdAt": "2020-02-27T03:07:13Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,506 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);\n+\n+    if (zkClient == null) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {\n+        // Check closed state again to avoid race condition and creating a new ZkClient\n+        // after FederatedZkClient is already closed.\n+        checkClosedState();\n+\n+        if (!_zkRealmToZkClientMap.containsKey(zkRealm)) {\n+          zkClient = createZkClient(zkRealm);\n+          _zkRealmToZkClientMap.put(zkRealm, zkClient);\n+        }\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a373edc786324cbfc917fe8d51f8b28718c08b90"}, "originalPosition": 533}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Mzg5ODky", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-365389892", "createdAt": "2020-02-27T03:12:06Z", "commit": {"oid": "a373edc786324cbfc917fe8d51f8b28718c08b90"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxMjowN1rOFvD8Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxMjowN1rOFvD8Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTkzMA==", "bodyText": "It will never return null though right? There are only 2 outcomes that are possible - 1) we return a newly created ZkClient or 2) we throw an exception and not return anything.\nIf you actually create a reference here, you might end up returning null. Consider the following scenario:\n\nZkClient hasn't been created, so zkClient is null.\nSince zkClient is null, it waits for the lock for _zkRealmToZkClientMap\nWhile waiting, some other thread creates the zkClient and puts it in the map\nI finally get the lock, enter the critical section, FederatedZkClient not closed, and reach the containsKey block.\ncontainsKey returns true (because some other thread created and put it in the map already), so you skip the entire creation block without updating the reference to zkClient.\nyou return zkClient, which is still null\n\nEither 1) you go back to using ConcurrentHashMap's containsKey primitive or 2) you'll have to add an else clause that updates the reference by doing\nelse {\n  zkClient = _zkRealmToZkClientMap.get(zkRealm);\n}\n\nOr 3) you could use computeIfAbsent but this option is slow, so not desirable.", "url": "https://github.com/apache/helix/pull/789#discussion_r384891930", "createdAt": "2020-02-27T03:12:07Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,506 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a373edc786324cbfc917fe8d51f8b28718c08b90"}, "originalPosition": 518}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/451276a1f31c046fabcc9770e3f3b8b5034aaf44", "committedDate": "2020-02-27T04:06:28Z", "message": "Fix potential NPE for returning zkclient."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDY1MDI2", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-366065026", "createdAt": "2020-02-27T23:11:39Z", "commit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzoxMTozOVrOFvkcLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzoxMTozOVrOFvkcLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyNDQyOA==", "bodyText": "This has nothing to do with \"order\" or sequential consistency in Zookeeper term. Let us don't confuse user with this consistency guarantee.\nFrom the user's perspective, they need to be aware their callback listerner can be invoked concurrently and should prepare to handle this concurrency accordingly, which is not the case before. Something like:\nFederated ZKClient is designed to perform CRUD operation across different zookeeper realms. It would handle data and node change notification. It does not support ephemeral node operation.\nFrom concurrency point of view, the callback notification can be invoked concurrently for ZK path in different zookeeper realm. This is different from other ZkClient which will invoke the callback in one thread. Thus, it is the user's responsibility to take care this concurrency.", "url": "https://github.com/apache/helix/pull/789#discussion_r385424428", "createdAt": "2020-02-27T23:11:39Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDc4MjIx", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-366078221", "createdAt": "2020-02-27T23:46:28Z", "commit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzo0NjoyOFrOFvlGeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzo1Njo0NlrOFvlTEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNTI1OA==", "bodyText": "Please add a comment here that why this kind of double locking is working. The stackoverflow thread you found. Also, explain why here this is faster. This help people later maintaining the code understand why it is done this way.", "url": "https://github.com/apache/helix/pull/789#discussion_r385435258", "createdAt": "2020-02-27T23:46:28Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44"}, "originalPosition": 519}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNjM3NQ==", "bodyText": "Change the comment to state that this synchronize() is pair with close() synchronized. This is to avoid creating another internal dedicated ZkClient by thread A when thread B invoked close() which subsequently close all internal dedicated ZkClient.", "url": "https://github.com/apache/helix/pull/789#discussion_r385436375", "createdAt": "2020-02-27T23:50:12Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);\n+\n+    if (zkClient == null) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44"}, "originalPosition": 522}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNzc1Nw==", "bodyText": "Seems to me this is ok.\nWe can reason it this way. The code in this synchronized() is paired with code in close() synchronized block. Thus, there are only two possibilities.\nCase 1/ this block run first, the block in closed() run next. In this case, the newly created dedicated ZkClient in this block would be closed in the closed() block\nCase 2/ this block run after the block in close(). In this case, we would not create dedicated ZkClient due to the flag of closed is set.", "url": "https://github.com/apache/helix/pull/789#discussion_r385437757", "createdAt": "2020-02-27T23:54:38Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();\n+\n+    String zkRealm = getZkRealm(path);\n+\n+    // Use this zkClient reference to protect the returning zkClient from being null because of\n+    // race condition.\n+    ZkClient zkClient = _zkRealmToZkClientMap.get(zkRealm);\n+\n+    if (zkClient == null) {\n+      // Synchronized to avoid creating duplicate ZkClient for the same ZkRealm.\n+      synchronized (_zkRealmToZkClientMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44"}, "originalPosition": 523}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzNzk3MA==", "bodyText": "See the reasoning bellow, this is not necessary. Isn't it?", "url": "https://github.com/apache/helix/pull/789#discussion_r385437970", "createdAt": "2020-02-27T23:55:19Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -20,344 +20,508 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: while the ordering of handling data/child changes listeners in one single ZK realm is\n+ * guaranteed, listeners from different ZK realms are NOT guaranteed in order, which means listeners\n+ * from different ZK realms could be handled concurrently. So the concurrency of listeners should be\n+ * aware of when implementing listeners for different ZK realms.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n+\n+    LOG.info(\"Closing {}.\", FEDERATED_ZK_CLIENT);\n \n+    synchronized (_zkRealmToZkClientMap) {\n+      _zkRealmToZkClientMap.values().forEach(ZkClient::close);\n+      _zkRealmToZkClientMap.clear();\n+      _isClosed = true;\n+    }\n   }\n \n   @Override\n   public boolean isClosed() {\n-    return false;\n+    return _isClosed;\n   }\n \n   @Override\n   public byte[] serialize(Object data, String path) {\n-    return new byte[0];\n+    return getZkClient(path).serialize(data, path);\n   }\n \n   @Override\n   public <T> T deserialize(byte[] data, String path) {\n-    return null;\n+    return getZkClient(path).deserialize(data, path);\n   }\n \n   @Override\n   public void setZkSerializer(ZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = new BasicZkSerializer(zkSerializer);\n+    _zkRealmToZkClientMap.values()\n+        .forEach(zkClient -> zkClient.setZkSerializer(_pathBasedZkSerializer));\n   }\n \n   @Override\n   public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n-\n+    _pathBasedZkSerializer = zkSerializer;\n+    _zkRealmToZkClientMap.values().forEach(zkClient -> zkClient.setZkSerializer(zkSerializer));\n   }\n \n   @Override\n   public PathBasedZkSerializer getZkSerializer() {\n-    return null;\n+    return _pathBasedZkSerializer;\n+  }\n+\n+  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+      final CreateMode mode, final String expectedSessionId) {\n+    if (mode.isEphemeral()) {\n+      throwUnsupportedOperationException();\n+    }\n+\n+    // Create mode is not session-aware, so the node does not have to be created\n+    // by the expectedSessionId.\n+    return getZkClient(path).create(path, dataObject, acl, mode);\n+  }\n+\n+  private ZkClient getZkClient(String path) {\n+    // If FederatedZkClient is closed, should not return ZkClient.\n+    checkClosedState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44"}, "originalPosition": 513}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzODQ4MA==", "bodyText": "Can we add a test case that one thread close the FederatedZKClient and then another thread use it, which would generate exception?", "url": "https://github.com/apache/helix/pull/789#discussion_r385438480", "createdAt": "2020-02-27T23:56:46Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestFederatedZkClient.java", "diffHunk": "@@ -0,0 +1,310 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.ZkServer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestFederatedZkClient extends ZkTestBase {\n+  private static final String TEST_SHARDING_KEY_PREFIX = \"/test_sharding_key_\";\n+  private static final String TEST_REALM_ONE_VALID_PATH = TEST_SHARDING_KEY_PREFIX + \"1/a/b/c\";\n+  private static final String TEST_REALM_TWO_VALID_PATH = TEST_SHARDING_KEY_PREFIX + \"2/x/y/z\";\n+  private static final String TEST_INVALID_PATH = TEST_SHARDING_KEY_PREFIX + \"invalid/a/b/c\";\n+  private static final String UNSUPPORTED_OPERATION_MESSAGE =\n+      \"Session-aware operation is not supported by FederatedZkClient.\";\n+\n+  private RealmAwareZkClient _realmAwareZkClient;\n+  // Need to start an extra ZK server for multi-realm test, if only one ZK server is running.\n+  private String _extraZkRealm;\n+  private ZkServer _extraZkServer;\n+\n+  @BeforeClass\n+  public void beforeClass() throws InvalidRoutingDataException {\n+    System.out.println(\"Starting \" + TestFederatedZkClient.class.getSimpleName());\n+\n+    // Populate rawRoutingData\n+    // <Realm, List of sharding keys> Mapping\n+    Map<String, List<String>> rawRoutingData = new HashMap<>();\n+    for (int i = 0; i < _numZk; i++) {\n+      List<String> shardingKeyList = Collections.singletonList(TEST_SHARDING_KEY_PREFIX + (i + 1));\n+      String realmName = ZK_PREFIX + (ZK_START_PORT + i);\n+      rawRoutingData.put(realmName, shardingKeyList);\n+    }\n+\n+    if (rawRoutingData.size() < 2) {\n+      System.out.println(\"There is only one ZK realm. Starting one more ZK to test multi-realm.\");\n+      _extraZkRealm = ZK_PREFIX + (ZK_START_PORT + 1);\n+      _extraZkServer = startZkServer(_extraZkRealm);\n+      // RealmTwo's sharding key: /test_sharding_key_2\n+      List<String> shardingKeyList = Collections.singletonList(TEST_SHARDING_KEY_PREFIX + \"2\");\n+      rawRoutingData.put(_extraZkRealm, shardingKeyList);\n+    }\n+\n+    // Feed the raw routing data into TrieRoutingData to construct an in-memory representation\n+    // of routing information.\n+    _realmAwareZkClient = new FederatedZkClient(new RealmAwareZkClient.RealmAwareZkClientConfig(),\n+        new TrieRoutingData(rawRoutingData));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    // Close it as it is created in before class.\n+    _realmAwareZkClient.close();\n+\n+    // Close the extra zk server.\n+    if (_extraZkServer != null) {\n+      _extraZkServer.shutdown();\n+    }\n+\n+    System.out.println(\"Ending \" + TestFederatedZkClient.class.getSimpleName());\n+  }\n+\n+  /*\n+   * Tests that an unsupported operation should throw an UnsupportedOperationException.\n+   */\n+  @Test\n+  public void testUnsupportedOperations() {\n+    // Test creating ephemeral.\n+    try {\n+      _realmAwareZkClient.create(TEST_REALM_ONE_VALID_PATH, \"Hello\", CreateMode.EPHEMERAL);\n+      Assert.fail(\"Ephemeral node should not be created.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    // Test creating ephemeral sequential.\n+    try {\n+      _realmAwareZkClient\n+          .create(TEST_REALM_ONE_VALID_PATH, \"Hello\", CreateMode.EPHEMERAL_SEQUENTIAL);\n+      Assert.fail(\"Ephemeral node should not be created.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    List<Op> ops = Arrays.asList(\n+        Op.create(TEST_REALM_ONE_VALID_PATH, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+            CreateMode.PERSISTENT), Op.delete(TEST_REALM_ONE_VALID_PATH, -1));\n+    try {\n+      _realmAwareZkClient.multi(ops);\n+      Assert.fail(\"multi() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    try {\n+      _realmAwareZkClient.getSessionId();\n+      Assert.fail(\"getSessionId() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    try {\n+      _realmAwareZkClient.getServers();\n+      Assert.fail(\"getServers() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    try {\n+      _realmAwareZkClient.waitUntilConnected(5L, TimeUnit.SECONDS);\n+      Assert.fail(\"getServers() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    // Test state change subscription.\n+    IZkStateListener listener = new IZkStateListener() {\n+      @Override\n+      public void handleStateChanged(Watcher.Event.KeeperState state) {\n+        System.out.println(\"Handle new state: \" + state);\n+      }\n+\n+      @Override\n+      public void handleNewSession(String sessionId) {\n+        System.out.println(\"Handle new session: \" + sessionId);\n+      }\n+\n+      @Override\n+      public void handleSessionEstablishmentError(Throwable error) {\n+        System.out.println(\"Handle session establishment error: \" + error);\n+      }\n+    };\n+\n+    try {\n+      _realmAwareZkClient.subscribeStateChanges(listener);\n+      Assert.fail(\"getServers() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+\n+    try {\n+      _realmAwareZkClient.unsubscribeStateChanges(listener);\n+      Assert.fail(\"getServers() should not be supported.\");\n+    } catch (UnsupportedOperationException ex) {\n+      Assert.assertTrue(ex.getMessage().startsWith(UNSUPPORTED_OPERATION_MESSAGE));\n+    }\n+  }\n+\n+  /*\n+   * Tests the persistent create() call against a valid path and an invalid path.\n+   * Valid path is one that belongs to the realm designated by the sharding key.\n+   * Invalid path is one that does not belong to the realm designated by the sharding key.\n+   */\n+  @Test(dependsOnMethods = \"testUnsupportedOperations\")\n+  public void testCreatePersistent() {\n+    _realmAwareZkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // Create a dummy ZNRecord\n+    ZNRecord znRecord = new ZNRecord(\"DummyRecord\");\n+    znRecord.setSimpleField(\"Dummy\", \"Value\");\n+\n+    // Test writing and reading against the validPath\n+    _realmAwareZkClient.createPersistent(TEST_REALM_ONE_VALID_PATH, true);\n+    _realmAwareZkClient.writeData(TEST_REALM_ONE_VALID_PATH, znRecord);\n+    Assert.assertEquals(_realmAwareZkClient.readData(TEST_REALM_ONE_VALID_PATH), znRecord);\n+\n+    // Test writing and reading against the invalid path\n+    try {\n+      _realmAwareZkClient.createPersistent(TEST_INVALID_PATH, true);\n+      Assert.fail(\"Create() should not succeed on an invalid path!\");\n+    } catch (NoSuchElementException ex) {\n+      Assert\n+          .assertEquals(ex.getMessage(), \"Cannot find ZK realm for the path: \" + TEST_INVALID_PATH);\n+    }\n+  }\n+\n+  /*\n+   * Tests that exists() works on valid path and fails on invalid path.\n+   */\n+  @Test(dependsOnMethods = \"testCreatePersistent\")\n+  public void testExists() {\n+    Assert.assertTrue(_realmAwareZkClient.exists(TEST_REALM_ONE_VALID_PATH));\n+\n+    try {\n+      _realmAwareZkClient.exists(TEST_INVALID_PATH);\n+      Assert.fail(\"Exists() should not succeed on an invalid path!\");\n+    } catch (NoSuchElementException ex) {\n+      Assert\n+          .assertEquals(ex.getMessage(), \"Cannot find ZK realm for the path: \" + TEST_INVALID_PATH);\n+    }\n+  }\n+\n+  /*\n+   * Tests that delete() works on valid path and fails on invalid path.\n+   */\n+  @Test(dependsOnMethods = \"testExists\")\n+  public void testDelete() {\n+    try {\n+      _realmAwareZkClient.delete(TEST_INVALID_PATH);\n+      Assert.fail(\"Exists() should not succeed on an invalid path!\");\n+    } catch (NoSuchElementException ex) {\n+      Assert\n+          .assertEquals(ex.getMessage(), \"Cannot find ZK realm for the path: \" + TEST_INVALID_PATH);\n+    }\n+\n+    Assert.assertTrue(_realmAwareZkClient.delete(TEST_REALM_ONE_VALID_PATH));\n+    Assert.assertFalse(_realmAwareZkClient.exists(TEST_REALM_ONE_VALID_PATH));\n+  }\n+\n+  /*\n+   * Tests that multi-realm feature.\n+   */\n+  @Test(dependsOnMethods = \"testDelete\")\n+  public void testMultiRealmCRUD() {\n+    ZNRecord realmOneZnRecord = new ZNRecord(\"realmOne\");\n+    realmOneZnRecord.setSimpleField(\"realmOne\", \"Value\");\n+\n+    ZNRecord realmTwoZnRecord = new ZNRecord(\"realmTwo\");\n+    realmTwoZnRecord.setSimpleField(\"realmTwo\", \"Value\");\n+\n+    // Writing on realmOne.\n+    _realmAwareZkClient.createPersistent(TEST_REALM_ONE_VALID_PATH, true);\n+    _realmAwareZkClient.writeData(TEST_REALM_ONE_VALID_PATH, realmOneZnRecord);\n+\n+    // RealmOne path is created but realmTwo path is not.\n+    Assert.assertTrue(_realmAwareZkClient.exists(TEST_REALM_ONE_VALID_PATH));\n+    Assert.assertFalse(_realmAwareZkClient.exists(TEST_REALM_TWO_VALID_PATH));\n+\n+    // Writing on realmTwo.\n+    _realmAwareZkClient.createPersistent(TEST_REALM_TWO_VALID_PATH, true);\n+    _realmAwareZkClient.writeData(TEST_REALM_TWO_VALID_PATH, realmTwoZnRecord);\n+\n+    // RealmTwo path is created.\n+    Assert.assertTrue(_realmAwareZkClient.exists(TEST_REALM_TWO_VALID_PATH));\n+\n+    // Reading on both realms.\n+    Assert.assertEquals(_realmAwareZkClient.readData(TEST_REALM_ONE_VALID_PATH), realmOneZnRecord);\n+    Assert.assertEquals(_realmAwareZkClient.readData(TEST_REALM_TWO_VALID_PATH), realmTwoZnRecord);\n+\n+    Assert.assertTrue(_realmAwareZkClient.delete(TEST_REALM_ONE_VALID_PATH));\n+    Assert.assertFalse(_realmAwareZkClient.exists(TEST_REALM_ONE_VALID_PATH));\n+\n+    // Deleting on realmOne does not delete on realmTwo.\n+    Assert.assertTrue(_realmAwareZkClient.exists(TEST_REALM_TWO_VALID_PATH));\n+\n+    // Deleting on realmTwo.\n+    Assert.assertTrue(_realmAwareZkClient.delete(TEST_REALM_TWO_VALID_PATH));\n+    Assert.assertFalse(_realmAwareZkClient.exists(TEST_REALM_TWO_VALID_PATH));\n+  }\n+\n+  /*\n+   * Tests that close() works.\n+   */\n+  @Test(dependsOnMethods = \"testMultiRealmCRUD\")\n+  public void testClose() {\n+    Assert.assertFalse(_realmAwareZkClient.isClosed());\n+\n+    _realmAwareZkClient.close();\n+\n+    Assert.assertTrue(_realmAwareZkClient.isClosed());\n+\n+    // Client is closed, so operation should not be executed.\n+    try {\n+      _realmAwareZkClient.createPersistent(TEST_REALM_ONE_VALID_PATH);\n+      Assert\n+          .fail(\"createPersistent() should not be executed because RealmAwareZkClient is closed.\");\n+    } catch (IllegalStateException ex) {\n+      Assert.assertEquals(ex.getMessage(), \"FederatedZkClient is closed!\");\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44"}, "originalPosition": 309}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDkwMzI1", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-366090325", "createdAt": "2020-02-28T00:21:46Z", "commit": {"oid": "451276a1f31c046fabcc9770e3f3b8b5034aaf44"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32bd22d09a5521681e9a9eb485f487fe5cabed97", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/32bd22d09a5521681e9a9eb485f487fe5cabed97", "committedDate": "2020-02-28T07:06:12Z", "message": "Add neccessary comments."}, "afterCommit": {"oid": "8107874cd53ecab8a26a135587ff9f5e43a521ed", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/8107874cd53ecab8a26a135587ff9f5e43a521ed", "committedDate": "2020-02-28T07:09:44Z", "message": "Add neccessary comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2426c64efa980f6acb2d923dcee1136316ea7dd9", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/2426c64efa980f6acb2d923dcee1136316ea7dd9", "committedDate": "2020-02-28T07:14:56Z", "message": "Add neccessary comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8107874cd53ecab8a26a135587ff9f5e43a521ed", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/8107874cd53ecab8a26a135587ff9f5e43a521ed", "committedDate": "2020-02-28T07:09:44Z", "message": "Add neccessary comments."}, "afterCommit": {"oid": "2426c64efa980f6acb2d923dcee1136316ea7dd9", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/2426c64efa980f6acb2d923dcee1136316ea7dd9", "committedDate": "2020-02-28T07:14:56Z", "message": "Add neccessary comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c6d5c8be8e6f57d52f559090e08c56f987532cc", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/9c6d5c8be8e6f57d52f559090e08c56f987532cc", "committedDate": "2020-02-29T00:50:33Z", "message": "Set closed state before closing all zkClients."}, "afterCommit": {"oid": "a42e2823bdd23b3e148c47c94fda110318d5f583", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/a42e2823bdd23b3e148c47c94fda110318d5f583", "committedDate": "2020-02-29T01:25:09Z", "message": "Set closed state before closing all zkClients."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a42e2823bdd23b3e148c47c94fda110318d5f583", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/a42e2823bdd23b3e148c47c94fda110318d5f583", "committedDate": "2020-02-29T01:25:09Z", "message": "Set closed state before closing all zkClients."}, "afterCommit": {"oid": "182f1d3810896a7111aa4f4c5ec576fe6cea22cd", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/182f1d3810896a7111aa4f4c5ec576fe6cea22cd", "committedDate": "2020-02-29T01:26:14Z", "message": "Set closed state before closing all zkClients."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "182f1d3810896a7111aa4f4c5ec576fe6cea22cd", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/182f1d3810896a7111aa4f4c5ec576fe6cea22cd", "committedDate": "2020-02-29T01:26:14Z", "message": "Set closed state before closing all zkClients."}, "afterCommit": {"oid": "5410ef50a3133f613f2bbf8ce681345963562466", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/5410ef50a3133f613f2bbf8ce681345963562466", "committedDate": "2020-02-29T01:27:00Z", "message": "Set closed state before closing all zkClients."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4215b699f835e92f6797e49dcb5a32814fc7e5a0", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/4215b699f835e92f6797e49dcb5a32814fc7e5a0", "committedDate": "2020-02-29T01:28:46Z", "message": "Set closed state before closing all zkClients."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5410ef50a3133f613f2bbf8ce681345963562466", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/5410ef50a3133f613f2bbf8ce681345963562466", "committedDate": "2020-02-29T01:27:00Z", "message": "Set closed state before closing all zkClients."}, "afterCommit": {"oid": "4215b699f835e92f6797e49dcb5a32814fc7e5a0", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/4215b699f835e92f6797e49dcb5a32814fc7e5a0", "committedDate": "2020-02-29T01:28:46Z", "message": "Set closed state before closing all zkClients."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Nzc1NTUx", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-366775551", "createdAt": "2020-02-29T04:09:01Z", "commit": {"oid": "4215b699f835e92f6797e49dcb5a32814fc7e5a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNDowOTowMlrOFwHguA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNDowOTowMlrOFwHguA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5OTAzMg==", "bodyText": "Good!", "url": "https://github.com/apache/helix/pull/789#discussion_r385999032", "createdAt": "2020-02-29T04:09:02Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -19,345 +19,535 @@\n  * under the License.\n  */\n \n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import com.sun.istack.internal.NotNull;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n import org.apache.helix.zookeeper.zkclient.DataUpdater;\n import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n-import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.BasicZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.Op;\n import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implements and supports all ZK operations defined in interface {@link RealmAwareZkClient},\n+ * except for session-aware operations such as creating ephemeral nodes, for which\n+ * an {@link UnsupportedOperationException} will be thrown.\n+ * <p>\n+ * It acts as a single ZK client but will automatically route read/write/change subscription\n+ * requests to the corresponding ZkClient with the help of metadata store directory service.\n+ * It could connect to multiple ZK addresses and maintain a {@link ZkClient} for each ZK address.\n+ * <p>\n+ * Note: each Zk realm has its own event queue to handle listeners. So listeners from different ZK\n+ * realms could be handled concurrently because listeners of a ZK realm are handled in its own\n+ * queue. The concurrency of listeners should be aware of when implementing listeners for different\n+ * ZK realms. The users should use thread-safe data structures if they wish to handle change\n+ * callbacks.\n+ */\n+public class FederatedZkClient implements RealmAwareZkClient {\n+  private static final Logger LOG = LoggerFactory.getLogger(FederatedZkClient.class);\n \n+  private static final String FEDERATED_ZK_CLIENT = FederatedZkClient.class.getSimpleName();\n+  private static final String DEDICATED_ZK_CLIENT_FACTORY =\n+      DedicatedZkClientFactory.class.getSimpleName();\n+\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final RealmAwareZkClient.RealmAwareZkClientConfig _clientConfig;\n+\n+  // ZK realm -> ZkClient\n+  private final Map<String, ZkClient> _zkRealmToZkClientMap;\n+\n+  private volatile boolean _isClosed;\n+  private PathBasedZkSerializer _pathBasedZkSerializer;\n+\n+  // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    if (clientConfig == null) {\n+      throw new IllegalArgumentException(\"Client config cannot be null!\");\n+    }\n+\n+    _isClosed = false;\n+    _clientConfig = clientConfig;\n+    _pathBasedZkSerializer = clientConfig.getZkSerializer();\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+    _zkRealmToZkClientMap = new ConcurrentHashMap<>();\n+  }\n \n-public class FederatedZkClient implements RealmAwareZkClient {\n   @Override\n   public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n-    return null;\n+    return getZkClient(path).subscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n-\n+    getZkClient(path).unsubscribeChildChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).subscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n-\n+    getZkClient(path).unsubscribeDataChanges(path, listener);\n   }\n \n   @Override\n   public void subscribeStateChanges(IZkStateListener listener) {\n-\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n   public void unsubscribeStateChanges(IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void subscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n   }\n \n   @Override\n-  public void unsubscribeAll() {\n+  public void unsubscribeStateChanges(\n+      org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener listener) {\n+    throwUnsupportedOperationException();\n+  }\n \n+  @Override\n+  public void unsubscribeAll() {\n+    _zkRealmToZkClientMap.values().forEach(ZkClient::unsubscribeAll);\n   }\n \n   @Override\n   public void createPersistent(String path) {\n-\n+    createPersistent(path, false);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents) {\n-\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n   }\n \n   @Override\n   public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n-\n+    getZkClient(path).createPersistent(path, createParents, acl);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data) {\n-\n+    create(path, data, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public void createPersistent(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.PERSISTENT);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n   }\n \n   @Override\n   public void createEphemeral(String path) {\n-\n+    create(path, null, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, String sessionId) {\n-\n+    createEphemeral(path, null, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n-\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String create(String path, Object data, CreateMode mode) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n   }\n \n   @Override\n-  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n-    return null;\n+  public String create(String path, Object data, List<ACL> acl, CreateMode mode) {\n+    return create(path, data, acl, mode, null);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data) {\n-\n+    create(path, data, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, String sessionId) {\n-\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n   }\n \n   @Override\n   public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n-\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data) {\n-    return null;\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, String sessionId) {\n-    return null;\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n   }\n \n   @Override\n   public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n       String sessionId) {\n-    return null;\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n   }\n \n   @Override\n   public List<String> getChildren(String path) {\n-    return null;\n+    return getZkClient(path).getChildren(path);\n   }\n \n   @Override\n   public int countChildren(String path) {\n-    return 0;\n+    return getZkClient(path).countChildren(path);\n   }\n \n   @Override\n   public boolean exists(String path) {\n-    return false;\n+    return getZkClient(path).exists(path);\n   }\n \n   @Override\n   public Stat getStat(String path) {\n-    return null;\n+    return getZkClient(path).getStat(path);\n   }\n \n   @Override\n   public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n-    return false;\n+    return getZkClient(path).waitUntilExists(path, timeUnit, time);\n   }\n \n   @Override\n   public void deleteRecursively(String path) {\n-\n+    getZkClient(path).deleteRecursively(path);\n   }\n \n   @Override\n   public boolean delete(String path) {\n-    return false;\n+    return getZkClient(path).delete(path);\n   }\n \n   @Override\n+  @SuppressWarnings(\"unchecked\")\n   public <T> T readData(String path) {\n-    return null;\n+    return (T) readData(path, false);\n   }\n \n   @Override\n   public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat) {\n-    return null;\n+    return getZkClient(path).readData(path, stat);\n   }\n \n   @Override\n   public <T> T readData(String path, Stat stat, boolean watch) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, watch);\n   }\n \n   @Override\n   public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n-    return null;\n+    return getZkClient(path).readData(path, stat, returnNullIfPathNotExists);\n   }\n \n   @Override\n   public void writeData(String path, Object object) {\n-\n+    writeData(path, object, -1);\n   }\n \n   @Override\n   public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n-\n+    getZkClient(path).updateDataSerialized(path, updater);\n   }\n \n   @Override\n-  public void writeData(String path, Object datat, int expectedVersion) {\n-\n+  public void writeData(String path, Object data, int expectedVersion) {\n+    writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataReturnStat(String path, Object data, int expectedVersion) {\n+    return getZkClient(path).writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n-    return null;\n+  public Stat writeDataGetStat(String path, Object data, int expectedVersion) {\n+    return writeDataReturnStat(path, data, expectedVersion);\n   }\n \n   @Override\n-  public void asyncCreate(String path, Object datat, CreateMode mode,\n+  public void asyncCreate(String path, Object data, CreateMode mode,\n       ZkAsyncCallbacks.CreateCallbackHandler cb) {\n-\n+    getZkClient(path).asyncCreate(path, data, mode, cb);\n   }\n \n   @Override\n-  public void asyncSetData(String path, Object datat, int version,\n+  public void asyncSetData(String path, Object data, int version,\n       ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncSetData(path, data, version, cb);\n   }\n \n   @Override\n   public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n-\n+    getZkClient(path).asyncGetData(path, cb);\n   }\n \n   @Override\n   public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n-\n+    getZkClient(path).asyncExists(path, cb);\n   }\n \n   @Override\n   public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n-\n+    getZkClient(path).asyncDelete(path, cb);\n   }\n \n   @Override\n   public void watchForData(String path) {\n-\n+    getZkClient(path).watchForData(path);\n   }\n \n   @Override\n   public List<String> watchForChilds(String path) {\n-    return null;\n+    return getZkClient(path).watchForChilds(path);\n   }\n \n   @Override\n   public long getCreationTime(String path) {\n-    return 0;\n+    return getZkClient(path).getCreationTime(path);\n   }\n \n   @Override\n   public List<OpResult> multi(Iterable<Op> ops) {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    throwUnsupportedOperationException();\n     return false;\n   }\n \n   @Override\n   public String getServers() {\n+    throwUnsupportedOperationException();\n     return null;\n   }\n \n   @Override\n   public long getSessionId() {\n-    return 0;\n+    // Session-aware is unsupported.\n+    throwUnsupportedOperationException();\n+    return 0L;\n   }\n \n   @Override\n   public void close() {\n+    if (isClosed()) {\n+      return;\n+    }\n \n+    _isClosed = true;\n+\n+    synchronized (_zkRealmToZkClientMap) {\n+      Iterator<Map.Entry<String, ZkClient>> iterator = _zkRealmToZkClientMap.entrySet().iterator();\n+\n+      while (iterator.hasNext()) {\n+        Map.Entry<String, ZkClient> entry = iterator.next();\n+        String zkRealm = entry.getKey();\n+        ZkClient zkClient = entry.getValue();\n+\n+        // Catch any exception from ZkClient's close() to avoid that there is leakage of\n+        // remaining unclosed ZkClient.\n+        try {\n+          zkClient.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4215b699f835e92f6797e49dcb5a32814fc7e5a0"}, "originalPosition": 469}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Nzc1NjAy", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-366775602", "createdAt": "2020-02-29T04:10:28Z", "commit": {"oid": "4215b699f835e92f6797e49dcb5a32814fc7e5a0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Nzg0Mjcw", "url": "https://github.com/apache/helix/pull/789#pullrequestreview-366784270", "createdAt": "2020-02-29T07:52:53Z", "commit": {"oid": "4215b699f835e92f6797e49dcb5a32814fc7e5a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNzo1Mjo1M1rOFwINHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNzo1Mjo1M1rOFwINHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMDM5Ng==", "bodyText": "Can we not include this? I understand what you're trying to do here, but I don't think you're using this particular annotation the right way.\nSee https://stackoverflow.com/questions/42576760/where-is-notnull-in-java\nWe don't have to use that annotation here...", "url": "https://github.com/apache/helix/pull/789#discussion_r386010396", "createdAt": "2020-02-29T07:52:53Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -19,345 +19,535 @@\n  * under the License.\n  */\n \n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n+import com.sun.istack.internal.NotNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4215b699f835e92f6797e49dcb5a32814fc7e5a0"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79be545249f5b571b488ff4657ba51ff4f595e9e", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/79be545249f5b571b488ff4657ba51ff4f595e9e", "committedDate": "2020-02-29T08:07:33Z", "message": "Remove NotNull"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4996, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}