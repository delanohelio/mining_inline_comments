{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzODgxOTkz", "number": 686, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MTo1MlrODY-NJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDoxNDo1MFrODZrdGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTExNTg5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MTo1MlrOFfInnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MTo1MlrOFfInnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTM5MQ==", "bodyText": "getOrCreateResourceMonitor()", "url": "https://github.com/apache/helix/pull/686#discussion_r368191391", "createdAt": "2020-01-18T00:51:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java", "diffHunk": "@@ -497,6 +497,25 @@ public void setResourceStatus(ExternalView externalView, IdealState idealState,\n     }\n   }\n \n+  /**\n+   * Updates metrics of average partition weight per capacity key for a resource. If a resource\n+   * monitor is not yet existed for this resource, a new resource monitor will be created for this\n+   * resource.\n+   *\n+   * @param resourceName The resource name for which partition weight is updated\n+   * @param averageWeightMap A map of average partition weight of each capacity key:\n+   *                         capacity key -> average partition weight\n+   */\n+  public void updatePartitionWeight(String resourceName, Map<String, Integer> averageWeightMap) {\n+    ResourceMonitor monitor = _resourceMonitorMap.get(resourceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTExNjM1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1Mjo0MVrOFfIn9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDoxNDowM1rOFgHZgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTQ3Nw==", "bodyText": "Why?", "url": "https://github.com/apache/helix/pull/686#discussion_r368191477", "createdAt": "2020-01-18T00:52:41Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java", "diffHunk": "@@ -519,7 +538,7 @@ public void updateRebalancerStats(String resourceName, long numPendingRecoveryRe\n     }\n   }\n \n-  private ResourceMonitor getOrCreateResourceMonitor(String resourceName) {\n+  ResourceMonitor getOrCreateResourceMonitor(String resourceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxOTk2OQ==", "bodyText": "For test purpose. As I discussed offline, we will keep this private and just call monitor's register().", "url": "https://github.com/apache/helix/pull/686#discussion_r369219969", "createdAt": "2020-01-21T20:14:03Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java", "diffHunk": "@@ -519,7 +538,7 @@ public void updateRebalancerStats(String resourceName, long numPendingRecoveryRe\n     }\n   }\n \n-  private ResourceMonitor getOrCreateResourceMonitor(String resourceName) {\n+  ResourceMonitor getOrCreateResourceMonitor(String resourceName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTQ3Nw=="}, "originalCommit": {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTEyNjA5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTowNDowOFrOFfItrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDoxMjo0NFrOFgHXSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mjk0MA==", "bodyText": "long would be safer.", "url": "https://github.com/apache/helix/pull/686#discussion_r368192940", "createdAt": "2020-01-18T01:04:08Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java", "diffHunk": "@@ -142,4 +142,97 @@ public static double measureBaselineDivergence(Map<String, ResourceAssignment> b\n     return numTotalBestPossibleReplicas == 0 ? 1.0d\n         : (1.0d - (double) numMatchedReplicas / (double) numTotalBestPossibleReplicas);\n   }\n+\n+  /**\n+   * Calculates average partition weight per capacity key for a resource config. Example as below:\n+   * Input =\n+   * {\n+   *   \"partition1\": {\n+   *     \"capacity1\": 20,\n+   *     \"capacity2\": 40\n+   *   },\n+   *   \"partition2\": {\n+   *     \"capacity1\": 30,\n+   *     \"capacity2\": 50\n+   *   },\n+   *   \"partition3\": {\n+   *     \"capacity1\": 16,\n+   *     \"capacity2\": 30\n+   *   }\n+   * }\n+   *\n+   * Total weight for key \"capacity1\" = 20 + 30 + 16 = 66;\n+   * Total weight for key \"capacity2\" = 40 + 50 + 30 = 120;\n+   * Total partitions = 3;\n+   * Average partition weight for \"capacity1\" = 66 / 3 = 22;\n+   * Average partition weight for \"capacity2\" = 120 / 3 = 40;\n+   *\n+   * Output =\n+   * {\n+   *   \"capacity1\": 22,\n+   *   \"capacity2\": 40\n+   * }\n+   *\n+   * @param partitionCapacityMap A map of partition capacity:\n+   *        <PartitionName or DEFAULT_PARTITION_KEY, <Capacity Key, Capacity Number>>\n+   * @return A map of partition weight: capacity key -> average partition weight\n+   */\n+  public static Map<String, Integer> calculateAveragePartitionWeight(\n+      Map<String, Map<String, Integer>> partitionCapacityMap) {\n+    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap =\n+        aggregatePartitionWeight(partitionCapacityMap);\n+\n+    // capacity key -> average partition weight\n+    Map<String, Integer> averagePartitionWeightMap = new HashMap<>();\n+\n+    // Calculate average partition weight for each capacity key.\n+    // Per capacity key level:\n+    // average partition weight = (total partition weight) / (number of partitions)\n+    for (Map.Entry<String, PartitionWeightCounterEntry> entry\n+        : countPartitionWeightMap.entrySet()) {\n+      String capacityKey = entry.getKey();\n+      PartitionWeightCounterEntry weightEntry = entry.getValue();\n+      int averageWeight = weightEntry.getWeight() / weightEntry.getPartitions();\n+      averagePartitionWeightMap.put(capacityKey, averageWeight);\n+    }\n+\n+    return averagePartitionWeightMap;\n+  }\n+\n+  /*\n+   * Aggregates partition weight for each capacity key.\n+   */\n+  private static Map<String, PartitionWeightCounterEntry> aggregatePartitionWeight(\n+      Map<String, Map<String, Integer>> partitionCapacityMap) {\n+    // capacity key -> [number of partitions, total weight per capacity key]\n+    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap = new HashMap<>();\n+\n+    partitionCapacityMap.values().forEach(partitionCapacityEntry ->\n+        partitionCapacityEntry.forEach((capacityKey, weight) -> countPartitionWeightMap\n+            .computeIfAbsent(capacityKey, counterEntry -> new PartitionWeightCounterEntry())\n+            .increase(1, weight)));\n+\n+    return countPartitionWeightMap;\n+  }\n+\n+  /*\n+   * Represents total number of partitions and total partition weight for a capacity key.\n+   */\n+  private static class PartitionWeightCounterEntry {\n+    private int partitions;\n+    private int weight;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxOTQwMw==", "bodyText": "Done.", "url": "https://github.com/apache/helix/pull/686#discussion_r369219403", "createdAt": "2020-01-21T20:12:44Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java", "diffHunk": "@@ -142,4 +142,97 @@ public static double measureBaselineDivergence(Map<String, ResourceAssignment> b\n     return numTotalBestPossibleReplicas == 0 ? 1.0d\n         : (1.0d - (double) numMatchedReplicas / (double) numTotalBestPossibleReplicas);\n   }\n+\n+  /**\n+   * Calculates average partition weight per capacity key for a resource config. Example as below:\n+   * Input =\n+   * {\n+   *   \"partition1\": {\n+   *     \"capacity1\": 20,\n+   *     \"capacity2\": 40\n+   *   },\n+   *   \"partition2\": {\n+   *     \"capacity1\": 30,\n+   *     \"capacity2\": 50\n+   *   },\n+   *   \"partition3\": {\n+   *     \"capacity1\": 16,\n+   *     \"capacity2\": 30\n+   *   }\n+   * }\n+   *\n+   * Total weight for key \"capacity1\" = 20 + 30 + 16 = 66;\n+   * Total weight for key \"capacity2\" = 40 + 50 + 30 = 120;\n+   * Total partitions = 3;\n+   * Average partition weight for \"capacity1\" = 66 / 3 = 22;\n+   * Average partition weight for \"capacity2\" = 120 / 3 = 40;\n+   *\n+   * Output =\n+   * {\n+   *   \"capacity1\": 22,\n+   *   \"capacity2\": 40\n+   * }\n+   *\n+   * @param partitionCapacityMap A map of partition capacity:\n+   *        <PartitionName or DEFAULT_PARTITION_KEY, <Capacity Key, Capacity Number>>\n+   * @return A map of partition weight: capacity key -> average partition weight\n+   */\n+  public static Map<String, Integer> calculateAveragePartitionWeight(\n+      Map<String, Map<String, Integer>> partitionCapacityMap) {\n+    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap =\n+        aggregatePartitionWeight(partitionCapacityMap);\n+\n+    // capacity key -> average partition weight\n+    Map<String, Integer> averagePartitionWeightMap = new HashMap<>();\n+\n+    // Calculate average partition weight for each capacity key.\n+    // Per capacity key level:\n+    // average partition weight = (total partition weight) / (number of partitions)\n+    for (Map.Entry<String, PartitionWeightCounterEntry> entry\n+        : countPartitionWeightMap.entrySet()) {\n+      String capacityKey = entry.getKey();\n+      PartitionWeightCounterEntry weightEntry = entry.getValue();\n+      int averageWeight = weightEntry.getWeight() / weightEntry.getPartitions();\n+      averagePartitionWeightMap.put(capacityKey, averageWeight);\n+    }\n+\n+    return averagePartitionWeightMap;\n+  }\n+\n+  /*\n+   * Aggregates partition weight for each capacity key.\n+   */\n+  private static Map<String, PartitionWeightCounterEntry> aggregatePartitionWeight(\n+      Map<String, Map<String, Integer>> partitionCapacityMap) {\n+    // capacity key -> [number of partitions, total weight per capacity key]\n+    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap = new HashMap<>();\n+\n+    partitionCapacityMap.values().forEach(partitionCapacityEntry ->\n+        partitionCapacityEntry.forEach((capacityKey, weight) -> countPartitionWeightMap\n+            .computeIfAbsent(capacityKey, counterEntry -> new PartitionWeightCounterEntry())\n+            .increase(1, weight)));\n+\n+    return countPartitionWeightMap;\n+  }\n+\n+  /*\n+   * Represents total number of partitions and total partition weight for a capacity key.\n+   */\n+  private static class PartitionWeightCounterEntry {\n+    private int partitions;\n+    private int weight;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mjk0MA=="}, "originalCommit": {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTEyODI2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTowNjo1MVrOFfIu4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDoxMjo1NFrOFgHXng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MzI0OA==", "bodyText": "Let's simplify this by merging the 2 methods?", "url": "https://github.com/apache/helix/pull/686#discussion_r368193248", "createdAt": "2020-01-18T01:06:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java", "diffHunk": "@@ -142,4 +142,97 @@ public static double measureBaselineDivergence(Map<String, ResourceAssignment> b\n     return numTotalBestPossibleReplicas == 0 ? 1.0d\n         : (1.0d - (double) numMatchedReplicas / (double) numTotalBestPossibleReplicas);\n   }\n+\n+  /**\n+   * Calculates average partition weight per capacity key for a resource config. Example as below:\n+   * Input =\n+   * {\n+   *   \"partition1\": {\n+   *     \"capacity1\": 20,\n+   *     \"capacity2\": 40\n+   *   },\n+   *   \"partition2\": {\n+   *     \"capacity1\": 30,\n+   *     \"capacity2\": 50\n+   *   },\n+   *   \"partition3\": {\n+   *     \"capacity1\": 16,\n+   *     \"capacity2\": 30\n+   *   }\n+   * }\n+   *\n+   * Total weight for key \"capacity1\" = 20 + 30 + 16 = 66;\n+   * Total weight for key \"capacity2\" = 40 + 50 + 30 = 120;\n+   * Total partitions = 3;\n+   * Average partition weight for \"capacity1\" = 66 / 3 = 22;\n+   * Average partition weight for \"capacity2\" = 120 / 3 = 40;\n+   *\n+   * Output =\n+   * {\n+   *   \"capacity1\": 22,\n+   *   \"capacity2\": 40\n+   * }\n+   *\n+   * @param partitionCapacityMap A map of partition capacity:\n+   *        <PartitionName or DEFAULT_PARTITION_KEY, <Capacity Key, Capacity Number>>\n+   * @return A map of partition weight: capacity key -> average partition weight\n+   */\n+  public static Map<String, Integer> calculateAveragePartitionWeight(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxOTQ4Ng==", "bodyText": "Done", "url": "https://github.com/apache/helix/pull/686#discussion_r369219486", "createdAt": "2020-01-21T20:12:54Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java", "diffHunk": "@@ -142,4 +142,97 @@ public static double measureBaselineDivergence(Map<String, ResourceAssignment> b\n     return numTotalBestPossibleReplicas == 0 ? 1.0d\n         : (1.0d - (double) numMatchedReplicas / (double) numTotalBestPossibleReplicas);\n   }\n+\n+  /**\n+   * Calculates average partition weight per capacity key for a resource config. Example as below:\n+   * Input =\n+   * {\n+   *   \"partition1\": {\n+   *     \"capacity1\": 20,\n+   *     \"capacity2\": 40\n+   *   },\n+   *   \"partition2\": {\n+   *     \"capacity1\": 30,\n+   *     \"capacity2\": 50\n+   *   },\n+   *   \"partition3\": {\n+   *     \"capacity1\": 16,\n+   *     \"capacity2\": 30\n+   *   }\n+   * }\n+   *\n+   * Total weight for key \"capacity1\" = 20 + 30 + 16 = 66;\n+   * Total weight for key \"capacity2\" = 40 + 50 + 30 = 120;\n+   * Total partitions = 3;\n+   * Average partition weight for \"capacity1\" = 66 / 3 = 22;\n+   * Average partition weight for \"capacity2\" = 120 / 3 = 40;\n+   *\n+   * Output =\n+   * {\n+   *   \"capacity1\": 22,\n+   *   \"capacity2\": 40\n+   * }\n+   *\n+   * @param partitionCapacityMap A map of partition capacity:\n+   *        <PartitionName or DEFAULT_PARTITION_KEY, <Capacity Key, Capacity Number>>\n+   * @return A map of partition weight: capacity key -> average partition weight\n+   */\n+  public static Map<String, Integer> calculateAveragePartitionWeight(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MzI0OA=="}, "originalCommit": {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTEzMzYxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMToxMTozMFrOFfIxlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDoxNDoyOVrOFgHaPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mzk0Mg==", "bodyText": "nit, static final and put to the class level?", "url": "https://github.com/apache/helix/pull/686#discussion_r368193942", "createdAt": "2020-01-18T01:11:30Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java", "diffHunk": "@@ -382,6 +367,37 @@ public void updateRebalancerStats(long numPendingRecoveryRebalancePartitions,\n     _numLoadRebalanceThrottledPartitions.updateValue(numLoadRebalanceThrottledPartitions);\n   }\n \n+  /**\n+   * Updates partition weight metric. If the partition capacity keys are changed, all MBean\n+   * attributes will be updated accordingly: old capacity keys will be replaced with new capacity\n+   * keys in MBean server.\n+   *\n+   * @param partitionWeightMap A map of partition weight: capacity key -> partition weight\n+   */\n+  void updatePartitionWeightStats(Map<String, Integer> partitionWeightMap) {\n+    synchronized (_dynamicCapacityMetricsMap) {\n+      if (_dynamicCapacityMetricsMap.keySet().equals(partitionWeightMap.keySet())) {\n+        for (Map.Entry<String, Integer> entry : partitionWeightMap.entrySet()) {\n+          _dynamicCapacityMetricsMap.get(entry.getKey()).updateValue((long) entry.getValue());\n+        }\n+        return;\n+      }\n+\n+      // Capacity keys are changed, so capacity attribute map needs to be updated.\n+      _dynamicCapacityMetricsMap.clear();\n+      final String gaugeMetricSuffix = \"Gauge\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIyMDE1OQ==", "bodyText": "OK.", "url": "https://github.com/apache/helix/pull/686#discussion_r369220159", "createdAt": "2020-01-21T20:14:29Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java", "diffHunk": "@@ -382,6 +367,37 @@ public void updateRebalancerStats(long numPendingRecoveryRebalancePartitions,\n     _numLoadRebalanceThrottledPartitions.updateValue(numLoadRebalanceThrottledPartitions);\n   }\n \n+  /**\n+   * Updates partition weight metric. If the partition capacity keys are changed, all MBean\n+   * attributes will be updated accordingly: old capacity keys will be replaced with new capacity\n+   * keys in MBean server.\n+   *\n+   * @param partitionWeightMap A map of partition weight: capacity key -> partition weight\n+   */\n+  void updatePartitionWeightStats(Map<String, Integer> partitionWeightMap) {\n+    synchronized (_dynamicCapacityMetricsMap) {\n+      if (_dynamicCapacityMetricsMap.keySet().equals(partitionWeightMap.keySet())) {\n+        for (Map.Entry<String, Integer> entry : partitionWeightMap.entrySet()) {\n+          _dynamicCapacityMetricsMap.get(entry.getKey()).updateValue((long) entry.getValue());\n+        }\n+        return;\n+      }\n+\n+      // Capacity keys are changed, so capacity attribute map needs to be updated.\n+      _dynamicCapacityMetricsMap.clear();\n+      final String gaugeMetricSuffix = \"Gauge\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mzk0Mg=="}, "originalCommit": {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjUyOTU1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestResourceMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDoxNDo1MFrOFgNCnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDoyNjozMlrOFgNO6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMjQxMg==", "bodyText": "In this case, put it in finally block and check if monitor is null before unregister.", "url": "https://github.com/apache/helix/pull/686#discussion_r369312412", "createdAt": "2020-01-22T00:14:50Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestResourceMonitor.java", "diffHunk": "@@ -217,10 +217,13 @@ public void testReportData() throws JMException {\n     monitor.setRebalanceState(ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED);\n     Assert.assertEquals(monitor.getRebalanceState(),\n         ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED.name());\n+\n+    // Has to unregister this monitor to clean up. Otherwise, later tests may be affected and fail.\n+    monitor.unregister();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1628de6eed11ca7143cd6e82e8fbeade784fd9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxNTU2MA==", "bodyText": "Done.", "url": "https://github.com/apache/helix/pull/686#discussion_r369315560", "createdAt": "2020-01-22T00:26:32Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestResourceMonitor.java", "diffHunk": "@@ -217,10 +217,13 @@ public void testReportData() throws JMException {\n     monitor.setRebalanceState(ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED);\n     Assert.assertEquals(monitor.getRebalanceState(),\n         ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED.name());\n+\n+    // Has to unregister this monitor to clean up. Otherwise, later tests may be affected and fail.\n+    monitor.unregister();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMjQxMg=="}, "originalCommit": {"oid": "5b1628de6eed11ca7143cd6e82e8fbeade784fd9"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1533, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}