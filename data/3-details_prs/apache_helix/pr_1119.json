{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4ODk1NTY1", "number": 1119, "title": "Add sync() call first for new session handling", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFix #1118\nDescription\n\n\n Here are some details about my PR, including screenshots of any UI changes:\nHelix may see stale data when session expires and get reconnected to\na slower ZKServer. This would cause various correctness problem.\nWe would call sync() to ZKserver first. This ensures Helix would\nnot see data that saw before.\n\n\nTests\n\n The following tests are written for this issue:\n\ntestAutoSyncWithNewSessionEstablishment()\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO]\n[INFO] Results:\n[INFO]\n[ERROR] Failures:\n[ERROR]   TestEnableCompression.testEnableCompressionResource:116 \u00bb ThreadTimeout Method...\n[INFO]\n[ERROR] Tests run: 1152, Failures: 1, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:22 h\n[INFO] Finished at: 2020-07-22T03:30:16-07:00\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M3:test (default-test) on project helix-core: There are test failures.\n[ERROR]\n[ERROR] Please refer to /home/ksun/helix_kaisun2000/helix/helix-core/target/surefire-reports for the individual test results.\n[ERROR] Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.\n[ERROR] -> [Help 1]\n[ERROR]\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR]\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\n[ksun@ksun-ld1 helix-core]$ mvn test > test.out 2>& 1\nIndividually run this timeout test would work.\nsecond run result. Individually run it work pass.\n[ERROR] org.apache.helix.controller.strategy.crushMapping.TestCardDealingAdjustmentAlgorithmV2.testComputeMappingForDifferentReplicas(org.apache.helix.controller.strategy.crushMapping.TestCardDealingAdjustmentAlgorithmV2)\n[ERROR]   Run 1: TestCardDealingAdjustmentAlgorithmV2.testComputeMappingForDifferentReplicas:273 Total movements: 4 != expected 8, replica: 1\n[ERROR]   Run 2: TestCardDealingAdjustmentAlgorithmV2.testComputeMappingForDifferentReplicas:273 Total movements: 4 != expected 8, replica: 2\n[ERROR]   Run 3: TestCardDealingAdjustmentAlgorithmV2.testComputeMappingForDifferentReplicas:273 Total movements: 12 != expected 21, replica: 3\n[INFO]   Run 4: PASS\n[INFO]   Run 5: PASS\n[INFO]\n[ERROR]   TestEnableCompression.testEnableCompressionResource:117 expected: but was:\n[ERROR]   TestWagedRebalance.testChangeIdealState:303->validate:646 expected: but was:\n[ERROR]   TestRebalanceRunningTask.testFixedTargetTaskAndEnabledRebalanceAndNodeAdded:330 expected: but was:\n[ERROR]   TestTaskSchedulingTwoCurrentStates.testTargetedTaskTwoCurrentStates:150 expected: but was:\n[ERROR]   TestClusterStatusMonitorLifecycle.testClusterStatusMonitorLifecycle:290 expected: but was:\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation (Optional)\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-06-24T00:43:24Z", "url": "https://github.com/apache/helix/pull/1119", "merged": true, "mergeCommit": {"oid": "7aeae0d36cd05886b34fb8583fd95cb831c48b72"}, "closed": true, "closedAt": "2020-07-24T02:22:05Z", "author": {"login": "kaisun2000"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuSqEBAFqTQzNjMyMDI2Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc328qZgFqTQ1NDUzMTA4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzIwMjY3", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-436320267", "createdAt": "2020-06-24T04:45:17Z", "commit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNDo0NToxN1rOGoCv6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNDo0NzowN1rOGoCxjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTI1OA==", "bodyText": "You mentioned we will have more changes here. Will we make it optional? If so, I think we should have the change in this PR.", "url": "https://github.com/apache/helix/pull/1119#discussion_r444641258", "createdAt": "2020-06-24T04:45:17Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -185,6 +188,7 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     if (zkConnection == null) {\n       throw new NullPointerException(\"Zookeeper connection is null!\");\n     }\n+    _syncOnNewSession = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTUyMQ==", "bodyText": "Please extract a method for sync.", "url": "https://github.com/apache/helix/pull/1119#discussion_r444641521", "createdAt": "2020-06-24T04:46:24Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTY3Ng==", "bodyText": "remove", "url": "https://github.com/apache/helix/pull/1119#discussion_r444641676", "createdAt": "2020-06-24T04:47:07Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {\n+                  throw new IllegalStateException(\n+                      \"ZkConnection is in invalid state! Please close this ZkClient and create new client.\");\n+                }\n+                final String syncPath = new String(\"/\");\n+                zkConnection.getZookeeper().sync(syncPath, new AsyncCallback.VoidCallback() {\n+                  @Override\n+                  public void processResult(int rt, String s, Object ctx) {\n+                    //System.out.println(\"sycnOnNewSession with sessionID \" + sessionId + \" async return code:\" + rt);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzIzODg0", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-436323884", "createdAt": "2020-06-24T04:57:53Z", "commit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNDo1Nzo1M1rOGoC7lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNDo1Nzo1M1rOGoC7lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0NDI0NA==", "bodyText": "I think zkConnection is not possible to be null here. Maybe zkConnection.getZookeeper() won't be null as well.\nBut check it is a valid thing to do.\nOne point is that line 1193 should use the same ZK object as it is checked here. Or it might become null later.", "url": "https://github.com/apache/helix/pull/1119#discussion_r444644244", "createdAt": "2020-06-24T04:57:53Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzUzMjg2", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-436353286", "createdAt": "2020-06-24T06:18:57Z", "commit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjoxODo1N1rOGoEZWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjoyODoxM1rOGoEntw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY2ODI0OQ==", "bodyText": "Remove commented debugging code?", "url": "https://github.com/apache/helix/pull/1119#discussion_r444668249", "createdAt": "2020-06-24T06:18:57Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY2OTg1Nw==", "bodyText": "Whats the purpose of using such new String(\"/\")? This brings in extra unnecessary string object creation. I think a constant would be nicer SYNC_ROOT_PATH = \"/\".", "url": "https://github.com/apache/helix/pull/1119#discussion_r444669857", "createdAt": "2020-06-24T06:23:06Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {\n+                  throw new IllegalStateException(\n+                      \"ZkConnection is in invalid state! Please close this ZkClient and create new client.\");\n+                }\n+                final String syncPath = new String(\"/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTEyNA==", "bodyText": "I don't think this null check is necessary, as zkConnection/zk won't be null once zkClient object is constructed. Only chance zk being null is this zkClient.close() is called, then zk is null. I would say this may be overcheck for nulls.", "url": "https://github.com/apache/helix/pull/1119#discussion_r444671124", "createdAt": "2020-06-24T06:26:13Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0NDI0NA=="}, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTkyNw==", "bodyText": "Do we also need to log time on this sync?", "url": "https://github.com/apache/helix/pull/1119#discussion_r444671927", "createdAt": "2020-06-24T06:28:13Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {\n+                  throw new IllegalStateException(\n+                      \"ZkConnection is in invalid state! Please close this ZkClient and create new client.\");\n+                }\n+                final String syncPath = new String(\"/\");\n+                zkConnection.getZookeeper().sync(syncPath, new AsyncCallback.VoidCallback() {\n+                  @Override\n+                  public void processResult(int rt, String s, Object ctx) {\n+                    //System.out.println(\"sycnOnNewSession with sessionID \" + sessionId + \" async return code:\" + rt);\n+                    LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", sessionId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzYzMDg0", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-436363084", "createdAt": "2020-06-24T06:39:07Z", "commit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjozOTowN1rOGoE3rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjozOTowN1rOGoE3rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3NjAxNA==", "bodyText": "We only call sync but don't check the return code it's successful or not? It doesn't guarantee data is synced. What if sync fails?", "url": "https://github.com/apache/helix/pull/1119#discussion_r444676014", "createdAt": "2020-06-24T06:39:07Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1172,13 +1176,32 @@ private void fireNewSessionEvents() {\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              if (_syncOnNewSession) {\n+                //System.out.println(\"syncOnNewSession with sessionID:\" + sessionId);\n+                LOG.info(\"syncOnNewSession with sessionId {}\", sessionId);\n+                final ZkConnection zkConnection = (ZkConnection) getConnection();\n+                if (zkConnection == null || zkConnection.getZookeeper() == null) {\n+                  throw new IllegalStateException(\n+                      \"ZkConnection is in invalid state! Please close this ZkClient and create new client.\");\n+                }\n+                final String syncPath = new String(\"/\");\n+                zkConnection.getZookeeper().sync(syncPath, new AsyncCallback.VoidCallback() {\n+                  @Override\n+                  public void processResult(int rt, String s, Object ctx) {\n+                    //System.out.println(\"sycnOnNewSession with sessionID \" + sessionId + \" async return code:\" + rt);\n+                    LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", sessionId,\n+                        rt);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NTY0MzQy", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-439564342", "createdAt": "2020-06-29T23:16:08Z", "commit": {"oid": "7fbd24345d3222483e6532d07295afc0df65af47"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzoxNjowOFrOGqlwRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzoyNDoyM1rOGql62Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMTk0Mg==", "bodyText": "private static?", "url": "https://github.com/apache/helix/pull/1119#discussion_r447311942", "createdAt": "2020-06-29T23:16:08Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -103,6 +111,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  final String _syncPath = new String(\"/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbd24345d3222483e6532d07295afc0df65af47"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMjU4MA==", "bodyText": "Directly do _syncPath = \"/\"; shall help to avoid unnecessary object creating.", "url": "https://github.com/apache/helix/pull/1119#discussion_r447312580", "createdAt": "2020-06-29T23:18:13Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -103,6 +111,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  final String _syncPath = new String(\"/\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMTk0Mg=="}, "originalCommit": {"oid": "7fbd24345d3222483e6532d07295afc0df65af47"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMzg4MQ==", "bodyText": "Please add the callback logic to ZkAsyncCallbacks.java if possible.\n\nThis file has been very large. We shall avoid adding more optional content here.\nZkAsyncCallbacks.java has all the callback defines there. We might be able to avoid some duplicated code if the class is defined there and extending the default callback class.", "url": "https://github.com/apache/helix/pull/1119#discussion_r447313881", "createdAt": "2020-06-29T23:21:58Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1165,20 +1177,92 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbd24345d3222483e6532d07295afc0df65af47"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDM5NQ==", "bodyText": "As commented, please check out the other callback implementations. I think the main logic is in common. So we don't need to re-define everything.", "url": "https://github.com/apache/helix/pull/1119#discussion_r447314395", "createdAt": "2020-06-29T23:23:31Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1165,20 +1177,92 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncContext {\n+    private CountDownLatch _latch;\n+    private AtomicInteger _rc;\n+\n+    public SyncContext(CountDownLatch latch) {\n+      _latch = latch;\n+    }\n+\n+    AtomicInteger getRc() {\n+      return _rc;\n+    }\n+\n+    void setRc(AtomicInteger rc) {\n+      _rc = rc;\n+    }\n+\n+    CountDownLatch getLatch() {\n+      return _latch;\n+    }\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+    while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbd24345d3222483e6532d07295afc0df65af47"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDY0OQ==", "bodyText": "Do we need to do this for every single state listener?\nWe shall only do it once, right?", "url": "https://github.com/apache/helix/pull/1119#discussion_r447314649", "createdAt": "2020-06-29T23:24:23Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1165,20 +1177,92 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncContext {\n+    private CountDownLatch _latch;\n+    private AtomicInteger _rc;\n+\n+    public SyncContext(CountDownLatch latch) {\n+      _latch = latch;\n+    }\n+\n+    AtomicInteger getRc() {\n+      return _rc;\n+    }\n+\n+    void setRc(AtomicInteger rc) {\n+      _rc = rc;\n+    }\n+\n+    CountDownLatch getLatch() {\n+      return _latch;\n+    }\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+    while (true) {\n+      CountDownLatch latch = new CountDownLatch(1);\n+      SyncContext ctx = new SyncContext(latch);\n+\n+      final ZkConnection zkConnection = (ZkConnection) getConnection();\n+      zkConnection.getZookeeper().sync(_syncPath, new AsyncCallback.VoidCallback() {\n+        @Override\n+        public void processResult(int rt, String s, Object ctx) {\n+          LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", sessionId, rt);\n+          SyncContext synCtx = ((SyncContext) ctx);\n+          synCtx.setRc(new AtomicInteger(rt));\n+          synCtx.getLatch().countDown();\n+        }\n+      }, ctx);\n+\n+      try {\n+        latch.await();\n+      } catch (InterruptedException e) {\n+        LOG.info(\"retrySync latch waiting got interrrupted with sessionId {} \", sessionId);\n+        throw new ZkInterruptedException(e);\n+      }\n+\n+      KeeperException.Code code = KeeperException.Code.get(ctx.getRc().get());\n+      if (code == OK) {\n+        LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+            code);\n+        break;\n+      }\n+      if (code == CONNECTIONLOSS || code == SESSIONMOVED) {\n+        LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and retry\", sessionId,\n+            code);\n+        continue;\n+      }\n+      // Not retryable, including session expiration; but having error. Log the error and return\n+      LOG.error(\n+          \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+          sessionId, code);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              boolean proceed = retrySync(sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbd24345d3222483e6532d07295afc0df65af47"}, "originalPosition": 137}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMjc1MDI0", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-440275024", "createdAt": "2020-06-30T18:20:46Z", "commit": {"oid": "7fbd24345d3222483e6532d07295afc0df65af47"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODoyMDo0NlrOGrJBCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODoyNTo1OVrOGrJNGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg4OTY3NQ==", "bodyText": "It is worth making it configurable. For all Helix related component, we can turn it on. Otherwise, every user operation can be delay a little bit for sync. It changed our current behavior for user.", "url": "https://github.com/apache/helix/pull/1119#discussion_r447889675", "createdAt": "2020-06-30T18:20:46Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -185,6 +188,7 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     if (zkConnection == null) {\n       throw new NullPointerException(\"Zookeeper connection is null!\");\n     }\n+    _syncOnNewSession = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY0MTI1OA=="}, "originalCommit": {"oid": "c5866f0e9daab9af120953672c4c7ae44faf40b0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5MTgyMw==", "bodyText": "Except these three types of code, is there any other code need to be handled?", "url": "https://github.com/apache/helix/pull/1119#discussion_r447891823", "createdAt": "2020-06-30T18:24:28Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1165,20 +1177,92 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncContext {\n+    private CountDownLatch _latch;\n+    private AtomicInteger _rc;\n+\n+    public SyncContext(CountDownLatch latch) {\n+      _latch = latch;\n+    }\n+\n+    AtomicInteger getRc() {\n+      return _rc;\n+    }\n+\n+    void setRc(AtomicInteger rc) {\n+      _rc = rc;\n+    }\n+\n+    CountDownLatch getLatch() {\n+      return _latch;\n+    }\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+    while (true) {\n+      CountDownLatch latch = new CountDownLatch(1);\n+      SyncContext ctx = new SyncContext(latch);\n+\n+      final ZkConnection zkConnection = (ZkConnection) getConnection();\n+      zkConnection.getZookeeper().sync(_syncPath, new AsyncCallback.VoidCallback() {\n+        @Override\n+        public void processResult(int rt, String s, Object ctx) {\n+          LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", sessionId, rt);\n+          SyncContext synCtx = ((SyncContext) ctx);\n+          synCtx.setRc(new AtomicInteger(rt));\n+          synCtx.getLatch().countDown();\n+        }\n+      }, ctx);\n+\n+      try {\n+        latch.await();\n+      } catch (InterruptedException e) {\n+        LOG.info(\"retrySync latch waiting got interrrupted with sessionId {} \", sessionId);\n+        throw new ZkInterruptedException(e);\n+      }\n+\n+      KeeperException.Code code = KeeperException.Code.get(ctx.getRc().get());\n+      if (code == OK) {\n+        LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+            code);\n+        break;\n+      }\n+      if (code == CONNECTIONLOSS || code == SESSIONMOVED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbd24345d3222483e6532d07295afc0df65af47"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5Mjc2MA==", "bodyText": "+1. This is not necessary doing sync for each of listener. Although once the first one retry complete rest will not cost much time, this is redundant logic. We should avoid it.", "url": "https://github.com/apache/helix/pull/1119#discussion_r447892760", "createdAt": "2020-06-30T18:25:59Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1165,20 +1177,92 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncContext {\n+    private CountDownLatch _latch;\n+    private AtomicInteger _rc;\n+\n+    public SyncContext(CountDownLatch latch) {\n+      _latch = latch;\n+    }\n+\n+    AtomicInteger getRc() {\n+      return _rc;\n+    }\n+\n+    void setRc(AtomicInteger rc) {\n+      _rc = rc;\n+    }\n+\n+    CountDownLatch getLatch() {\n+      return _latch;\n+    }\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+    while (true) {\n+      CountDownLatch latch = new CountDownLatch(1);\n+      SyncContext ctx = new SyncContext(latch);\n+\n+      final ZkConnection zkConnection = (ZkConnection) getConnection();\n+      zkConnection.getZookeeper().sync(_syncPath, new AsyncCallback.VoidCallback() {\n+        @Override\n+        public void processResult(int rt, String s, Object ctx) {\n+          LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", sessionId, rt);\n+          SyncContext synCtx = ((SyncContext) ctx);\n+          synCtx.setRc(new AtomicInteger(rt));\n+          synCtx.getLatch().countDown();\n+        }\n+      }, ctx);\n+\n+      try {\n+        latch.await();\n+      } catch (InterruptedException e) {\n+        LOG.info(\"retrySync latch waiting got interrrupted with sessionId {} \", sessionId);\n+        throw new ZkInterruptedException(e);\n+      }\n+\n+      KeeperException.Code code = KeeperException.Code.get(ctx.getRc().get());\n+      if (code == OK) {\n+        LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+            code);\n+        break;\n+      }\n+      if (code == CONNECTIONLOSS || code == SESSIONMOVED) {\n+        LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and retry\", sessionId,\n+            code);\n+        continue;\n+      }\n+      // Not retryable, including session expiration; but having error. Log the error and return\n+      LOG.error(\n+          \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+          sessionId, code);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n     for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n+      _eventThread\n+          .send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n-        @Override\n-        public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n-        }\n-      });\n+            @Override\n+            public void run() throws Exception {\n+              boolean proceed = retrySync(sessionId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDY0OQ=="}, "originalCommit": {"oid": "7fbd24345d3222483e6532d07295afc0df65af47"}, "originalPosition": 137}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "30660554e0cd8f47444b2c5484c2d371bc9caa22", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/30660554e0cd8f47444b2c5484c2d371bc9caa22", "committedDate": "2020-07-14T22:23:28Z", "message": "minor fix of return value."}, "afterCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/2ea1d623e0aa9c095febe55a9a623610f9b5aadc", "committedDate": "2020-07-14T22:59:17Z", "message": "minor fix of return value."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NTI2MjUx", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-448526251", "createdAt": "2020-07-14T23:10:54Z", "commit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzoxMDo1NFrOGxoekw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzo1MTozNFrOGxpR7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5NjU5NQ==", "bodyText": "How about just call it \"zk.autosync.enabled\"", "url": "https://github.com/apache/helix/pull/1119#discussion_r454696595", "createdAt": "2020-07-14T23:10:54Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/ZkSystemPropertyKeys.java", "diffHunk": "@@ -50,4 +50,14 @@\n    */\n   public static final String ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES =\n       \"zk.serializer.znrecord.write.size.limit.bytes\";\n+\n+  /**\n+   * This property determines the behavior of ZkClient issuing an sync() to server upon new session\n+   * established.\n+   *\n+   * <p>\n+   *   The default value is \"true\" (issuing sync)\n+   */\n+  public static final String ZK_SYNC_UPON_NEWSESSION =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMjg2Mg==", "bodyText": "nit, shall we define the default value of ZK_SYNC_UPON_NEWSESSION in the ZkSystemPropertyKeys instead of hardcode it here?", "url": "https://github.com/apache/helix/pull/1119#discussion_r454702862", "createdAt": "2020-07-14T23:29:50Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -187,6 +199,10 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     if (zkConnection == null) {\n       throw new NullPointerException(\"Zookeeper connection is null!\");\n     }\n+\n+    String syncUpOnNewSession = System.getProperty(ZkSystemPropertyKeys.ZK_SYNC_UPON_NEWSESSION, \"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzM4Mg==", "bodyText": "private static final String SYNC_PATH = \"/\" ?", "url": "https://github.com/apache/helix/pull/1119#discussion_r454703382", "createdAt": "2020-07-14T23:31:30Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -105,6 +114,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  final String _syncPath = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNDE0Mw==", "bodyText": "Can we move it to the ZkAsyncCallbacks file so all the callbacks can be found there?", "url": "https://github.com/apache/helix/pull/1119#discussion_r454704143", "createdAt": "2020-07-14T23:33:53Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTIwMQ==", "bodyText": "Pass the current system time or the metric number will be messed up.", "url": "https://github.com/apache/helix/pull/1119#discussion_r454705201", "createdAt": "2020-07-14T23:37:11Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNTY3NQ==", "bodyText": "Is sync counted as write operations? Just to confirm.\nI know it is kind of happening in order like a write, but does it actually update anything on the server-side? Note if we record the type differently, then the server-side metric and client-side metric will have different numbers.", "url": "https://github.com/apache/helix/pull/1119#discussion_r454705675", "createdAt": "2020-07-14T23:38:36Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNjI4Mw==", "bodyText": "Can we move this check to the caller of retrySync()? So the method will do exactly what it is named.", "url": "https://github.com/apache/helix/pull/1119#discussion_r454706283", "createdAt": "2020-07-14T23:40:18Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);\n+          }\n+        });\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNzU0Mw==", "bodyText": "As mentioned above, the check of _syncOnNewSession can be put here to avoid the unnecessary ZK event.", "url": "https://github.com/apache/helix/pull/1119#discussion_r454707543", "createdAt": "2020-07-14T23:44:18Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);\n+          }\n+        });\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+\n+    SyncCallbackHandler callbackHandler = new SyncCallbackHandler(sessionId);\n+\n+    final ZkConnection zkConnection = (ZkConnection) getConnection();\n+    final ZooKeeper zk = zkConnection.getZookeeper();\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, _syncPath, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+        sessionId, code);\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n+\n+    _eventThread.send(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNzc4Ng==", "bodyText": "nit, to be compact,\nif (retrySync(sessionId) == false) {\n...\n}", "url": "https://github.com/apache/helix/pull/1119#discussion_r454707786", "createdAt": "2020-07-14T23:44:58Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);\n+          }\n+        });\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+\n+    SyncCallbackHandler callbackHandler = new SyncCallbackHandler(sessionId);\n+\n+    final ZkConnection zkConnection = (ZkConnection) getConnection();\n+    final ZooKeeper zk = zkConnection.getZookeeper();\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, _syncPath, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+        sessionId, code);\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n+\n+    _eventThread.send(\n+        new ZkEventThread.ZkEvent(\"Sync call before new session event of session \" + sessionId,\n+            sessionId) {\n+          @Override\n+          public void run() throws Exception {\n+            boolean syncStatus = retrySync(sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA==", "bodyText": "I think you can just refer the ZkClient object itself in the doAsyncSync call to simplify these codes. Or is there any concern of reading the Zookeeper inside doAsyncSync where it is really used?", "url": "https://github.com/apache/helix/pull/1119#discussion_r454708714", "createdAt": "2020-07-14T23:48:06Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);\n+          }\n+        });\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+\n+    SyncCallbackHandler callbackHandler = new SyncCallbackHandler(sessionId);\n+\n+    final ZkConnection zkConnection = (ZkConnection) getConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwOTc0MQ==", "bodyText": "I guess you concern if the Zookeeper object is changed if new session established. But I think we can still keep retrying the sync call, although it is in theory not possible because we stop retrying on session expiring.\nOr is there anything else?", "url": "https://github.com/apache/helix/pull/1119#discussion_r454709741", "createdAt": "2020-07-14T23:51:34Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,20 +1237,109 @@ private void reconnect() {\n     }\n   }\n \n+  private class SyncCallbackHandler extends ZkAsyncCallbacks.DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      } catch (ClassCastException | NullPointerException ex) {\n+        LOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying. ex {}\",\n+            _sessionId, rc, ex);\n+        return false;\n+      }\n+    }\n+  }\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, startT, cb);\n+          }\n+        });\n+  }\n+\n+  private boolean retrySync(String sessionId) throws ZkInterruptedException {\n+    if (!_syncOnNewSession) {\n+      return true;\n+    }\n+\n+    SyncCallbackHandler callbackHandler = new SyncCallbackHandler(sessionId);\n+\n+    final ZkConnection zkConnection = (ZkConnection) getConnection();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwODcxNA=="}, "originalCommit": {"oid": "2ea1d623e0aa9c095febe55a9a623610f9b5aadc"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMDgxMzA2", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-450081306", "createdAt": "2020-07-16T17:52:53Z", "commit": {"oid": "d001716f4e00deb7e07676eb031f519164dae800"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzo1Mjo1NFrOGy2BHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzo1NzowOVrOGy2LAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NzAwNA==", "bodyText": "Will there be potential sync on different code? If not, \"if\" statement will be much simpler than this.", "url": "https://github.com/apache/helix/pull/1119#discussion_r455967004", "createdAt": "2020-07-16T17:52:54Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -120,6 +122,41 @@ public void handle() {\n     }\n   }\n \n+  public static class SyncCallbackHandler extends DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    public SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        switch (KeeperException.Code.get(rc)) {\n+          /** Connection to the server has been lost */\n+          case CONNECTIONLOSS:\n+            return true;\n+          default:\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d001716f4e00deb7e07676eb031f519164dae800"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NzkzMw==", "bodyText": "The only usage for zkConnection is to get Zookeeper. Why not combine these two in oneline:\nfinal ZooKeeper zk = (ZkConnection) getConnection().getZookeeper();", "url": "https://github.com/apache/helix/pull/1119#discussion_r455967933", "createdAt": "2020-07-16T17:54:31Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1238,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, retrySync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  retrySync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean retrySync(String sessionId, ZooKeeper zk) throws ZkInterruptedException {\n+    ZkAsyncCallbacks.SyncCallbackHandler callbackHandler =\n+        new ZkAsyncCallbacks.SyncCallbackHandler(sessionId);\n+\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, _syncPath, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+        sessionId, code);\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n-    for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n+    if (_syncOnNewSession) {\n+      final ZkConnection zkConnection = (ZkConnection) getConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d001716f4e00deb7e07676eb031f519164dae800"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2OTE0OA==", "bodyText": "If there is a lot of connect/disconnect, could this zk.sync be called multiple times at same time? Would that cause potential problems?\nSince Zookeeper event thread is not dedup thread, are we just assuming the sync call could be short?", "url": "https://github.com/apache/helix/pull/1119#discussion_r455969148", "createdAt": "2020-07-16T17:56:29Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1238,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, retrySync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d001716f4e00deb7e07676eb031f519164dae800"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2OTUzOA==", "bodyText": "Let rename it. We dont have retry right now. It could cause reader confusing.", "url": "https://github.com/apache/helix/pull/1119#discussion_r455969538", "createdAt": "2020-07-16T17:57:09Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1238,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, retrySync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  retrySync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean retrySync(String sessionId, ZooKeeper zk) throws ZkInterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d001716f4e00deb7e07676eb031f519164dae800"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxOTI1NzUw", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-451925750", "createdAt": "2020-07-20T20:14:03Z", "commit": {"oid": "d001716f4e00deb7e07676eb031f519164dae800"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDoxNDowM1rOG0dp_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDoxNTowNlrOG0dsRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2NTAyMA==", "bodyText": "Don't forget to remove these unused static imports.\nFYI, actually I would prefer not to import the static constant. You could just use KeeperException.Code.CONNECTIONLOSS for better readability. Ref: https://docs.oracle.com/javase/7/docs/technotes/guides/language/static-import.html", "url": "https://github.com/apache/helix/pull/1119#discussion_r457665020", "createdAt": "2020-07-20T20:14:03Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -63,6 +68,10 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.zookeeper.KeeperException.Code.CONNECTIONLOSS;\n+import static org.apache.zookeeper.KeeperException.Code.OK;\n+import static org.apache.zookeeper.KeeperException.Code.SESSIONMOVED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d001716f4e00deb7e07676eb031f519164dae800"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2NTI1OA==", "bodyText": "static final?", "url": "https://github.com/apache/helix/pull/1119#discussion_r457665258", "createdAt": "2020-07-20T20:14:30Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -74,6 +83,7 @@\n public class ZkClient implements Watcher {\n   private static Logger LOG = LoggerFactory.getLogger(ZkClient.class);\n   private static long MAX_RECONNECT_INTERVAL_MS = 30000; // 30 seconds\n+  private static String ZK_AUTOSYNC_ENABLED_DEFAULT = \"true\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d001716f4e00deb7e07676eb031f519164dae800"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2NTYwNA==", "bodyText": "I think it is better to make it a constant: static final SYNC_PATH?", "url": "https://github.com/apache/helix/pull/1119#discussion_r457665604", "createdAt": "2020-07-20T20:15:06Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -105,6 +115,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  private final String _syncPath = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d001716f4e00deb7e07676eb031f519164dae800"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNzIwMTEx", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-453720111", "createdAt": "2020-07-22T22:08:59Z", "commit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjowODo1OVrOG119oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjowODo1OVrOG119oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTg0MA==", "bodyText": "I think I have commented before the name convention of static final field is SYNC_PATH.", "url": "https://github.com/apache/helix/pull/1119#discussion_r459111840", "createdAt": "2020-07-22T22:08:59Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -105,6 +111,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  private static final String _syncPath = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNzEzODIw", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-453713820", "createdAt": "2020-07-22T21:56:10Z", "commit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMTo1NjoxMFrOG11qPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjowOTowOFrOG1197Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwNjg3Nw==", "bodyText": "_syncPath -> SYNC_PATH?", "url": "https://github.com/apache/helix/pull/1119#discussion_r459106877", "createdAt": "2020-07-22T21:56:10Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -105,6 +111,9 @@\n   // ZkEventThread. Otherwise the retry request might block the normal event processing.\n   protected final ZkAsyncRetryThread _asyncCallRetryThread;\n \n+  private final boolean _syncOnNewSession;\n+  private static final String _syncPath = \"/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTU4Mg==", "bodyText": "Actually this is no need. If exception is thrown here, test will fail.", "url": "https://github.com/apache/helix/pull/1119#discussion_r459109582", "createdAt": "2020-07-22T22:03:10Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {\n+    final String path = \"/\" + TestHelper.getTestMethodName();\n+    final String data = \"Hello Helix 2\";\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper\n+        .verify(() -> _zkClient.getConnection().getZookeeperState().isConnected(), 1000L));\n+\n+    final long originalSessionId = _zkClient.getSessionId();\n+\n+    try {\n+      // Create node.\n+      _zkClient.create(path, data, CreateMode.PERSISTENT);\n+    } catch (Exception ex) {\n+      Assert.fail(\"Failed to create ephemeral node.\", ex);\n+    }\n+\n+    // Expire the original session.\n+    ZkTestHelper.expireSession(_zkClient);\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper.verify(() -> {\n+      try {\n+        // New session id should not equal to expired session id.\n+        return _zkClient.getSessionId() != originalSessionId;\n+      } catch (ZkClientException ex) {\n+        return false;\n+      }\n+    }, 1000L));\n+\n+    // Verify the node is created and its data is correct.\n+    Stat stat = new Stat();\n+    String nodeData = null;\n+    try {\n+       nodeData = _zkClient.readData(path, stat, true);\n+    } catch (ZkException e) {\n+      Assert.fail(\"fail to read data\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTY2NA==", "bodyText": "Same. Actually this is no need. If exception is thrown here, test will fail.\nRealizing this will also help you with later tests implement.", "url": "https://github.com/apache/helix/pull/1119#discussion_r459109664", "createdAt": "2020-07-22T22:03:23Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {\n+    final String path = \"/\" + TestHelper.getTestMethodName();\n+    final String data = \"Hello Helix 2\";\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper\n+        .verify(() -> _zkClient.getConnection().getZookeeperState().isConnected(), 1000L));\n+\n+    final long originalSessionId = _zkClient.getSessionId();\n+\n+    try {\n+      // Create node.\n+      _zkClient.create(path, data, CreateMode.PERSISTENT);\n+    } catch (Exception ex) {\n+      Assert.fail(\"Failed to create ephemeral node.\", ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTkxNw==", "bodyText": "I wonder how NullPointerException is thrown?\nI think KeeperException.Code.get(rc) returns null if rc is not a valid KeeperException code.\nSo if it returns null, I think we log it as unknot return code?", "url": "https://github.com/apache/helix/pull/1119#discussion_r459111917", "createdAt": "2020-07-22T22:09:08Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -120,6 +122,39 @@ public void handle() {\n     }\n   }\n \n+  public static class SyncCallbackHandler extends DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    public SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        // Connection to the server has been lost\n+        if (KeeperException.Code.get(rc) == Code.CONNECTIONLOSS) {\n+          return true;\n+        } \n+        return false;\n+      } catch (ClassCastException | NullPointerException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNzIzNDQ0", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-453723444", "createdAt": "2020-07-22T22:16:08Z", "commit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjoxNjowOFrOG12ILg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjoxNjowOFrOG12ILg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNDU0Mg==", "bodyText": "I still think Zookeeper is not required here. Please see my reply to the original thread. If we put the check logic here, it will work.\nThe reason I insist on doing this is that, when you put the old zk object here, if any new session created, then the old zk object will throw exceptions when you call it. That would be a ZK exception. And then we rely on our exception handling logic to ensure everything works fine.\nIf we check the current zk object with the session Id, then we can end this operation with explicit logic and with a very clean warning or error log.\nMoreover, as I mentioned in the first comment, the session Id and the input zk contain redundant information. You only need one of them.", "url": "https://github.com/apache/helix/pull/1119#discussion_r459114542", "createdAt": "2020-07-22T22:16:08Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1234,84 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(String sessionId, ZooKeeper zk) throws ZkInterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNzc5NTE1", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-453779515", "createdAt": "2020-07-23T01:01:51Z", "commit": {"oid": "9e6dafa1f4151613f5537f4a49e18254620bc40d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMTowMTo1MlrOG15MFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMToxMDoyMVrOG15UEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NDY5Mw==", "bodyText": "Nit. This could be a constant: static final boolean SYNC_ON_NEW_SESSION = Boolean.parseBoolean(System.getProperty(ZkSystemPropertyKeys.ZK_AUTOSYNC_ENABLED, ZK_AUTOSYNC_ENABLED_DEFAULT))", "url": "https://github.com/apache/helix/pull/1119#discussion_r459164693", "createdAt": "2020-07-23T01:01:52Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -187,6 +196,10 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     if (zkConnection == null) {\n       throw new NullPointerException(\"Zookeeper connection is null!\");\n     }\n+\n+    String syncUpOnNewSession = System.getProperty(ZkSystemPropertyKeys.ZK_AUTOSYNC_ENABLED, ZK_AUTOSYNC_ENABLED_DEFAULT);\n+    _syncOnNewSession = Boolean.parseBoolean(syncUpOnNewSession);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6dafa1f4151613f5537f4a49e18254620bc40d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTYzMw==", "bodyText": "I meant, it is not about it doesn't hurt. ZkTestHelper.expireSession(_zkClient) could also possibly throw exception. Are you going to do this try...catch...fail?\nIf this test throws exception, it definitely will fail from the point where exception is thrown.", "url": "https://github.com/apache/helix/pull/1119#discussion_r459165633", "createdAt": "2020-07-23T01:05:56Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {\n+    final String path = \"/\" + TestHelper.getTestMethodName();\n+    final String data = \"Hello Helix 2\";\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper\n+        .verify(() -> _zkClient.getConnection().getZookeeperState().isConnected(), 1000L));\n+\n+    final long originalSessionId = _zkClient.getSessionId();\n+\n+    try {\n+      // Create node.\n+      _zkClient.create(path, data, CreateMode.PERSISTENT);\n+    } catch (Exception ex) {\n+      Assert.fail(\"Failed to create ephemeral node.\", ex);\n+    }\n+\n+    // Expire the original session.\n+    ZkTestHelper.expireSession(_zkClient);\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper.verify(() -> {\n+      try {\n+        // New session id should not equal to expired session id.\n+        return _zkClient.getSessionId() != originalSessionId;\n+      } catch (ZkClientException ex) {\n+        return false;\n+      }\n+    }, 1000L));\n+\n+    // Verify the node is created and its data is correct.\n+    Stat stat = new Stat();\n+    String nodeData = null;\n+    try {\n+       nodeData = _zkClient.readData(path, stat, true);\n+    } catch (ZkException e) {\n+      Assert.fail(\"fail to read data\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTU4Mg=="}, "originalCommit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NjczNw==", "bodyText": "@kaisun2000 Could you help understand this: KeeperException.Code.get() can throw null point exception. Underneath the lookup is a map. map.get(rc) returns null if rc doesn't exist.\n/**\n         * Get the Code value for a particular integer error code\n         * @param code int error code\n         * @return Code value corresponding to specified int code, or null\n         */\n        public static Code get(int code) {\n            return lookup.get(code);\n        }\n\nThe code should be like\nif (KeeperException.Code.get(rc) == Code.CONNECTIONLOSS) {\n     return true;\n}\nLOG.error(\"Session {} failed to handle unknown return code {}. Skip retrying.\",\n             _sessionId, rc);\nreturn false;", "url": "https://github.com/apache/helix/pull/1119#discussion_r459166737", "createdAt": "2020-07-23T01:10:21Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -120,6 +122,39 @@ public void handle() {\n     }\n   }\n \n+  public static class SyncCallbackHandler extends DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    public SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);\n+      callback(rc, path, ctx);\n+    }\n+\n+    @Override\n+    public void handle() {\n+      // Make compiler happy, not used.\n+    }\n+\n+    @Override\n+    protected boolean needRetry(int rc) {\n+      try {\n+        // Connection to the server has been lost\n+        if (KeeperException.Code.get(rc) == Code.CONNECTIONLOSS) {\n+          return true;\n+        } \n+        return false;\n+      } catch (ClassCastException | NullPointerException ex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTkxNw=="}, "originalCommit": {"oid": "9468e5d9e774dd1c79cae48d66e94d3287522a33"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzODk2Nzk4", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-453896798", "createdAt": "2020-07-23T07:38:45Z", "commit": {"oid": "9e6dafa1f4151613f5537f4a49e18254620bc40d"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNzozODo0NlrOG1_Yjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwODozNDowMVrOG2BGVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2NjE5MA==", "bodyText": "Nit, I think assertTrue(_zkClient.waitUntilConnected(1, TimeUnit.Second)); would be better than polling", "url": "https://github.com/apache/helix/pull/1119#discussion_r459266190", "createdAt": "2020-07-23T07:38:46Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {\n+    final String path = \"/\" + TestHelper.getTestMethodName();\n+    final String data = \"Hello Helix 2\";\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6dafa1f4151613f5537f4a49e18254620bc40d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2NzE1Mw==", "bodyText": "No need for this check, as it is already verified new session is established in ZkTestHelper.expireSession().", "url": "https://github.com/apache/helix/pull/1119#discussion_r459267153", "createdAt": "2020-07-23T07:40:49Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {\n+    final String path = \"/\" + TestHelper.getTestMethodName();\n+    final String data = \"Hello Helix 2\";\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper\n+        .verify(() -> _zkClient.getConnection().getZookeeperState().isConnected(), 1000L));\n+\n+    final long originalSessionId = _zkClient.getSessionId();\n+\n+    try {\n+      // Create node.\n+      _zkClient.create(path, data, CreateMode.PERSISTENT);\n+    } catch (Exception ex) {\n+      Assert.fail(\"Failed to create ephemeral node.\", ex);\n+    }\n+\n+    // Expire the original session.\n+    ZkTestHelper.expireSession(_zkClient);\n+\n+    // Wait until the ZkClient has got a new session.\n+    Assert.assertTrue(TestHelper.verify(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6dafa1f4151613f5537f4a49e18254620bc40d"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3MTAxMg==", "bodyText": "Do I understand correctly? This test actually doesn't really test sync, because:\nit is only one zk. It doesn't have to propagate data to other zk learners. So even without sync, this test will always pass, as the zkclient always connects to the same zk so it always sees the latest data.\nI actually think it may be difficult to test sync here. We could see how zk tests sync, which is more complicated: https://github.com/apache/zookeeper/blob/master/zookeeper-server/src/test/java/org/apache/zookeeper/test/SyncCallTest.java", "url": "https://github.com/apache/helix/pull/1119#discussion_r459271012", "createdAt": "2020-07-23T07:49:12Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -553,6 +554,52 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6dafa1f4151613f5537f4a49e18254620bc40d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5MjkwOQ==", "bodyText": "From your comment The sync() would fail with a stale session., I understand that if the session expires, the following events with the expired session calls handleNewSession but they are skipped.\nI think there is other case other than sessionExpired that causes issueSync() to fail. If it fails, warn msg is logged. But stateListener still calls handleNewSession. It conflicts the log \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\". Then there is still a possibility handleNewSession reads stale data. Do I miss anything?", "url": "https://github.com/apache/helix/pull/1119#discussion_r459292909", "createdAt": "2020-07-23T08:31:28Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1234,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {\n+    String sessionId = Long.toHexString(zk.getSessionId());\n+    ZkAsyncCallbacks.SyncCallbackHandler callbackHandler =\n+        new ZkAsyncCallbacks.SyncCallbackHandler(sessionId);\n+\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, SYNC_PATH, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == KeeperException.Code.OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",\n+        sessionId, code);\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n-    for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n+    if (_syncOnNewSession) {\n+      final ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+      _eventThread.send(new ZkEventThread.ZkEvent(\"Sync call before new session event of session \" + sessionId,\n+          sessionId) {\n         @Override\n         public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n+          if (issueSync(zk) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6dafa1f4151613f5537f4a49e18254620bc40d"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5NDI5NQ==", "bodyText": "I think this log should be outside of issueSync as \"stop calling handleNewSession\" is outside logic. This issueSync jus tells sync succeeds or not. But it doesn't have to determine handleNewSession or not, right?", "url": "https://github.com/apache/helix/pull/1119#discussion_r459294295", "createdAt": "2020-07-23T08:34:01Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1221,21 +1234,85 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {\n+    String sessionId = Long.toHexString(zk.getSessionId());\n+    ZkAsyncCallbacks.SyncCallbackHandler callbackHandler =\n+        new ZkAsyncCallbacks.SyncCallbackHandler(sessionId);\n+\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, SYNC_PATH, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == KeeperException.Code.OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; Log the error and return\n+    LOG.warn(\n+        \"sycnOnNewSession with sessionID {} async return code: {} and not retryable, stop calling handleNewSession\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6dafa1f4151613f5537f4a49e18254620bc40d"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDE0MzI4", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-454414328", "createdAt": "2020-07-23T19:00:45Z", "commit": {"oid": "63a004ce6e299d6f7770c1b90dda0d9f873e16bc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "166ef21e2c53f9614081b89a5f1eaf570f835c7a", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/166ef21e2c53f9614081b89a5f1eaf570f835c7a", "committedDate": "2020-07-23T19:07:22Z", "message": "Add sync() call first for new session handling (#1118)\n\nHelix may see stale data when session expires and get reconnected to\na slower ZKServer. This would cause various correctness problem.\nWe would call sync() to ZKserver first. This ensures Helix would\nnot see data that saw before."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ed63d4cc8f491eb47a9907e8c2225d39ff02ec7", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/7ed63d4cc8f491eb47a9907e8c2225d39ff02ec7", "committedDate": "2020-07-23T19:07:32Z", "message": "format code with style sheet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc3b91ae65417a621dc2c30c2d9ed0bc7c62c633", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/fc3b91ae65417a621dc2c30c2d9ed0bc7c62c633", "committedDate": "2020-07-23T19:07:32Z", "message": "blocking version."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "542e29304e5e6bee0a5e1f68d369be1bb08d8fac", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/542e29304e5e6bee0a5e1f68d369be1bb08d8fac", "committedDate": "2020-07-23T19:07:32Z", "message": "leverage AsyncCallbacks pattern; rebased"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "645cf93c9ceab44e54738c6e87a2ffbd5a6c0d17", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/645cf93c9ceab44e54738c6e87a2ffbd5a6c0d17", "committedDate": "2020-07-23T19:07:32Z", "message": "minor fix of return value."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bfdfeabece7419d8ba4b9a37b0d33b37c57f36f", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/0bfdfeabece7419d8ba4b9a37b0d33b37c57f36f", "committedDate": "2020-07-23T19:07:32Z", "message": "some further refactor based on feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16333a32276a111b1cfe9119c1ea4af413fe3bf3", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/16333a32276a111b1cfe9119c1ea4af413fe3bf3", "committedDate": "2020-07-23T19:08:50Z", "message": "treat sync() metric the same as Zk server metric"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ef1888f9d4890cef0343711cd5328bffae5749a", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/2ef1888f9d4890cef0343711cd5328bffae5749a", "committedDate": "2020-07-23T19:08:53Z", "message": "added tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89bf13fb5cd710bd1b7026288759f47782c1cf33", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/89bf13fb5cd710bd1b7026288759f47782c1cf33", "committedDate": "2020-07-23T19:09:59Z", "message": "mintor style fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb1eaac31e63031c8905891d9b454059c664816e", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/cb1eaac31e63031c8905891d9b454059c664816e", "committedDate": "2020-07-23T19:10:02Z", "message": "remove redundant params to issueSync()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/3a564e1805dafa3323ba1370843e6a0b4102a8c2", "committedDate": "2020-07-23T19:10:02Z", "message": "some change based on huizhi's feedback."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63a004ce6e299d6f7770c1b90dda0d9f873e16bc", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/63a004ce6e299d6f7770c1b90dda0d9f873e16bc", "committedDate": "2020-07-23T18:48:29Z", "message": "some change based on huizhi's feedback."}, "afterCommit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/3a564e1805dafa3323ba1370843e6a0b4102a8c2", "committedDate": "2020-07-23T19:10:02Z", "message": "some change based on huizhi's feedback."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDI5NDg3", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-454429487", "createdAt": "2020-07-23T19:23:17Z", "commit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOToyMzoxN1rOG2YY6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOToyMzoxN1rOG2YY6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NTg4MA==", "bodyText": "should we name it \"zk.zkclient.autosync.enabled\"?  zk is higher namespace, it includes configs not only applies to zkClient, it could be all zk-related configs in Helix.", "url": "https://github.com/apache/helix/pull/1119#discussion_r459675880", "createdAt": "2020-07-23T19:23:17Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/ZkSystemPropertyKeys.java", "diffHunk": "@@ -50,4 +50,14 @@\n    */\n   public static final String ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES =\n       \"zk.serializer.znrecord.write.size.limit.bytes\";\n+\n+  /**\n+   * This property determines the behavior of ZkClient issuing an sync() to server upon new session\n+   * established.\n+   *\n+   * <p>\n+   *   The default value is \"true\" (issuing sync)\n+   */\n+  public static final String ZK_AUTOSYNC_ENABLED =\n+      \"zk.autosync.enabled\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d59ff16a27f7f424a415b9412f7f171727973ef", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/7d59ff16a27f7f424a415b9412f7f171727973ef", "committedDate": "2020-07-23T19:27:32Z", "message": "change to make sure not understanding return code is logged."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDMzMjgw", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-454433280", "createdAt": "2020-07-23T19:29:04Z", "commit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOToyOTowNFrOG2YknA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOToyOTowNFrOG2YknA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3ODg3Ng==", "bodyText": "Should this config per zkClient or globally in one JVM? If it is globally, the syncUpOnNewSession should be static and initiated at place it is defined?", "url": "https://github.com/apache/helix/pull/1119#discussion_r459678876", "createdAt": "2020-07-23T19:29:04Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -200,6 +211,10 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     if (zkConnection == null) {\n       throw new NullPointerException(\"Zookeeper connection is null!\");\n     }\n+\n+    String syncUpOnNewSession = System.getProperty(ZkSystemPropertyKeys.ZK_AUTOSYNC_ENABLED, ZK_AUTOSYNC_ENABLED_DEFAULT);\n+    _syncOnNewSession = Boolean.parseBoolean(syncUpOnNewSession);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDQ1Mjc3", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-454445277", "createdAt": "2020-07-23T19:48:07Z", "commit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo0ODowN1rOG2ZJ2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo0ODowN1rOG2ZJ2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4ODQxMA==", "bodyText": "If we do not plan to change doAsynSync as a public API, i.e, it will use internally in this case, why not merge this two methods together to one?", "url": "https://github.com/apache/helix/pull/1119#discussion_r459688410", "createdAt": "2020-07-23T19:48:07Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1256,21 +1271,82 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDQ2NzY1", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-454446765", "createdAt": "2020-07-23T19:50:23Z", "commit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo1MDoyM1rOG2ZOSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo1MDoyM1rOG2ZOSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4OTU0Nw==", "bodyText": "getHexSessionId()?", "url": "https://github.com/apache/helix/pull/1119#discussion_r459689547", "createdAt": "2020-07-23T19:50:23Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1256,21 +1271,82 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {\n+    String sessionId = Long.toHexString(zk.getSessionId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDQ3NjY1", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-454447665", "createdAt": "2020-07-23T19:51:50Z", "commit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo1MTo1MFrOG2ZRAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo1MTo1MFrOG2ZRAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MDI0Mg==", "bodyText": "suggest to change to \"Failed to call sync() on new session {}\" to be more specific.", "url": "https://github.com/apache/helix/pull/1119#discussion_r459690242", "createdAt": "2020-07-23T19:51:50Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1256,21 +1271,82 @@ private void reconnect() {\n     }\n   }\n \n+\n+\n+  private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n+      final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n+    zk.sync(path, cb,\n+        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+          @Override\n+          protected void doRetry() throws Exception {\n+            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+          }\n+        });\n+  }\n+\n+  /*\n+   *  Note, issueSync takes a ZooKeeper (client) object and pass it to doAsyncSync().\n+   *  The reason we do this is that we want to ensure each new session event is preceded with exactly\n+   *  one sync() to server. The sync() is to make sure the server would not see stale data.\n+   *\n+   *  ZooKeeper client object has an invariant of each object has one session. With this invariant\n+   *  we can achieve each one sync() to server upon new session establishment. The reasoning is:\n+   *  issueSync() is called when fireNewSessionEvents() which in under eventLock of ZkClient. Thus\n+   *  we are guaranteed the ZooKeeper object passed in would have the new incoming sessionId. If by\n+   *  the time sync() is invoked, the session expires. The sync() would fail with a stale session.\n+   *  This is exactly what we want. The newer session would ensure another fireNewSessionEvents.\n+   */\n+  private boolean issueSync(ZooKeeper zk) {\n+    String sessionId = Long.toHexString(zk.getSessionId());\n+    ZkAsyncCallbacks.SyncCallbackHandler callbackHandler =\n+        new ZkAsyncCallbacks.SyncCallbackHandler(sessionId);\n+\n+    final long startT = System.currentTimeMillis();\n+    doAsyncSync(zk, SYNC_PATH, startT, callbackHandler);\n+\n+    callbackHandler.waitForSuccess();\n+\n+    KeeperException.Code code = KeeperException.Code.get(callbackHandler.getRc());\n+    if (code == KeeperException.Code.OK) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {} and proceeds\", sessionId,\n+          code);\n+      return true;\n+    }\n+\n+    // Not retryable error, including session expiration; return false.\n+    return false;\n+  }\n+\n   private void fireNewSessionEvents() {\n     // only managing zkclient fire handleNewSession event\n     if (!isManagingZkConnection()) {\n       return;\n     }\n     final String sessionId = getHexSessionId();\n-    for (final IZkStateListener stateListener : _stateListener) {\n-      _eventThread.send(new ZkEventThread.ZkEvent(\"New session event sent to \" + stateListener, sessionId) {\n \n+    if (_syncOnNewSession) {\n+      final ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+      _eventThread.send(new ZkEventThread.ZkEvent(\"Sync call before new session event of session \" + sessionId,\n+          sessionId) {\n         @Override\n         public void run() throws Exception {\n-          stateListener.handleNewSession(sessionId);\n+          if (issueSync(zk) == false) {\n+            LOG.warn(\"sync on session {} failed\", sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDQ5Mzc5", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-454449379", "createdAt": "2020-07-23T19:54:36Z", "commit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo1NDozNlrOG2ZWkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo1NDozNlrOG2ZWkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MTY2NA==", "bodyText": "Do we need a info log here if return success?  Also \"syncOnNewSession\" is not accurate, it should be \"sync() call\", right?", "url": "https://github.com/apache/helix/pull/1119#discussion_r459691664", "createdAt": "2020-07-23T19:54:36Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -120,6 +122,39 @@ public void handle() {\n     }\n   }\n \n+  public static class SyncCallbackHandler extends DefaultCallback implements AsyncCallback.VoidCallback {\n+    private String _sessionId;\n+\n+    public SyncCallbackHandler(String sessionId) {\n+      _sessionId = sessionId;\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      LOG.info(\"sycnOnNewSession with sessionID {} async return code: {}\", _sessionId, rc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDUwNzcz", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-454450773", "createdAt": "2020-07-23T19:56:43Z", "commit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo1Njo0M1rOG2Za-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo1Njo0M1rOG2Za-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5Mjc5Mg==", "bodyText": "This test seems is not quite relevant, how can we at least make sure the sync call success from this test?", "url": "https://github.com/apache/helix/pull/1119#discussion_r459692792", "createdAt": "2020-07-23T19:56:43Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -558,6 +558,41 @@ public void testCreateEphemeralWithValidSession()\n     _zkClient.delete(path);\n   }\n \n+  /*\n+   * This test validates that when ZK_AUTOSYNC_ENABLED_DEFAULT is enabled, sync() would be issued\n+   * before handleNewSession. ZKclient would not see stale data.\n+   */\n+  @Test\n+  public void testAutoSyncWithNewSessionEstablishment() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a564e1805dafa3323ba1370843e6a0b4102a8c2"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9658e39799d8279989e6de73eb09a91e1ad9442", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/f9658e39799d8279989e6de73eb09a91e1ad9442", "committedDate": "2020-07-23T21:30:00Z", "message": "address some further comment from Lei"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NTMxMDg2", "url": "https://github.com/apache/helix/pull/1119#pullrequestreview-454531086", "createdAt": "2020-07-23T22:13:03Z", "commit": {"oid": "f9658e39799d8279989e6de73eb09a91e1ad9442"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMjoxMzowM1rOG2dXTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMjoxMzowM1rOG2dXTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc1NzM4OA==", "bodyText": "Unnecessary extra comma @kaisun2000", "url": "https://github.com/apache/helix/pull/1119#discussion_r459757388", "createdAt": "2020-07-23T22:13:03Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -118,6 +126,12 @@\n     NUM_CHILDREN_LIMIT = 100 * 1000;\n   }\n \n+  private static final boolean SYNC_ON_SESSION = Boolean.parseBoolean(\n+      System.getProperty(ZkSystemPropertyKeys.ZK_AUTOSYNC_ENABLED, ZK_AUTOSYNC_ENABLED_DEFAULT));\n+  ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9658e39799d8279989e6de73eb09a91e1ad9442"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4524, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}