{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4NjQ2NDI2", "number": 1149, "title": "Refine the ZkHelixManager.disconnect() method so it won't be blocked when the ZK connection breaks.", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\n#1148\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThe issue was that if ZkHelixManager.disconnect() is called when the ZK connection is not synConnected, the disconnect() call will hang and never return. This usually blocks Helix users' code when they try to clean up and finalize after ZK connection becomes unrecoverable.\nThis PR introduces a temporary thread to finish the cleanup work which relies on the ZK connection (or application code). This thread will be interrupted if ZK connection breaks before or during the disconnect process.\nTests\n\n The following tests are written for this issue:\n\nTestZkConnectionLost.testDisconnectWhenConnectionBreak()\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\nhelix-core\n[INFO] Tests run: 1152, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4,613.998 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 1152, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\nhelix-rest\n[INFO] Tests run: 163, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 46.568 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 163, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation (Optional)\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-07-14T05:06:32Z", "url": "https://github.com/apache/helix/pull/1149", "merged": true, "mergeCommit": {"oid": "3b7c991b32dd5d6ff76298f27ac9ed9e22bb2e83"}, "closed": true, "closedAt": "2020-07-16T20:52:47Z", "author": {"login": "jiajunwang"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0u4MEgH2gAyNDQ4NjQ2NDI2OjU2MjNlOWNjYjljYzNmNzJjMjAxMTFmMDkzMmQyMWNjNTdlYmY3NGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1lYCugFqTQ1MDE5NzM1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5623e9ccb9cc3f72c20111f0932d21cc57ebf74a", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/5623e9ccb9cc3f72c20111f0932d21cc57ebf74a", "committedDate": "2020-07-14T05:07:09Z", "message": "Refine the ZkHelixManager.disconnect() method so it won't be blocked when the ZK connection breaks.\n\nThe issue was that if ZkHelixManager.disconnect() is called when the ZK connection is not synConnected, the disconnect() call will hang and never return. This usually blocks Helix users' code when they try to cleanup and finalize after ZK connection becomes unrecoverable.\nThis PR introduces a temporary thread to finish the cleanup work which relies on the ZK connection (or application code). This thread will be interrpted if ZK connection breaks before or during the disconnect process."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3ODMzNzQ3", "url": "https://github.com/apache/helix/pull/1149#pullrequestreview-447833747", "createdAt": "2020-07-14T06:52:00Z", "commit": {"oid": "8bee314ba8b8e208ca37bb5384c0bbfb2d309d25"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNjo1MjowMFrOGxGkVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNjo1MjowMFrOGxGkVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE0MTAxMg==", "bodyText": "Instead of giving a hard-coded timeout value, do you think we could use a CountDownLatch for this so the test doesn't depend on timing?", "url": "https://github.com/apache/helix/pull/1149#discussion_r454141012", "createdAt": "2020-07-14T06:52:00Z", "author": {"login": "narendly"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkConnectionLost.java", "diffHunk": "@@ -103,6 +104,28 @@ public void afterClass() throws Exception {\n     TestHelper.stopZkServer(_zkServerRef.get());\n   }\n \n+  @Test\n+  public void testDisconnectWhenConnectionBreak() throws Exception {\n+    _zkServerRef.get().shutdown();\n+    AtomicBoolean disconnected = new AtomicBoolean(false);\n+    Thread testThread = new Thread(\"Testing HelixManager disconnect\") {\n+      @Override\n+      public void run() {\n+        _controller.disconnect();\n+        disconnected.set(true);\n+      }\n+    };\n+    try {\n+      testThread.start();\n+      testThread.join(5000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bee314ba8b8e208ca37bb5384c0bbfb2d309d25"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8bee314ba8b8e208ca37bb5384c0bbfb2d309d25", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/8bee314ba8b8e208ca37bb5384c0bbfb2d309d25", "committedDate": "2020-07-14T05:02:36Z", "message": "Refine the ZkHelixManager.disconnect() method so it won't be blocked when the ZK connection breaks.\n\nThe issue was that if ZkHelixManager.disconnect() is called when the ZK connection is not synConnected, the disconnect() call will hang and never return. This usually blocks Helix users' code when they try to cleanup and finalize after ZK connection becomes unrecoverable.\nThis PR introduces a temporary thread to finish the cleanup work which relies on the ZK connection (or application code). This thread will be interrpted if ZK connection breaks before or during the disconnect process."}, "afterCommit": {"oid": "d3cc4b01503b137929f04eeb8488a4aa54ed470e", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/d3cc4b01503b137929f04eeb8488a4aa54ed470e", "committedDate": "2020-07-14T08:19:32Z", "message": "Fix test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "231a65aec9f35f47f26354ebb14ae055b9054e82", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/231a65aec9f35f47f26354ebb14ae055b9054e82", "committedDate": "2020-07-14T18:04:14Z", "message": "Fix test."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MzQ4ODMz", "url": "https://github.com/apache/helix/pull/1149#pullrequestreview-448348833", "createdAt": "2020-07-14T18:13:25Z", "commit": {"oid": "d3cc4b01503b137929f04eeb8488a4aa54ed470e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxODoxMzoyNVrOGxfhkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxODoxMzoyNVrOGxfhkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU0OTkwNw==", "bodyText": "Why are these imports needed?", "url": "https://github.com/apache/helix/pull/1149#discussion_r454549907", "createdAt": "2020-07-14T18:13:25Z", "author": {"login": "narendly"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkConnectionLost.java", "diffHunk": "@@ -39,15 +40,15 @@\n import org.apache.helix.integration.task.WorkflowGenerator;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n import org.apache.helix.manager.zk.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n import org.apache.helix.task.JobConfig;\n import org.apache.helix.task.JobQueue;\n import org.apache.helix.task.TaskState;\n import org.apache.helix.task.WorkflowContext;\n import org.apache.helix.tools.ClusterSetup;\n import org.apache.helix.tools.ClusterVerifiers.BestPossibleExternalViewVerifier;\n import org.apache.helix.tools.ClusterVerifiers.ZkHelixClusterVerifier;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3cc4b01503b137929f04eeb8488a4aa54ed470e"}, "originalPosition": 22}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d3cc4b01503b137929f04eeb8488a4aa54ed470e", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/d3cc4b01503b137929f04eeb8488a4aa54ed470e", "committedDate": "2020-07-14T08:19:32Z", "message": "Fix test."}, "afterCommit": {"oid": "231a65aec9f35f47f26354ebb14ae055b9054e82", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/231a65aec9f35f47f26354ebb14ae055b9054e82", "committedDate": "2020-07-14T18:04:14Z", "message": "Fix test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85", "committedDate": "2020-07-16T01:03:20Z", "message": "Simply the logic little bit."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMDY3NTM5", "url": "https://github.com/apache/helix/pull/1149#pullrequestreview-450067539", "createdAt": "2020-07-16T17:34:36Z", "commit": {"oid": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzozNDozN1rOGy1WIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzozNzowNFrOGy1bpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NjAwMQ==", "bodyText": "Why this require an active zkclient? CallbackHandler are in memory object, is there anything we need to connection to ZK?", "url": "https://github.com/apache/helix/pull/1149#discussion_r455956001", "createdAt": "2020-07-16T17:34:37Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -866,6 +858,83 @@ public void disconnect() {\n     }\n   }\n \n+  /**\n+   * The callback handler cleanup operations that require an active ZkClient connection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NzQxMw==", "bodyText": "It is complicated to create a listener for subscription. Shall we use some simple way to see whether the connection is alive? For example, just have an exist call for the cluster since it is in HelixManager?", "url": "https://github.com/apache/helix/pull/1149#discussion_r455957413", "createdAt": "2020-07-16T17:37:04Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -866,6 +858,83 @@ public void disconnect() {\n     }\n   }\n \n+  /**\n+   * The callback handler cleanup operations that require an active ZkClient connection.\n+   * If ZkClient is not connected, Helix Manager shall skip the cleanup.\n+   *\n+   * @return true if the cleanup has been done successfully.\n+   */\n+  private boolean cleanupCallbackHandlers() {\n+    AtomicBoolean cleanupDone = new AtomicBoolean(false);\n+\n+    if (_zkclient.waitUntilConnected(_waitForConnectedTimeout, TimeUnit.MILLISECONDS)) {\n+      // Create a separate thread for executing cleanup task to avoid forever retry.\n+      Thread cleanupThread = new Thread(String\n+          .format(\"Cleanup thread for %s-%s-%s\", _clusterName, _instanceName, _instanceType)) {\n+        @Override\n+        public void run() {\n+          // TODO reset user defined handlers only\n+          resetHandlers(true);\n+\n+          if (_leaderElectionHandler != null) {\n+            _leaderElectionHandler.reset(true);\n+          }\n+\n+          ParticipantManager participantManager = _participantManager;\n+          if (participantManager != null) {\n+            participantManager.disconnect();\n+          }\n+\n+          cleanupDone.set(true);\n+        }\n+      };\n+\n+      // Define the state listener to terminate the cleanup thread when the ZkConnection breaks.\n+      IZkStateListener stateListener = new IZkStateListener() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTAxNjM1", "url": "https://github.com/apache/helix/pull/1149#pullrequestreview-450101635", "createdAt": "2020-07-16T18:21:07Z", "commit": {"oid": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODoyMTowN1rOGy3DTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODoyMTowN1rOGy3DTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4Mzk0OA==", "bodyText": "Will the call be hanging here as well? If there is no connection, cleanupThread got interrupted, but no one set this value to be true.", "url": "https://github.com/apache/helix/pull/1149#discussion_r455983948", "createdAt": "2020-07-16T18:21:07Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -866,6 +858,83 @@ public void disconnect() {\n     }\n   }\n \n+  /**\n+   * The callback handler cleanup operations that require an active ZkClient connection.\n+   * If ZkClient is not connected, Helix Manager shall skip the cleanup.\n+   *\n+   * @return true if the cleanup has been done successfully.\n+   */\n+  private boolean cleanupCallbackHandlers() {\n+    AtomicBoolean cleanupDone = new AtomicBoolean(false);\n+\n+    if (_zkclient.waitUntilConnected(_waitForConnectedTimeout, TimeUnit.MILLISECONDS)) {\n+      // Create a separate thread for executing cleanup task to avoid forever retry.\n+      Thread cleanupThread = new Thread(String\n+          .format(\"Cleanup thread for %s-%s-%s\", _clusterName, _instanceName, _instanceType)) {\n+        @Override\n+        public void run() {\n+          // TODO reset user defined handlers only\n+          resetHandlers(true);\n+\n+          if (_leaderElectionHandler != null) {\n+            _leaderElectionHandler.reset(true);\n+          }\n+\n+          ParticipantManager participantManager = _participantManager;\n+          if (participantManager != null) {\n+            participantManager.disconnect();\n+          }\n+\n+          cleanupDone.set(true);\n+        }\n+      };\n+\n+      // Define the state listener to terminate the cleanup thread when the ZkConnection breaks.\n+      IZkStateListener stateListener = new IZkStateListener() {\n+        @Override\n+        public void handleStateChanged(KeeperState state) {\n+          // If the connection breaks during the cleanup , then stop the cleanup thread.\n+          if (state != KeeperState.SyncConnected) {\n+            cleanupThread.interrupt();\n+          }\n+        }\n+\n+        @Override\n+        public void handleNewSession(String sessionId) {\n+          // nothing\n+        }\n+\n+        @Override\n+        public void handleSessionEstablishmentError(Throwable error) {\n+          // nothing\n+        }\n+      };\n+\n+      cleanupThread.start();\n+      try {\n+        // Subscribe and check the connection status one more time to ensure the thread is running\n+        // with an active ZkConnection.\n+        _zkclient.subscribeStateChanges(stateListener);\n+        if (!_zkclient.waitUntilConnected(0, TimeUnit.MILLISECONDS)) {\n+          cleanupThread.interrupt();\n+        }\n+\n+        try {\n+          cleanupThread.join();\n+        } catch (InterruptedException ex) {\n+          cleanupThread.interrupt();\n+        }\n+      } finally {\n+        _zkclient.unsubscribeStateChanges(stateListener);\n+      }\n+    } else {\n+      LOG.warn(\n+          \"ZkClient is not connected to the Zookeeper. Skip the cleanup work that requires accessing Zookeeper.\");\n+    }\n+\n+    return cleanupDone.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85"}, "originalPosition": 141}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTk3MzU1", "url": "https://github.com/apache/helix/pull/1149#pullrequestreview-450197355", "createdAt": "2020-07-16T20:36:49Z", "commit": {"oid": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4557, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}