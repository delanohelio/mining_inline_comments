{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3OTU4OTQ1", "number": 1058, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODoxNzo1NVrOEDkbkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODoyODo1M1rOEEaeeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTc4MDY1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODoxNzo1NVrOGgqbcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjoxMjo0OFrOGhmLuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMjc3MQ==", "bodyText": "Let's have a different name for this private class. I would still prefer the old name DryrunWagedRebalancer.\nBut feel free to have a better name for this method.", "url": "https://github.com/apache/helix/pull/1058#discussion_r436902771", "createdAt": "2020-06-08T18:17:55Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java", "diffHunk": "@@ -428,4 +432,20 @@ public String toString() {\n     return verifierName + \"(\" + _clusterName + \"@\" + _zkClient + \"@resources[\"\n        + (_resources != null ? Arrays.toString(_resources.toArray()) : \"\") + \"])\";\n   }\n+\n+  private class ReadOnlyWagedRebalancer extends org.apache.helix.controller.rebalancer.waged.ReadOnlyWagedRebalancer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88fcb0e58508acaacdef4dcda9af46802480cb0"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTc4NA==", "bodyText": "Okay. Changed to Dryrun", "url": "https://github.com/apache/helix/pull/1058#discussion_r437881784", "createdAt": "2020-06-10T06:12:48Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java", "diffHunk": "@@ -428,4 +432,20 @@ public String toString() {\n     return verifierName + \"(\" + _clusterName + \"@\" + _zkClient + \"@resources[\"\n        + (_resources != null ? Arrays.toString(_resources.toArray()) : \"\") + \"])\";\n   }\n+\n+  private class ReadOnlyWagedRebalancer extends org.apache.helix.controller.rebalancer.waged.ReadOnlyWagedRebalancer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMjc3MQ=="}, "originalCommit": {"oid": "c88fcb0e58508acaacdef4dcda9af46802480cb0"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTc4NTM4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/util/HelixUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODoxOToyNVrOGgqehw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODoxOToyNVrOGgqehw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMzU1OQ==", "bodyText": "As we see in the test, the current way overriding the live instance info won't work. We need to retain the session Id somehow. Otherwise, the current state won't be read correctly.", "url": "https://github.com/apache/helix/pull/1058#discussion_r436903559", "createdAt": "2020-06-08T18:19:25Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/util/HelixUtil.java", "diffHunk": "@@ -175,27 +175,34 @@ public static String serializeByComma(List<String> objects) {\n       String metadataStoreAddress, ClusterConfig clusterConfig,\n       List<InstanceConfig> instanceConfigs, List<String> liveInstances,\n       List<IdealState> idealStates, List<ResourceConfig> resourceConfigs) {\n+    // Copy the cluster config and make globalRebalance happen synchronously\n+    // Otherwise, globalRebalance may not complete and this util might end up returning\n+    // an empty assignment.\n+    ClusterConfig globalSyncClusterConfig = new ClusterConfig(clusterConfig.getRecord());\n+    globalSyncClusterConfig.setGlobalRebalanceAsyncMode(false);\n+\n     // Prepare a data accessor for a dataProvider (cache) refresh\n     BaseDataAccessor<ZNRecord> baseDataAccessor = new ZkBaseDataAccessor<>(metadataStoreAddress);\n     HelixDataAccessor helixDataAccessor =\n-        new ZKHelixDataAccessor(clusterConfig.getClusterName(), baseDataAccessor);\n+        new ZKHelixDataAccessor(globalSyncClusterConfig.getClusterName(), baseDataAccessor);\n \n     // Create an instance of read-only WAGED rebalancer\n     ReadOnlyWagedRebalancer readOnlyWagedRebalancer =\n-        new ReadOnlyWagedRebalancer(metadataStoreAddress, clusterConfig.getClusterName(),\n-            clusterConfig.getGlobalRebalancePreference());\n+        new ReadOnlyWagedRebalancer(metadataStoreAddress, globalSyncClusterConfig.getClusterName(),\n+            globalSyncClusterConfig.getGlobalRebalancePreference());\n \n     // Use a dummy event to run the required stages for BestPossibleState calculation\n     // Attributes RESOURCES and RESOURCES_TO_REBALANCE are populated in ResourceComputationStage\n-    ClusterEvent event = new ClusterEvent(clusterConfig.getClusterName(), ClusterEventType.Unknown);\n+    ClusterEvent event =\n+        new ClusterEvent(globalSyncClusterConfig.getClusterName(), ClusterEventType.Unknown);\n \n     try {\n       // Obtain a refreshed dataProvider (cache) and overwrite cluster parameters with the given parameters\n       ResourceControllerDataProvider dataProvider =\n-          new ResourceControllerDataProvider(clusterConfig.getClusterName());\n+          new ResourceControllerDataProvider(globalSyncClusterConfig.getClusterName());\n       dataProvider.requireFullRefresh();\n       dataProvider.refresh(helixDataAccessor);\n-      dataProvider.setClusterConfig(clusterConfig);\n+      dataProvider.setClusterConfig(globalSyncClusterConfig);\n       dataProvider.setInstanceConfigMap(instanceConfigs.stream()\n           .collect(Collectors.toMap(InstanceConfig::getInstanceName, Function.identity())));\n       dataProvider.setLiveInstances(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88fcb0e58508acaacdef4dcda9af46802480cb0"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDYyMzQwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODoyNToxM1rOGiBQJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODoyNToxM1rOGiBQJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMyNTI4Ng==", "bodyText": "I should have made myself clearer. What I meant to say is that you can name the newly defined private class DryrunWagedRebalancer here. But the one in the package org.apache.helix.controller.rebalancer.waged can still be named ReadOnlyWagedRebalancer.\nThe purpose is to differentiate the names so as to avoid confusion.", "url": "https://github.com/apache/helix/pull/1058#discussion_r438325286", "createdAt": "2020-06-10T18:25:13Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java", "diffHunk": "@@ -428,4 +432,20 @@ public String toString() {\n     return verifierName + \"(\" + _clusterName + \"@\" + _zkClient + \"@resources[\"\n        + (_resources != null ? Arrays.toString(_resources.toArray()) : \"\") + \"])\";\n   }\n+\n+  private class DryrunWagedRebalancer extends org.apache.helix.controller.rebalancer.waged.DryrunWagedRebalancer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "647996cf95c185a73893613fb04ad38911f7b4a0"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDYzNTQ0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/util/HelixUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODoyODo1M1rOGiBYDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxOTo1OTowNVrOGiERKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMyNzMwOQ==", "bodyText": "Please don't filter out any live instances that are in the input but not in the dataProvider.\nThe caller might want to test with those non-exist live instances. And even the sessions of those non-exist live instances are empty, the tool can still running fine because there won't be any current state read for the non-exist instances anyway.", "url": "https://github.com/apache/helix/pull/1058#discussion_r438327309", "createdAt": "2020-06-10T18:28:53Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/util/HelixUtil.java", "diffHunk": "@@ -175,37 +176,50 @@ public static String serializeByComma(List<String> objects) {\n       String metadataStoreAddress, ClusterConfig clusterConfig,\n       List<InstanceConfig> instanceConfigs, List<String> liveInstances,\n       List<IdealState> idealStates, List<ResourceConfig> resourceConfigs) {\n+    // Copy the cluster config and make globalRebalance happen synchronously\n+    // Otherwise, globalRebalance may not complete and this util might end up returning\n+    // an empty assignment.\n+    ClusterConfig globalSyncClusterConfig = new ClusterConfig(clusterConfig.getRecord());\n+    globalSyncClusterConfig.setGlobalRebalanceAsyncMode(false);\n+\n     // Prepare a data accessor for a dataProvider (cache) refresh\n     BaseDataAccessor<ZNRecord> baseDataAccessor = new ZkBaseDataAccessor<>(metadataStoreAddress);\n     HelixDataAccessor helixDataAccessor =\n-        new ZKHelixDataAccessor(clusterConfig.getClusterName(), baseDataAccessor);\n+        new ZKHelixDataAccessor(globalSyncClusterConfig.getClusterName(), baseDataAccessor);\n \n     // Create an instance of read-only WAGED rebalancer\n-    ReadOnlyWagedRebalancer readOnlyWagedRebalancer =\n-        new ReadOnlyWagedRebalancer(metadataStoreAddress, clusterConfig.getClusterName(),\n-            clusterConfig.getGlobalRebalancePreference());\n+    DryrunWagedRebalancer dryrunWagedRebalancer =\n+        new DryrunWagedRebalancer(metadataStoreAddress, globalSyncClusterConfig.getClusterName(),\n+            globalSyncClusterConfig.getGlobalRebalancePreference());\n \n     // Use a dummy event to run the required stages for BestPossibleState calculation\n     // Attributes RESOURCES and RESOURCES_TO_REBALANCE are populated in ResourceComputationStage\n-    ClusterEvent event = new ClusterEvent(clusterConfig.getClusterName(), ClusterEventType.Unknown);\n+    ClusterEvent event =\n+        new ClusterEvent(globalSyncClusterConfig.getClusterName(), ClusterEventType.Unknown);\n \n     try {\n       // Obtain a refreshed dataProvider (cache) and overwrite cluster parameters with the given parameters\n       ResourceControllerDataProvider dataProvider =\n-          new ResourceControllerDataProvider(clusterConfig.getClusterName());\n+          new ResourceControllerDataProvider(globalSyncClusterConfig.getClusterName());\n       dataProvider.requireFullRefresh();\n       dataProvider.refresh(helixDataAccessor);\n-      dataProvider.setClusterConfig(clusterConfig);\n+      dataProvider.setClusterConfig(globalSyncClusterConfig);\n       dataProvider.setInstanceConfigMap(instanceConfigs.stream()\n           .collect(Collectors.toMap(InstanceConfig::getInstanceName, Function.identity())));\n-      dataProvider.setLiveInstances(\n-          liveInstances.stream().map(LiveInstance::new).collect(Collectors.toList()));\n+      // For LiveInstances, we must preserve the existing session IDs\n+      // So read LiveInstance objects from the cluster and do a \"retainAll\" on them\n+      // liveInstanceMap is an unmodifiableMap instances, so we filter using a stream\n+      Map<String, LiveInstance> liveInstanceMap = dataProvider.getLiveInstances();\n+      List<LiveInstance> filteredLiveInstances = liveInstanceMap.entrySet().stream()\n+          .filter(entry -> liveInstances.contains(entry.getKey())).map(Map.Entry::getValue)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "647996cf95c185a73893613fb04ad38911f7b4a0"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3NDY5Ng==", "bodyText": "Fixed", "url": "https://github.com/apache/helix/pull/1058#discussion_r438374696", "createdAt": "2020-06-10T19:59:05Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/util/HelixUtil.java", "diffHunk": "@@ -175,37 +176,50 @@ public static String serializeByComma(List<String> objects) {\n       String metadataStoreAddress, ClusterConfig clusterConfig,\n       List<InstanceConfig> instanceConfigs, List<String> liveInstances,\n       List<IdealState> idealStates, List<ResourceConfig> resourceConfigs) {\n+    // Copy the cluster config and make globalRebalance happen synchronously\n+    // Otherwise, globalRebalance may not complete and this util might end up returning\n+    // an empty assignment.\n+    ClusterConfig globalSyncClusterConfig = new ClusterConfig(clusterConfig.getRecord());\n+    globalSyncClusterConfig.setGlobalRebalanceAsyncMode(false);\n+\n     // Prepare a data accessor for a dataProvider (cache) refresh\n     BaseDataAccessor<ZNRecord> baseDataAccessor = new ZkBaseDataAccessor<>(metadataStoreAddress);\n     HelixDataAccessor helixDataAccessor =\n-        new ZKHelixDataAccessor(clusterConfig.getClusterName(), baseDataAccessor);\n+        new ZKHelixDataAccessor(globalSyncClusterConfig.getClusterName(), baseDataAccessor);\n \n     // Create an instance of read-only WAGED rebalancer\n-    ReadOnlyWagedRebalancer readOnlyWagedRebalancer =\n-        new ReadOnlyWagedRebalancer(metadataStoreAddress, clusterConfig.getClusterName(),\n-            clusterConfig.getGlobalRebalancePreference());\n+    DryrunWagedRebalancer dryrunWagedRebalancer =\n+        new DryrunWagedRebalancer(metadataStoreAddress, globalSyncClusterConfig.getClusterName(),\n+            globalSyncClusterConfig.getGlobalRebalancePreference());\n \n     // Use a dummy event to run the required stages for BestPossibleState calculation\n     // Attributes RESOURCES and RESOURCES_TO_REBALANCE are populated in ResourceComputationStage\n-    ClusterEvent event = new ClusterEvent(clusterConfig.getClusterName(), ClusterEventType.Unknown);\n+    ClusterEvent event =\n+        new ClusterEvent(globalSyncClusterConfig.getClusterName(), ClusterEventType.Unknown);\n \n     try {\n       // Obtain a refreshed dataProvider (cache) and overwrite cluster parameters with the given parameters\n       ResourceControllerDataProvider dataProvider =\n-          new ResourceControllerDataProvider(clusterConfig.getClusterName());\n+          new ResourceControllerDataProvider(globalSyncClusterConfig.getClusterName());\n       dataProvider.requireFullRefresh();\n       dataProvider.refresh(helixDataAccessor);\n-      dataProvider.setClusterConfig(clusterConfig);\n+      dataProvider.setClusterConfig(globalSyncClusterConfig);\n       dataProvider.setInstanceConfigMap(instanceConfigs.stream()\n           .collect(Collectors.toMap(InstanceConfig::getInstanceName, Function.identity())));\n-      dataProvider.setLiveInstances(\n-          liveInstances.stream().map(LiveInstance::new).collect(Collectors.toList()));\n+      // For LiveInstances, we must preserve the existing session IDs\n+      // So read LiveInstance objects from the cluster and do a \"retainAll\" on them\n+      // liveInstanceMap is an unmodifiableMap instances, so we filter using a stream\n+      Map<String, LiveInstance> liveInstanceMap = dataProvider.getLiveInstances();\n+      List<LiveInstance> filteredLiveInstances = liveInstanceMap.entrySet().stream()\n+          .filter(entry -> liveInstances.contains(entry.getKey())).map(Map.Entry::getValue)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMyNzMwOQ=="}, "originalCommit": {"oid": "647996cf95c185a73893613fb04ad38911f7b4a0"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1115, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}