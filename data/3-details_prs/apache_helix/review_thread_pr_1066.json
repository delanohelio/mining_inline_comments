{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NjczOTIy", "number": 1066, "reviewThreads": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToxNDo0NFrOEDEbxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMjoxOTo1OFrOEqgEFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjUzODMwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/ControllerLeaderSession.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToxNDo0NFrOGf6Y4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOTo1MTozOFrOGf7Ybg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTY4Mg==", "bodyText": "Why do we need to wrap in a POJO? Wouldn't AtomicReference work here?", "url": "https://github.com/apache/helix/pull/1066#discussion_r436115682", "createdAt": "2020-06-05T19:14:44Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/ControllerLeaderSession.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.apache.helix.controller;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * A thin wrapper to include a ZK session. This is created for controller leader to retrieve ZK\n+ * session from Helix Manager in the mean time when checking leadership.\n+ */\n+public class ControllerLeaderSession {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88c0153bdfd87890dc806014ca89498e6661b603"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzMTk1MA==", "bodyText": "AtomicReference would work, but it over qualifies. It guarantees the variable could be read and write atomically. It is designed for multi threading.\nHere in our case, we only need a way to get the value set out of scope as below:\nvar name;\nfoo(name); // sets name = \"helix\" inside method\nprint(name); // prints \"helix\"\n\nWe don't need atomicity. AtomicReference would be heavier than this light wrapper as internally it needs more memory work to guarantee atomicity. So I go with the thin wrapper which satisfies us better.", "url": "https://github.com/apache/helix/pull/1066#discussion_r436131950", "createdAt": "2020-06-05T19:51:38Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/ControllerLeaderSession.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.apache.helix.controller;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * A thin wrapper to include a ZK session. This is created for controller leader to retrieve ZK\n+ * session from Helix Manager in the mean time when checking leadership.\n+ */\n+public class ControllerLeaderSession {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTY4Mg=="}, "originalCommit": {"oid": "88c0153bdfd87890dc806014ca89498e6661b603"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjczNzMwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoyNToxOVrOGf8V2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoyNToxOVrOGf8V2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NzY3Mg==", "bodyText": "Got it. Thanks for pointing that out. I will get a better name for it. Maybe \"ZkSessionWrapper\". If you have a better name, please let me know.\n\u2026\nOn Fri, Jun 5, 2020 at 12:52 PM Lei Xia @.> wrote: @.* commented on this pull request. ------------------------------ In helix-core/src/main/java/org/apache/helix/HelixManager.java <#1066 (comment)>: > @@ -425,6 +426,19 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l / boolean isLeader(); + /* + * Checks if the cluster manager is leader and sets its ZK session in + * @.*** ControllerLeaderSession}. + * + * @param controllerLeaderSession To include ZK session of the cluster manager in return + * + * @return true if this is a controller and a leader of the cluster. Zk session of the cluster + * manager is set in controllerLeaderSession + */ + default boolean isLeader(ControllerLeaderSession controllerLeaderSession) {\n\n\nThis could be confusion because there is no \"leader\" concept for a Helix manager. Leader only applies to a controller instance, but HelixManager is a broader concept here.\n\nThinking in another aspect, the java doc also confuses. That's why I call it ControllerLeaderSession. Though we don't have a \"leader\" concept for helix manager, but a helix manager could be attached to a controller which could be a leader. And this is already public API, we could not change the name of the old API now. For this new one, maybe we could think of a new name. Maybe like isInstanceLeader()?\nLet me also fix the java doc to avoid any confusion.", "url": "https://github.com/apache/helix/pull/1066#discussion_r436147672", "createdAt": "2020-06-05T20:25:19Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -425,6 +426,19 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   boolean isLeader();\n \n+  /**\n+   * Checks if the cluster manager is leader and sets its ZK session in\n+   * {@link ControllerLeaderSession}.\n+   *\n+   * @param controllerLeaderSession To include ZK session of the cluster manager in return\n+   *\n+   * @return true if this is a controller and a leader of the cluster. Zk session of the cluster\n+   * manager is set in controllerLeaderSession\n+   */\n+  default boolean isLeader(ControllerLeaderSession controllerLeaderSession) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88c0153bdfd87890dc806014ca89498e6661b603"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjg3OTg1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMToyNDozMFrOGf9wGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzo1Nzo0OVrOGhgVmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDc3OQ==", "bodyText": "Shall we throw an exception to break the pipeline? If we know session is not matched. Then there is no reason to keep following pipeline based on stale data.", "url": "https://github.com/apache/helix/pull/1066#discussion_r436170779", "createdAt": "2020-06-05T21:24:30Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,13 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n-    List<Message> messagesSent = sendMessages(dataAccessor, outputMessages);\n+    String expectedSession = event.getAttribute(AttributeName.CONTROLLER_LEADER_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent. This potentially avoid\n+    // double masters for a single partition.\n+    List<Message> messagesSent = manager.getSessionId().equals(expectedSession)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88c0153bdfd87890dc806014ca89498e6661b603"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyODIyMg==", "bodyText": "I proposed to do some checks at stages like ReadClusterDataStage and terminate the remaining pipeline if controller loses leadership. In our issue, I see that leader lost leadership at ReadClusterDataStage. So there is no need to continue the pipeline and it would help save some computation resource or write traffic to EV/persist assignment. But in the discussion we agreed on not doing that and just blocking messages. We could definitely pick it up and discuss again. @jiajunwang", "url": "https://github.com/apache/helix/pull/1066#discussion_r436228222", "createdAt": "2020-06-06T02:10:17Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,13 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n-    List<Message> messagesSent = sendMessages(dataAccessor, outputMessages);\n+    String expectedSession = event.getAttribute(AttributeName.CONTROLLER_LEADER_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent. This potentially avoid\n+    // double masters for a single partition.\n+    List<Message> messagesSent = manager.getSessionId().equals(expectedSession)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDc3OQ=="}, "originalCommit": {"oid": "88c0153bdfd87890dc806014ca89498e6661b603"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYxNzI0Nw==", "bodyText": "I think stopping the pipeline is much better. Because that saves you time if client reconnect with different session for next pipeline.\nI am OK to skip the change in the PR. But please add it to the TODO part. This is necessary especially when our pipeline takes much longer time for larger amount of resources computation.", "url": "https://github.com/apache/helix/pull/1066#discussion_r437617247", "createdAt": "2020-06-09T17:59:33Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,13 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n-    List<Message> messagesSent = sendMessages(dataAccessor, outputMessages);\n+    String expectedSession = event.getAttribute(AttributeName.CONTROLLER_LEADER_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent. This potentially avoid\n+    // double masters for a single partition.\n+    List<Message> messagesSent = manager.getSessionId().equals(expectedSession)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDc3OQ=="}, "originalCommit": {"oid": "88c0153bdfd87890dc806014ca89498e6661b603"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4NjAwOA==", "bodyText": "I've updated it to stop the pipeline at this point: thrown StageException.", "url": "https://github.com/apache/helix/pull/1066#discussion_r437786008", "createdAt": "2020-06-09T23:57:49Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,13 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n-    List<Message> messagesSent = sendMessages(dataAccessor, outputMessages);\n+    String expectedSession = event.getAttribute(AttributeName.CONTROLLER_LEADER_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent. This potentially avoid\n+    // double masters for a single partition.\n+    List<Message> messagesSent = manager.getSessionId().equals(expectedSession)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDc3OQ=="}, "originalCommit": {"oid": "88c0153bdfd87890dc806014ca89498e6661b603"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjI0MDcwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzo1ODoxM1rOGhV_cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMDozNzowMlrOGit70w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYxNjQ5Nw==", "bodyText": "Let's make the naming consistent. Better to be isLeader(Session).", "url": "https://github.com/apache/helix/pull/1066#discussion_r437616497", "createdAt": "2020-06-09T17:58:13Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -425,6 +426,20 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   boolean isLeader();\n \n+  /**\n+   * Checks whether the cluster manager is leader and sets its ZK session in param\n+   * {@link InstanceLeaderSession} if and only if it is leader.\n+   *\n+   * @param instanceLeaderSession To include ZK session ID of the cluster manager in return\n+   *\n+   * @return true if the instance is a leader of the cluster and Zk session of the cluster\n+   * manager is return in param {@link InstanceLeaderSession}\n+   */\n+  default boolean isInstanceLeader(InstanceLeaderSession instanceLeaderSession) {\n+    throw new UnsupportedOperationException(\n+        \"Checking leader and returning session is not supported.\");\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a37e8119f5b5fa05e3c89f177edcb46ae877e1b0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYyNDcwMQ==", "bodyText": "I was making it the same name isLeader(session). @lei-xia reminded that helix manager does not have a controller concept so no leader/follower concept. I thought the instance itself managed by the helix manager is a controller. So I name it isInstanceLeader(session). We could discuss and have an agreement. @jiajunwang Could you also take a look? Thanks.", "url": "https://github.com/apache/helix/pull/1066#discussion_r437624701", "createdAt": "2020-06-09T18:12:31Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -425,6 +426,20 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   boolean isLeader();\n \n+  /**\n+   * Checks whether the cluster manager is leader and sets its ZK session in param\n+   * {@link InstanceLeaderSession} if and only if it is leader.\n+   *\n+   * @param instanceLeaderSession To include ZK session ID of the cluster manager in return\n+   *\n+   * @return true if the instance is a leader of the cluster and Zk session of the cluster\n+   * manager is return in param {@link InstanceLeaderSession}\n+   */\n+  default boolean isInstanceLeader(InstanceLeaderSession instanceLeaderSession) {\n+    throw new UnsupportedOperationException(\n+        \"Checking leader and returning session is not supported.\");\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYxNjQ5Nw=="}, "originalCommit": {"oid": "a37e8119f5b5fa05e3c89f177edcb46ae877e1b0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NzM2Mw==", "bodyText": "@dasahcc An update. I've synced up with @jiajunwang about this. We decided to change it a bit to Optional<String> getSessionIdIfLeader() to avoid the new wrapper InstanceLeaderSession.", "url": "https://github.com/apache/helix/pull/1066#discussion_r439057363", "createdAt": "2020-06-11T20:37:02Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -425,6 +426,20 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   boolean isLeader();\n \n+  /**\n+   * Checks whether the cluster manager is leader and sets its ZK session in param\n+   * {@link InstanceLeaderSession} if and only if it is leader.\n+   *\n+   * @param instanceLeaderSession To include ZK session ID of the cluster manager in return\n+   *\n+   * @return true if the instance is a leader of the cluster and Zk session of the cluster\n+   * manager is return in param {@link InstanceLeaderSession}\n+   */\n+  default boolean isInstanceLeader(InstanceLeaderSession instanceLeaderSession) {\n+    throw new UnsupportedOperationException(\n+        \"Checking leader and returning session is not supported.\");\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYxNjQ5Nw=="}, "originalCommit": {"oid": "a37e8119f5b5fa05e3c89f177edcb46ae877e1b0"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODA5OTE2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/BaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzoyNDo1M1rOGhoC1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNjowNToxNFrOGlgwYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMjI3Nw==", "bodyText": "Instead of polluting the interface, shall we have a new interface called sessionAwareZkClient or something like that? Note that an implementation can implement multiple interfaces. So we just need to let the right class implement that interface. And this one won't need to have this ugly and not supported method.", "url": "https://github.com/apache/helix/pull/1066#discussion_r437912277", "createdAt": "2020-06-10T07:24:53Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/BaseDataAccessor.java", "diffHunk": "@@ -95,6 +95,24 @@\n    */\n   boolean[] createChildren(List<String> paths, List<T> records, int options);\n \n+  /**\n+   * Use it when creating children under a parent node with an expected ZK session.\n+   * <p>\n+   * This will use async api for better performance. If the children already exist it will return\n+   * false.\n+   *\n+   * @param paths the paths to the children ZNodes\n+   * @param records List of data to write to each of the path\n+   * @param options Set the type of ZNode see the valid values in {@link AccessOption}\n+   * @param expectedSession The expected ZK session to create children\n+   * @return For each child: true if creation succeeded, false otherwise (e.g. if the child exists)\n+   */\n+  default boolean[] createChildren(List<String> paths, List<T> records, int options,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMyMzE0MA==", "bodyText": "This is a Helix Java API interface. Do you think we would need new interfaces for the Java APIs?\nI've carefully thought about having new interfaces. But it bings in 3 new interfaces for zkclient/BaseDataAccessor/HelixDataAccessor, which causes more efforts to maintain. And we may need to create all the APIs with expected session aware.\nCurrently we are only adding one new API to each of the 3 interfaces. I feel that this is the easiest way and it won't add too much pollution.\nIf we decide to go to that direction, that would be another PR. Let's discuss this more.", "url": "https://github.com/apache/helix/pull/1066#discussion_r438323140", "createdAt": "2020-06-10T18:21:24Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/BaseDataAccessor.java", "diffHunk": "@@ -95,6 +95,24 @@\n    */\n   boolean[] createChildren(List<String> paths, List<T> records, int options);\n \n+  /**\n+   * Use it when creating children under a parent node with an expected ZK session.\n+   * <p>\n+   * This will use async api for better performance. If the children already exist it will return\n+   * false.\n+   *\n+   * @param paths the paths to the children ZNodes\n+   * @param records List of data to write to each of the path\n+   * @param options Set the type of ZNode see the valid values in {@link AccessOption}\n+   * @param expectedSession The expected ZK session to create children\n+   * @return For each child: true if creation succeeded, false otherwise (e.g. if the child exists)\n+   */\n+  default boolean[] createChildren(List<String> paths, List<T> records, int options,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMjI3Nw=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM0MTMwMQ==", "bodyText": "Do you mean these methods are really needed by the controller logic? So they will be called in the critical controller stages? Let's sync up offline. I thought it would only in the ZkClient code. Maybe that is a wrong impression.", "url": "https://github.com/apache/helix/pull/1066#discussion_r438341301", "createdAt": "2020-06-10T18:54:41Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/BaseDataAccessor.java", "diffHunk": "@@ -95,6 +95,24 @@\n    */\n   boolean[] createChildren(List<String> paths, List<T> records, int options);\n \n+  /**\n+   * Use it when creating children under a parent node with an expected ZK session.\n+   * <p>\n+   * This will use async api for better performance. If the children already exist it will return\n+   * false.\n+   *\n+   * @param paths the paths to the children ZNodes\n+   * @param records List of data to write to each of the path\n+   * @param options Set the type of ZNode see the valid values in {@link AccessOption}\n+   * @param expectedSession The expected ZK session to create children\n+   * @return For each child: true if creation succeeded, false otherwise (e.g. if the child exists)\n+   */\n+  default boolean[] createChildren(List<String> paths, List<T> records, int options,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMjI3Nw=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MTUyNw==", "bodyText": "Yes. The logic is: sendMessages() -> HelixDataAccessor.createChildren() -> BaseDataAccessor.createChildren() -> ZkClient.asyncCreate().\nSo we need the expectedSession to be passed all way down to zkclient from sendMessages().", "url": "https://github.com/apache/helix/pull/1066#discussion_r438491527", "createdAt": "2020-06-11T01:21:06Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/BaseDataAccessor.java", "diffHunk": "@@ -95,6 +95,24 @@\n    */\n   boolean[] createChildren(List<String> paths, List<T> records, int options);\n \n+  /**\n+   * Use it when creating children under a parent node with an expected ZK session.\n+   * <p>\n+   * This will use async api for better performance. If the children already exist it will return\n+   * false.\n+   *\n+   * @param paths the paths to the children ZNodes\n+   * @param records List of data to write to each of the path\n+   * @param options Set the type of ZNode see the valid values in {@link AccessOption}\n+   * @param expectedSession The expected ZK session to create children\n+   * @return For each child: true if creation succeeded, false otherwise (e.g. if the child exists)\n+   */\n+  default boolean[] createChildren(List<String> paths, List<T> records, int options,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMjI3Nw=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMDQyNQ==", "bodyText": "After comparing options, I still think new interfaces would be easier.\nWe can have interfaces defined by extending the existing one, but have the additional methods.\nFor example,\npublic interface SessionAwareBaseDataAccessor<T> extends BaseDataAccessor<T> {}\nThe reason I prefer new interfaces is that the new methods do not make much sense for most of the external users. And the parameters are confusing for those who don't care about the session.\nWe shall try to keep the session aware accessors / clients as private as possible.", "url": "https://github.com/apache/helix/pull/1066#discussion_r441920425", "createdAt": "2020-06-18T01:37:48Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/BaseDataAccessor.java", "diffHunk": "@@ -95,6 +95,24 @@\n    */\n   boolean[] createChildren(List<String> paths, List<T> records, int options);\n \n+  /**\n+   * Use it when creating children under a parent node with an expected ZK session.\n+   * <p>\n+   * This will use async api for better performance. If the children already exist it will return\n+   * false.\n+   *\n+   * @param paths the paths to the children ZNodes\n+   * @param records List of data to write to each of the path\n+   * @param options Set the type of ZNode see the valid values in {@link AccessOption}\n+   * @param expectedSession The expected ZK session to create children\n+   * @return For each child: true if creation succeeded, false otherwise (e.g. if the child exists)\n+   */\n+  default boolean[] createChildren(List<String> paths, List<T> records, int options,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMjI3Nw=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4NzE2OQ==", "bodyText": "I understand your point. By having a new interface, we could add javadoc to explain not use it if they don't care about session (maybe helix internal use only). They still keep using BaseDataAccessor without being confused by the extra session aware api. This is the benefit.\nAnd another benefit is we may add more session aware apis to the new interface in the future if we need.\nThe downside of having a new interface is\n\nwe have to maintain the extra interfaces: SessionAwareBaseDataAccessor, SessionAwareHelixDataAccessor, (maybe session aware zkclient?).\nNeed more code changes to implement the new interfaces (SessionAwareBaseDataAccessor) in this PR.\n\nLet's discuss further.", "url": "https://github.com/apache/helix/pull/1066#discussion_r441987169", "createdAt": "2020-06-18T06:05:14Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/BaseDataAccessor.java", "diffHunk": "@@ -95,6 +95,24 @@\n    */\n   boolean[] createChildren(List<String> paths, List<T> records, int options);\n \n+  /**\n+   * Use it when creating children under a parent node with an expected ZK session.\n+   * <p>\n+   * This will use async api for better performance. If the children already exist it will return\n+   * false.\n+   *\n+   * @param paths the paths to the children ZNodes\n+   * @param records List of data to write to each of the path\n+   * @param options Set the type of ZNode see the valid values in {@link AccessOption}\n+   * @param expectedSession The expected ZK session to create children\n+   * @return For each child: true if creation succeeded, false otherwise (e.g. if the child exists)\n+   */\n+  default boolean[] createChildren(List<String> paths, List<T> records, int options,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMjI3Nw=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODA5OTU3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixDataAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzoyNTowMlrOGhoDFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzoyNTowMlrOGhoDFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMjM0MQ==", "bodyText": "same here", "url": "https://github.com/apache/helix/pull/1066#discussion_r437912341", "createdAt": "2020-06-10T07:25:02Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixDataAccessor.java", "diffHunk": "@@ -188,6 +188,22 @@\n    */\n   <T extends HelixProperty> boolean[] createChildren(List<PropertyKey> keys, List<T> children);\n \n+  /**\n+   * Adds multiple children to a parent. If successful, the children will be created by the expected\n+   * ZK session. If current ZK session does not match expected session, the creation operation will\n+   * fail.\n+   *\n+   * @param keys property keys\n+   * @param children list of children znodes to be created\n+   * @param expectedSession expected ZK session to create the children znodes\n+   * @return array where true means the child was added and false means it was not\n+   */\n+  default <T extends HelixProperty> boolean[] createChildren(List<PropertyKey> keys, List<T> children,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODEwMDA0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzoyNTowN1rOGhoDWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODoxNzo0NFrOGiA_zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMjQwOQ==", "bodyText": "Same here", "url": "https://github.com/apache/helix/pull/1066#discussion_r437912409", "createdAt": "2020-06-10T07:25:07Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -425,6 +426,20 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   boolean isLeader();\n \n+  /**\n+   * Checks whether the cluster manager is leader and sets its ZK session in param\n+   * {@link InstanceLeaderSession} if and only if it is leader.\n+   *\n+   * @param instanceLeaderSession To include ZK session ID of the cluster manager in return\n+   *\n+   * @return true if the instance is a leader of the cluster and Zk session of the cluster\n+   * manager is returned in param {@link InstanceLeaderSession}\n+   */\n+  default boolean isInstanceLeader(InstanceLeaderSession instanceLeaderSession) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMyMTEwMA==", "bodyText": "This is only one API required to be added to this HelixManager. HelixManager is no supposed to be a public API, right? We wound't want a new interface just for this API. I think this one is fine.\nBut I think we could determine the name of this new API, as Junkai mentioned we should make it consistent with isLeader().", "url": "https://github.com/apache/helix/pull/1066#discussion_r438321100", "createdAt": "2020-06-10T18:17:44Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -425,6 +426,20 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   boolean isLeader();\n \n+  /**\n+   * Checks whether the cluster manager is leader and sets its ZK session in param\n+   * {@link InstanceLeaderSession} if and only if it is leader.\n+   *\n+   * @param instanceLeaderSession To include ZK session ID of the cluster manager in return\n+   *\n+   * @return true if the instance is a leader of the cluster and Zk session of the cluster\n+   * manager is returned in param {@link InstanceLeaderSession}\n+   */\n+  default boolean isInstanceLeader(InstanceLeaderSession instanceLeaderSession) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMjQwOQ=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODEwNjg1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/AttributeName.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzoyNzowM1rOGhoHew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzoyNzowM1rOGhoHew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMzQ2Nw==", "bodyText": "This can be more generic. Just call it event_session?\nAs you can imagine, this can be used in multiple ways.", "url": "https://github.com/apache/helix/pull/1066#discussion_r437913467", "createdAt": "2020-06-10T07:27:03Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/AttributeName.java", "diffHunk": "@@ -40,5 +40,6 @@\n   PipelineType,\n   LastRebalanceFinishTimeStamp,\n   ControllerDataProvider,\n-  STATEFUL_REBALANCER\n+  STATEFUL_REBALANCER,\n+  CONTROLLER_LEADER_SESSION", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODEyMjg4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzozMjowMFrOGhoRew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNTo0ODowNVrOGlgbYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxNjAyNw==", "bodyText": "This may cause some issues. If the session is updated randomly, a new session may be populated before new session handling is done.", "url": "https://github.com/apache/helix/pull/1066#discussion_r437916027", "createdAt": "2020-06-10T07:32:00Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -401,6 +402,8 @@ void checkConnected(long timeout) {\n       throw new HelixException(\n           \"HelixManager is not connected within retry timeout for cluster \" + _clusterName);\n     }\n+\n+    _sessionId = ZKUtil.toHexSessionId(_zkclient.getSessionId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0NjI4MQ==", "bodyText": "I was waiting for you to point it out and discuss :) I had the same thought when I considered adding this assignment. _sessionId is only assigned in waitUntilConnected(). Each time handleNewSession() also calls waitUntilConnected(). handleNewSession(expectedSession) handles expected session. If the sessionId changes before handleNewSession() is done, I expect handleNewSession() should be able to handle the expired session because it is handling an expected session? Maybe I miss some corner cases? Let's carefully think about this here.", "url": "https://github.com/apache/helix/pull/1066#discussion_r437946281", "createdAt": "2020-06-10T08:20:18Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -401,6 +402,8 @@ void checkConnected(long timeout) {\n       throw new HelixException(\n           \"HelixManager is not connected within retry timeout for cluster \" + _clusterName);\n     }\n+\n+    _sessionId = ZKUtil.toHexSessionId(_zkclient.getSessionId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxNjAyNw=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNjg4MA==", "bodyText": "If the sessionId changes before handleNewSession() is done, I expect handleNewSession() should be able to handle the expired session because it is handling an expected session\n\nWhat if the session Id is changed before handleNewSession() get a chance to execute? This will update the session Id unexpectedly. This means the handlers are not correctly reset. I suggest not break this assumption.\nOn the other side, if we don't set this, then the operation will fail if they are session aware. Isn't that a result that we want?", "url": "https://github.com/apache/helix/pull/1066#discussion_r441936880", "createdAt": "2020-06-18T02:43:28Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -401,6 +402,8 @@ void checkConnected(long timeout) {\n       throw new HelixException(\n           \"HelixManager is not connected within retry timeout for cluster \" + _clusterName);\n     }\n+\n+    _sessionId = ZKUtil.toHexSessionId(_zkclient.getSessionId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxNjAyNw=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4MTc5Mg==", "bodyText": "I remember why I added this: I was using this api getSessionId() when checking leadership. Since we have getSessionIdIfLead(), you are right, we don't need this.", "url": "https://github.com/apache/helix/pull/1066#discussion_r441981792", "createdAt": "2020-06-18T05:48:05Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -401,6 +402,8 @@ void checkConnected(long timeout) {\n       throw new HelixException(\n           \"HelixManager is not connected within retry timeout for cluster \" + _clusterName);\n     }\n+\n+    _sessionId = ZKUtil.toHexSessionId(_zkclient.getSessionId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxNjAyNw=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODE1NDAwOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzozOTozNlrOGholXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNTo1MToyOFrOGosQuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTExNg==", "bodyText": "This is a great idea!", "url": "https://github.com/apache/helix/pull/1066#discussion_r437921116", "createdAt": "2020-06-10T07:39:36Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2119,8 +2126,41 @@ private String getHexSessionId() {\n    * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n    */\n   private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+    return expectedSessionId != null && !expectedSessionId.isEmpty() && mode.isEphemeral();\n+  }\n+\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUwMDk2Nw==", "bodyText": "I actually also tried to use this API in create() that we previous added. But inside create() there is a isSessionAwareOperation() check. If we don't need this check, we could just use the this method getExpectedZookeeper. And I actually don't think we need the check \"isSessionAwareOperation()\" since we only expose createEphemeral() to have expectedSession. We should be good.", "url": "https://github.com/apache/helix/pull/1066#discussion_r438500967", "createdAt": "2020-06-11T01:58:26Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2119,8 +2126,41 @@ private String getHexSessionId() {\n    * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n    */\n   private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+    return expectedSessionId != null && !expectedSessionId.isEmpty() && mode.isEphemeral();\n+  }\n+\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTExNg=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI0OTY2OQ==", "bodyText": "How do we reason this is correct? Note, previously, we have acquireEventLock when checking sessionId is equal to expected sessionId.\nif (isSessionAwareOperation(expectedSessionId, mode)) {\n          acquireEventLock();\n          try {\n            final String actualSessionId = Long.toHexString(zooKeeper.getSessionId());\n            if (!actualSessionId.equals(expectedSessionId)) {\n              throw new ZkSessionMismatchedException(\n                  \"Failed to create ephemeral node! There is a session id mismatch. Expected: \"\n                      + expectedSessionId + \". Actual: \" + actualSessionId);\n            }\n\n            /*\n             * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n             * under this zookeeper connection. This is to avoid locking zooKeeper.create() which\n             * may cause potential performance issue.\n             */\n            zooKeeper = ((ZkConnection) getConnection()).getZookeeper();", "url": "https://github.com/apache/helix/pull/1066#discussion_r445249669", "createdAt": "2020-06-25T00:54:27Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2119,8 +2126,41 @@ private String getHexSessionId() {\n    * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n    */\n   private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+    return expectedSessionId != null && !expectedSessionId.isEmpty() && mode.isEphemeral();\n+  }\n+\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTExNg=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1MDQ2NA==", "bodyText": "So here, we are saying the native Zookeeper object zookeeper can't be changed even session changed. Still one Zookeeeper object one session invariant, right? Save us one lock.", "url": "https://github.com/apache/helix/pull/1066#discussion_r445250464", "createdAt": "2020-06-25T00:57:34Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2119,8 +2126,41 @@ private String getHexSessionId() {\n    * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n    */\n   private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+    return expectedSessionId != null && !expectedSessionId.isEmpty() && mode.isEphemeral();\n+  }\n+\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTExNg=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyMTQwMw==", "bodyText": "@kaisun2000 Yes, correct! We don't have to lock it actually.", "url": "https://github.com/apache/helix/pull/1066#discussion_r445321403", "createdAt": "2020-06-25T05:51:28Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2119,8 +2126,41 @@ private String getHexSessionId() {\n    * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n    */\n   private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+    return expectedSessionId != null && !expectedSessionId.isEmpty() && mode.isEphemeral();\n+  }\n+\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTExNg=="}, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTMzMzYyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoyNzo0MlrOGiIX5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoyNzo0MlrOGiIX5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MTk1OQ==", "bodyText": "As we discussed,\n\nmake it private if not used anywhere else.\nmake it getSessionIdIfLeader() which returns an Optional object if the node is leader.", "url": "https://github.com/apache/helix/pull/1066#discussion_r438441959", "createdAt": "2020-06-10T22:27:42Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -901,6 +904,11 @@ public void addPreConnectCallback(PreConnectCallback callback) {\n \n   @Override\n   public boolean isLeader() {\n+    return isInstanceLeader(null);\n+  }\n+\n+  @Override\n+  public boolean isInstanceLeader(InstanceLeaderSession instanceLeaderSession) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49845ece32a8d1528af381dc67a51c5ace87389d"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzI1NjEzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMTo0NzozOVrOGlc1IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNTo0Mjo0NFrOGlgVmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMjg0OQ==", "bodyText": "It's good to consider backward compatibility here. But I believe HeixManager is not a \"public\" interface, meaning we shall not assume the user will implement this class and send back to any of the Helix components to use. So I think we don't need to make it default and throws UnsupportedOperationException.\n@dasahcc and @lei-xia, what do you think?", "url": "https://github.com/apache/helix/pull/1066#discussion_r441922849", "createdAt": "2020-06-18T01:47:39Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0ODg3OQ==", "bodyText": "Another concern is getSessionId() would become less useful with this call. And would it be confusing for the caller which one to call?", "url": "https://github.com/apache/helix/pull/1066#discussion_r441948879", "createdAt": "2020-06-18T03:32:57Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMjg0OQ=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4MDMxMw==", "bodyText": "I thought about that. I remember you said HelixManager is not supposed to be a public interface and recent customize view changes were also added. It should be fine not to add this. It is just my habit to consider backward compatibility in a public interface.\nBut helix has 3 other internal implementations: MockZKHelixManager, DummyClusterManager, MockManager that implements HelixManager. I just did not want to add empty implementation in these 3 classes. I am fine to add that if we decide not to add this default implementation.\nIn terms of getSessionId(), maybe we could add more javadoc to make them clear: getSessionId() returns session directly, while getSessionIdIfLead() checks leadership by reading the cluster data store and returns session id if lead.", "url": "https://github.com/apache/helix/pull/1066#discussion_r441980313", "createdAt": "2020-06-18T05:42:44Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMjg0OQ=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzI2MjEwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMTo1MToyMVrOGlc42w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNTozMzo1NVrOGlgLvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMzgwMw==", "bodyText": "nit, safer to go reverse way. Since you already checked expectedSession is not null, so there is guarantee no NPE if you do expectedSession.equals(...)", "url": "https://github.com/apache/helix/pull/1066#discussion_r441923803", "createdAt": "2020-06-18T01:51:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,17 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n-    List<Message> messagesSent = sendMessages(dataAccessor, outputMessages);\n+    String expectedSession = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent and the pipeline is stopped.\n+    // This potentially avoid double masters for a single partition.\n+    if (expectedSession != null && !manager.getSessionId().equals(expectedSession)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk3Nzc5MA==", "bodyText": "That's because in the first version of code, expectedSession != null was not checked :) And I intentionally do it for the purpose of avoiding NPE.\nActually manager.getSessionId() won't give null because inside getSessionId(), session connection is checked. The only change sessionId being null is zkclient is constructed but session is not yet established. Because of checkConnected(), the session id might be expired but won't be null.\nAnyway, it is a good habit to do what you suggest, especially when we are not sure if manager.getSessionId() would give null.", "url": "https://github.com/apache/helix/pull/1066#discussion_r441977790", "createdAt": "2020-06-18T05:33:55Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,17 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n-    List<Message> messagesSent = sendMessages(dataAccessor, outputMessages);\n+    String expectedSession = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent and the pipeline is stopped.\n+    // This potentially avoid double masters for a single partition.\n+    if (expectedSession != null && !manager.getSessionId().equals(expectedSession)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMzgwMw=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzM0ODc4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMjo0NjoyOFrOGldu5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNToyNzoyNlrOGlgEug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNzYzNw==", "bodyText": "Let's don't bother keeping the backward compatibility fo the test classes.\nMy suggestion is that we throw the exception by default. But change the test callers to catch it if necessary.\nIf this is not clean, then just add the additional parameters to the callers.", "url": "https://github.com/apache/helix/pull/1066#discussion_r441937637", "createdAt": "2020-06-18T02:46:28Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -788,14 +788,22 @@ protected void setupInstances(String clusterName, int[] instances) {\n     }\n   }\n \n-  protected void runPipeline(ClusterEvent event, Pipeline pipeline) {\n+  protected void runPipeline(ClusterEvent event, Pipeline pipeline) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk3NTk5NA==", "bodyText": "OK then let's just keep this protected void runPipeline(ClusterEvent event, Pipeline pipeline, boolean shouldThrowException) throws Exception;", "url": "https://github.com/apache/helix/pull/1066#discussion_r441975994", "createdAt": "2020-06-18T05:27:26Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -788,14 +788,22 @@ protected void setupInstances(String clusterName, int[] instances) {\n     }\n   }\n \n-  protected void runPipeline(ClusterEvent event, Pipeline pipeline) {\n+  protected void runPipeline(ClusterEvent event, Pipeline pipeline) throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNzYzNw=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzQwODI1OnYy", "diffSide": "LEFT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMzoyMzo0NlrOGleSbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQwNjoyNTo0OVrOGmlEFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0NjczMg==", "bodyText": "Why changing the name? I think datat stands for data type. In this scenario, it means this is an object with a certain data type. \"data\" is very generic so it might be less meaningful.\nI don't have a strong preference on the names. But if you are going to change it, please change all the datat in this java file at least : ) Or even better, the whole project.", "url": "https://github.com/apache/helix/pull/1066#discussion_r441946732", "createdAt": "2020-06-18T03:23:46Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1738,29 +1705,36 @@ public Stat writeDataGetStat(final String path, Object datat, final int expected\n     return writeDataReturnStat(path, datat, expectedVersion);\n   }\n \n-  public void asyncCreate(final String path, Object datat, final CreateMode mode,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk2MzAzMQ==", "bodyText": "Because the API is changed so I change the name. I don't think datat stands for data type. Here it is not a data type like T, but it is data that being written to ZK.\nChanging the name datat -> data is not scope of this PR. If necessary, I would prefer to change all of them in another PR.", "url": "https://github.com/apache/helix/pull/1066#discussion_r441963031", "createdAt": "2020-06-18T04:34:59Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1738,29 +1705,36 @@ public Stat writeDataGetStat(final String path, Object datat, final int expected\n     return writeDataReturnStat(path, datat, expectedVersion);\n   }\n \n-  public void asyncCreate(final String path, Object datat, final CreateMode mode,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0NjczMg=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3NjU3OQ==", "bodyText": "In that case, please change them in a batch in a separate PR. This change won't help with this PR.", "url": "https://github.com/apache/helix/pull/1066#discussion_r442476579", "createdAt": "2020-06-18T20:12:12Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1738,29 +1705,36 @@ public Stat writeDataGetStat(final String path, Object datat, final int expected\n     return writeDataReturnStat(path, datat, expectedVersion);\n   }\n \n-  public void asyncCreate(final String path, Object datat, final CreateMode mode,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0NjczMg=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwNjMyNA==", "bodyText": "Since there is not much value to change them, I would just leave them as they are: datat", "url": "https://github.com/apache/helix/pull/1066#discussion_r443106324", "createdAt": "2020-06-20T06:25:49Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1738,29 +1705,36 @@ public Stat writeDataGetStat(final String path, Object datat, final int expected\n     return writeDataReturnStat(path, datat, expectedVersion);\n   }\n \n-  public void asyncCreate(final String path, Object datat, final CreateMode mode,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0NjczMg=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzQxMjg3OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMzoyNjo0NVrOGleVMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQwNjoyODo1NlrOGmlErQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0NzQ0Mg==", "bodyText": "return zk?", "url": "https://github.com/apache/helix/pull/1066#discussion_r441947442", "createdAt": "2020-06-18T03:26:45Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2114,13 +2088,43 @@ private String getHexSessionId() {\n   }\n \n   /*\n-   * Session aware operation needs below requirements:\n-   * 1. the session id is NOT null or empty\n-   * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n+   * Gets the zookeeper instance that ensures its session ID matches the expected session ID.\n+   * It is used for write operations that suppose the znode to be created by the expected session.\n    */\n-  private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n+    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+\n+    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n+      return zk;\n+    }\n+\n+    /*\n+     * 1. If operation is session aware, we have to check whether or not the\n+     * passed-in(expected) session id matches actual session's id.\n+     * If not, znode creation is failed. This validation is\n+     * critical to guarantee the znode is created by the expected ZK session.\n+     *\n+     * 2. Otherwise, the operation is NOT session aware.\n+     * In this case, we will use the actual zookeeper session to create the node.\n+     */\n+    acquireEventLock();\n+    try {\n+      final String actualSessionId = Long.toHexString(zk.getSessionId());\n+      if (!actualSessionId.equals(expectedSessionId)) {\n+        throw new ZkSessionMismatchedException(\n+            \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n+                + expectedSessionId + \". Actual: \" + actualSessionId);\n+      }\n+\n+      /*\n+       * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n+       * under this zookeeper connection. This is to avoid locking zooKeeper.create() which\n+       * may cause potential performance issue.\n+       */\n+      return ((ZkConnection) getConnection()).getZookeeper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk3MzI0Ng==", "bodyText": "Rethinking about this code block, I just realized that maybe we don't need to acquireEventLock: we already have the zk object, so we are checking this zk's session and using it to execute operations. Even the zkclient's session changes, which means this zk object expires, it will throw SessionExpiredException and retry. I think acquireEventLock is redundant here.\nThe reason why we considered acquireEventLock is, to prevent session changes after we check zkclient's session. But now we are using the zk object. If the client's session changes, this zk object expires, we then retry and get another zk object.\nprivate ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n\n    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n      return zk;\n    }\n\n    final String actualSessionId = Long.toHexString(zk.getSessionId());\n    if (!actualSessionId.equals(expectedSessionId)) {\n      throw new ZkSessionMismatchedException(\n          \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n                + expectedSessionId + \". Actual: \" + actualSessionId);\n\n    return zk;\n  }\n\nWhat do you think?", "url": "https://github.com/apache/helix/pull/1066#discussion_r441973246", "createdAt": "2020-06-18T05:17:06Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2114,13 +2088,43 @@ private String getHexSessionId() {\n   }\n \n   /*\n-   * Session aware operation needs below requirements:\n-   * 1. the session id is NOT null or empty\n-   * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n+   * Gets the zookeeper instance that ensures its session ID matches the expected session ID.\n+   * It is used for write operations that suppose the znode to be created by the expected session.\n    */\n-  private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n+    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+\n+    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n+      return zk;\n+    }\n+\n+    /*\n+     * 1. If operation is session aware, we have to check whether or not the\n+     * passed-in(expected) session id matches actual session's id.\n+     * If not, znode creation is failed. This validation is\n+     * critical to guarantee the znode is created by the expected ZK session.\n+     *\n+     * 2. Otherwise, the operation is NOT session aware.\n+     * In this case, we will use the actual zookeeper session to create the node.\n+     */\n+    acquireEventLock();\n+    try {\n+      final String actualSessionId = Long.toHexString(zk.getSessionId());\n+      if (!actualSessionId.equals(expectedSessionId)) {\n+        throw new ZkSessionMismatchedException(\n+            \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n+                + expectedSessionId + \". Actual: \" + actualSessionId);\n+      }\n+\n+      /*\n+       * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n+       * under this zookeeper connection. This is to avoid locking zooKeeper.create() which\n+       * may cause potential performance issue.\n+       */\n+      return ((ZkConnection) getConnection()).getZookeeper();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0NzQ0Mg=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4MjA1OQ==", "bodyText": "It looks good to me.", "url": "https://github.com/apache/helix/pull/1066#discussion_r442482059", "createdAt": "2020-06-18T20:23:54Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2114,13 +2088,43 @@ private String getHexSessionId() {\n   }\n \n   /*\n-   * Session aware operation needs below requirements:\n-   * 1. the session id is NOT null or empty\n-   * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n+   * Gets the zookeeper instance that ensures its session ID matches the expected session ID.\n+   * It is used for write operations that suppose the znode to be created by the expected session.\n    */\n-  private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n+    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+\n+    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n+      return zk;\n+    }\n+\n+    /*\n+     * 1. If operation is session aware, we have to check whether or not the\n+     * passed-in(expected) session id matches actual session's id.\n+     * If not, znode creation is failed. This validation is\n+     * critical to guarantee the znode is created by the expected ZK session.\n+     *\n+     * 2. Otherwise, the operation is NOT session aware.\n+     * In this case, we will use the actual zookeeper session to create the node.\n+     */\n+    acquireEventLock();\n+    try {\n+      final String actualSessionId = Long.toHexString(zk.getSessionId());\n+      if (!actualSessionId.equals(expectedSessionId)) {\n+        throw new ZkSessionMismatchedException(\n+            \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n+                + expectedSessionId + \". Actual: \" + actualSessionId);\n+      }\n+\n+      /*\n+       * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n+       * under this zookeeper connection. This is to avoid locking zooKeeper.create() which\n+       * may cause potential performance issue.\n+       */\n+      return ((ZkConnection) getConnection()).getZookeeper();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0NzQ0Mg=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwNjQ3Nw==", "bodyText": "Thanks for confirming. Simplified it.", "url": "https://github.com/apache/helix/pull/1066#discussion_r443106477", "createdAt": "2020-06-20T06:28:56Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2114,13 +2088,43 @@ private String getHexSessionId() {\n   }\n \n   /*\n-   * Session aware operation needs below requirements:\n-   * 1. the session id is NOT null or empty\n-   * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n+   * Gets the zookeeper instance that ensures its session ID matches the expected session ID.\n+   * It is used for write operations that suppose the znode to be created by the expected session.\n    */\n-  private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n+    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+\n+    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n+      return zk;\n+    }\n+\n+    /*\n+     * 1. If operation is session aware, we have to check whether or not the\n+     * passed-in(expected) session id matches actual session's id.\n+     * If not, znode creation is failed. This validation is\n+     * critical to guarantee the znode is created by the expected ZK session.\n+     *\n+     * 2. Otherwise, the operation is NOT session aware.\n+     * In this case, we will use the actual zookeeper session to create the node.\n+     */\n+    acquireEventLock();\n+    try {\n+      final String actualSessionId = Long.toHexString(zk.getSessionId());\n+      if (!actualSessionId.equals(expectedSessionId)) {\n+        throw new ZkSessionMismatchedException(\n+            \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n+                + expectedSessionId + \". Actual: \" + actualSessionId);\n+      }\n+\n+      /*\n+       * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n+       * under this zookeeper connection. This is to avoid locking zooKeeper.create() which\n+       * may cause potential performance issue.\n+       */\n+      return ((ZkConnection) getConnection()).getZookeeper();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0NzQ0Mg=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzQ0MTUzOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMzo0NTo1N1rOGlemrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowMjowMVrOGzNNBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1MTkxNw==", "bodyText": "It's better to support this API for the dedicated zkclient only. For the other clients, especially the customer-facing ones, I would prefer not to open this API for now.", "url": "https://github.com/apache/helix/pull/1066#discussion_r441951917", "createdAt": "2020-06-18T03:45:57Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -372,6 +372,12 @@ public void asyncCreate(String path, Object datat, CreateMode mode,\n     _rawZkClient.asyncCreate(path, datat, mode, cb);\n   }\n \n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk3NDc0NA==", "bodyText": "Yes, only DedicatedZkClient supports this operation. The others (FederatedZkClient and SharedZkClient) don't support.\nOr did you mean adding a final check using isManagingConnection()? Maybe it is unnecessary?", "url": "https://github.com/apache/helix/pull/1066#discussion_r441974744", "createdAt": "2020-06-18T05:23:00Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -372,6 +372,12 @@ public void asyncCreate(String path, Object datat, CreateMode mode,\n     _rawZkClient.asyncCreate(path, datat, mode, cb);\n   }\n \n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1MTkxNw=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4MjQwOQ==", "bodyText": "By doing so, I believe additional interface would help. Or you need to do the ugly default methods everywhere.", "url": "https://github.com/apache/helix/pull/1066#discussion_r442482409", "createdAt": "2020-06-18T20:24:38Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -372,6 +372,12 @@ public void asyncCreate(String path, Object datat, CreateMode mode,\n     _rawZkClient.asyncCreate(path, datat, mode, cb);\n   }\n \n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1MTkxNw=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3MjcxMQ==", "bodyText": "There is trade-off: with additional interfaces, we need to maintain the additional interfaces, and we need to change the zkclient type with SessionAwareZkClient in HelixManager as well, because these BaseDataAccessors are using the zkclient in helix manager underneath. Let's discuss it further :)", "url": "https://github.com/apache/helix/pull/1066#discussion_r445372711", "createdAt": "2020-06-25T07:52:44Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -372,6 +372,12 @@ public void asyncCreate(String path, Object datat, CreateMode mode,\n     _rawZkClient.asyncCreate(path, datat, mode, cb);\n   }\n \n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1MTkxNw=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0Njg4Nw==", "bodyText": "@jiajunwang PR updated.\nWe decided to keep current existing interfaces as they are. Instead, we use the srcSessionId in message as the expected session id to create message znode.", "url": "https://github.com/apache/helix/pull/1066#discussion_r456346887", "createdAt": "2020-07-17T10:02:01Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -372,6 +372,12 @@ public void asyncCreate(String path, Object datat, CreateMode mode,\n     _rawZkClient.asyncCreate(path, datat, mode, cb);\n   }\n \n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1MTkxNw=="}, "originalCommit": {"oid": "48e8a5f405a7e5e93fd4f0c8479f070b0ad0d971"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDMxNTI2OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMToxMjozMVrOGooK-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzo0ODozOFrOGovP3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1NDM5NA==", "bodyText": "I assume we should invoke this one in ZkBaseDataAccessor#createChildren. But I did not see it.\nAm I missing something here?", "url": "https://github.com/apache/helix/pull/1066#discussion_r445254394", "createdAt": "2020-06-25T01:12:31Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1740,27 +1707,34 @@ public Stat writeDataGetStat(final String path, Object datat, final int expected\n \n   public void asyncCreate(final String path, Object datat, final CreateMode mode,\n       final ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    asyncCreate(path, datat, mode, cb, null);\n+  }\n+\n+  public void asyncCreate(final String path, Object data, final CreateMode mode,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506df964cf755939fdb51df09098254647cfe568"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3MDMzNQ==", "bodyText": "@kaisun2000 You've got an eye on it. We have a discussion here regarding the new API vs new interface: #1066 (comment)\nYou may put some opinions there :)", "url": "https://github.com/apache/helix/pull/1066#discussion_r445370335", "createdAt": "2020-06-25T07:48:38Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1740,27 +1707,34 @@ public Stat writeDataGetStat(final String path, Object datat, final int expected\n \n   public void asyncCreate(final String path, Object datat, final CreateMode mode,\n       final ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    asyncCreate(path, datat, mode, cb, null);\n+  }\n+\n+  public void asyncCreate(final String path, Object data, final CreateMode mode,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1NDM5NA=="}, "originalCommit": {"oid": "506df964cf755939fdb51df09098254647cfe568"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDMxOTE1OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMToxNTowN1rOGooNfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNTo1MDo0M1rOGosP8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1NTAzNg==", "bodyText": "Nit, I saw this non-essential beautification all the time. Let us not add them to divert the attention.", "url": "https://github.com/apache/helix/pull/1066#discussion_r445255036", "createdAt": "2020-06-25T01:15:07Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -149,8 +149,7 @@ public void handleSessionEstablishmentError(Throwable error) {\n    * Tests session expiry for the helix's IZkStateListener.\n    */\n   @Test\n-  void testSessionExpiry()\n-      throws Exception {\n+  void testSessionExpiry() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506df964cf755939fdb51df09098254647cfe568"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyMTIwMg==", "bodyText": "These are formatted by helix-style. I guess I formatted the whole file. Usually I don't do that. Well just a few lines I think.", "url": "https://github.com/apache/helix/pull/1066#discussion_r445321202", "createdAt": "2020-06-25T05:50:43Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java", "diffHunk": "@@ -149,8 +149,7 @@ public void handleSessionEstablishmentError(Throwable error) {\n    * Tests session expiry for the helix's IZkStateListener.\n    */\n   @Test\n-  void testSessionExpiry()\n-      throws Exception {\n+  void testSessionExpiry() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1NTAzNg=="}, "originalCommit": {"oid": "506df964cf755939fdb51df09098254647cfe568"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODE5NTQ3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo1NTo0OVrOGzcGPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOToyNjo0OFrOG0cKtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MDkxMQ==", "bodyText": "Sorry that if I asked this question before (this PR has been opened for a long time), but can we actually add the session Id to the ClusterEvent when it is constructed, and then use that session Id directly here?\nOr they are actually different Session Ids. 1. is the id that from which the HelixManger get events. 2. is the current HelixManager session Id.\nIf this is the case, then we shall not call it EVENT_SESSION. It would be misleading.\nI think that using the real EVENT session Id would be good enough. So we may don't need this Manger Session Id here.", "url": "https://github.com/apache/helix/pull/1066#discussion_r456590911", "createdAt": "2020-07-17T17:55:49Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -695,12 +695,19 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n         _rebalancerRef.getRebalancer(manager));\n \n-    if (!manager.isLeader()) {\n-      logger.error(\"Cluster manager: \" + manager.getInstanceName() + \" is not leader for \" + manager\n-          .getClusterName() + \". Pipeline will not be invoked\");\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5Mzc3OA==", "bodyText": "@jiajunwang\n\ncan we actually add the session Id to the ClusterEvent when it is constructed, and then use that session Id directly here?\n\nI don't think it is accurate: when the event is constructed and we add this session id S0 to event, if the manager session id changes to S1 when handling the event, the event would not be processed. But actually I think it would be more accurate to use the session id when starting to process the pipeline.\nOr even session id changes to S1 and the event is not handled, there will be future events to keep the correctness. In this case, I think it is fine to add the session id to when event is created. But I think it may affect a bit performance: originally event0 will process the pipeline, but it is discarded and next event1 will be processed later.\nSo I think it is better to add the session right before running the pipeline.", "url": "https://github.com/apache/helix/pull/1066#discussion_r456993778", "createdAt": "2020-07-20T02:15:53Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -695,12 +695,19 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n         _rebalancerRef.getRebalancer(manager));\n \n-    if (!manager.isLeader()) {\n-      logger.error(\"Cluster manager: \" + manager.getInstanceName() + \" is not leader for \" + manager\n-          .getClusterName() + \". Pipeline will not be invoked\");\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MDkxMQ=="}, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4NTE5MQ==", "bodyText": "The reason we want this change is to prevent 2 pipelines running. So if the S0 session event is handled in S1, do you think it would be risky that we have more confusion and leads to a bad result?", "url": "https://github.com/apache/helix/pull/1066#discussion_r457585191", "createdAt": "2020-07-20T17:46:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -695,12 +695,19 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n         _rebalancerRef.getRebalancer(manager));\n \n-    if (!manager.isLeader()) {\n-      logger.error(\"Cluster manager: \" + manager.getInstanceName() + \" is not leader for \" + manager\n-          .getClusterName() + \". Pipeline will not be invoked\");\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MDkxMQ=="}, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0MDYyOQ==", "bodyText": "Synced with @jiajunwang offline. We agreed to add event session when event is created. Updated the PR.", "url": "https://github.com/apache/helix/pull/1066#discussion_r457640629", "createdAt": "2020-07-20T19:26:48Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -695,12 +695,19 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n         _rebalancerRef.getRebalancer(manager));\n \n-    if (!manager.isLeader()) {\n-      logger.error(\"Cluster manager: \" + manager.getInstanceName() + \" is not leader for \" + manager\n-          .getClusterName() + \". Pipeline will not be invoked\");\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MDkxMQ=="}, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODIwNjE1OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo1ODo0M1rOGzcMrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoxODo1NFrOGz0uQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MjU1Nw==", "bodyText": "Will \"data instanceof Message\" be simpler here?", "url": "https://github.com/apache/helix/pull/1066#discussion_r456592557", "createdAt": "2020-07-17T17:58:43Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2234,13 +2205,59 @@ private String getHexSessionId() {\n   }\n \n   /*\n-   * Session aware operation needs below requirements:\n-   * 1. the session id is NOT null or empty\n-   * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n+   * Gets the zookeeper instance that ensures its session ID matches the expected session ID.\n+   * It is used for write operations that suppose the znode to be created by the expected session.\n    */\n-  private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n+    /*\n+     * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n+     * under this zookeeper connection. This is to avoid zk session change after expected\n+     * session check.\n+     */\n+    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+\n+    /*\n+     * The operation is NOT session aware, we will use the actual zookeeper session without\n+     * checking expected session.\n+     */\n+    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n+      return zk;\n+    }\n+\n+    /*\n+     * If operation is session aware (expectedSession is valid),\n+     * we have to check whether or not the passed-in(expected) session id\n+     * matches actual session's id.\n+     * If not, we should not return a zk object for the zk operation.\n+     */\n+    final String actualSessionId = Long.toHexString(zk.getSessionId());\n+    if (!actualSessionId.equals(expectedSessionId)) {\n+      throw new ZkSessionMismatchedException(\n+          \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n+              + expectedSessionId + \". Actual: \" + actualSessionId);\n+    }\n+\n+    return zk;\n+  }\n+\n+  private String parseExpectedSessionId(Object data) {\n+    if (data == null) {\n+      return null;\n+    }\n+\n+    ZNRecord record;\n+    try {\n+      record = (ZNRecord) data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NDM3MA==", "bodyText": "I've thought about it. data instanceof Message adds one more check.\nif (!data instanceof Message) {\n  return null;\n}\n\nZNRecord record = (ZNRecord) data;\n...\n\nSince most of the time, this API is for message and we need to cast the type, I prefer this so no need to always do the instanceof check.", "url": "https://github.com/apache/helix/pull/1066#discussion_r456994370", "createdAt": "2020-07-20T02:18:54Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2234,13 +2205,59 @@ private String getHexSessionId() {\n   }\n \n   /*\n-   * Session aware operation needs below requirements:\n-   * 1. the session id is NOT null or empty\n-   * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n+   * Gets the zookeeper instance that ensures its session ID matches the expected session ID.\n+   * It is used for write operations that suppose the znode to be created by the expected session.\n    */\n-  private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n+    /*\n+     * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n+     * under this zookeeper connection. This is to avoid zk session change after expected\n+     * session check.\n+     */\n+    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+\n+    /*\n+     * The operation is NOT session aware, we will use the actual zookeeper session without\n+     * checking expected session.\n+     */\n+    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n+      return zk;\n+    }\n+\n+    /*\n+     * If operation is session aware (expectedSession is valid),\n+     * we have to check whether or not the passed-in(expected) session id\n+     * matches actual session's id.\n+     * If not, we should not return a zk object for the zk operation.\n+     */\n+    final String actualSessionId = Long.toHexString(zk.getSessionId());\n+    if (!actualSessionId.equals(expectedSessionId)) {\n+      throw new ZkSessionMismatchedException(\n+          \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n+              + expectedSessionId + \". Actual: \" + actualSessionId);\n+    }\n+\n+    return zk;\n+  }\n+\n+  private String parseExpectedSessionId(Object data) {\n+    if (data == null) {\n+      return null;\n+    }\n+\n+    ZNRecord record;\n+    try {\n+      record = (ZNRecord) data;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MjU1Nw=="}, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODIxMDIzOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo1OTo0NVrOGzcPIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODoyNzoxOVrOG1El9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MzE4NA==", "bodyText": "So we only protect create but not write?", "url": "https://github.com/apache/helix/pull/1066#discussion_r456593184", "createdAt": "2020-07-17T17:59:45Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1827,18 +1796,20 @@ public void asyncCreate(final String path, Object datat, final CreateMode mode,\n           new ZkAsyncCallMonitorContext(_monitor, startT, 0, false), null);\n       return;\n     }\n-    doAsyncCreate(path, data, mode, startT, cb);\n+    doAsyncCreate(path, data, mode, startT, cb, parseExpectedSessionId(datat));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5Njg4NQ==", "bodyText": "For this fix, we only need it for creating messages. For updating messages, it should be done by participants. So we don't need that (correct me if I am wrong). If we want to do it for all the write/create operations, we have to protect all the async/sync operations, which I don't think we want to do now.\nIf in the future we also need to protect write operations, we could definitely quickly add the same logic as in create. What do you think?", "url": "https://github.com/apache/helix/pull/1066#discussion_r456996885", "createdAt": "2020-07-20T02:30:48Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1827,18 +1796,20 @@ public void asyncCreate(final String path, Object datat, final CreateMode mode,\n           new ZkAsyncCallMonitorContext(_monitor, startT, 0, false), null);\n       return;\n     }\n-    doAsyncCreate(path, data, mode, startT, cb);\n+    doAsyncCreate(path, data, mode, startT, cb, parseExpectedSessionId(datat));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MzE4NA=="}, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjk2NQ==", "bodyText": "We agreed to protect all write operations, as well.", "url": "https://github.com/apache/helix/pull/1066#discussion_r458302965", "createdAt": "2020-07-21T18:27:19Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1827,18 +1796,20 @@ public void asyncCreate(final String path, Object datat, final CreateMode mode,\n           new ZkAsyncCallMonitorContext(_monitor, startT, 0, false), null);\n       return;\n     }\n-    doAsyncCreate(path, data, mode, startT, cb);\n+    doAsyncCreate(path, data, mode, startT, cb, parseExpectedSessionId(datat));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MzE4NA=="}, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODIxNzQyOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODowMjowMVrOGzcTjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNjoyMToxN1rOGz6ibg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5NDMxNg==", "bodyText": "This logic is Helix logic specific, not a good idea to put in ZkClient.\nTo make it generic, one way is adding a new interface of ZnRecord (SessionAwareZnRecordUpdateRequest, etc.) which provides a method such as getExpectedSessionId() to return this information.", "url": "https://github.com/apache/helix/pull/1066#discussion_r456594316", "createdAt": "2020-07-17T18:02:01Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2234,13 +2205,59 @@ private String getHexSessionId() {\n   }\n \n   /*\n-   * Session aware operation needs below requirements:\n-   * 1. the session id is NOT null or empty\n-   * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n+   * Gets the zookeeper instance that ensures its session ID matches the expected session ID.\n+   * It is used for write operations that suppose the znode to be created by the expected session.\n    */\n-  private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n+    /*\n+     * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n+     * under this zookeeper connection. This is to avoid zk session change after expected\n+     * session check.\n+     */\n+    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+\n+    /*\n+     * The operation is NOT session aware, we will use the actual zookeeper session without\n+     * checking expected session.\n+     */\n+    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n+      return zk;\n+    }\n+\n+    /*\n+     * If operation is session aware (expectedSession is valid),\n+     * we have to check whether or not the passed-in(expected) session id\n+     * matches actual session's id.\n+     * If not, we should not return a zk object for the zk operation.\n+     */\n+    final String actualSessionId = Long.toHexString(zk.getSessionId());\n+    if (!actualSessionId.equals(expectedSessionId)) {\n+      throw new ZkSessionMismatchedException(\n+          \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n+              + expectedSessionId + \". Actual: \" + actualSessionId);\n+    }\n+\n+    return zk;\n+  }\n+\n+  private String parseExpectedSessionId(Object data) {\n+    if (data == null) {\n+      return null;\n+    }\n+\n+    ZNRecord record;\n+    try {\n+      record = (ZNRecord) data;\n+    } catch (ClassCastException e) {\n+      LOG.debug(\"Failed to parse expected session id!\", e);\n+      return null;\n+    }\n+\n+    // Check it is a message and get src session id as expected session id for message.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NzA4MQ==", "bodyText": "Yep, I agree we should separate helix and zk logic cleanly. Let me change and see if this will make it cleaner.", "url": "https://github.com/apache/helix/pull/1066#discussion_r456997081", "createdAt": "2020-07-20T02:31:46Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2234,13 +2205,59 @@ private String getHexSessionId() {\n   }\n \n   /*\n-   * Session aware operation needs below requirements:\n-   * 1. the session id is NOT null or empty\n-   * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n+   * Gets the zookeeper instance that ensures its session ID matches the expected session ID.\n+   * It is used for write operations that suppose the znode to be created by the expected session.\n    */\n-  private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n+    /*\n+     * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n+     * under this zookeeper connection. This is to avoid zk session change after expected\n+     * session check.\n+     */\n+    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+\n+    /*\n+     * The operation is NOT session aware, we will use the actual zookeeper session without\n+     * checking expected session.\n+     */\n+    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n+      return zk;\n+    }\n+\n+    /*\n+     * If operation is session aware (expectedSession is valid),\n+     * we have to check whether or not the passed-in(expected) session id\n+     * matches actual session's id.\n+     * If not, we should not return a zk object for the zk operation.\n+     */\n+    final String actualSessionId = Long.toHexString(zk.getSessionId());\n+    if (!actualSessionId.equals(expectedSessionId)) {\n+      throw new ZkSessionMismatchedException(\n+          \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n+              + expectedSessionId + \". Actual: \" + actualSessionId);\n+    }\n+\n+    return zk;\n+  }\n+\n+  private String parseExpectedSessionId(Object data) {\n+    if (data == null) {\n+      return null;\n+    }\n+\n+    ZNRecord record;\n+    try {\n+      record = (ZNRecord) data;\n+    } catch (ClassCastException e) {\n+      LOG.debug(\"Failed to parse expected session id!\", e);\n+      return null;\n+    }\n+\n+    // Check it is a message and get src session id as expected session id for message.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5NDMxNg=="}, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA4OTY0Ng==", "bodyText": "@jiajunwang I've cleaned up the code in zkClient. I think it is cleaner. My thought is we don't have to create a new class extends ZNRecord which only introduces an expectedSessionId. It is fine to just add the field/methods to existing ZNRecord. And we move the expected session population logic to ZkHelixDataAccessor's createChildren. It seems to me a clean way. What do you think?", "url": "https://github.com/apache/helix/pull/1066#discussion_r457089646", "createdAt": "2020-07-20T06:21:17Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -2234,13 +2205,59 @@ private String getHexSessionId() {\n   }\n \n   /*\n-   * Session aware operation needs below requirements:\n-   * 1. the session id is NOT null or empty\n-   * 2. create mode is EPHEMERAL or EPHEMERAL_SEQUENTIAL\n+   * Gets the zookeeper instance that ensures its session ID matches the expected session ID.\n+   * It is used for write operations that suppose the znode to be created by the expected session.\n    */\n-  private boolean isSessionAwareOperation(String expectedSessionId, CreateMode mode) {\n-    return expectedSessionId != null && !expectedSessionId.isEmpty() && (\n-        mode == CreateMode.EPHEMERAL || mode == CreateMode.EPHEMERAL_SEQUENTIAL);\n+  private ZooKeeper getExpectedZookeeper(final String expectedSessionId) {\n+    /*\n+     * Cache the zookeeper reference and make sure later zooKeeper.create() is being run\n+     * under this zookeeper connection. This is to avoid zk session change after expected\n+     * session check.\n+     */\n+    ZooKeeper zk = ((ZkConnection) getConnection()).getZookeeper();\n+\n+    /*\n+     * The operation is NOT session aware, we will use the actual zookeeper session without\n+     * checking expected session.\n+     */\n+    if (expectedSessionId == null || expectedSessionId.isEmpty()) {\n+      return zk;\n+    }\n+\n+    /*\n+     * If operation is session aware (expectedSession is valid),\n+     * we have to check whether or not the passed-in(expected) session id\n+     * matches actual session's id.\n+     * If not, we should not return a zk object for the zk operation.\n+     */\n+    final String actualSessionId = Long.toHexString(zk.getSessionId());\n+    if (!actualSessionId.equals(expectedSessionId)) {\n+      throw new ZkSessionMismatchedException(\n+          \"Failed to get expected zookeeper instance! There is a session id mismatch. Expected: \"\n+              + expectedSessionId + \". Actual: \" + actualSessionId);\n+    }\n+\n+    return zk;\n+  }\n+\n+  private String parseExpectedSessionId(Object data) {\n+    if (data == null) {\n+      return null;\n+    }\n+\n+    ZNRecord record;\n+    try {\n+      record = (ZNRecord) data;\n+    } catch (ClassCastException e) {\n+      LOG.debug(\"Failed to parse expected session id!\", e);\n+      return null;\n+    }\n+\n+    // Check it is a message and get src session id as expected session id for message.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5NDMxNg=="}, "originalCommit": {"oid": "c0357b56f4e20b03713389760273665444df14d4"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODYyMjg1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODo0ODoyNlrOG2XQJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODo1MzowMFrOG2XZ5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NzI1NQ==", "bodyText": "What is the difference between SrcSessionId and ExpectedSessionId?", "url": "https://github.com/apache/helix/pull/1066#discussion_r459657255", "createdAt": "2020-07-23T18:48:26Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java", "diffHunk": "@@ -445,7 +448,8 @@ private Message createStateTransitionCancellationMessage(HelixManager manager, R\n       message.setFromState(fromState);\n       message.setToState(toState);\n       message.setTgtSessionId(sessionId);\n-      message.setSrcSessionId(manager.getSessionId());\n+      message.setSrcSessionId(managerSessionId);\n+      message.setExpectedSessionId(managerSessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1OTc1MA==", "bodyText": "The difference I suppose is: say, a message is forwarded/sent from node1 to node2. So srcSessionId = sessionNode1. This message doesn't have to be written by node1's zkclient, but another zkclient session-0. So expectedSessionId = session-0. I'd like to differentiate  srcSessionId and write expectedSessionId.\nLet me know I miss anything.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459659750", "createdAt": "2020-07-23T18:53:00Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java", "diffHunk": "@@ -445,7 +448,8 @@ private Message createStateTransitionCancellationMessage(HelixManager manager, R\n       message.setFromState(fromState);\n       message.setToState(toState);\n       message.setTgtSessionId(sessionId);\n-      message.setSrcSessionId(manager.getSessionId());\n+      message.setSrcSessionId(managerSessionId);\n+      message.setExpectedSessionId(managerSessionId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NzI1NQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODYyODAyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODo0OTo1NlrOG2XTXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxOTowOTowNlrOG5GSMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1ODA3Ng==", "bodyText": "getSessionIdIfLeader?  Also, why do we need this if we already have manager.getSessionId?", "url": "https://github.com/apache/helix/pull/1066#discussion_r459658076", "createdAt": "2020-07-23T18:49:56Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyMjA1MQ==", "bodyText": "manager.getSessionIdIfLead checks whether the cluster manager is leader and returns the session ID associated to the connection of cluster data store, if and only if it is leader. It combines isLeader() and getSessionId() in one method to ensure the session id returning is what we check leadership in isLeader().\nWithout it, we may do this:\nif (isLeader()) {\nsessionId = manager.getSessionId();\n}\nThe problem is race condition. sessionId may change after isLeader().\nSo we need manager.getSessionIdIfLead to check leadership and get sessionId at the same time.", "url": "https://github.com/apache/helix/pull/1066#discussion_r460222051", "createdAt": "2020-07-24T18:33:12Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1ODA3Ng=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA2OTU1Ng==", "bodyText": "Basically, the idea is that check leader and get leader sessionID at one operation, later if sessionID changes, we use sessionAwareWriter interface to fail it.", "url": "https://github.com/apache/helix/pull/1066#discussion_r461069556", "createdAt": "2020-07-27T17:59:03Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1ODA3Ng=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEyNzY0NA==", "bodyText": "@kaisun2000 You are right. This is the core idea.", "url": "https://github.com/apache/helix/pull/1066#discussion_r461127644", "createdAt": "2020-07-27T19:45:59Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1ODA3Ng=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyNDk3Ng==", "bodyText": "One more thing for why do we need this if we already have manager.getSessionId?:\ngetSessionId just directly returns the existing sessionId in manager. But getSessionIdIfLeader() does more thing by reading zk to check leadership. This is the main difference.", "url": "https://github.com/apache/helix/pull/1066#discussion_r462524976", "createdAt": "2020-07-29T19:09:06Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1ODA3Ng=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODY0OTg1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODo1NjoyM1rOG2XhMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjo1NjoyOFrOG2k8Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2MTYxNg==", "bodyText": "why change this?", "url": "https://github.com/apache/helix/pull/1066#discussion_r459661616", "createdAt": "2020-07-23T18:56:23Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "diffHunk": "@@ -189,7 +200,7 @@ public final String getId() {\n    * Get the backing ZNRecord\n    * @return ZNRecord object associated with this property\n    */\n-  public final ZNRecord getRecord() {\n+  public ZNRecord getRecord() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4MTUxOA==", "bodyText": "I had another code change that required override getRecord() in Message. But now it doesn't need that. I will restore this.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459881518", "createdAt": "2020-07-24T06:56:28Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "diffHunk": "@@ -189,7 +200,7 @@ public final String getId() {\n    * Get the backing ZNRecord\n    * @return ZNRecord object associated with this property\n    */\n-  public final ZNRecord getRecord() {\n+  public ZNRecord getRecord() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2MTYxNg=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODY1NTE2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODo1Nzo1OFrOG2XkqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDoyMzo0MVrOG28ssw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2MjUwNQ==", "bodyText": "In HandleEvent you already check if the sessionId matches the expected sessionId, why do we check again here?", "url": "https://github.com/apache/helix/pull/1066#discussion_r459662505", "createdAt": "2020-07-23T18:57:58Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -312,6 +312,17 @@ private void forceRebalance(HelixManager manager, ClusterEventType eventType) {\n     changeContext.setType(NotificationContext.Type.CALLBACK);\n     String uid = UUID.randomUUID().toString().substring(0, 8);\n     ClusterEvent event = new ClusterEvent(_clusterName, eventType, uid);\n+\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();\n+    // If session is not present, this cluster manager is not leader for the cluster.\n+    if (!leaderSession.isPresent()) {\n+      logger.warn(\"Cluster manager {} is not leader for {}. Event {} is discarded.\",\n+          manager.getInstanceName(), manager.getClusterName(), event);\n+      return;\n+    }\n+\n+    // Pipeline should be run and Zk writes should be completed by the event session.\n+    event.addAttribute(AttributeName.EVENT_SESSION.name(), leaderSession.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4NDUyMA==", "bodyText": "The purpose of this check here is to only add events to the queue if and only if controller is leader. We attach the session id as event session id. If controller is not leader, we discard the event and don't push it to queue.\nIn HandleEvent(), we check it as a filter if we should start the pipeline for the event. Because during the event in the queue, controller's session may change. If it changes, there is no need to start the pipeline for the stale event.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459884520", "createdAt": "2020-07-24T07:05:24Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -312,6 +312,17 @@ private void forceRebalance(HelixManager manager, ClusterEventType eventType) {\n     changeContext.setType(NotificationContext.Type.CALLBACK);\n     String uid = UUID.randomUUID().toString().substring(0, 8);\n     ClusterEvent event = new ClusterEvent(_clusterName, eventType, uid);\n+\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();\n+    // If session is not present, this cluster manager is not leader for the cluster.\n+    if (!leaderSession.isPresent()) {\n+      logger.warn(\"Cluster manager {} is not leader for {}. Event {} is discarded.\",\n+          manager.getInstanceName(), manager.getClusterName(), event);\n+      return;\n+    }\n+\n+    // Pipeline should be run and Zk writes should be completed by the event session.\n+    event.addAttribute(AttributeName.EVENT_SESSION.name(), leaderSession.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2MjUwNQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4NDU4Mw==", "bodyText": "Then when we created the event, just add the current session to the event attributes, is that good enough? We will check whether current controller is a leader and whether session matches anyway in handleEvent?", "url": "https://github.com/apache/helix/pull/1066#discussion_r460184583", "createdAt": "2020-07-24T17:16:11Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -312,6 +312,17 @@ private void forceRebalance(HelixManager manager, ClusterEventType eventType) {\n     changeContext.setType(NotificationContext.Type.CALLBACK);\n     String uid = UUID.randomUUID().toString().substring(0, 8);\n     ClusterEvent event = new ClusterEvent(_clusterName, eventType, uid);\n+\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();\n+    // If session is not present, this cluster manager is not leader for the cluster.\n+    if (!leaderSession.isPresent()) {\n+      logger.warn(\"Cluster manager {} is not leader for {}. Event {} is discarded.\",\n+          manager.getInstanceName(), manager.getClusterName(), event);\n+      return;\n+    }\n+\n+    // Pipeline should be run and Zk writes should be completed by the event session.\n+    event.addAttribute(AttributeName.EVENT_SESSION.name(), leaderSession.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2MjUwNQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4NTA5Mg==", "bodyText": "What I meant, just need one line in the event create places:\nevent.addAttribute(AttributeName.EVENT_SESSION.name(), manager.getSessionId());", "url": "https://github.com/apache/helix/pull/1066#discussion_r460185092", "createdAt": "2020-07-24T17:17:04Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -312,6 +312,17 @@ private void forceRebalance(HelixManager manager, ClusterEventType eventType) {\n     changeContext.setType(NotificationContext.Type.CALLBACK);\n     String uid = UUID.randomUUID().toString().substring(0, 8);\n     ClusterEvent event = new ClusterEvent(_clusterName, eventType, uid);\n+\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();\n+    // If session is not present, this cluster manager is not leader for the cluster.\n+    if (!leaderSession.isPresent()) {\n+      logger.warn(\"Cluster manager {} is not leader for {}. Event {} is discarded.\",\n+          manager.getInstanceName(), manager.getClusterName(), event);\n+      return;\n+    }\n+\n+    // Pipeline should be run and Zk writes should be completed by the event session.\n+    event.addAttribute(AttributeName.EVENT_SESSION.name(), leaderSession.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2MjUwNQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNzA4MA==", "bodyText": "Then when we created the event, just add the current session to the event attributes, is that good enough? We will check whether current controller is a leader and whether session matches anyway in handleEvent?\n\nIt is OK to check session when handleEvent, which could reduce the checks when pushing event. Downside is when we create the events, manager session has already expired. Then we still push stale events to the event queue.", "url": "https://github.com/apache/helix/pull/1066#discussion_r460227080", "createdAt": "2020-07-24T18:44:03Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -312,6 +312,17 @@ private void forceRebalance(HelixManager manager, ClusterEventType eventType) {\n     changeContext.setType(NotificationContext.Type.CALLBACK);\n     String uid = UUID.randomUUID().toString().substring(0, 8);\n     ClusterEvent event = new ClusterEvent(_clusterName, eventType, uid);\n+\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();\n+    // If session is not present, this cluster manager is not leader for the cluster.\n+    if (!leaderSession.isPresent()) {\n+      logger.warn(\"Cluster manager {} is not leader for {}. Event {} is discarded.\",\n+          manager.getInstanceName(), manager.getClusterName(), event);\n+      return;\n+    }\n+\n+    // Pipeline should be run and Zk writes should be completed by the event session.\n+    event.addAttribute(AttributeName.EVENT_SESSION.name(), leaderSession.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2MjUwNQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MDc3MQ==", "bodyText": "Since there are 3 places creating new events, I've moved the check to handleEvent().", "url": "https://github.com/apache/helix/pull/1066#discussion_r460270771", "createdAt": "2020-07-24T20:23:41Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -312,6 +312,17 @@ private void forceRebalance(HelixManager manager, ClusterEventType eventType) {\n     changeContext.setType(NotificationContext.Type.CALLBACK);\n     String uid = UUID.randomUUID().toString().substring(0, 8);\n     ClusterEvent event = new ClusterEvent(_clusterName, eventType, uid);\n+\n+    Optional<String> leaderSession = manager.getSessionIdIfLead();\n+    // If session is not present, this cluster manager is not leader for the cluster.\n+    if (!leaderSession.isPresent()) {\n+      logger.warn(\"Cluster manager {} is not leader for {}. Event {} is discarded.\",\n+          manager.getInstanceName(), manager.getClusterName(), event);\n+      return;\n+    }\n+\n+    // Pipeline should be run and Zk writes should be completed by the event session.\n+    event.addAttribute(AttributeName.EVENT_SESSION.name(), leaderSession.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2MjUwNQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODY2NDQyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTowMDo0N1rOG2XqXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDoyMjo1NlrOG28rhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2Mzk2NA==", "bodyText": "if(eventSessionId != null && manager.getSessionId.equals(eventSessionId)) {\n...\n}", "url": "https://github.com/apache/helix/pull/1066#discussion_r459663964", "createdAt": "2020-07-23T19:00:47Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +762,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    String eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    if (eventSessionId != null) {\n+      String managerSessionId = manager.getSessionId();\n+      if (!eventSessionId.equals(managerSessionId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwODY0NA==", "bodyText": "String managerSessionId = manager.getSessionId(); is having managerSessionId to be used in if check and log. If we do it in the way you suggested, either we don't log this manager session, or we need manager.getSessionId() again in log. getSessionId also wait for connected. And if during these two getSessionId, the session id changes, we have different session ids.\nI prefer to log manager session id so this is why I put a variable here.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459708644", "createdAt": "2020-07-23T20:27:45Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +762,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    String eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    if (eventSessionId != null) {\n+      String managerSessionId = manager.getSessionId();\n+      if (!eventSessionId.equals(managerSessionId)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2Mzk2NA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MzIzMg==", "bodyText": "that is fine, what I meant is we do not two levels of embeded if.. statements in this case.\nif(eventSessionId != null && managerSessionId.equals(eventSessionId))...", "url": "https://github.com/apache/helix/pull/1066#discussion_r460183232", "createdAt": "2020-07-24T17:13:47Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +762,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    String eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    if (eventSessionId != null) {\n+      String managerSessionId = manager.getSessionId();\n+      if (!eventSessionId.equals(managerSessionId)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2Mzk2NA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIxMDc1Ng==", "bodyText": "I got your point. To achieve one level if statement, we could move managerSessionId outside. Then the scope of managerSessionId is bigger.\nString eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\nString managerSessionId = manager.getSessionId();\nif (eventSessionId != null && !eventSessionId.equals(managerSessionId)) {\n...\n}\n\nBut after this if statement we don't need managerSessionId. This what I try to do, following Effective Java Item - 45 : Minimize the scope of local variables: https://gist.github.com/kpgalligan/4cf93abd88044df71da5", "url": "https://github.com/apache/helix/pull/1066#discussion_r460210756", "createdAt": "2020-07-24T18:09:21Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +762,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    String eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    if (eventSessionId != null) {\n+      String managerSessionId = manager.getSessionId();\n+      if (!eventSessionId.equals(managerSessionId)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2Mzk2NA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MDQ2OQ==", "bodyText": "Changed.", "url": "https://github.com/apache/helix/pull/1066#discussion_r460270469", "createdAt": "2020-07-24T20:22:56Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +762,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    String eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    if (eventSessionId != null) {\n+      String managerSessionId = manager.getSessionId();\n+      if (!eventSessionId.equals(managerSessionId)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2Mzk2NA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODY4MDk5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTowNTozNFrOG2X0bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMDowOVrOG2aJww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NjU0MA==", "bodyText": "This warn message is misleading, it does not necessarily mean the current controller is not the leader of the cluster. This just means we discarded event that was generated from an old session.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459666540", "createdAt": "2020-07-23T19:05:34Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +762,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    String eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    if (eventSessionId != null) {\n+      String managerSessionId = manager.getSessionId();\n+      if (!eventSessionId.equals(managerSessionId)) {\n+        logger.warn(\n+            \"Controller pipeline is not invoked because cluster manager {} lost leadership for \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNDc3MQ==", "bodyText": "The cluster manager's session changed, lost and then acquired leadership again. Yep, you are right. I'll make the log clearer.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459704771", "createdAt": "2020-07-23T20:20:09Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +762,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    String eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    if (eventSessionId != null) {\n+      String managerSessionId = manager.getSessionId();\n+      if (!eventSessionId.equals(managerSessionId)) {\n+        logger.warn(\n+            \"Controller pipeline is not invoked because cluster manager {} lost leadership for \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NjU0MA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODY4OTg3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTowODoxNVrOG2X53w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDoyMjo0MFrOG28rCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NzkzNQ==", "bodyText": "Seems we have multiple places to check this event session ID matches. In pushEventToQueue, in HandleEvent(), in ForceRebalance().  Do we really need to validate this everywhere?  Can we combine them together in one place?", "url": "https://github.com/apache/helix/pull/1066#discussion_r459667935", "createdAt": "2020-07-23T19:08:15Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1360,8 +1390,20 @@ private boolean updateControllerState(NotificationContext changeContext, PauseSi\n         String uid = UUID.randomUUID().toString().substring(0, 8);\n         ClusterEvent event = new ClusterEvent(_clusterName, ClusterEventType.Resume,\n             String.format(\"%s_%s\", uid, Pipeline.Type.DEFAULT.name()));\n+\n+        HelixManager manager = changeContext.getManager();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4NTY4NA==", "bodyText": "As mentioned above, they are different: ForceRebalance() and pushEventToQueue() are creating new events. We want to check the leadership and add the session to the event.\nFor later checks such as in HandleEvent(), they are just using the event session id to check current controller session. If controller session changes, we stop the event/pipeline.\nSo, since we have 3 places that create new events, I don't think we could combine them together in one place(I've thought about it and tried).", "url": "https://github.com/apache/helix/pull/1066#discussion_r459885684", "createdAt": "2020-07-24T07:09:09Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1360,8 +1390,20 @@ private boolean updateControllerState(NotificationContext changeContext, PauseSi\n         String uid = UUID.randomUUID().toString().substring(0, 8);\n         ClusterEvent event = new ClusterEvent(_clusterName, ClusterEventType.Resume,\n             String.format(\"%s_%s\", uid, Pipeline.Type.DEFAULT.name()));\n+\n+        HelixManager manager = changeContext.getManager();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NzkzNQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MDM0Nw==", "bodyText": "To make code clean, I decided to put it the check in one place in handleEvent(). It is fine to push stale events into queue.", "url": "https://github.com/apache/helix/pull/1066#discussion_r460270347", "createdAt": "2020-07-24T20:22:40Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1360,8 +1390,20 @@ private boolean updateControllerState(NotificationContext changeContext, PauseSi\n         String uid = UUID.randomUUID().toString().substring(0, 8);\n         ClusterEvent event = new ClusterEvent(_clusterName, ClusterEventType.Resume,\n             String.format(\"%s_%s\", uid, Pipeline.Type.DEFAULT.name()));\n+\n+        HelixManager manager = changeContext.getManager();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NzkzNQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODY5MzQwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTowOToyMVrOG2X8CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNzoxNzowM1rOG2lXVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2ODQ4OA==", "bodyText": "Also using of manager.getSessionIdIfLead here could be confusing. We used getSessionId in other places, what is the difference?  Where we should use getSessionIdIfLead and where we should use getSessionId?", "url": "https://github.com/apache/helix/pull/1066#discussion_r459668488", "createdAt": "2020-07-23T19:09:21Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1360,8 +1390,20 @@ private boolean updateControllerState(NotificationContext changeContext, PauseSi\n         String uid = UUID.randomUUID().toString().substring(0, 8);\n         ClusterEvent event = new ClusterEvent(_clusterName, ClusterEventType.Resume,\n             String.format(\"%s_%s\", uid, Pipeline.Type.DEFAULT.name()));\n+\n+        HelixManager manager = changeContext.getManager();\n+        Optional<String> leaderSession = manager.getSessionIdIfLead();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4ODQ2OQ==", "bodyText": "manager.getSessionIdIfLead checks whether the cluster manager is leader and returns the session ID associated to the connection of cluster data store, if and only if it is leader. It combines isLeader() and getSessionId() in one method to ensure the session id returning is what we check leadership in isLeader().\nWithout it, we may do this:\nif (isLeader()) {\n  sessionId = manager.getSessionId();\n}\n\nThe problem is race condition. sessionId may change after isLeader().\nSo we need manager.getSessionIdIfLead to check leadership and get sessionId at the same time.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459888469", "createdAt": "2020-07-24T07:17:03Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1360,8 +1390,20 @@ private boolean updateControllerState(NotificationContext changeContext, PauseSi\n         String uid = UUID.randomUUID().toString().substring(0, 8);\n         ClusterEvent event = new ClusterEvent(_clusterName, ClusterEventType.Resume,\n             String.format(\"%s_%s\", uid, Pipeline.Type.DEFAULT.name()));\n+\n+        HelixManager manager = changeContext.getManager();\n+        Optional<String> leaderSession = manager.getSessionIdIfLead();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2ODQ4OA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODY5ODU5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOToxMTowNlrOG2X_Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODoyMTowM1rOG25Xtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2OTM0Mg==", "bodyText": "should we do this for all Stage? or just messageDispatchStage?  If for all stages, maybe we should put this check before where each stage was called.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459669342", "createdAt": "2020-07-23T19:11:06Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,17 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n+    String expectedSession = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent and pipeline should stop.\n+    // This avoids potential double masters for a single partition.\n+    if (expectedSession != null && !expectedSession.equals(manager.getSessionId())) {\n+      throw new StageException(\n+          \"Controller: \" + manager.getInstanceName() + \" lost leadership! Expected session: \"\n+              + expectedSession + \", actual: \" + manager.getSessionId());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4OTExNA==", "bodyText": "We've discussed this question. We decided not to do the check for all stages (too many stages). Performance is not concern. Correctness is the most critical. We only do it for to ensure correctness here.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459889114", "createdAt": "2020-07-24T07:18:43Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,17 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n+    String expectedSession = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent and pipeline should stop.\n+    // This avoids potential double masters for a single partition.\n+    if (expectedSession != null && !expectedSession.equals(manager.getSessionId())) {\n+      throw new StageException(\n+          \"Controller: \" + manager.getInstanceName() + \" lost leadership! Expected session: \"\n+              + expectedSession + \", actual: \" + manager.getSessionId());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2OTM0Mg=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3OTY0OQ==", "bodyText": "Why checking in every stage is too much? Do you mean code wise is too much, actually you just need the same code, in different place, right?", "url": "https://github.com/apache/helix/pull/1066#discussion_r460179649", "createdAt": "2020-07-24T17:06:18Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,17 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n+    String expectedSession = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent and pipeline should stop.\n+    // This avoids potential double masters for a single partition.\n+    if (expectedSession != null && !expectedSession.equals(manager.getSessionId())) {\n+      throw new StageException(\n+          \"Controller: \" + manager.getInstanceName() + \" lost leadership! Expected session: \"\n+              + expectedSession + \", actual: \" + manager.getSessionId());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2OTM0Mg=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIxNjI0Nw==", "bodyText": "What I was thinking about is, we also check this stage in ReadClusterDataStage() because this place is the highly possible one that session expires. In our issue, the session expiry also happened in ReadClusterDataStage.\nIf we don't check it at every stage, it just costs extra resource(CPU/memory/network IO) which we could tolerate. I think checking at every stage may be excessive because most of stages are pretty fast(ReadClusterDataStage takes longer time) and very tiny possibility that session changes. As long as we protect sending message, correctness is ensured. We wanted to make minimum code change.", "url": "https://github.com/apache/helix/pull/1066#discussion_r460216247", "createdAt": "2020-07-24T18:21:03Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +78,17 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n+    String expectedSession = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller lost leadership, then messages should not be sent and pipeline should stop.\n+    // This avoids potential double masters for a single partition.\n+    if (expectedSession != null && !expectedSession.equals(manager.getSessionId())) {\n+      throw new StageException(\n+          \"Controller: \" + manager.getInstanceName() + \" lost leadership! Expected session: \"\n+              + expectedSession + \", actual: \" + manager.getSessionId());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2OTM0Mg=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODcxMDE3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOToxNDozN1rOG2YGhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxOTowNjo0OVrOG5GNYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTE3NA==", "bodyText": "I still do not think adding this new subtype ZNRecord is an elegant solution here, specially you put it as a private class here only for message could make it look a bit hacky. Let us discuss what other options here.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459671174", "createdAt": "2020-07-23T19:14:37Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "diffHunk": "@@ -953,4 +970,35 @@ public boolean isValid() {\n     }\n     return true;\n   }\n+\n+  // A class represents session aware ZNRecord for message. The message should be written to zk\n+  // by the expected session.\n+  // TODO: remove this class once public session-aware ZNRecord is available\n+  private static class SessionAwareZNRecord extends ZNRecord implements SessionAwareZkWriteData {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5MTk2NA==", "bodyText": "This is the most challenging part remaining in the PR that we consider. Multiple options are considered and tried. This one is by far a relatively cleaner one.\nConsidering:\n\nnot adding new session aware methods/interfaces ---> attach expected session together with data object\nmaking it generic in zkclient ---> new interface SessionAwareZkDataRecord\nLess hacky way than checking ZNRecord in zkclient ----> SessionAwareZNRecord extends ZNRecord implements SessionAwareZkWriteData. We don't have a public implementation SessionAwareZNRecord. So this is needed. I've added TODO if in future we implement public SessionAwareZNRecord, we should remove this private class.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459891964", "createdAt": "2020-07-24T07:25:47Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "diffHunk": "@@ -953,4 +970,35 @@ public boolean isValid() {\n     }\n     return true;\n   }\n+\n+  // A class represents session aware ZNRecord for message. The message should be written to zk\n+  // by the expected session.\n+  // TODO: remove this class once public session-aware ZNRecord is available\n+  private static class SessionAwareZNRecord extends ZNRecord implements SessionAwareZkWriteData {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTE3NA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3OTAzNA==", "bodyText": "If we believe this is the right solution, why not make it public?", "url": "https://github.com/apache/helix/pull/1066#discussion_r460179034", "createdAt": "2020-07-24T17:04:59Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "diffHunk": "@@ -953,4 +970,35 @@ public boolean isValid() {\n     }\n     return true;\n   }\n+\n+  // A class represents session aware ZNRecord for message. The message should be written to zk\n+  // by the expected session.\n+  // TODO: remove this class once public session-aware ZNRecord is available\n+  private static class SessionAwareZNRecord extends ZNRecord implements SessionAwareZkWriteData {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTE3NA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIxODYzNg==", "bodyText": "We still want to make minimum changes in this PR. Putting it private gives us more flexibility to change in future: may add more stuff to this class. If in future we find that we need SessionAwareZNRecord in other places, we should create such thing as public. We need to discuss more and have a more comprehensive design for public SessionAwareZNRecord. What do you think?", "url": "https://github.com/apache/helix/pull/1066#discussion_r460218636", "createdAt": "2020-07-24T18:25:52Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "diffHunk": "@@ -953,4 +970,35 @@ public boolean isValid() {\n     }\n     return true;\n   }\n+\n+  // A class represents session aware ZNRecord for message. The message should be written to zk\n+  // by the expected session.\n+  // TODO: remove this class once public session-aware ZNRecord is available\n+  private static class SessionAwareZNRecord extends ZNRecord implements SessionAwareZkWriteData {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTE3NA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMzc0NQ==", "bodyText": "@lei-xia I've considered and tried to break the PR down to 2 smaller ones: fixing the issue without new interface and adding new interface. But the first one PR would look quite hacky and I don't feel comfortable merging the commit to code base. So I decided to keep this PR and make SessionAwareZNRecord public. Even in the future we need to add more APIs to the interface, we could also add API implementation to SessionAwareZNRecord. In this way, I feel it is cleaner to check in.", "url": "https://github.com/apache/helix/pull/1066#discussion_r462523745", "createdAt": "2020-07-29T19:06:49Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "diffHunk": "@@ -953,4 +970,35 @@ public boolean isValid() {\n     }\n     return true;\n   }\n+\n+  // A class represents session aware ZNRecord for message. The message should be written to zk\n+  // by the expected session.\n+  // TODO: remove this class once public session-aware ZNRecord is available\n+  private static class SessionAwareZNRecord extends ZNRecord implements SessionAwareZkWriteData {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTE3NA=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODcyMDAyOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/SessionAwareZkWriteData.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOToxNzozMlrOG2YMiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNToxNTozN1rOG76gtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MjcxNQ==", "bodyText": "Again this name is confusing. What SessionAware exactly mean here?  And \"ZkWriteData\", does that mean I should only use this type when I write a data to ZK, should we return this type in a ZK read operation?   A better name could be SessionAwareZkDataType or SessionAwareZkDataRecord, something like that.", "url": "https://github.com/apache/helix/pull/1066#discussion_r459672715", "createdAt": "2020-07-23T19:17:32Z", "author": {"login": "lei-xia"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/SessionAwareZkWriteData.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.apache.helix.zookeeper.zkclient;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * An interface representing data being written to ZK is session aware:\n+ * data is supposed to be written by expected ZK session. If ZkClient's actual session\n+ * doesn't match expected session, data is not written to ZK.\n+ */\n+public interface SessionAwareZkWriteData {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5MzAyMA==", "bodyText": "Yep I actually also thought about SessionAwareZkDataRecord. But considering the data is only session-aware for write but not read, I made it SessionAwareZkData to indicate reading data may not use this one as session aware. We could think of a better name to make it clear.\n@jiajunwang What's your choice?", "url": "https://github.com/apache/helix/pull/1066#discussion_r459893020", "createdAt": "2020-07-24T07:28:32Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/SessionAwareZkWriteData.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.apache.helix.zookeeper.zkclient;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * An interface representing data being written to ZK is session aware:\n+ * data is supposed to be written by expected ZK session. If ZkClient's actual session\n+ * doesn't match expected session, data is not written to ZK.\n+ */\n+public interface SessionAwareZkWriteData {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MjcxNQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NzgxNA==", "bodyText": "Will decide this new interface in another PR.", "url": "https://github.com/apache/helix/pull/1066#discussion_r465477814", "createdAt": "2020-08-05T05:15:37Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/SessionAwareZkWriteData.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.apache.helix.zookeeper.zkclient;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * An interface representing data being written to ZK is session aware:\n+ * data is supposed to be written by expected ZK session. If ZkClient's actual session\n+ * doesn't match expected session, data is not written to ZK.\n+ */\n+public interface SessionAwareZkWriteData {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MjcxNQ=="}, "originalCommit": {"oid": "3fb7668c54a9f23ce5ee3862209e4db1efe781be"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjA2NzIwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNzoxMToyMVrOG23Sfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDozMzowMlrOHbo5DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjE0Mg==", "bodyText": "Again, why do we need a default constructor here?", "url": "https://github.com/apache/helix/pull/1066#discussion_r460182142", "createdAt": "2020-07-24T17:11:21Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "diffHunk": "@@ -148,7 +154,12 @@ public String toString() {\n     }\n   }\n \n-  private Stat _stat;\n+  protected Stat _stat;\n+\n+  public HelixProperty() {\n+    _record = DEFAULT_ZNRECORD;\n+    _stat = DEFAULT_STAT;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff3cceaf95fb2f088a6a7f10a355260808352c1f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIwNzIxOQ==", "bodyText": "If we don't have this default constructor, in Message's constructor, we need to call super(ZNRecord). HelixProperty defines ZNRecord but not SessionAwareZNRecord. Then if we want Message's SessionAwareZNRecord, we may override getRecord() to convert ZNRecord to SessionAwareZNRecord:\nOverride\npublic ZNRecord getRecord() {\n  return new SessionAwareZNRecord(_record);\n}\n\nThe problem is this creates a new record from the original one _record. We could not access the original one: message.getRecord().setSimpleField().\nSo we need to create SessionAwareZNRecord in Message's constructor and override parent's ZNRecord. Without the default constructor, we won't be able to do _record = new SessionAwareZNRecord() in Message.", "url": "https://github.com/apache/helix/pull/1066#discussion_r460207219", "createdAt": "2020-07-24T18:01:44Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "diffHunk": "@@ -148,7 +154,12 @@ public String toString() {\n     }\n   }\n \n-  private Stat _stat;\n+  protected Stat _stat;\n+\n+  public HelixProperty() {\n+    _record = DEFAULT_ZNRECORD;\n+    _stat = DEFAULT_STAT;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjE0Mg=="}, "originalCommit": {"oid": "ff3cceaf95fb2f088a6a7f10a355260808352c1f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzIwMw==", "bodyText": "How about do this?\npublic HelixProperty(SessionAwareZNRecord record, String id) {\n_record = record;\n_stat = new Stat(_record.getVersion(), _record.getCreationTime(), _record.getModifiedTime(),\n_record.getEphemeralOwner());\n}", "url": "https://github.com/apache/helix/pull/1066#discussion_r468097203", "createdAt": "2020-08-10T18:29:15Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "diffHunk": "@@ -148,7 +154,12 @@ public String toString() {\n     }\n   }\n \n-  private Stat _stat;\n+  protected Stat _stat;\n+\n+  public HelixProperty() {\n+    _record = DEFAULT_ZNRECORD;\n+    _stat = DEFAULT_STAT;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjE0Mg=="}, "originalCommit": {"oid": "ff3cceaf95fb2f088a6a7f10a355260808352c1f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMjE5NA==", "bodyText": "I know there are multiple options. But how about the one that I mentioned above?", "url": "https://github.com/apache/helix/pull/1066#discussion_r483322194", "createdAt": "2020-09-04T00:31:48Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "diffHunk": "@@ -148,7 +154,12 @@ public String toString() {\n     }\n   }\n \n-  private Stat _stat;\n+  protected Stat _stat;\n+\n+  public HelixProperty() {\n+    _record = DEFAULT_ZNRECORD;\n+    _stat = DEFAULT_STAT;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjE0Mg=="}, "originalCommit": {"oid": "ff3cceaf95fb2f088a6a7f10a355260808352c1f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0MzU2NQ==", "bodyText": "My first impression was these two constructors are kind of similar and it's not really clear that super(SessionAwareZNRecord, id) would 100% call HelixProperty(SessionAwareZNRecord record, String id) but not HelixProperty(ZNRecord record, String id).\nTested. It's working. Good idea. We can still keep the original logic in Message.", "url": "https://github.com/apache/helix/pull/1066#discussion_r498743565", "createdAt": "2020-10-02T10:33:02Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "diffHunk": "@@ -148,7 +154,12 @@ public String toString() {\n     }\n   }\n \n-  private Stat _stat;\n+  protected Stat _stat;\n+\n+  public HelixProperty() {\n+    _record = DEFAULT_ZNRECORD;\n+    _stat = DEFAULT_STAT;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjE0Mg=="}, "originalCommit": {"oid": "ff3cceaf95fb2f088a6a7f10a355260808352c1f"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjExNDcyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNzoyNjoxN1rOG23vyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODozMTowNlrOG25qpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4OTY0Mg==", "bodyText": "Still, if you think this is the name we are using, let us rename isLeader() to isLead(), just make them consistent :).", "url": "https://github.com/apache/helix/pull/1066#discussion_r460189642", "createdAt": "2020-07-24T17:26:17Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -971,19 +972,24 @@ public void addPreConnectCallback(PreConnectCallback callback) {\n \n   @Override\n   public boolean isLeader() {\n+    return getSessionIdIfLead().isPresent();\n+  }\n+\n+  @Override\n+  public Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff3cceaf95fb2f088a6a7f10a355260808352c1f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyMTA5NQ==", "bodyText": "Why we name it getSessionIfLead() is because following if should be an adj., eg. putIfAbsent(), computeIfPresent() etc.. Lead is an adj. Leader is not. So I think from usage, I prefer getSessionIfLead(). isLeader() is also fine I think.", "url": "https://github.com/apache/helix/pull/1066#discussion_r460221095", "createdAt": "2020-07-24T18:31:06Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -971,19 +972,24 @@ public void addPreConnectCallback(PreConnectCallback callback) {\n \n   @Override\n   public boolean isLeader() {\n+    return getSessionIdIfLead().isPresent();\n+  }\n+\n+  @Override\n+  public Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4OTY0Mg=="}, "originalCommit": {"oid": "ff3cceaf95fb2f088a6a7f10a355260808352c1f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjc0MDExOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo1OToyNFrOG71c6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNToxMjowMlrOG76clA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NDkyMw==", "bodyText": "If I understand correctly, the sessionId here can still be stale. eventually, we need sessionaware write of zkclient used by ZkHelixManager to ensure correctness, right?", "url": "https://github.com/apache/helix/pull/1066#discussion_r465394923", "createdAt": "2020-08-04T23:59:24Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +753,20 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    // If manager session changes, no need to run pipeline for the stale event.\n+    Optional<String> eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    String managerSessionId = manager.getSessionId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8bf9ca2984a00f0a385ff603160882f35c9ed4"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NTg3MA==", "bodyText": "I think there are  other event not trigger from ZkClient, such as periodical timer triggered, or onDemandtimer triggered. Do we need special treatment here? or Special treatment when event to controller is constructed?", "url": "https://github.com/apache/helix/pull/1066#discussion_r465395870", "createdAt": "2020-08-05T00:02:20Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +753,20 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    // If manager session changes, no need to run pipeline for the stale event.\n+    Optional<String> eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    String managerSessionId = manager.getSessionId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NDkyMw=="}, "originalCommit": {"oid": "ab8bf9ca2984a00f0a385ff603160882f35c9ed4"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3Njc1Ng==", "bodyText": "@kaisun2000 Here if session id from manager is different from event session -- the session is changed. We check it and stop processing the event or sending messages.\nThe check in Zkclient is the last step. Most of the time this check here will stop the stale session sending messages.\nRegarding other events, each time an event is created, we add the event_session to it. The event session is from cluster manager.\nif (!eventSessionId.isPresent() || !eventSessionId.get().equals(managerSessionId)) { only it's leader and session doesn't change, it continues, otherwise, pipeline is not invoked.", "url": "https://github.com/apache/helix/pull/1066#discussion_r465476756", "createdAt": "2020-08-05T05:12:02Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -757,9 +753,20 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     }\n     event.addAttribute(AttributeName.ControllerDataProvider.name(), dataProvider);\n \n-    logger.info(String.format(\"START: Invoking %s controller pipeline for cluster %s event: %s  %s\",\n-        manager.getClusterName(), dataProvider.getPipelineName(), event.getEventType(),\n-        event.getEventId()));\n+    // If manager session changes, no need to run pipeline for the stale event.\n+    Optional<String> eventSessionId = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    String managerSessionId = manager.getSessionId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NDkyMw=="}, "originalCommit": {"oid": "ab8bf9ca2984a00f0a385ff603160882f35c9ed4"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjc2MzY4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMDoxMTowOFrOG71qUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMzowOToyNFrOHb9sLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5ODM1NA==", "bodyText": "This part is actually debatable? updateControllerState is used to pause or restart paused pipeline. Does it care about session? Can we lose this signal due to session check? How do we reason this one?\nI am not very familiar with this logic. @jiajunwang , @lei-xia, @dasahcc", "url": "https://github.com/apache/helix/pull/1066#discussion_r465398354", "createdAt": "2020-08-05T00:11:08Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1360,6 +1369,8 @@ private boolean updateControllerState(NotificationContext changeContext, PauseSi\n         String uid = UUID.randomUUID().toString().substring(0, 8);\n         ClusterEvent event = new ClusterEvent(_clusterName, ClusterEventType.Resume,\n             String.format(\"%s_%s\", uid, Pipeline.Type.DEFAULT.name()));\n+        event.addAttribute(AttributeName.EVENT_SESSION.name(),\n+            changeContext.getManager().getSessionIdIfLead());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab8bf9ca2984a00f0a385ff603160882f35c9ed4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4NDMzNA==", "bodyText": "@pkuwm , here is the thing. If say when pause signal znode is added, the under old session S0, the event is put into zkclient queue. Then a new session establish for S1, would the controller under S1 for this logic, would not pause of the old event.\nThe question is that can you double check if the new session, controller would get another event of pausing due to controller cache refresh? This is to make sure pause will not be lost immediately followed by a controller change.", "url": "https://github.com/apache/helix/pull/1066#discussion_r499084334", "createdAt": "2020-10-02T23:09:24Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1360,6 +1369,8 @@ private boolean updateControllerState(NotificationContext changeContext, PauseSi\n         String uid = UUID.randomUUID().toString().substring(0, 8);\n         ClusterEvent event = new ClusterEvent(_clusterName, ClusterEventType.Resume,\n             String.format(\"%s_%s\", uid, Pipeline.Type.DEFAULT.name()));\n+        event.addAttribute(AttributeName.EVENT_SESSION.name(),\n+            changeContext.getManager().getSessionIdIfLead());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5ODM1NA=="}, "originalCommit": {"oid": "ab8bf9ca2984a00f0a385ff603160882f35c9ed4"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTE5MjQyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDoyOTowOFrOG9r_ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDozODoxM1rOHbpBrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzA2MQ==", "bodyText": "Let me open another thread for this change. I would like to hear your idea.\nHigh-levelly, the Session Id is tightly bounded with ZK. But what if we have other HelixManager that are not based on ZK? So I am thinking that maybe we should make the session a more generic concept. For the management connection that has a session concept, we implement it and return real session. For the other management connection that does not care about session, we just return a fake constant session so no one needs to try catch on this method.", "url": "https://github.com/apache/helix/pull/1066#discussion_r467337061", "createdAt": "2020-08-08T00:29:08Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxNjIzNw==", "bodyText": "@jiajunwang Thanks for sharing your thought. I think the concept \"fake constant session\" is like an empty Optional object? With Optional, it looks more straightforward and clear than a fake constant session.\nWith a fake constant, we still need an if to check leadership for those storage systems that have leadership. I would say null is kind of this fake constant: if no session concept, then return null. And I think Optional is better than null here.", "url": "https://github.com/apache/helix/pull/1066#discussion_r469416237", "createdAt": "2020-08-12T17:16:21Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzA2MQ=="}, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMjM5Ng==", "bodyText": "Optional is not looking good here.\nIt might be overkill, but how about we define a \"private\" SessionAwareHelixManager interface? Which extends HelixManager but add getSessionIdIfLead() method.", "url": "https://github.com/apache/helix/pull/1066#discussion_r483322396", "createdAt": "2020-09-04T00:32:39Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzA2MQ=="}, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0NTc3Mw==", "bodyText": "I thought about the private interface. My thought is that this private interface will increase more work to identify which places will need this SessionAwareHelixManager and construct it. And it doesn't converge. Eg. if there is only one place that uses the sessionAwareHelixManager and only one place checking the session, it's fine.\nBut if there is mixed usage, we may need to use instaceof to check, which doesn't look nice.", "url": "https://github.com/apache/helix/pull/1066#discussion_r498745773", "createdAt": "2020-10-02T10:38:13Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +420,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code Optional<String>} session ID is present inside the {@code Optional} object\n+   * if the cluster manager is leader. Otherwise, returns an empty {@code Optional} object.\n+   */\n+  default Optional<String> getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzA2MQ=="}, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU5MzE4OnYy", "diffSide": "LEFT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODozMTowN1rOG-acoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMToxMzozNlrOG-gATA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODIwOA==", "bodyText": "Delaying this check might cause confusing and seems not necessary to this PR. Let's don't change it in this PR even if desired.", "url": "https://github.com/apache/helix/pull/1066#discussion_r468098208", "createdAt": "2020-08-10T18:31:07Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -695,12 +697,6 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n         _rebalancerRef.getRebalancer(manager));\n \n-    if (!manager.isLeader()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4OTI2MA==", "bodyText": "Ah good catch. I intended to replace this line with the new one: check leader and get session at the same time. But somehow it goes to later right before invoking pipeline. Resolved.", "url": "https://github.com/apache/helix/pull/1066#discussion_r468189260", "createdAt": "2020-08-10T21:13:36Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -695,12 +697,6 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n         _rebalancerRef.getRebalancer(manager));\n \n-    if (!manager.isLeader()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODIwOA=="}, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDYyNzExOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/AttributeName.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0MTowMlrOG-axGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0MTowMlrOG-axGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMzQ0OA==", "bodyText": "This claim is not related to this field but with the internal logic. Let's just say this is the session that in which we get the event.", "url": "https://github.com/apache/helix/pull/1066#discussion_r468103448", "createdAt": "2020-08-10T18:41:02Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/AttributeName.java", "diffHunk": "@@ -40,5 +40,8 @@\n   PipelineType,\n   LastRebalanceFinishTimeStamp,\n   ControllerDataProvider,\n-  STATEFUL_REBALANCER\n+  STATEFUL_REBALANCER,\n+\n+  /** Event should be processed by the expected session. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDYzMzYzOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/datamodel/SessionAwareZNRecord.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0Mjo1MVrOG-a1Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDo1ODo0MlrOG-fkzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNDQ1NQ==", "bodyText": "Is this one needed?", "url": "https://github.com/apache/helix/pull/1066#discussion_r468104455", "createdAt": "2020-08-10T18:42:51Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/datamodel/SessionAwareZNRecord.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.apache.helix.zookeeper.datamodel;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.codehaus.jackson.annotate.JsonIgnore;\n+\n+/**\n+ * A class represents a session aware ZNRecord: the ZNRecord should be written to zk by\n+ * the expected zk session. When the ZNRecord is being written to zk, if the actual\n+ * zk session id doesn't match the expected zk session id set in the {@code SessionAwareZNRecord},\n+ * writing to zk will fail. It is supposed to be used within Helix only.\n+ * <p>\n+ * If this ZNRecord is not supposed to be written only by the expected zk session,\n+ * {@link ZNRecord} is recommended to use.\n+ */\n+public class SessionAwareZNRecord extends ZNRecord {\n+  @JsonIgnore\n+  private String expectedSessionId;\n+\n+  public SessionAwareZNRecord(String id) {\n+    super(id);\n+  }\n+\n+  public SessionAwareZNRecord(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  public SessionAwareZNRecord(ZNRecord record, String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MjIyMQ==", "bodyText": "Yes in Message constructor:\n  public Message(ZNRecord record, String id) {\n    _record = new SessionAwareZNRecord(record, id);", "url": "https://github.com/apache/helix/pull/1066#discussion_r468182221", "createdAt": "2020-08-10T20:58:42Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/datamodel/SessionAwareZNRecord.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.apache.helix.zookeeper.datamodel;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.codehaus.jackson.annotate.JsonIgnore;\n+\n+/**\n+ * A class represents a session aware ZNRecord: the ZNRecord should be written to zk by\n+ * the expected zk session. When the ZNRecord is being written to zk, if the actual\n+ * zk session id doesn't match the expected zk session id set in the {@code SessionAwareZNRecord},\n+ * writing to zk will fail. It is supposed to be used within Helix only.\n+ * <p>\n+ * If this ZNRecord is not supposed to be written only by the expected zk session,\n+ * {@link ZNRecord} is recommended to use.\n+ */\n+public class SessionAwareZNRecord extends ZNRecord {\n+  @JsonIgnore\n+  private String expectedSessionId;\n+\n+  public SessionAwareZNRecord(String id) {\n+    super(id);\n+  }\n+\n+  public SessionAwareZNRecord(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  public SessionAwareZNRecord(ZNRecord record, String id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNDQ1NQ=="}, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDYzMzk2OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/datamodel/SessionAwareZNRecord.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0Mjo1OFrOG-a1OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzo0NDowM1rOHM63_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNDUwNQ==", "bodyText": "Is this one needed?", "url": "https://github.com/apache/helix/pull/1066#discussion_r468104505", "createdAt": "2020-08-10T18:42:58Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/datamodel/SessionAwareZNRecord.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.apache.helix.zookeeper.datamodel;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.codehaus.jackson.annotate.JsonIgnore;\n+\n+/**\n+ * A class represents a session aware ZNRecord: the ZNRecord should be written to zk by\n+ * the expected zk session. When the ZNRecord is being written to zk, if the actual\n+ * zk session id doesn't match the expected zk session id set in the {@code SessionAwareZNRecord},\n+ * writing to zk will fail. It is supposed to be used within Helix only.\n+ * <p>\n+ * If this ZNRecord is not supposed to be written only by the expected zk session,\n+ * {@link ZNRecord} is recommended to use.\n+ */\n+public class SessionAwareZNRecord extends ZNRecord {\n+  @JsonIgnore\n+  private String expectedSessionId;\n+\n+  public SessionAwareZNRecord(String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MTk0NQ==", "bodyText": "Yes, it is needed in Message constructor:\n    _record = new SessionAwareZNRecord(msgId);", "url": "https://github.com/apache/helix/pull/1066#discussion_r468181945", "createdAt": "2020-08-10T20:58:05Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/datamodel/SessionAwareZNRecord.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.apache.helix.zookeeper.datamodel;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.codehaus.jackson.annotate.JsonIgnore;\n+\n+/**\n+ * A class represents a session aware ZNRecord: the ZNRecord should be written to zk by\n+ * the expected zk session. When the ZNRecord is being written to zk, if the actual\n+ * zk session id doesn't match the expected zk session id set in the {@code SessionAwareZNRecord},\n+ * writing to zk will fail. It is supposed to be used within Helix only.\n+ * <p>\n+ * If this ZNRecord is not supposed to be written only by the expected zk session,\n+ * {@link ZNRecord} is recommended to use.\n+ */\n+public class SessionAwareZNRecord extends ZNRecord {\n+  @JsonIgnore\n+  private String expectedSessionId;\n+\n+  public SessionAwareZNRecord(String id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNDUwNQ=="}, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwOTU2NQ==", "bodyText": "In this case, I guess you don't need public SessionAwareZNRecord(ZNRecord record) {} it can be transformed to SessionAwareZNRecord(record, record.getId()) without much overhead.", "url": "https://github.com/apache/helix/pull/1066#discussion_r483309565", "createdAt": "2020-09-03T23:44:03Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/datamodel/SessionAwareZNRecord.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.apache.helix.zookeeper.datamodel;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.codehaus.jackson.annotate.JsonIgnore;\n+\n+/**\n+ * A class represents a session aware ZNRecord: the ZNRecord should be written to zk by\n+ * the expected zk session. When the ZNRecord is being written to zk, if the actual\n+ * zk session id doesn't match the expected zk session id set in the {@code SessionAwareZNRecord},\n+ * writing to zk will fail. It is supposed to be used within Helix only.\n+ * <p>\n+ * If this ZNRecord is not supposed to be written only by the expected zk session,\n+ * {@link ZNRecord} is recommended to use.\n+ */\n+public class SessionAwareZNRecord extends ZNRecord {\n+  @JsonIgnore\n+  private String expectedSessionId;\n+\n+  public SessionAwareZNRecord(String id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNDUwNQ=="}, "originalCommit": {"oid": "45ab1177113be89d8cb601cc89442d7701fab7cb"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTgxNjk5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzowMDo1N1rOHM6HOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTo0NjozMVrOHbnnyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5NzA4MA==", "bodyText": "How about giving us a break by keeping the existing method with shouldThrowException default to be false?\nSo you have much less changed files.", "url": "https://github.com/apache/helix/pull/1066#discussion_r483297080", "createdAt": "2020-09-03T23:00:57Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -788,14 +788,18 @@ protected void setupInstances(String clusterName, int[] instances) {\n     }\n   }\n \n-  protected void runPipeline(ClusterEvent event, Pipeline pipeline) {\n+  protected void runPipeline(ClusterEvent event, Pipeline pipeline, boolean shouldThrowException)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyMjc2MQ==", "bodyText": "Actually in the first version of the change, the existing method was kept and boolean as false by default. Then we synced and agreed that it is a method in our tests, so we can just directly change it to keep only one single method. So let's keep the changes now.", "url": "https://github.com/apache/helix/pull/1066#discussion_r498722761", "createdAt": "2020-10-02T09:46:31Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -788,14 +788,18 @@ protected void setupInstances(String clusterName, int[] instances) {\n     }\n   }\n \n-  protected void runPipeline(ClusterEvent event, Pipeline pipeline) {\n+  protected void runPipeline(ClusterEvent event, Pipeline pipeline, boolean shouldThrowException)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5NzA4MA=="}, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTg4NDc2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/test/java/org/apache/helix/controller/stages/DummyClusterManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzozNTo0M1rOHM6upg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzozNTo0M1rOHM6upg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNzE3NA==", "bodyText": "Remove it.", "url": "https://github.com/apache/helix/pull/1066#discussion_r483307174", "createdAt": "2020-09-03T23:35:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/controller/stages/DummyClusterManager.java", "diffHunk": "@@ -199,7 +208,7 @@ public String getMetadataStoreConnectionString() {\n   @Override\n   public String getInstanceName() {\n     // TODO Auto-generated method stub", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTkzMTE4OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzo1OTo1M1rOHM7JLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QyMToyOTozMFrOHcDusg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxMzk2NQ==", "bodyText": "How about the sync version of setting data? Maybe also multiOps, which we may start using soon.", "url": "https://github.com/apache/helix/pull/1066#discussion_r483313965", "createdAt": "2020-09-03T23:59:53Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1967,18 +1937,19 @@ public void asyncSetData(final String path, Object datat, final int version,\n           new ZkAsyncCallMonitorContext(_monitor, startT, 0, false), null);\n       return;\n     }\n-    doAsyncSetData(path, data, version, startT, cb);\n+    doAsyncSetData(path, data, version, startT, cb, parseExpectedSessionId(datat));\n   }\n \n   private void doAsyncSetData(final String path, byte[] data, final int version, final long startT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNjAyNg==", "bodyText": "We may do it later if we need the expected session. I'd like to make this diff minimal.", "url": "https://github.com/apache/helix/pull/1066#discussion_r498736026", "createdAt": "2020-10-02T10:15:40Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1967,18 +1937,19 @@ public void asyncSetData(final String path, Object datat, final int version,\n           new ZkAsyncCallMonitorContext(_monitor, startT, 0, false), null);\n       return;\n     }\n-    doAsyncSetData(path, data, version, startT, cb);\n+    doAsyncSetData(path, data, version, startT, cb, parseExpectedSessionId(datat));\n   }\n \n   private void doAsyncSetData(final String path, byte[] data, final int version, final long startT,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxMzk2NQ=="}, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4MzI4Mg==", "bodyText": "We'll track the work in another issue: #1434", "url": "https://github.com/apache/helix/pull/1066#discussion_r499183282", "createdAt": "2020-10-03T21:29:30Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1967,18 +1937,19 @@ public void asyncSetData(final String path, Object datat, final int version,\n           new ZkAsyncCallMonitorContext(_monitor, startT, 0, false), null);\n       return;\n     }\n-    doAsyncSetData(path, data, version, startT, cb);\n+    doAsyncSetData(path, data, version, startT, cb, parseExpectedSessionId(datat));\n   }\n \n   private void doAsyncSetData(final String path, byte[] data, final int version, final long startT,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxMzk2NQ=="}, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTk1NDEwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDoxMzoxNFrOHM7W1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDozMToxNVrOHbo2cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxNzQ2Mw==", "bodyText": "This looks ugly.\nLet's do this,\npublic Message(ZNRecord record, String id) {\n_record = new SessionAwareZNRecord(record, id);\n_stat = new Stat(_record.getVersion(), _record.getCreationTime(), _record.getModifiedTime(),\n_record.getEphemeralOwner());\n}\nThen the other constructors refer to this one.", "url": "https://github.com/apache/helix/pull/1066#discussion_r483317463", "createdAt": "2020-09-04T00:13:14Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "diffHunk": "@@ -937,6 +946,13 @@ private boolean isNullOrEmpty(String data) {\n     return data == null || data.length() == 0 || data.trim().length() == 0;\n   }\n \n+  private void initStat() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0Mjg5OQ==", "bodyText": "Actually the existing code is already messing :(", "url": "https://github.com/apache/helix/pull/1066#discussion_r498742899", "createdAt": "2020-10-02T10:31:15Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "diffHunk": "@@ -937,6 +946,13 @@ private boolean isNullOrEmpty(String data) {\n     return data == null || data.length() == 0 || data.trim().length() == 0;\n   }\n \n+  private void initStat() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxNzQ2Mw=="}, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTk1NTc4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDoxNDoyNVrOHM7X3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDoxNDoyNVrOHM7X3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxNzcyNw==", "bodyText": "This seems not being used, just deprecate it?", "url": "https://github.com/apache/helix/pull/1066#discussion_r483317727", "createdAt": "2020-09-04T00:14:25Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/Message.java", "diffHunk": "@@ -206,10 +194,27 @@ public Message(ZNRecord record, String id) {\n    * @param id unique message identifier\n    */\n   public Message(Message message, String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTk2MTQwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDoxNjo1NlrOHM7a6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTo1Mjo1NVrOHbnzpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxODUwNQ==", "bodyText": "Can we skip the dispatch but continue the pipeline for the other stages?\nI'm not sure, this is a question.", "url": "https://github.com/apache/helix/pull/1066#discussion_r483318505", "createdAt": "2020-09-04T00:16:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +79,17 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller's session changes, then messages should not be sent and pipeline should stop.\n+    Optional<String> expectedSession = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    if (!expectedSession.isPresent() || !expectedSession.get().equals(manager.getSessionId())) {\n+      throw new StageException(String.format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNTc5OQ==", "bodyText": "If we continue, it may cause problems or inconsistency. If the controller loses leadership(session changes), there is no need to keep running the remaining stages. So to be save, throwing an exception stops the pipeline. It'll also save CPU and maybe further ZK writes. I guess the session change case doesn't happen frequently.", "url": "https://github.com/apache/helix/pull/1066#discussion_r498725799", "createdAt": "2020-10-02T09:52:55Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageDispatchStage.java", "diffHunk": "@@ -78,7 +79,17 @@ protected void processEvent(ClusterEvent event, MessageOutput messageOutput) thr\n         batchMessage(dataAccessor.keyBuilder(), messagesToSend, resourceMap, liveInstanceMap,\n             manager.getProperties());\n \n+    // An early check for expected leader session. If the sessions don't match, it means the\n+    // controller's session changes, then messages should not be sent and pipeline should stop.\n+    Optional<String> expectedSession = event.getAttribute(AttributeName.EVENT_SESSION.name());\n+    if (!expectedSession.isPresent() || !expectedSession.get().equals(manager.getSessionId())) {\n+      throw new StageException(String.format(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxODUwNQ=="}, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTk3NDY2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDoyNDo0M1rOHM7iag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTo0OTo1NlrOHbnuRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMDQyNg==", "bodyText": "This is right, but the original logic was, if the manager is not leader, do not run the pipeline. Where is that logic going?", "url": "https://github.com/apache/helix/pull/1066#discussion_r483320426", "createdAt": "2020-09-04T00:24:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -703,9 +705,15 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n         _rebalancerRef.getRebalancer(manager));\n \n-    if (!manager.isLeader()) {\n-      logger.error(\"Cluster manager: \" + manager.getInstanceName() + \" is not leader for \" + manager\n-          .getClusterName() + \". Pipeline will not be invoked\");\n+    // If manager session changes, no need to run pipeline for the stale event.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNDQyMw==", "bodyText": "It's after the comment. The logic is in manager.getSessionIdIfLead() and it is put where the attribute EVENT_SESSION is added.", "url": "https://github.com/apache/helix/pull/1066#discussion_r498724423", "createdAt": "2020-10-02T09:49:56Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -703,9 +705,15 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n         _rebalancerRef.getRebalancer(manager));\n \n-    if (!manager.isLeader()) {\n-      logger.error(\"Cluster manager: \" + manager.getInstanceName() + \" is not leader for \" + manager\n-          .getClusterName() + \". Pipeline will not be invoked\");\n+    // If manager session changes, no need to run pipeline for the stale event.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMDQyNg=="}, "originalCommit": {"oid": "87409eb28dabce4ed8461d29fef60a0c11cefce7"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTU5MjUzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOTo1ODowMlrOHcrqug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMDoyMzoyMFrOHcx_Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgzNzYyNg==", "bodyText": "This means the input record will directly be passed to the field. It breaks the original assumption.\nHow about doing this,\n_record = record instanceof SessionAwareZNRecord? new SessionAwareZNRecord(record, id) : new ZNRecord(record, id);\n_stat = new Stat(_record.getVersion(), _record.getCreationTime(), _record.getModifiedTime(),\n    _record.getEphemeralOwner());", "url": "https://github.com/apache/helix/pull/1066#discussion_r499837626", "createdAt": "2020-10-05T19:58:02Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "diffHunk": "@@ -177,6 +178,15 @@ public HelixProperty(ZNRecord record, String id) {\n         _record.getEphemeralOwner());\n   }\n \n+  /*\n+   * Only used by Message which needs to be session-aware.\n+   */\n+  protected HelixProperty(SessionAwareZNRecord record, String id) {\n+    _record = record;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315ea159a9f6d6ccaaf5315e9bb75980238f17cb"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0MTE4Nw==", "bodyText": "Synced offline. Updated.", "url": "https://github.com/apache/helix/pull/1066#discussion_r499941187", "createdAt": "2020-10-06T00:23:20Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/HelixProperty.java", "diffHunk": "@@ -177,6 +178,15 @@ public HelixProperty(ZNRecord record, String id) {\n         _record.getEphemeralOwner());\n   }\n \n+  /*\n+   * Only used by Message which needs to be session-aware.\n+   */\n+  protected HelixProperty(SessionAwareZNRecord record, String id) {\n+    _record = record;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgzNzYyNg=="}, "originalCommit": {"oid": "315ea159a9f6d6ccaaf5315e9bb75980238f17cb"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDAwOTgzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMjoxOTo1OFrOHcvsgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMjoxOTo1OFrOHcvsgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMzYxNg==", "bodyText": "If you think my previous suggestion about the SessionAwareHelixManager interface is too much, then please still keep the Optional here.", "url": "https://github.com/apache/helix/pull/1066#discussion_r499903616", "createdAt": "2020-10-05T22:19:58Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/HelixManager.java", "diffHunk": "@@ -419,6 +419,17 @@ void addExternalViewChangeListener(org.apache.helix.ExternalViewChangeListener l\n    */\n   Long getSessionStartTime();\n \n+  /**\n+   * Checks whether the cluster manager is leader and returns the session ID associated to the\n+   * connection of cluster data store, if and only if it is leader.\n+   *\n+   * @return {@code String} session ID is a valid string if the cluster manager is leader.\n+   * Otherwise, returns null.\n+   */\n+  default String getSessionIdIfLead() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315ea159a9f6d6ccaaf5315e9bb75980238f17cb"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1134, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}