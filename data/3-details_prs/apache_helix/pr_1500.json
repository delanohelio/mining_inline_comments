{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNzgzOTY1", "number": 1500, "title": "Refine the message handler error handling logic to avoid unnecessary retry.", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nResolve #1488\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis PR enhances the message event processing logic to prevent silent failure and unnecessary retry.\n\nIf creating a message handler fails unexpectedly (meaning there is an Exception), then the message will be marked as UNPROCESSABLE unless the message is sent with a retry count larger than 0. When the retry count is configured, then before the message runs out of the retry count, the participant will keep retrying on any message callbacks.\nThe UNPROCESSABLE message, which is generated due to the previous point, will be left in the participant message folder and not automatically removed. This is to prevent unnecessary retry.\nIf the message handler fails due to the participant cannot schedule the task, then the message will be discarded. If the message is a state transition message, then the corresponding state model and the partition current state will be set to ERROR. This is also to prevent unnecessary retry.\n\nTests\n\n The following tests are written for this issue:\n\nTestHelixTaskExecutor\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[WARNING] Tests run: 1237, Failures: 0, Errors: 0, Skipped: 1\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  02:00 h\n[INFO] Finished at: 2020-10-29T22:59:19-07:00\n[INFO] ------------------------------------------------------------------------\nDocumentation (Optional)\n\nIn case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCommits\n\nMy commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\nMy diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-10-30T06:17:20Z", "url": "https://github.com/apache/helix/pull/1500", "merged": true, "mergeCommit": {"oid": "f11396e5feebe20552d259e553342c17a8573a8e"}, "closed": true, "closedAt": "2020-11-05T17:18:58Z", "author": {"login": "jiajunwang"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXhFpsAFqTUyMDQxMDgxOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZePnYgH2gAyNTEyNzgzOTY1OjYzMDRlZGQzNTAxNTlhYjg1NzNhYzE2NjFmMzM2ZTEzNGJjZWJmMTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNDEwODE4", "url": "https://github.com/apache/helix/pull/1500#pullrequestreview-520410818", "createdAt": "2020-10-30T06:50:31Z", "commit": {"oid": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjo1MDozMlrOHrDERg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjo1MDozMlrOHrDERg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMTA2Mg==", "bodyText": "this is a little confusing. what's wrong with leaving it as readMsgs? updatingMsgs is a confusing name since messages don't update themselves.\nor msgsToBeHandled or msgsToHandle could also be as equally descriptive", "url": "https://github.com/apache/helix/pull/1500#discussion_r514901062", "createdAt": "2020-10-30T06:50:32Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -788,8 +793,8 @@ public void onMessage(String instanceName, List<Message> messages,\n     List<MessageHandler> nonStateTransitionHandlers = new ArrayList<>();\n     List<NotificationContext> nonStateTransitionContexts = new ArrayList<>();\n \n-    // message read\n-    List<Message> readMsgs = new ArrayList<>();\n+    // message to be updated in ZK\n+    List<Message> updatingMsgs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNDExMjMy", "url": "https://github.com/apache/helix/pull/1500#pullrequestreview-520411232", "createdAt": "2020-10-30T06:51:44Z", "commit": {"oid": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjo1MTo0NFrOHrDFfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjo1MTo0NFrOHrDFfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMTM3NA==", "bodyText": "is this log absolutely necessary? wouldn't it be sufficient to log when we've used up all the retry counts? i'm afraid this might just end up polluting the log", "url": "https://github.com/apache/helix/pull/1500#discussion_r514901374", "createdAt": "2020-10-30T06:51:44Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,66 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);\n+        // continue processing in the next section where handler object is double-checked.\n+      }\n+\n+      if (msgHandler == null) {\n+        if (message.getRetryCount() < 0) {\n+          // If no more retry count remains, then mark the message to be UNPROCESSABLE.\n+          String errorMsg = String\n+              .format(\"Message %s has a negative remaining retry count %d. Stop processing it!\",\n+                  message.getMsgId(), message.getRetryCount());\n+          updateUnprocessableMessage(message, null, errorMsg, manager);\n+          updatingMsgs.add(message);\n         } else {\n-          // Need future process non state transition messages by triggering the handler\n-          nonStateTransitionHandlers.add(msgHandler);\n-          nonStateTransitionContexts.add(msgWorkingContext);\n+          // Skip processing this message in this callback. The same message process will be retried\n+          // in the next round.\n+          LOG.warn(\"There is no existing handler for message {}.\"\n+                  + \" Skip processing it for now. Will retry on the next callback.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNDEyMDcw", "url": "https://github.com/apache/helix/pull/1500#pullrequestreview-520412070", "createdAt": "2020-10-30T06:53:52Z", "commit": {"oid": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjo1Mzo1MlrOHrDIAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjo1Mzo1MlrOHrDIAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMjAxOA==", "bodyText": "nit: instead of saying \"negative retry count\", what you really meant is \"this message has been retried for \"retryCount\" times\"\nalso i'd print the msgHandler here. although we could deduce this info from the code, we might want to indicate that msgHandler is null in the log message as well for faster debugging", "url": "https://github.com/apache/helix/pull/1500#discussion_r514902018", "createdAt": "2020-10-30T06:53:52Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,66 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);\n+        // continue processing in the next section where handler object is double-checked.\n+      }\n+\n+      if (msgHandler == null) {\n+        if (message.getRetryCount() < 0) {\n+          // If no more retry count remains, then mark the message to be UNPROCESSABLE.\n+          String errorMsg = String\n+              .format(\"Message %s has a negative remaining retry count %d. Stop processing it!\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNDE2MDM1", "url": "https://github.com/apache/helix/pull/1500#pullrequestreview-520416035", "createdAt": "2020-10-30T07:04:33Z", "commit": {"oid": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzowNDozM1rOHrDUVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzowNDozM1rOHrDUVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwNTE3Mg==", "bodyText": "are we writing this back to zk or is this for in-memory use only? if we're writing back, would that be an added amount of zk writes/updates that we should worry about?\nshould be possible to track remaining retry counts purely in-memory per cached message using message id.", "url": "https://github.com/apache/helix/pull/1500#discussion_r514905172", "createdAt": "2020-10-30T07:04:33Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,66 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODAyMTkw", "url": "https://github.com/apache/helix/pull/1500#pullrequestreview-522802190", "createdAt": "2020-11-03T19:13:48Z", "commit": {"oid": "326bd7129fee4ed5020c62f0590f03ebdb19bd26"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToxMzo0OFrOHs87eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyNzowM1rOHs9W5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NzY1OA==", "bodyText": "Seems even there is no exception, you will still set the message as unprocessable after retry instead of leaving it as NEW?", "url": "https://github.com/apache/helix/pull/1500#discussion_r516897658", "createdAt": "2020-11-03T19:13:48Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,67 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);\n+        // continue processing in the next section where handler object is double-checked.\n+      }\n+\n+      if (msgHandler == null) {\n+        if (message.getRetryCount() < 0) {\n+          // If no more retry count remains, then mark the message to be UNPROCESSABLE.\n+          String errorMsg = String\n+              .format(\"No available message Handler found!\"\n+                      + \" Stop processing message %s since it has a negative remaining retry count %d!\",\n+                  message.getMsgId(), message.getRetryCount());\n+          updateUnprocessableMessage(message, null, errorMsg, manager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326bd7129fee4ed5020c62f0590f03ebdb19bd26"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5OTc2NQ==", "bodyText": "I don't quite understand why we swallow exception here. This exception means user's reset has an issue, and can we just let the error go?", "url": "https://github.com/apache/helix/pull/1500#discussion_r516899765", "createdAt": "2020-11-03T19:17:42Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -613,7 +613,12 @@ void reset() {\n \n       MsgHandlerFactoryRegistryItem item = _hdlrFtyRegistry.get(msgType);\n       if (item.factory() != null) {\n-        item.factory().reset();\n+        try {\n+          item.factory().reset();\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326bd7129fee4ed5020c62f0590f03ebdb19bd26"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNDY3OA==", "bodyText": "I think we changed the original behavior, and never remove messages in this case. There is a mismatch in the comment. But, is this what we would like to do? not removing duplicated message, but only mark it? Seems we leave many unnecessary messages on ZK.", "url": "https://github.com/apache/helix/pull/1500#discussion_r516904678", "createdAt": "2020-11-03T19:27:03Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -993,67 +1034,78 @@ private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n    * Preprocess the state transition message to validate if the request is valid.\n    * If no operation needs to be triggered, discard the the message.\n    * @param message\n-   * @param instanceName\n    * @param manager\n    * @param stateTransitionHandlers\n    * @param createHandler\n    * @return True if the requested state transition is valid, and need to schedule the transition.\n    *         False if no more operation is required.\n    */\n-  private boolean validateAndProcessStateTransitionMessage(Message message, String instanceName,\n-      HelixManager manager, Map<String, MessageHandler> stateTransitionHandlers,\n-      MessageHandler createHandler) {\n-    HelixDataAccessor accessor = manager.getHelixDataAccessor();\n-\n+  private boolean validateAndProcessStateTransitionMessage(Message message, HelixManager manager,\n+      Map<String, MessageHandler> stateTransitionHandlers, MessageHandler createHandler) {\n     String messageTarget = getMessageTarget(message.getResourceName(), message.getPartitionName());\n-    if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n-        && isStateTransitionInProgress(messageTarget)) {\n-      String taskId = _messageTaskMap.get(messageTarget);\n-      Message msg = _taskMap.get(taskId).getTask().getMessage();\n-      // If there is another state transition for same partition is going on,\n-      // discard the message. Controller will resend if this is a valid message\n-      String errMsg = String.format(\n-          \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n-          message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n-          msg.isRelayMessage(), msg.getReadTimeStamp(), System.currentTimeMillis(),\n-          message.getFromState(), message.getToState());\n-      handleUnprocessableMessage(message, null /* exception */, errMsg, accessor, instanceName,\n-          manager);\n-      return false;\n-    }\n-    if (createHandler instanceof HelixStateTransitionHandler) {\n-      // We only check to state if there is no ST task scheduled/executing.\n-      HelixStateTransitionHandler.StaleMessageValidateResult result =\n-          ((HelixStateTransitionHandler) createHandler).staleMessageValidator();\n-      if (!result.isValid) {\n-        handleUnprocessableMessage(message, null /* exception */, result.exception.getMessage(),\n-            accessor, instanceName, manager);\n+\n+    try {\n+      if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n+          && isStateTransitionInProgress(messageTarget)) {\n+        String taskId = _messageTaskMap.get(messageTarget);\n+        Message msg = _taskMap.get(taskId).getTask().getMessage();\n+        // If there is another state transition for same partition is going on,\n+        // discard the message. Controller will resend if this is a valid message\n+        String errMsg = String.format(\n+            \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n+            message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n+            msg.isRelayMessage(), msg.getReadTimeStamp(), System.currentTimeMillis(),\n+            message.getFromState(), message.getToState());\n+        updateUnprocessableMessage(message, null /* exception */, errMsg, manager);\n         return false;\n       }\n-    }\n-    if (stateTransitionHandlers.containsKey(messageTarget)) {\n-      // If there are 2 messages in same batch about same partition's state transition,\n-      // the later one is discarded\n-      Message duplicatedMessage = stateTransitionHandlers.get(messageTarget)._message;\n-      String errMsg = String.format(\n-          \"Duplicated state transition message: %s. Existing: %s->%s; New (Discarded): %s->%s\",\n-          message.getMsgId(), duplicatedMessage.getFromState(), duplicatedMessage.getToState(),\n-          message.getFromState(), message.getToState());\n-      handleUnprocessableMessage(message, null /* exception */, errMsg, accessor, instanceName,\n+      if (createHandler instanceof HelixStateTransitionHandler) {\n+        // We only check to state if there is no ST task scheduled/executing.\n+        HelixStateTransitionHandler.StaleMessageValidateResult result =\n+            ((HelixStateTransitionHandler) createHandler).staleMessageValidator();\n+        if (!result.isValid) {\n+          updateUnprocessableMessage(message, null /* exception */, result.exception.getMessage(),\n+              manager);\n+          return false;\n+        }\n+      }\n+      if (stateTransitionHandlers.containsKey(messageTarget)) {\n+        // If there are 2 messages in same batch about same partition's state transition,\n+        // the later one is discarded\n+        Message duplicatedMessage = stateTransitionHandlers.get(messageTarget)._message;\n+        String errMsg = String.format(\n+            \"Duplicated state transition message: %s. Existing: %s->%s; New (Discarded): %s->%s\",\n+            message.getMsgId(), duplicatedMessage.getFromState(), duplicatedMessage.getToState(),\n+            message.getFromState(), message.getToState());\n+        updateUnprocessableMessage(message, null /* exception */, errMsg, manager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "326bd7129fee4ed5020c62f0590f03ebdb19bd26"}, "originalPosition": 253}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56d2e229fe0acd883d0f18a2c1433de4b6af6127", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/56d2e229fe0acd883d0f18a2c1433de4b6af6127", "committedDate": "2020-11-04T05:53:24Z", "message": "Refine the message handler error handling logic to avoid unnecessary retry."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bec10b0136089416a4ec0cca67e3bc81982fddd9", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/bec10b0136089416a4ec0cca67e3bc81982fddd9", "committedDate": "2020-11-04T05:53:24Z", "message": "Address comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "352d4408f4b72838ee62694df75031bc4f63c03b", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/352d4408f4b72838ee62694df75031bc4f63c03b", "committedDate": "2020-11-04T05:53:24Z", "message": "Address more comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "927507d0071156181f030393f51d7b7e5214791a", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/927507d0071156181f030393f51d7b7e5214791a", "committedDate": "2020-11-03T22:32:49Z", "message": "Address more comments."}, "afterCommit": {"oid": "352d4408f4b72838ee62694df75031bc4f63c03b", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/352d4408f4b72838ee62694df75031bc4f63c03b", "committedDate": "2020-11-04T05:53:24Z", "message": "Address more comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjQ3NDIz", "url": "https://github.com/apache/helix/pull/1500#pullrequestreview-523647423", "createdAt": "2020-11-04T18:55:01Z", "commit": {"oid": "352d4408f4b72838ee62694df75031bc4f63c03b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxODo1NTowMVrOHtlgAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxOTowMzoxMFrOHtlyOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjM2OQ==", "bodyText": "NIT: From the retry count definition, we should let retry count check happens before you try another round of creation. If retry count is less than 0, it means it has one more retry than what we defined for the retry count. I know this could be a minor issue. But logically, it breaks the counting rule. Better to reorganize it.", "url": "https://github.com/apache/helix/pull/1500#discussion_r517562369", "createdAt": "2020-11-04T18:55:01Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,67 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);\n+        // continue processing in the next section where handler object is double-checked.\n+      }\n+\n+      if (msgHandler == null) {\n+        if (message.getRetryCount() < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "352d4408f4b72838ee62694df75031bc4f63c03b"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2NzAzNA==", "bodyText": "This changes the behavior. If the message is not exact state we are targeting, it should be a intermediate state, we should throw away this message instead of let it hanging there. Otherwise, we will face a lot of human involved operations.\nFor example, for the p2p arrived but timedout, the message will be discarded. But if you hang it as unprocessable, the partition will be stuck.", "url": "https://github.com/apache/helix/pull/1500#discussion_r517567034", "createdAt": "2020-11-04T19:03:10Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -993,67 +1034,78 @@ private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n    * Preprocess the state transition message to validate if the request is valid.\n    * If no operation needs to be triggered, discard the the message.\n    * @param message\n-   * @param instanceName\n    * @param manager\n    * @param stateTransitionHandlers\n    * @param createHandler\n    * @return True if the requested state transition is valid, and need to schedule the transition.\n    *         False if no more operation is required.\n    */\n-  private boolean validateAndProcessStateTransitionMessage(Message message, String instanceName,\n-      HelixManager manager, Map<String, MessageHandler> stateTransitionHandlers,\n-      MessageHandler createHandler) {\n-    HelixDataAccessor accessor = manager.getHelixDataAccessor();\n-\n+  private boolean validateAndProcessStateTransitionMessage(Message message, HelixManager manager,\n+      Map<String, MessageHandler> stateTransitionHandlers, MessageHandler createHandler) {\n     String messageTarget = getMessageTarget(message.getResourceName(), message.getPartitionName());\n-    if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n-        && isStateTransitionInProgress(messageTarget)) {\n-      String taskId = _messageTaskMap.get(messageTarget);\n-      Message msg = _taskMap.get(taskId).getTask().getMessage();\n-      // If there is another state transition for same partition is going on,\n-      // discard the message. Controller will resend if this is a valid message\n-      String errMsg = String.format(\n-          \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n-          message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n-          msg.isRelayMessage(), msg.getReadTimeStamp(), System.currentTimeMillis(),\n-          message.getFromState(), message.getToState());\n-      handleUnprocessableMessage(message, null /* exception */, errMsg, accessor, instanceName,\n-          manager);\n-      return false;\n-    }\n-    if (createHandler instanceof HelixStateTransitionHandler) {\n-      // We only check to state if there is no ST task scheduled/executing.\n-      HelixStateTransitionHandler.StaleMessageValidateResult result =\n-          ((HelixStateTransitionHandler) createHandler).staleMessageValidator();\n-      if (!result.isValid) {\n-        handleUnprocessableMessage(message, null /* exception */, result.exception.getMessage(),\n-            accessor, instanceName, manager);\n+\n+    try {\n+      if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n+          && isStateTransitionInProgress(messageTarget)) {\n+        String taskId = _messageTaskMap.get(messageTarget);\n+        Message msg = _taskMap.get(taskId).getTask().getMessage();\n+        // If there is another state transition for same partition is going on,\n+        // discard the message. Controller will resend if this is a valid message\n+        String errMsg = String.format(\n+            \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n+            message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n+            msg.isRelayMessage(), msg.getReadTimeStamp(), System.currentTimeMillis(),\n+            message.getFromState(), message.getToState());\n+        updateUnprocessableMessage(message, null /* exception */, errMsg, manager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "352d4408f4b72838ee62694df75031bc4f63c03b"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzOTA0MjA4", "url": "https://github.com/apache/helix/pull/1500#pullrequestreview-523904208", "createdAt": "2020-11-05T03:40:19Z", "commit": {"oid": "352d4408f4b72838ee62694df75031bc4f63c03b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6304edd350159ab8573ac1661f336e134bcebf14", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/6304edd350159ab8573ac1661f336e134bcebf14", "committedDate": "2020-11-05T08:39:33Z", "message": "Address final comment."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4395, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}