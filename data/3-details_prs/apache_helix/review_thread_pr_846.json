{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNjk4NjU0", "number": 846, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo0MzoyMVrODk8Hgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNTowNDowNlrODnVYrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDYwMjkxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo0MzoyMVrOFxiupw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo1MTo1OVrOFxi7Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5MzU0Mw==", "bodyText": "The new ConfigAccessor should be created with a Builder. I'm going to assume that this is just a placeholder? :)", "url": "https://github.com/apache/helix/pull/846#discussion_r387493543", "createdAt": "2020-03-04T07:43:21Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -118,6 +118,11 @@ public ConfigAccessor(HelixZkClient zkClient) {\n     _usesExternalZkClient = true;\n   }\n \n+  public ConfigAccessor(RealmAwareZkClient zkClient) {\n+    _zkClient = zkClient;\n+    _usesExternalZkClient = true;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039f735ce85ffc5f3e0af10a3a9109547f7cbfb3"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5Njc0Ng==", "bodyText": "On a second thought, I forgot to add this constructor. I'll go ahead and work on that as well.", "url": "https://github.com/apache/helix/pull/846#discussion_r387496746", "createdAt": "2020-03-04T07:51:59Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -118,6 +118,11 @@ public ConfigAccessor(HelixZkClient zkClient) {\n     _usesExternalZkClient = true;\n   }\n \n+  public ConfigAccessor(RealmAwareZkClient zkClient) {\n+    _zkClient = zkClient;\n+    _usesExternalZkClient = true;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5MzU0Mw=="}, "originalCommit": {"oid": "039f735ce85ffc5f3e0af10a3a9109547f7cbfb3"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDYxMDU2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo0Njo1OFrOFxiztg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo0Njo1OFrOFxiztg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5NDgzOA==", "bodyText": "We should use a Builder pattern for HelixAdmin here. This is because we need to allow users to provide connection and client configs.\nFor example, users should be able to set operationRetry time. If we just provide a constructor that doesn't take in any parameters, it won't be very flexible.\n#819 for a reference.", "url": "https://github.com/apache/helix/pull/846#discussion_r387494838", "createdAt": "2020-03-04T07:46:58Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -89,33 +91,55 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   private final ConfigAccessor _configAccessor;\n   // true if ZKHelixAdmin was instantiated with a HelixZkClient, false otherwise\n   // This is used for close() to determine how ZKHelixAdmin should close the underlying ZkClient\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n \n-  @Deprecated\n-  public ZKHelixAdmin(HelixZkClient zkClient) {\n+  public ZKHelixAdmin() {\n+    _zkClient = new FederatedZkClient();\n+    _configAccessor = new ConfigAccessor(_zkClient);\n+    _usesExternalZkClient = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039f735ce85ffc5f3e0af10a3a9109547f7cbfb3"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDYyMTEyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo1MToyNVrOFxi6Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo1MToyNVrOFxi6Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5NjQ5OQ==", "bodyText": "I just realized I forgot to add this logic for ConfigAccessor. Let me open another PR :)", "url": "https://github.com/apache/helix/pull/846#discussion_r387496499", "createdAt": "2020-03-04T07:51:25Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -89,33 +91,55 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   private final ConfigAccessor _configAccessor;\n   // true if ZKHelixAdmin was instantiated with a HelixZkClient, false otherwise\n   // This is used for close() to determine how ZKHelixAdmin should close the underlying ZkClient\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n \n-  @Deprecated\n-  public ZKHelixAdmin(HelixZkClient zkClient) {\n+  public ZKHelixAdmin() {\n+    _zkClient = new FederatedZkClient();\n+    _configAccessor = new ConfigAccessor(_zkClient);\n+    _usesExternalZkClient = false;\n+  }\n+\n+  public ZKHelixAdmin(RealmAwareZkClient zkClient) {\n     _zkClient = zkClient;\n     _configAccessor = new ConfigAccessor(zkClient);\n     _usesExternalZkClient = true;\n   }\n \n   public ZKHelixAdmin(String zkAddress) {\n     int timeOutInSec = Integer.parseInt(System.getProperty(CONNECTION_TIMEOUT, \"30\"));\n-    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-    clientConfig.setZkSerializer(new ZNRecordSerializer())\n-        .setConnectInitTimeout(timeOutInSec * 1000);\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-    _zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039f735ce85ffc5f3e0af10a3a9109547f7cbfb3"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDYzMjk3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo1NjoxOFrOFxjBVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTowNjowMFrOFygLgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5ODMyNA==", "bodyText": "Do you think we could refactor these two methods to reduce duplicate logic? You could take in the factory in the parameter and switch back and forth between dedicated and shared that way.", "url": "https://github.com/apache/helix/pull/846#discussion_r387498324", "createdAt": "2020-03-04T07:56:18Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1264,87 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    RealmAwareZkClient newClient;\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      newClient = buildSharedZkClient(connectionConfig, clientConfig);\n+    } else {\n+      newClient = buildDedicatedZkClient(connectionConfig, clientConfig);\n+    }\n+\n+    return newClient;\n+  }\n+\n+  private RealmAwareZkClient buildSharedZkClient(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    RealmAwareZkClient zkClient;\n+    // TODO: change exception type\n+    try {\n+      zkClient =\n+          SharedZkClientFactory.getInstance().buildZkClient(connectionConfig, clientConfig);\n+    } catch (IllegalArgumentException e) {\n+      LOG.warn(\"Not able to build realm-aware shared ZK client for sharding key: {}, caused by: {}\"\n+              + \" Fallback to HelixZkClient.\", connectionConfig.getZkRealmShardingKey(),\n+          e.getMessage());\n+\n+      // Fallback to HelixZkClient\n+      HelixZkClient.ZkConnectionConfig helixZkConnectionConfig =\n+          new HelixZkClient.ZkConnectionConfig(_zkAddress);\n+      helixZkConnectionConfig.setSessionTimeout(connectionConfig.getSessionTimeout());\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(helixZkConnectionConfig, clientConfig.createHelixZkClientConfig());\n+    }\n+\n+    return zkClient;\n+  }\n+\n+  private RealmAwareZkClient buildDedicatedZkClient(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    RealmAwareZkClient zkClient;\n+    // TODO: change exception type\n+    try {\n+      zkClient =\n+          DedicatedZkClientFactory.getInstance().buildZkClient(connectionConfig, clientConfig);\n+    } catch (IllegalArgumentException e) {\n+      LOG.warn(\"Not able to build realm-aware Dedicated ZK client for sharding key: {}, caused by: {}\"\n+              + \" Fallback to HelixZkClient.\", connectionConfig.getZkRealmShardingKey(),\n+          e.getMessage());\n+\n+      // Fallback to HelixZkClient\n+      HelixZkClient.ZkConnectionConfig helixZkConnectionConfig =\n+          new HelixZkClient.ZkConnectionConfig(_zkAddress);\n+      helixZkConnectionConfig.setSessionTimeout(connectionConfig.getSessionTimeout());\n+      zkClient = DedicatedZkClientFactory.getInstance()\n+          .buildZkClient(helixZkConnectionConfig, clientConfig.createHelixZkClientConfig());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039f735ce85ffc5f3e0af10a3a9109547f7cbfb3"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwMDM1Mg==", "bodyText": "I tried. We have 2 options:\n\n\nAs you said, we can pass in the factory as a parameter. But we have to make HelixZkClientFactory public. Shall we do this?\npublic abstract class HelixZkClientFactory implements RealmAwareZkClientFactory\n\n\nIt is the implemented as I do. KeepHelixZkClientFactory as it is. I prefer this considering that we don't want HelixZkClientFactory public.", "url": "https://github.com/apache/helix/pull/846#discussion_r388500352", "createdAt": "2020-03-05T19:06:00Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1264,87 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    RealmAwareZkClient newClient;\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      newClient = buildSharedZkClient(connectionConfig, clientConfig);\n+    } else {\n+      newClient = buildDedicatedZkClient(connectionConfig, clientConfig);\n+    }\n+\n+    return newClient;\n+  }\n+\n+  private RealmAwareZkClient buildSharedZkClient(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    RealmAwareZkClient zkClient;\n+    // TODO: change exception type\n+    try {\n+      zkClient =\n+          SharedZkClientFactory.getInstance().buildZkClient(connectionConfig, clientConfig);\n+    } catch (IllegalArgumentException e) {\n+      LOG.warn(\"Not able to build realm-aware shared ZK client for sharding key: {}, caused by: {}\"\n+              + \" Fallback to HelixZkClient.\", connectionConfig.getZkRealmShardingKey(),\n+          e.getMessage());\n+\n+      // Fallback to HelixZkClient\n+      HelixZkClient.ZkConnectionConfig helixZkConnectionConfig =\n+          new HelixZkClient.ZkConnectionConfig(_zkAddress);\n+      helixZkConnectionConfig.setSessionTimeout(connectionConfig.getSessionTimeout());\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(helixZkConnectionConfig, clientConfig.createHelixZkClientConfig());\n+    }\n+\n+    return zkClient;\n+  }\n+\n+  private RealmAwareZkClient buildDedicatedZkClient(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    RealmAwareZkClient zkClient;\n+    // TODO: change exception type\n+    try {\n+      zkClient =\n+          DedicatedZkClientFactory.getInstance().buildZkClient(connectionConfig, clientConfig);\n+    } catch (IllegalArgumentException e) {\n+      LOG.warn(\"Not able to build realm-aware Dedicated ZK client for sharding key: {}, caused by: {}\"\n+              + \" Fallback to HelixZkClient.\", connectionConfig.getZkRealmShardingKey(),\n+          e.getMessage());\n+\n+      // Fallback to HelixZkClient\n+      HelixZkClient.ZkConnectionConfig helixZkConnectionConfig =\n+          new HelixZkClient.ZkConnectionConfig(_zkAddress);\n+      helixZkConnectionConfig.setSessionTimeout(connectionConfig.getSessionTimeout());\n+      zkClient = DedicatedZkClientFactory.getInstance()\n+          .buildZkClient(helixZkConnectionConfig, clientConfig.createHelixZkClientConfig());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5ODMyNA=="}, "originalCommit": {"oid": "039f735ce85ffc5f3e0af10a3a9109547f7cbfb3"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDY0MDg0OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo1OToxNFrOFxjFyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNzo1OToxNFrOFxjFyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5OTQ2Nw==", "bodyText": "FederatedZkClient should take in connectionConfig and clientConfig. I'll just assume this is a placeholder.", "url": "https://github.com/apache/helix/pull/846#discussion_r387499467", "createdAt": "2020-03-04T07:59:14Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -79,7 +83,31 @@\n   private volatile boolean _isClosed;\n   private PathBasedZkSerializer _pathBasedZkSerializer;\n \n+  public FederatedZkClient() {\n+    this(new RealmAwareZkClient.RealmAwareZkClientConfig()\n+        .setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n   // TODO: support capacity of ZkClient number in one FederatedZkClient and do garbage collection.\n+  public FederatedZkClient(RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039f735ce85ffc5f3e0af10a3a9109547f7cbfb3"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzk3OTc4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMToyNzoxNlrOFyDi1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTowNjowNlrOFygLtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAzMTE5MQ==", "bodyText": "Is it possible to combine buildSharedZkClient and buildDedicatedZkClient to reduce duplication? Both instances of the factories extend HelixZkClientFactory.", "url": "https://github.com/apache/helix/pull/846#discussion_r388031191", "createdAt": "2020-03-05T01:27:16Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,85 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    RealmAwareZkClient newClient;\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      newClient = buildSharedZkClient(connectionConfig, clientConfig);\n+    } else {\n+      newClient = buildDedicatedZkClient(connectionConfig, clientConfig);\n+    }\n+\n+    return newClient;\n+  }\n+\n+  private RealmAwareZkClient buildSharedZkClient(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29386bf1c066a36b47fa50ad75cf8e31f907e9a2"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwMDQwNQ==", "bodyText": "I tried. We have 2 options:\n\n\nAs you said, we can pass in the factory as a parameter. But we have to make HelixZkClientFactory public. Shall we do this?\npublic abstract class HelixZkClientFactory implements RealmAwareZkClientFactory\n\n\nIt is the implemented as I do. KeepHelixZkClientFactory as it is. I prefer this considering that we don't want HelixZkClientFactory public.", "url": "https://github.com/apache/helix/pull/846#discussion_r388500405", "createdAt": "2020-03-05T19:06:06Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,85 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    RealmAwareZkClient newClient;\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      newClient = buildSharedZkClient(connectionConfig, clientConfig);\n+    } else {\n+      newClient = buildDedicatedZkClient(connectionConfig, clientConfig);\n+    }\n+\n+    return newClient;\n+  }\n+\n+  private RealmAwareZkClient buildSharedZkClient(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAzMTE5MQ=="}, "originalCommit": {"oid": "29386bf1c066a36b47fa50ad75cf8e31f907e9a2"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzk4MTM0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMToyODoxNVrOFyDj4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMToyODoxNVrOFyDj4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAzMTQ1OQ==", "bodyText": "Nit: not much point declaring SLASH if it's character counter-part is a local variable.", "url": "https://github.com/apache/helix/pull/846#discussion_r388031459", "createdAt": "2020-03-05T01:28:15Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,85 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    RealmAwareZkClient newClient;\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      newClient = buildSharedZkClient(connectionConfig, clientConfig);\n+    } else {\n+      newClient = buildDedicatedZkClient(connectionConfig, clientConfig);\n+    }\n+\n+    return newClient;\n+  }\n+\n+  private RealmAwareZkClient buildSharedZkClient(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient =\n+          SharedZkClientFactory.getInstance().buildZkClient(connectionConfig, clientConfig);\n+    } catch (IllegalArgumentException | IOException | InvalidRoutingDataException e) {\n+      LOG.warn(\"Not able to build realm-aware shared ZK client for sharding key: {}, caused by: {}\"\n+              + \" Fallback to HelixZkClient.\", connectionConfig.getZkRealmShardingKey(),\n+          e.getMessage());\n+\n+      // Fallback to HelixZkClient\n+      HelixZkClient.ZkConnectionConfig helixZkConnectionConfig =\n+          new HelixZkClient.ZkConnectionConfig(_zkAddress);\n+      helixZkConnectionConfig.setSessionTimeout(connectionConfig.getSessionTimeout());\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(helixZkConnectionConfig, clientConfig.createHelixZkClientConfig());\n+    }\n+\n+    return zkClient;\n+  }\n+\n+  private RealmAwareZkClient buildDedicatedZkClient(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient =\n+          DedicatedZkClientFactory.getInstance().buildZkClient(connectionConfig, clientConfig);\n+    } catch (IllegalArgumentException | IOException | InvalidRoutingDataException e) {\n+      LOG.warn(\"Not able to build realm-aware Dedicated ZK client for sharding key: {}, caused by: {}\"\n+              + \" Fall back to HelixZkClient.\", connectionConfig.getZkRealmShardingKey(),\n+          e.getMessage());\n+\n+      // Fallback to HelixZkClient\n+      HelixZkClient.ZkConnectionConfig helixZkConnectionConfig =\n+          new HelixZkClient.ZkConnectionConfig(_zkAddress);\n+      helixZkConnectionConfig.setSessionTimeout(connectionConfig.getSessionTimeout());\n+      zkClient = DedicatedZkClientFactory.getInstance()\n+          .buildZkClient(helixZkConnectionConfig, clientConfig.createHelixZkClientConfig());\n+    }\n+\n+    return zkClient;\n+  }\n+\n+  private String buildShardingKey() {\n+    return _clusterName.charAt(0) == '/' ? _clusterName : SLASH + _clusterName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29386bf1c066a36b47fa50ad75cf8e31f907e9a2"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzA1MjIxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToyODozOFrOFyg_dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDo0NDo1MlrOFyjftA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMzY1NQ==", "bodyText": "Why is the constructor throwing all sorts of exceptions? As we discussed, this is where we catch checked exceptions.", "url": "https://github.com/apache/helix/pull/846#discussion_r388513655", "createdAt": "2020-03-05T19:28:38Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -89,33 +91,77 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   private final ConfigAccessor _configAccessor;\n-  // true if ZKHelixAdmin was instantiated with a HelixZkClient, false otherwise\n+  // true if ZKHelixAdmin was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZKHelixAdmin should close the underlying ZkClient\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZKHelixAdmin(HelixZkClient zkClient) {\n+  public ZKHelixAdmin(RealmAwareZkClient zkClient) {\n     _zkClient = zkClient;\n     _configAccessor = new ConfigAccessor(zkClient);\n     _usesExternalZkClient = true;\n   }\n \n   public ZKHelixAdmin(String zkAddress) {\n     int timeOutInSec = Integer.parseInt(System.getProperty(CONNECTION_TIMEOUT, \"30\"));\n-    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-    clientConfig.setZkSerializer(new ZNRecordSerializer())\n-        .setConnectInitTimeout(timeOutInSec * 1000);\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-    _zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig()\n+            .setConnectInitTimeout(timeOutInSec * 1000L)\n+            .setZkSerializer(new ZNRecordSerializer());\n+\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      LOG.info(\"Not able to connect on multi-realm mode. \"\n+          + \"Connecting on single-realm mode to ZK: {}\", zkAddress);\n+\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+              clientConfig.createHelixZkClientConfig());\n+      zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    }\n+\n+    _zkClient = zkClient;\n+    _configAccessor = new ConfigAccessor(_zkClient);\n+    _usesExternalZkClient = false;\n+  }\n+\n+  private ZKHelixAdmin(Builder builder) throws IOException, InvalidRoutingDataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca0e0cba1b7bbc223053d333c3e3033b50d3a703"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1NDY3Ng==", "bodyText": "I followed ConfigAccessor to make it consistent. If ConfigAccessor  is not a special case, we may also need to change it?\n  private ConfigAccessor(Builder builder) throws IOException, InvalidRoutingDataException {", "url": "https://github.com/apache/helix/pull/846#discussion_r388554676", "createdAt": "2020-03-05T20:44:52Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -89,33 +91,77 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   private final ConfigAccessor _configAccessor;\n-  // true if ZKHelixAdmin was instantiated with a HelixZkClient, false otherwise\n+  // true if ZKHelixAdmin was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZKHelixAdmin should close the underlying ZkClient\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZKHelixAdmin(HelixZkClient zkClient) {\n+  public ZKHelixAdmin(RealmAwareZkClient zkClient) {\n     _zkClient = zkClient;\n     _configAccessor = new ConfigAccessor(zkClient);\n     _usesExternalZkClient = true;\n   }\n \n   public ZKHelixAdmin(String zkAddress) {\n     int timeOutInSec = Integer.parseInt(System.getProperty(CONNECTION_TIMEOUT, \"30\"));\n-    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-    clientConfig.setZkSerializer(new ZNRecordSerializer())\n-        .setConnectInitTimeout(timeOutInSec * 1000);\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-    _zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig()\n+            .setConnectInitTimeout(timeOutInSec * 1000L)\n+            .setZkSerializer(new ZNRecordSerializer());\n+\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      LOG.info(\"Not able to connect on multi-realm mode. \"\n+          + \"Connecting on single-realm mode to ZK: {}\", zkAddress);\n+\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+              clientConfig.createHelixZkClientConfig());\n+      zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    }\n+\n+    _zkClient = zkClient;\n+    _configAccessor = new ConfigAccessor(_zkClient);\n+    _usesExternalZkClient = false;\n+  }\n+\n+  private ZKHelixAdmin(Builder builder) throws IOException, InvalidRoutingDataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMzY1NQ=="}, "originalCommit": {"oid": "ca0e0cba1b7bbc223053d333c3e3033b50d3a703"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzA1MzE0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToyODo1NFrOFyhADQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjozNjowOVrOFyrcNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMzgwNQ==", "bodyText": "This should be a try-catch.", "url": "https://github.com/apache/helix/pull/846#discussion_r388513805", "createdAt": "2020-03-05T19:28:54Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -89,33 +91,77 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   private final ConfigAccessor _configAccessor;\n-  // true if ZKHelixAdmin was instantiated with a HelixZkClient, false otherwise\n+  // true if ZKHelixAdmin was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZKHelixAdmin should close the underlying ZkClient\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZKHelixAdmin(HelixZkClient zkClient) {\n+  public ZKHelixAdmin(RealmAwareZkClient zkClient) {\n     _zkClient = zkClient;\n     _configAccessor = new ConfigAccessor(zkClient);\n     _usesExternalZkClient = true;\n   }\n \n   public ZKHelixAdmin(String zkAddress) {\n     int timeOutInSec = Integer.parseInt(System.getProperty(CONNECTION_TIMEOUT, \"30\"));\n-    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-    clientConfig.setZkSerializer(new ZNRecordSerializer())\n-        .setConnectInitTimeout(timeOutInSec * 1000);\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-    _zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig()\n+            .setConnectInitTimeout(timeOutInSec * 1000L)\n+            .setZkSerializer(new ZNRecordSerializer());\n+\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      LOG.info(\"Not able to connect on multi-realm mode. \"\n+          + \"Connecting on single-realm mode to ZK: {}\", zkAddress);\n+\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+              clientConfig.createHelixZkClientConfig());\n+      zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    }\n+\n+    _zkClient = zkClient;\n+    _configAccessor = new ConfigAccessor(_zkClient);\n+    _usesExternalZkClient = false;\n+  }\n+\n+  private ZKHelixAdmin(Builder builder) throws IOException, InvalidRoutingDataException {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        _zkClient = new FederatedZkClient(builder.realmAwareZkConnectionConfig,\n+            builder.realmAwareZkClientConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca0e0cba1b7bbc223053d333c3e3033b50d3a703"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDIxOQ==", "bodyText": "Example: https://github.com/apache/helix/pull/863/files#diff-259ce65919d1337b08cb736839d755feR178-R192\nWhat are your thoughts?", "url": "https://github.com/apache/helix/pull/846#discussion_r388514219", "createdAt": "2020-03-05T19:29:42Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -89,33 +91,77 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   private final ConfigAccessor _configAccessor;\n-  // true if ZKHelixAdmin was instantiated with a HelixZkClient, false otherwise\n+  // true if ZKHelixAdmin was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZKHelixAdmin should close the underlying ZkClient\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZKHelixAdmin(HelixZkClient zkClient) {\n+  public ZKHelixAdmin(RealmAwareZkClient zkClient) {\n     _zkClient = zkClient;\n     _configAccessor = new ConfigAccessor(zkClient);\n     _usesExternalZkClient = true;\n   }\n \n   public ZKHelixAdmin(String zkAddress) {\n     int timeOutInSec = Integer.parseInt(System.getProperty(CONNECTION_TIMEOUT, \"30\"));\n-    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-    clientConfig.setZkSerializer(new ZNRecordSerializer())\n-        .setConnectInitTimeout(timeOutInSec * 1000);\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-    _zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig()\n+            .setConnectInitTimeout(timeOutInSec * 1000L)\n+            .setZkSerializer(new ZNRecordSerializer());\n+\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      LOG.info(\"Not able to connect on multi-realm mode. \"\n+          + \"Connecting on single-realm mode to ZK: {}\", zkAddress);\n+\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+              clientConfig.createHelixZkClientConfig());\n+      zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    }\n+\n+    _zkClient = zkClient;\n+    _configAccessor = new ConfigAccessor(_zkClient);\n+    _usesExternalZkClient = false;\n+  }\n+\n+  private ZKHelixAdmin(Builder builder) throws IOException, InvalidRoutingDataException {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        _zkClient = new FederatedZkClient(builder.realmAwareZkConnectionConfig,\n+            builder.realmAwareZkClientConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMzgwNQ=="}, "originalCommit": {"oid": "ca0e0cba1b7bbc223053d333c3e3033b50d3a703"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY4NDg1NA==", "bodyText": "Above reply.", "url": "https://github.com/apache/helix/pull/846#discussion_r388684854", "createdAt": "2020-03-06T02:36:09Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -89,33 +91,77 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   private final ConfigAccessor _configAccessor;\n-  // true if ZKHelixAdmin was instantiated with a HelixZkClient, false otherwise\n+  // true if ZKHelixAdmin was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZKHelixAdmin should close the underlying ZkClient\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZKHelixAdmin(HelixZkClient zkClient) {\n+  public ZKHelixAdmin(RealmAwareZkClient zkClient) {\n     _zkClient = zkClient;\n     _configAccessor = new ConfigAccessor(zkClient);\n     _usesExternalZkClient = true;\n   }\n \n   public ZKHelixAdmin(String zkAddress) {\n     int timeOutInSec = Integer.parseInt(System.getProperty(CONNECTION_TIMEOUT, \"30\"));\n-    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-    clientConfig.setZkSerializer(new ZNRecordSerializer())\n-        .setConnectInitTimeout(timeOutInSec * 1000);\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-    _zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig()\n+            .setConnectInitTimeout(timeOutInSec * 1000L)\n+            .setZkSerializer(new ZNRecordSerializer());\n+\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      LOG.info(\"Not able to connect on multi-realm mode. \"\n+          + \"Connecting on single-realm mode to ZK: {}\", zkAddress);\n+\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+              clientConfig.createHelixZkClientConfig());\n+      zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    }\n+\n+    _zkClient = zkClient;\n+    _configAccessor = new ConfigAccessor(_zkClient);\n+    _usesExternalZkClient = false;\n+  }\n+\n+  private ZKHelixAdmin(Builder builder) throws IOException, InvalidRoutingDataException {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        _zkClient = new FederatedZkClient(builder.realmAwareZkConnectionConfig,\n+            builder.realmAwareZkClientConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMzgwNQ=="}, "originalCommit": {"oid": "ca0e0cba1b7bbc223053d333c3e3033b50d3a703"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzA1OTc3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTozMDo1OFrOFyhEQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjozMDoyOVrOFyrXFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDg4MA==", "bodyText": "This could actually be simplified to\n      // Resolve RealmAwareZkClientConfig\n      if (_realmAwareZkClientConfig == null) {\n        _realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig();\n      }", "url": "https://github.com/apache/helix/pull/846#discussion_r388514880", "createdAt": "2020-03-05T19:30:58Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1799,4 +1845,71 @@ private boolean validateWeightForResourceConfig(ClusterConfig clusterConfig,\n             clusterConfig));\n     return true;\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZKHelixAdmin.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin build() throws Exception {\n+      validate();\n+      return new ZKHelixAdmin(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca0e0cba1b7bbc223053d333c3e3033b50d3a703"}, "originalPosition": 396}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY4MzU0Mw==", "bodyText": "Done. We may want to make ConfigAccessor consistent with this?", "url": "https://github.com/apache/helix/pull/846#discussion_r388683543", "createdAt": "2020-03-06T02:30:29Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1799,4 +1845,71 @@ private boolean validateWeightForResourceConfig(ClusterConfig clusterConfig,\n             clusterConfig));\n     return true;\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZKHelixAdmin.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin build() throws Exception {\n+      validate();\n+      return new ZKHelixAdmin(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDg4MA=="}, "originalCommit": {"oid": "ca0e0cba1b7bbc223053d333c3e3033b50d3a703"}, "originalPosition": 396}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODYzMjM0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0Njo1OFrOFyvq5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0Njo1OFrOFyvq5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1NDE1MQ==", "bodyText": "ConfigAccessor -> ZkHelixAdmin?", "url": "https://github.com/apache/helix/pull/846#discussion_r388754151", "createdAt": "2020-03-06T07:46:58Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1799,4 +1856,69 @@ private boolean validateWeightForResourceConfig(ClusterConfig clusterConfig,\n             clusterConfig));\n     return true;\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZKHelixAdmin.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin build() throws Exception {\n+      validate();\n+      return new ZKHelixAdmin(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f76e522b5252eb0aba5a5367ec5427cfd4e5039a"}, "originalPosition": 388}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODYzNTc4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0ODo0MlrOFyvtCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0ODo0MlrOFyvtCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1NDY5OQ==", "bodyText": "Nit: remove extra line", "url": "https://github.com/apache/helix/pull/846#discussion_r388754699", "createdAt": "2020-03-06T07:48:42Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,62 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    RealmAwareZkClient newClient;\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      newClient = buildHelixZkClient(SharedZkClientFactory.getInstance(), connectionConfig,\n+          clientConfig);\n+    } else {\n+      newClient = buildHelixZkClient(DedicatedZkClientFactory.getInstance(), connectionConfig,\n+          clientConfig);\n+    }\n+\n+    return newClient;\n+  }\n+\n+  private RealmAwareZkClient buildHelixZkClient(HelixZkClientFactory zkClientFactory,\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    try {\n+      return zkClientFactory.buildZkClient(connectionConfig, clientConfig);\n+    } catch (IllegalArgumentException | IOException | InvalidRoutingDataException e) {\n+      LOG.info(\"Not able to connect on realm-aware mode for sharding key: {}, caused by: {} .\"\n+              + \"Trying to connect to ZK: {}.\", connectionConfig.getZkRealmShardingKey(),\n+          e.getMessage(), _zkAddress);\n+    }\n+\n+    // Fall back to HelixZkClient\n+    HelixZkClient.ZkClientConfig helixZkClientConfig = clientConfig.createHelixZkClientConfig();\n+    HelixZkClient.ZkConnectionConfig helixZkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(_zkAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+\n+    return zkClientFactory.buildZkClient(helixZkConnectionConfig, helixZkClientConfig);\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f76e522b5252eb0aba5a5367ec5427cfd4e5039a"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTUxMjcxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDozMzo1MFrOFzLNtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMzoyMjo0N1rOFzSL7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTQzMQ==", "bodyText": "@pkuwm\nPlease throw a HelixException here and propagate the exception.\nAlso note that per our offline discussion, there will no longer be a fallback to single realm mode. If multi-realm fails, we fail the creation.", "url": "https://github.com/apache/helix/pull/846#discussion_r389205431", "createdAt": "2020-03-07T00:33:50Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -89,33 +91,88 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   private final ConfigAccessor _configAccessor;\n-  // true if ZKHelixAdmin was instantiated with a HelixZkClient, false otherwise\n+  // true if ZKHelixAdmin was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZKHelixAdmin should close the underlying ZkClient\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZKHelixAdmin(HelixZkClient zkClient) {\n+  public ZKHelixAdmin(RealmAwareZkClient zkClient) {\n     _zkClient = zkClient;\n     _configAccessor = new ConfigAccessor(zkClient);\n     _usesExternalZkClient = true;\n   }\n \n   public ZKHelixAdmin(String zkAddress) {\n     int timeOutInSec = Integer.parseInt(System.getProperty(CONNECTION_TIMEOUT, \"30\"));\n-    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-    clientConfig.setZkSerializer(new ZNRecordSerializer())\n-        .setConnectInitTimeout(timeOutInSec * 1000);\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-    _zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig()\n+            .setConnectInitTimeout(timeOutInSec * 1000L)\n+            .setZkSerializer(new ZNRecordSerializer());\n+\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      LOG.info(\"Not able to connect on multi-realm mode. \"\n+          + \"Connecting on single-realm mode to ZK: {}\", zkAddress);\n+\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+              clientConfig.createHelixZkClientConfig());\n+      zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    }\n+\n+    _zkClient = zkClient;\n+    _configAccessor = new ConfigAccessor(_zkClient);\n+    _usesExternalZkClient = false;\n+  }\n+\n+  private ZKHelixAdmin(Builder builder) {\n+    RealmAwareZkClient zkClient;\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          zkClient = new FederatedZkClient(builder.realmAwareZkConnectionConfig,\n+              builder.realmAwareZkClientConfig);\n+          break;\n+        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n+          if (builder.zkAddress == null || builder.zkAddress.isEmpty()) {\n+            throw new IllegalStateException(\"Not able to connect on multi-realm mode.\", e);\n+          }\n+          LOG.info(\"Not able to connect on multi-realm mode. \"\n+              + \"Connecting on single-realm mode to ZK: {}\", builder.zkAddress);\n+          builder.setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c989ccc20408c6a7bd47613bc266568d37a4a145"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxOTY2Mw==", "bodyText": "Done.", "url": "https://github.com/apache/helix/pull/846#discussion_r389319663", "createdAt": "2020-03-07T23:22:47Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -89,33 +91,88 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+\n   public static final String CONNECTION_TIMEOUT = \"helixAdmin.timeOutInSec\";\n   private static final String MAINTENANCE_ZNODE_ID = \"maintenance\";\n   private static final int DEFAULT_SUPERCLUSTER_REPLICA = 3;\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   private final ConfigAccessor _configAccessor;\n-  // true if ZKHelixAdmin was instantiated with a HelixZkClient, false otherwise\n+  // true if ZKHelixAdmin was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZKHelixAdmin should close the underlying ZkClient\n   private final boolean _usesExternalZkClient;\n \n   private static Logger logger = LoggerFactory.getLogger(ZKHelixAdmin.class);\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZKHelixAdmin(HelixZkClient zkClient) {\n+  public ZKHelixAdmin(RealmAwareZkClient zkClient) {\n     _zkClient = zkClient;\n     _configAccessor = new ConfigAccessor(zkClient);\n     _usesExternalZkClient = true;\n   }\n \n   public ZKHelixAdmin(String zkAddress) {\n     int timeOutInSec = Integer.parseInt(System.getProperty(CONNECTION_TIMEOUT, \"30\"));\n-    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-    clientConfig.setZkSerializer(new ZNRecordSerializer())\n-        .setConnectInitTimeout(timeOutInSec * 1000);\n-    _zkClient = SharedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-    _zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig()\n+            .setConnectInitTimeout(timeOutInSec * 1000L)\n+            .setZkSerializer(new ZNRecordSerializer());\n+\n+    RealmAwareZkClient zkClient;\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      LOG.info(\"Not able to connect on multi-realm mode. \"\n+          + \"Connecting on single-realm mode to ZK: {}\", zkAddress);\n+\n+      zkClient = SharedZkClientFactory.getInstance()\n+          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+              clientConfig.createHelixZkClientConfig());\n+      zkClient.waitUntilConnected(timeOutInSec, TimeUnit.SECONDS);\n+    }\n+\n+    _zkClient = zkClient;\n+    _configAccessor = new ConfigAccessor(_zkClient);\n+    _usesExternalZkClient = false;\n+  }\n+\n+  private ZKHelixAdmin(Builder builder) {\n+    RealmAwareZkClient zkClient;\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          zkClient = new FederatedZkClient(builder.realmAwareZkConnectionConfig,\n+              builder.realmAwareZkClientConfig);\n+          break;\n+        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n+          if (builder.zkAddress == null || builder.zkAddress.isEmpty()) {\n+            throw new IllegalStateException(\"Not able to connect on multi-realm mode.\", e);\n+          }\n+          LOG.info(\"Not able to connect on multi-realm mode. \"\n+              + \"Connecting on single-realm mode to ZK: {}\", builder.zkAddress);\n+          builder.setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTQzMQ=="}, "originalCommit": {"oid": "c989ccc20408c6a7bd47613bc266568d37a4a145"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMjM0MzYxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMzo1NToyOVrOFzSS3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMzo1NToyOVrOFzSS3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyMTQzNw==", "bodyText": "This is not configAccessor... lets fix the log? :)", "url": "https://github.com/apache/helix/pull/846#discussion_r389321437", "createdAt": "2020-03-07T23:55:29Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1799,4 +1851,69 @@ private boolean validateWeightForResourceConfig(ClusterConfig clusterConfig,\n             clusterConfig));\n     return true;\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZKHelixAdmin.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin build() throws Exception {\n+      validate();\n+      return new ZKHelixAdmin(this);\n+    }\n+\n+    /*\n+     * Validates the given parameters before creating an instance of ZKHelixAdmin.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58e0214a73af8924c45857f49ac4231fb399ce2a"}, "originalPosition": 390}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMjM0NDgwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMzo1NzowMFrOFzSTYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQwMDowMTo1MFrOFzSUqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyMTU2OQ==", "bodyText": "Also we need to throw exception when zkaddr is set on multi-realm mode.", "url": "https://github.com/apache/helix/pull/846#discussion_r389321569", "createdAt": "2020-03-07T23:57:00Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1799,4 +1851,69 @@ private boolean validateWeightForResourceConfig(ClusterConfig clusterConfig,\n             clusterConfig));\n     return true;\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZKHelixAdmin.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin build() throws Exception {\n+      validate();\n+      return new ZKHelixAdmin(this);\n+    }\n+\n+    /*\n+     * Validates the given parameters before creating an instance of ZKHelixAdmin.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58e0214a73af8924c45857f49ac4231fb399ce2a"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyMTg5Nw==", "bodyText": "Fixed.", "url": "https://github.com/apache/helix/pull/846#discussion_r389321897", "createdAt": "2020-03-08T00:01:50Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1799,4 +1851,69 @@ private boolean validateWeightForResourceConfig(ClusterConfig clusterConfig,\n             clusterConfig));\n     return true;\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZKHelixAdmin.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZKHelixAdmin build() throws Exception {\n+      validate();\n+      return new ZKHelixAdmin(this);\n+    }\n+\n+    /*\n+     * Validates the given parameters before creating an instance of ZKHelixAdmin.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyMTU2OQ=="}, "originalCommit": {"oid": "58e0214a73af8924c45857f49ac4231fb399ce2a"}, "originalPosition": 388}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTg2NTQwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo1MDowMFrOF0sFVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNDoyNjo0N1rOF1Q38g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5MjUzMw==", "bodyText": "These method names are very confusing. You're creating HelixZkClient in buildRealmAwareZkClient() and creating RealmAwareZkClient in buildHelixZkClient()? Could we try to improve the naming for these methods so that it's easier to read? I think this could be refactored for readability. Thoughts?", "url": "https://github.com/apache/helix/pull/846#discussion_r390792533", "createdAt": "2020-03-11T07:50:00Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,63 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    RealmAwareZkClient newClient;\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      newClient = buildHelixZkClient(SharedZkClientFactory.getInstance(), connectionConfig,\n+          clientConfig);\n+    } else {\n+      newClient = buildHelixZkClient(DedicatedZkClientFactory.getInstance(), connectionConfig,\n+          clientConfig);\n+    }\n+\n+    return newClient;\n+  }\n+\n+  private RealmAwareZkClient buildHelixZkClient(HelixZkClientFactory zkClientFactory,\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    if (Boolean.getBoolean(SystemPropertyKeys.MULTI_ZK_ENABLED)) {\n+      try {\n+        // Create realm-aware ZkClient.\n+        return zkClientFactory.buildZkClient(connectionConfig, clientConfig);\n+      } catch (IllegalArgumentException | IOException | InvalidRoutingDataException e) {\n+        throw new HelixException(\"Not able to connect on realm-aware mode for sharding key: \"\n+            + connectionConfig.getZkRealmShardingKey(), e);\n+      }\n+    }\n+\n+    // If multi-zk mode is not enabled, create HelixZkClient with the provided zk address.\n+    HelixZkClient.ZkClientConfig helixZkClientConfig = clientConfig.createHelixZkClientConfig();\n+    HelixZkClient.ZkConnectionConfig helixZkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(_zkAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+\n+    return zkClientFactory.buildZkClient(helixZkConnectionConfig, helixZkClientConfig);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aa70c05552bd344c705c47a2d0adc87a7109f49"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5NTMxNA==", "bodyText": "I also had the same thought. Based on the original name and the current code structure, I could not find good names. Updated with my new idea. If you have better ideas, please suggest.", "url": "https://github.com/apache/helix/pull/846#discussion_r391395314", "createdAt": "2020-03-12T04:26:47Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,63 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    RealmAwareZkClient newClient;\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      newClient = buildHelixZkClient(SharedZkClientFactory.getInstance(), connectionConfig,\n+          clientConfig);\n+    } else {\n+      newClient = buildHelixZkClient(DedicatedZkClientFactory.getInstance(), connectionConfig,\n+          clientConfig);\n+    }\n+\n+    return newClient;\n+  }\n+\n+  private RealmAwareZkClient buildHelixZkClient(HelixZkClientFactory zkClientFactory,\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+    if (Boolean.getBoolean(SystemPropertyKeys.MULTI_ZK_ENABLED)) {\n+      try {\n+        // Create realm-aware ZkClient.\n+        return zkClientFactory.buildZkClient(connectionConfig, clientConfig);\n+      } catch (IllegalArgumentException | IOException | InvalidRoutingDataException e) {\n+        throw new HelixException(\"Not able to connect on realm-aware mode for sharding key: \"\n+            + connectionConfig.getZkRealmShardingKey(), e);\n+      }\n+    }\n+\n+    // If multi-zk mode is not enabled, create HelixZkClient with the provided zk address.\n+    HelixZkClient.ZkClientConfig helixZkClientConfig = clientConfig.createHelixZkClientConfig();\n+    HelixZkClient.ZkConnectionConfig helixZkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(_zkAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+\n+    return zkClientFactory.buildZkClient(helixZkConnectionConfig, helixZkClientConfig);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5MjUzMw=="}, "originalCommit": {"oid": "8aa70c05552bd344c705c47a2d0adc87a7109f49"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTg2NzI0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo1MDo0NFrOF0sGcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDo1OTo1OVrOF064Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5MjgxOA==", "bodyText": "Shouldn't this be deprecated?", "url": "https://github.com/apache/helix/pull/846#discussion_r390792818", "createdAt": "2020-03-11T07:50:44Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,14 +103,13 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n-  @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aa70c05552bd344c705c47a2d0adc87a7109f49"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNDg5MA==", "bodyText": "Good catch. It should be. When I started working on it, I was not sure and thought we would keep the new RealmAwareZkClient  and deprecate HelixZkClient  instead. I already deprecated in the ZkBaseDataAccessor PR.\nUpdated to deprecate it.", "url": "https://github.com/apache/helix/pull/846#discussion_r391034890", "createdAt": "2020-03-11T14:59:59Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,14 +103,13 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n+  private final RealmAwareZkClient _zkClient;\n   // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n-  @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5MjgxOA=="}, "originalCommit": {"oid": "8aa70c05552bd344c705c47a2d0adc87a7109f49"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE0NzUyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1MToyNFrOF1L82A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNDoyNToxM1rOF1Q2jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNDY0OA==", "bodyText": "Add TODO here. We need to refactor all the builders before merging to the master.", "url": "https://github.com/apache/helix/pull/846#discussion_r391314648", "createdAt": "2020-03-11T22:51:24Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1799,4 +1867,73 @@ private boolean validateWeightForResourceConfig(ClusterConfig clusterConfig,\n             clusterConfig));\n     return true;\n   }\n+\n+  public static class Builder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "294015f5607962e2659cdc1d92f04533f933cc51"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5NDk1Nw==", "bodyText": "Added.", "url": "https://github.com/apache/helix/pull/846#discussion_r391394957", "createdAt": "2020-03-12T04:25:13Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1799,4 +1867,73 @@ private boolean validateWeightForResourceConfig(ClusterConfig clusterConfig,\n             clusterConfig));\n     return true;\n   }\n+\n+  public static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNDY0OA=="}, "originalCommit": {"oid": "294015f5607962e2659cdc1d92f04533f933cc51"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTY5MTgzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNDo0Nzo0NlrOF1RH7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNTowMTo0N1rOF1RTzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5OTQwNA==", "bodyText": "Nit: one empty line would suffice?", "url": "https://github.com/apache/helix/pull/846#discussion_r391399404", "createdAt": "2020-03-12T04:47:46Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -90,33 +92,98 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55153ff1318afc1aeedf7b237cd5f406bb0c3b3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMjQ0Nw==", "bodyText": "How could 2 empty lines be added...\nAddressed.", "url": "https://github.com/apache/helix/pull/846#discussion_r391402447", "createdAt": "2020-03-12T05:01:47Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -90,33 +92,98 @@\n \n \n public class ZKHelixAdmin implements HelixAdmin {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZKHelixAdmin.class);\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5OTQwNA=="}, "originalCommit": {"oid": "d55153ff1318afc1aeedf7b237cd5f406bb0c3b3"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTcwMDc5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNDo1MzozOFrOF1RNGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNDo1MzozOFrOF1RNGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMDczMA==", "bodyText": "Nit: I know we don't have to change this, but initializing to null is redundant.", "url": "https://github.com/apache/helix/pull/846#discussion_r391400730", "createdAt": "2020-03-12T04:53:38Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -117,7 +121,7 @@\n   private final String _version;\n   private int _reportLatency;\n \n-  protected HelixZkClient _zkclient = null;\n+  protected RealmAwareZkClient _zkclient = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55153ff1318afc1aeedf7b237cd5f406bb0c3b3"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTcwOTEyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNTowMDowNVrOF1RSRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNTowNjo0MVrOF1RX3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMjA1NA==", "bodyText": "My suggestion is\n\nJavaDoc:\n\nResolves what type of ZkClient this HelixManager should use based on whether MULTI_ZK_ENABLED System config is set or not. Two types of ZkClients are available: 1) If MULTI_ZK_ENABLED is set to true, we create a dedicated RealmAwareZkClient that provides full ZkClient functionalities and connects to the correct ZK by querying MetadataStoreDirectoryService. 2) Otherwise, we create a dedicated HelixZkClient which plainly connects to the ZK address given.\n\nRename the method to resolveZkClient()\n\nI think this will make our intention more clear.", "url": "https://github.com/apache/helix/pull/846#discussion_r391402054", "createdAt": "2020-03-12T05:00:05Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,60 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient createSingleRealmZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      return buildSelectiveZkClient(SharedZkClientFactory.getInstance(), connectionConfig,\n+          clientConfig);\n+    }\n+\n+    return buildSelectiveZkClient(DedicatedZkClientFactory.getInstance(), connectionConfig,\n+        clientConfig);\n+  }\n+\n+  private RealmAwareZkClient buildSelectiveZkClient(HelixZkClientFactory zkClientFactory,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55153ff1318afc1aeedf7b237cd5f406bb0c3b3"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMzQ4NQ==", "bodyText": "Added. Thx.", "url": "https://github.com/apache/helix/pull/846#discussion_r391403485", "createdAt": "2020-03-12T05:06:41Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,60 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient createSingleRealmZkClient() {\n+    final String shardingKey = buildShardingKey();\n+    PathBasedZkSerializer zkSerializer =\n+        ChainedPathZkSerializer.builder(new ZNRecordSerializer()).build();\n+\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder()\n+            .setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM)\n+            .setZkRealmShardingKey(shardingKey)\n+            .setSessionTimeout(_sessionTimeout).build();\n+\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    clientConfig.setZkSerializer(zkSerializer)\n+        .setConnectInitTimeout(_connectionInitTimeout)\n+        .setMonitorType(_instanceType.name())\n+        .setMonitorKey(_clusterName)\n+        .setMonitorInstanceName(_instanceName)\n+        .setMonitorRootPathOnly(isMonitorRootPathOnly());\n+\n+    if (_instanceType == InstanceType.ADMINISTRATOR) {\n+      return buildSelectiveZkClient(SharedZkClientFactory.getInstance(), connectionConfig,\n+          clientConfig);\n+    }\n+\n+    return buildSelectiveZkClient(DedicatedZkClientFactory.getInstance(), connectionConfig,\n+        clientConfig);\n+  }\n+\n+  private RealmAwareZkClient buildSelectiveZkClient(HelixZkClientFactory zkClientFactory,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMjA1NA=="}, "originalCommit": {"oid": "d55153ff1318afc1aeedf7b237cd5f406bb0c3b3"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTcxNDM2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNTowNDowNlrOF1RVjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNToxODoyNFrOF1RhyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMjg5NQ==", "bodyText": "Rename the method to prepareAndGetZkClient()\n\n\nJavadoc:\n\n\nPrepares connection config and client config based on the internal parameters given to HelixManager in order to create a ZkClient instance to use. Note that a shared ZkClient instance will be created if connecting as an ADMINISTRATOR to minimize the cost of creating ZkConnections.", "url": "https://github.com/apache/helix/pull/846#discussion_r391402895", "createdAt": "2020-03-12T05:04:06Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,60 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient createSingleRealmZkClient() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55153ff1318afc1aeedf7b237cd5f406bb0c3b3"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwNjAyNA==", "bodyText": "prepareAndGet sounds like a method does 2 things. I prefer to name a method which does one thing. get is better than prepareAndGet as there is no need to care about \"prepare\" since the final purpose is \"get\". There is already one method createClient() so I prefer to keep the name.\nIt is a private method and the logic is pretty straightforward. That's why I didn't consider adding comments. Anyway, since you suggested here, added.", "url": "https://github.com/apache/helix/pull/846#discussion_r391406024", "createdAt": "2020-03-12T05:18:24Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -1285,4 +1266,60 @@ public void handleSessionEstablishmentError(Throwable error) throws Exception {\n   public Long getSessionStartTime() {\n     return _sessionStartTime;\n   }\n+\n+  private RealmAwareZkClient createSingleRealmZkClient() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMjg5NQ=="}, "originalCommit": {"oid": "d55153ff1318afc1aeedf7b237cd5f406bb0c3b3"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1318, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}