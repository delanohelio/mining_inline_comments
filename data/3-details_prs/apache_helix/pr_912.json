{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzOTQ4Mjcz", "number": 912, "title": "Add integration test to customized view aggregation", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nThis PR added an integration test to customized view aggregation. The integration test involves components: update customized state using customized view provider, and use routing table provider to listen to changes in customized view which is aggregated in controller.\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis integration test involves the following steps:\n\nupdate/delete customized state to ZK\nupdate/delete the same customized state in a local recorded map\nconfigure the customized state types serve as data sources to routing table provider\nupdate the same customized state types to a local recorded set which represents the customize state types that are currently being listened\nget customized views from routing table provider\ncompare customized state values in the customized views fetched by routing table provider, and in local recorded map; also compare the customized state types available from ZK and local set\n\nTests\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 85.425 s - in org.apache.helix.integration.TestCustomizedViewAggregation\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:29 min\n[INFO] Finished at: 2020-03-25T21:05:05-07:00\n[INFO] --------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-03-26T04:23:20Z", "url": "https://github.com/apache/helix/pull/912", "merged": true, "mergeCommit": {"oid": "77110f61409e864070576d03231e5b02a835b7db"}, "closed": true, "closedAt": "2020-03-31T17:49:53Z", "author": {"login": "mgao0"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRVVwhAFqTM4MTcwNzYzMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTF35CgBqjMxODQxOTAxNjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNzA3NjMx", "url": "https://github.com/apache/helix/pull/912#pullrequestreview-381707631", "createdAt": "2020-03-26T05:15:55Z", "commit": {"oid": "cd3bb8e1dc9a715fb413ecae735dace047559dbc"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwNToxNTo1NVrOF73q2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwNTozNDoyOFrOF738rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyMjM5Mw==", "bodyText": "Let's try to make the naming convention more standard. It should have the type + number, and the number should start from 0 instead of 1.", "url": "https://github.com/apache/helix/pull/912#discussion_r398322393", "createdAt": "2020-03-26T05:15:55Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3bb8e1dc9a715fb413ecae735dace047559dbc"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNDI1NQ==", "bodyText": "This is not the right way to restrict the customized state types for aggregation. We should change the aggregation config to denote what are the states to be aggregated.", "url": "https://github.com/apache/helix/pull/912#discussion_r398324255", "createdAt": "2020-03-26T05:23:53Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays\n+        .asList(CustomizedStateType.TYPE_A.name(), CustomizedStateType.TYPE_B.name(),\n+            CustomizedStateType.TYPE_C.name());\n+    CustomizedStateConfig.Builder customizedStateConfigBuilder =\n+        new CustomizedStateConfig.Builder();\n+    customizedStateConfigBuilder.setAggregationEnabledTypes(aggregationEnabledTypes);\n+    dataAccessor.updateProperty(dataAccessor.keyBuilder().customizedStateConfig(),\n+        customizedStateConfigBuilder.build());\n+\n+    _localCustomizedView = new HashMap<>();\n+    _localVisibleCustomizedStateType = new HashSet<>();\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _routingTableProvider.shutdown();\n+    _manager.disconnect();\n+    _spectator.disconnect();\n+  }\n+\n+  /**\n+   * Compare the customized state values between ZK and local record\n+   * @throws Exception thread interrupted exception\n+   */\n+  private void validateAggregationSnapshot() throws Exception {\n+    boolean result = TestHelper.verify(new TestHelper.Verifier() {\n+      @Override\n+      public boolean verify() {\n+        Map<String, Map<String, RoutingTableSnapshot>> routingTableSnapshots =\n+            _routingTableProvider.getRoutingTableSnapshots();\n+\n+        // Get customized view snapshot\n+        Map<String, RoutingTableSnapshot> fullCustomizedViewSnapshot =\n+            routingTableSnapshots.get(PropertyType.CUSTOMIZEDVIEW.name());\n+\n+        for (String customizedStateType : fullCustomizedViewSnapshot.keySet()) {\n+          if (!_localVisibleCustomizedStateType.contains(customizedStateType)) {\n+            System.out.println(\n+                \"Local record does not contain customized state type \" + customizedStateType\n+                    + \", while it is shown in snapshot\");\n+            return false;\n+          }\n+\n+          // Get per customized state type snapshot\n+          RoutingTableSnapshot customizedViewSnapshot =\n+              fullCustomizedViewSnapshot.get(customizedStateType);\n+\n+          // local per customized state type map\n+          Map<String, Map<String, Map<String, String>>> localSnapshot =\n+              _localCustomizedView.getOrDefault(customizedStateType, Maps.newHashMap());\n+\n+          Collection<CustomizedView> customizedViews = customizedViewSnapshot.getCustomizeViews();\n+\n+          // Get per resource snapshot\n+          for (CustomizedView resourceCustomizedView : customizedViews) {\n+            ZNRecord record = resourceCustomizedView.getRecord();\n+            Map<String, Map<String, String>> resourceStateMap = record.getMapFields();\n+\n+            // Get local per resource map\n+            Map<String, Map<String, String>> localPerResourceCustomizedView = localSnapshot\n+                .getOrDefault(resourceCustomizedView.getResourceName(), Maps.newHashMap());\n+\n+            // Get per partition snapshot\n+            for (String partitionName : resourceStateMap.keySet()) {\n+              Map<String, String> stateMap =\n+                  resourceStateMap.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              // Get local per partition map\n+              Map<String, String> localStateMap =\n+                  localPerResourceCustomizedView.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              for (String instanceName : stateMap.keySet()) {\n+                // Per instance value\n+                String stateMapValue = stateMap.get(instanceName);\n+                String localStateMapValue = localStateMap.get(instanceName);\n+                if (isEmptyValue(stateMapValue) && isEmptyValue(localStateMapValue)) {\n+                  return true;\n+                }\n+                if ((!isEmptyValue(stateMapValue) && !isEmptyValue(localStateMapValue)\n+                    && !stateMapValue.equals(localStateMapValue)) || (isEmptyValue(stateMapValue)\n+                    || isEmptyValue(localStateMapValue))) {\n+                  System.out.println(\"The customized state value is: \" + stateMapValue\n+                      + \", it does not match local record value: \" + localStateMapValue\n+                      + \", for instance \" + instanceName + \".\");\n+                  return false;\n+                }\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+        return false; // There is no any customized state type enabled for aggregation set\n+      }\n+    }, 12000);\n+\n+    Assert.assertTrue(result);\n+  }\n+\n+  private boolean isEmptyValue(String value) {\n+    return value == null || value.equals(\"\");\n+  }\n+\n+  /**\n+   * Update the local record of customized state\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   */\n+  private void updateLocalCustomizedViewMap(String instanceName,\n+      CustomizedStateType customizedStateType, String resourceName, String partitionName,\n+      CurrentStateValues customizedStateValue) {\n+    _localCustomizedView.putIfAbsent(customizedStateType.name(), new TreeMap<>());\n+    Map<String, Map<String, Map<String, String>>> localPerStateType =\n+        _localCustomizedView.get(customizedStateType.name());\n+    localPerStateType.putIfAbsent(resourceName, new TreeMap<>());\n+    Map<String, Map<String, String>> localPerResource = localPerStateType.get(resourceName);\n+    localPerResource.putIfAbsent(partitionName, new TreeMap<>());\n+    Map<String, String> localPerPartition = localPerResource.get(partitionName);\n+    if (customizedStateValue == null) {\n+      localPerPartition.remove(instanceName);\n+    } else {\n+      localPerPartition.put(instanceName, customizedStateValue.name());\n+    }\n+  }\n+\n+  /**\n+   * Call this method in the test for an update on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void update(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName, CurrentStateValues customizedStateValue)\n+      throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   *\n+   * Call this method in the test for an delete on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void delete(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName) throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   * Set the customized state types to be listened by routing table provider\n+   * @param customizedStateTypes a list of the types to listen\n+   */\n+  private void setTypesToListenInRoutingTableProvider(\n+      List<CustomizedStateType> customizedStateTypes) {\n+    List<String> enabledTypes = new ArrayList<>();\n+    _localVisibleCustomizedStateType.clear();\n+    for (CustomizedStateType type : customizedStateTypes) {\n+      enabledTypes.add(type.name());\n+      _localVisibleCustomizedStateType.add(type.name());\n+    }\n+    Map<PropertyType, List<String>> dataSource = new HashMap<>();\n+    dataSource.put(PropertyType.CUSTOMIZEDVIEW, enabledTypes);\n+    _routingTableProvider = new RoutingTableProvider(_spectator, dataSource);\n+  }\n+\n+  /**\n+   * First update of customized state\n+   * Currently only aggregates CURRENT_STATE\n+   * instance    state type  resource    partition            key                 value\n+   * ---------------------------------------------------------------------------------\n+   *    0            A          A           1            CURRENT_STATE         StatusA1 - D\n+   *    0            B          A           1            CURRENT_STATE         StatusB1\n+   *    0            B          A           2            CURRENT_STATE         StatusB2  -M -> StatusB3\n+   *    0            A          B           2            CURRENT_STATE         StatusA2  -M -> StatusA1\n+   *    1            C          A           1            CURRENT_STATE         StatusC1\n+   *    1            C          A           2            CURRENT_STATE         StatusC2\n+   *    1            A          B           1            CURRENT_STATE         StatusA3 -D\n+   *    1            B          B           1            CURRENT_STATE         StatusB3 -D -M-> StatusB2\n+   *    1            C          B           1            CURRENT_STATE         StatusC3 -M -> StatusC1\n+   *\n+   *    -D: to be deleted in the test\n+   *    -M: to be modified in the test\n+   */\n+  @Test\n+  public void testCustomizedStateViewAggregation() throws Exception {\n+\n+    update(INSTANCE_0, CustomizedStateType.TYPE_A, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusA1);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_B, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusB1);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_B, RESOURCE_A, PARTITION_A2,\n+        CurrentStateValues.StatusB2);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_A, RESOURCE_B, PARTITION_B2,\n+        CurrentStateValues.StatusA2);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusC1);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_A, PARTITION_A2,\n+        CurrentStateValues.StatusC2);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_A, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusA3);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_B, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusB3);\n+\n+    // Test batch update API to update several customized states in the same customized state type for one resource, but for now only CURRENT_STATE will be aggregated in customized view\n+    Map<String, String> customizedStates = Maps.newHashMap();\n+    customizedStates.put(\"CURRENT_STATE\", CurrentStateValues.StatusC3.name());\n+    customizedStates.put(\"PREVIOUS_STATE\", CurrentStateValues.StatusC1.name());\n+    _customizedStateProvider_participant1\n+        .updateCustomizedState(CustomizedStateType.TYPE_C.name(), RESOURCE_B, PARTITION_B1,\n+            customizedStates);\n+    updateLocalCustomizedViewMap(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusC3);\n+\n+    // Only listen to Type A\n+    setTypesToListenInRoutingTableProvider(Arrays.asList(CustomizedStateType.TYPE_A));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3bb8e1dc9a715fb413ecae735dace047559dbc"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNDczMg==", "bodyText": "To be more accurate, it's not several customized states. It's one customized state with different fields. We do not support multiple customized state update.", "url": "https://github.com/apache/helix/pull/912#discussion_r398324732", "createdAt": "2020-03-26T05:25:56Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays\n+        .asList(CustomizedStateType.TYPE_A.name(), CustomizedStateType.TYPE_B.name(),\n+            CustomizedStateType.TYPE_C.name());\n+    CustomizedStateConfig.Builder customizedStateConfigBuilder =\n+        new CustomizedStateConfig.Builder();\n+    customizedStateConfigBuilder.setAggregationEnabledTypes(aggregationEnabledTypes);\n+    dataAccessor.updateProperty(dataAccessor.keyBuilder().customizedStateConfig(),\n+        customizedStateConfigBuilder.build());\n+\n+    _localCustomizedView = new HashMap<>();\n+    _localVisibleCustomizedStateType = new HashSet<>();\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _routingTableProvider.shutdown();\n+    _manager.disconnect();\n+    _spectator.disconnect();\n+  }\n+\n+  /**\n+   * Compare the customized state values between ZK and local record\n+   * @throws Exception thread interrupted exception\n+   */\n+  private void validateAggregationSnapshot() throws Exception {\n+    boolean result = TestHelper.verify(new TestHelper.Verifier() {\n+      @Override\n+      public boolean verify() {\n+        Map<String, Map<String, RoutingTableSnapshot>> routingTableSnapshots =\n+            _routingTableProvider.getRoutingTableSnapshots();\n+\n+        // Get customized view snapshot\n+        Map<String, RoutingTableSnapshot> fullCustomizedViewSnapshot =\n+            routingTableSnapshots.get(PropertyType.CUSTOMIZEDVIEW.name());\n+\n+        for (String customizedStateType : fullCustomizedViewSnapshot.keySet()) {\n+          if (!_localVisibleCustomizedStateType.contains(customizedStateType)) {\n+            System.out.println(\n+                \"Local record does not contain customized state type \" + customizedStateType\n+                    + \", while it is shown in snapshot\");\n+            return false;\n+          }\n+\n+          // Get per customized state type snapshot\n+          RoutingTableSnapshot customizedViewSnapshot =\n+              fullCustomizedViewSnapshot.get(customizedStateType);\n+\n+          // local per customized state type map\n+          Map<String, Map<String, Map<String, String>>> localSnapshot =\n+              _localCustomizedView.getOrDefault(customizedStateType, Maps.newHashMap());\n+\n+          Collection<CustomizedView> customizedViews = customizedViewSnapshot.getCustomizeViews();\n+\n+          // Get per resource snapshot\n+          for (CustomizedView resourceCustomizedView : customizedViews) {\n+            ZNRecord record = resourceCustomizedView.getRecord();\n+            Map<String, Map<String, String>> resourceStateMap = record.getMapFields();\n+\n+            // Get local per resource map\n+            Map<String, Map<String, String>> localPerResourceCustomizedView = localSnapshot\n+                .getOrDefault(resourceCustomizedView.getResourceName(), Maps.newHashMap());\n+\n+            // Get per partition snapshot\n+            for (String partitionName : resourceStateMap.keySet()) {\n+              Map<String, String> stateMap =\n+                  resourceStateMap.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              // Get local per partition map\n+              Map<String, String> localStateMap =\n+                  localPerResourceCustomizedView.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              for (String instanceName : stateMap.keySet()) {\n+                // Per instance value\n+                String stateMapValue = stateMap.get(instanceName);\n+                String localStateMapValue = localStateMap.get(instanceName);\n+                if (isEmptyValue(stateMapValue) && isEmptyValue(localStateMapValue)) {\n+                  return true;\n+                }\n+                if ((!isEmptyValue(stateMapValue) && !isEmptyValue(localStateMapValue)\n+                    && !stateMapValue.equals(localStateMapValue)) || (isEmptyValue(stateMapValue)\n+                    || isEmptyValue(localStateMapValue))) {\n+                  System.out.println(\"The customized state value is: \" + stateMapValue\n+                      + \", it does not match local record value: \" + localStateMapValue\n+                      + \", for instance \" + instanceName + \".\");\n+                  return false;\n+                }\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+        return false; // There is no any customized state type enabled for aggregation set\n+      }\n+    }, 12000);\n+\n+    Assert.assertTrue(result);\n+  }\n+\n+  private boolean isEmptyValue(String value) {\n+    return value == null || value.equals(\"\");\n+  }\n+\n+  /**\n+   * Update the local record of customized state\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   */\n+  private void updateLocalCustomizedViewMap(String instanceName,\n+      CustomizedStateType customizedStateType, String resourceName, String partitionName,\n+      CurrentStateValues customizedStateValue) {\n+    _localCustomizedView.putIfAbsent(customizedStateType.name(), new TreeMap<>());\n+    Map<String, Map<String, Map<String, String>>> localPerStateType =\n+        _localCustomizedView.get(customizedStateType.name());\n+    localPerStateType.putIfAbsent(resourceName, new TreeMap<>());\n+    Map<String, Map<String, String>> localPerResource = localPerStateType.get(resourceName);\n+    localPerResource.putIfAbsent(partitionName, new TreeMap<>());\n+    Map<String, String> localPerPartition = localPerResource.get(partitionName);\n+    if (customizedStateValue == null) {\n+      localPerPartition.remove(instanceName);\n+    } else {\n+      localPerPartition.put(instanceName, customizedStateValue.name());\n+    }\n+  }\n+\n+  /**\n+   * Call this method in the test for an update on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void update(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName, CurrentStateValues customizedStateValue)\n+      throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   *\n+   * Call this method in the test for an delete on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void delete(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName) throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   * Set the customized state types to be listened by routing table provider\n+   * @param customizedStateTypes a list of the types to listen\n+   */\n+  private void setTypesToListenInRoutingTableProvider(\n+      List<CustomizedStateType> customizedStateTypes) {\n+    List<String> enabledTypes = new ArrayList<>();\n+    _localVisibleCustomizedStateType.clear();\n+    for (CustomizedStateType type : customizedStateTypes) {\n+      enabledTypes.add(type.name());\n+      _localVisibleCustomizedStateType.add(type.name());\n+    }\n+    Map<PropertyType, List<String>> dataSource = new HashMap<>();\n+    dataSource.put(PropertyType.CUSTOMIZEDVIEW, enabledTypes);\n+    _routingTableProvider = new RoutingTableProvider(_spectator, dataSource);\n+  }\n+\n+  /**\n+   * First update of customized state\n+   * Currently only aggregates CURRENT_STATE\n+   * instance    state type  resource    partition            key                 value\n+   * ---------------------------------------------------------------------------------\n+   *    0            A          A           1            CURRENT_STATE         StatusA1 - D\n+   *    0            B          A           1            CURRENT_STATE         StatusB1\n+   *    0            B          A           2            CURRENT_STATE         StatusB2  -M -> StatusB3\n+   *    0            A          B           2            CURRENT_STATE         StatusA2  -M -> StatusA1\n+   *    1            C          A           1            CURRENT_STATE         StatusC1\n+   *    1            C          A           2            CURRENT_STATE         StatusC2\n+   *    1            A          B           1            CURRENT_STATE         StatusA3 -D\n+   *    1            B          B           1            CURRENT_STATE         StatusB3 -D -M-> StatusB2\n+   *    1            C          B           1            CURRENT_STATE         StatusC3 -M -> StatusC1\n+   *\n+   *    -D: to be deleted in the test\n+   *    -M: to be modified in the test\n+   */\n+  @Test\n+  public void testCustomizedStateViewAggregation() throws Exception {\n+\n+    update(INSTANCE_0, CustomizedStateType.TYPE_A, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusA1);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_B, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusB1);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_B, RESOURCE_A, PARTITION_A2,\n+        CurrentStateValues.StatusB2);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_A, RESOURCE_B, PARTITION_B2,\n+        CurrentStateValues.StatusA2);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusC1);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_A, PARTITION_A2,\n+        CurrentStateValues.StatusC2);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_A, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusA3);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_B, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusB3);\n+\n+    // Test batch update API to update several customized states in the same customized state type for one resource, but for now only CURRENT_STATE will be aggregated in customized view", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3bb8e1dc9a715fb413ecae735dace047559dbc"}, "originalPosition": 358}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTEyNA==", "bodyText": "We may not need this mapping when checking in the code. If the comment is clear enough, we're fine. Also it's a bit hard to read this mapping due to the state type and resource are both named with A, B, C.", "url": "https://github.com/apache/helix/pull/912#discussion_r398325124", "createdAt": "2020-03-26T05:27:27Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays\n+        .asList(CustomizedStateType.TYPE_A.name(), CustomizedStateType.TYPE_B.name(),\n+            CustomizedStateType.TYPE_C.name());\n+    CustomizedStateConfig.Builder customizedStateConfigBuilder =\n+        new CustomizedStateConfig.Builder();\n+    customizedStateConfigBuilder.setAggregationEnabledTypes(aggregationEnabledTypes);\n+    dataAccessor.updateProperty(dataAccessor.keyBuilder().customizedStateConfig(),\n+        customizedStateConfigBuilder.build());\n+\n+    _localCustomizedView = new HashMap<>();\n+    _localVisibleCustomizedStateType = new HashSet<>();\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _routingTableProvider.shutdown();\n+    _manager.disconnect();\n+    _spectator.disconnect();\n+  }\n+\n+  /**\n+   * Compare the customized state values between ZK and local record\n+   * @throws Exception thread interrupted exception\n+   */\n+  private void validateAggregationSnapshot() throws Exception {\n+    boolean result = TestHelper.verify(new TestHelper.Verifier() {\n+      @Override\n+      public boolean verify() {\n+        Map<String, Map<String, RoutingTableSnapshot>> routingTableSnapshots =\n+            _routingTableProvider.getRoutingTableSnapshots();\n+\n+        // Get customized view snapshot\n+        Map<String, RoutingTableSnapshot> fullCustomizedViewSnapshot =\n+            routingTableSnapshots.get(PropertyType.CUSTOMIZEDVIEW.name());\n+\n+        for (String customizedStateType : fullCustomizedViewSnapshot.keySet()) {\n+          if (!_localVisibleCustomizedStateType.contains(customizedStateType)) {\n+            System.out.println(\n+                \"Local record does not contain customized state type \" + customizedStateType\n+                    + \", while it is shown in snapshot\");\n+            return false;\n+          }\n+\n+          // Get per customized state type snapshot\n+          RoutingTableSnapshot customizedViewSnapshot =\n+              fullCustomizedViewSnapshot.get(customizedStateType);\n+\n+          // local per customized state type map\n+          Map<String, Map<String, Map<String, String>>> localSnapshot =\n+              _localCustomizedView.getOrDefault(customizedStateType, Maps.newHashMap());\n+\n+          Collection<CustomizedView> customizedViews = customizedViewSnapshot.getCustomizeViews();\n+\n+          // Get per resource snapshot\n+          for (CustomizedView resourceCustomizedView : customizedViews) {\n+            ZNRecord record = resourceCustomizedView.getRecord();\n+            Map<String, Map<String, String>> resourceStateMap = record.getMapFields();\n+\n+            // Get local per resource map\n+            Map<String, Map<String, String>> localPerResourceCustomizedView = localSnapshot\n+                .getOrDefault(resourceCustomizedView.getResourceName(), Maps.newHashMap());\n+\n+            // Get per partition snapshot\n+            for (String partitionName : resourceStateMap.keySet()) {\n+              Map<String, String> stateMap =\n+                  resourceStateMap.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              // Get local per partition map\n+              Map<String, String> localStateMap =\n+                  localPerResourceCustomizedView.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              for (String instanceName : stateMap.keySet()) {\n+                // Per instance value\n+                String stateMapValue = stateMap.get(instanceName);\n+                String localStateMapValue = localStateMap.get(instanceName);\n+                if (isEmptyValue(stateMapValue) && isEmptyValue(localStateMapValue)) {\n+                  return true;\n+                }\n+                if ((!isEmptyValue(stateMapValue) && !isEmptyValue(localStateMapValue)\n+                    && !stateMapValue.equals(localStateMapValue)) || (isEmptyValue(stateMapValue)\n+                    || isEmptyValue(localStateMapValue))) {\n+                  System.out.println(\"The customized state value is: \" + stateMapValue\n+                      + \", it does not match local record value: \" + localStateMapValue\n+                      + \", for instance \" + instanceName + \".\");\n+                  return false;\n+                }\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+        return false; // There is no any customized state type enabled for aggregation set\n+      }\n+    }, 12000);\n+\n+    Assert.assertTrue(result);\n+  }\n+\n+  private boolean isEmptyValue(String value) {\n+    return value == null || value.equals(\"\");\n+  }\n+\n+  /**\n+   * Update the local record of customized state\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   */\n+  private void updateLocalCustomizedViewMap(String instanceName,\n+      CustomizedStateType customizedStateType, String resourceName, String partitionName,\n+      CurrentStateValues customizedStateValue) {\n+    _localCustomizedView.putIfAbsent(customizedStateType.name(), new TreeMap<>());\n+    Map<String, Map<String, Map<String, String>>> localPerStateType =\n+        _localCustomizedView.get(customizedStateType.name());\n+    localPerStateType.putIfAbsent(resourceName, new TreeMap<>());\n+    Map<String, Map<String, String>> localPerResource = localPerStateType.get(resourceName);\n+    localPerResource.putIfAbsent(partitionName, new TreeMap<>());\n+    Map<String, String> localPerPartition = localPerResource.get(partitionName);\n+    if (customizedStateValue == null) {\n+      localPerPartition.remove(instanceName);\n+    } else {\n+      localPerPartition.put(instanceName, customizedStateValue.name());\n+    }\n+  }\n+\n+  /**\n+   * Call this method in the test for an update on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void update(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName, CurrentStateValues customizedStateValue)\n+      throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   *\n+   * Call this method in the test for an delete on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void delete(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName) throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   * Set the customized state types to be listened by routing table provider\n+   * @param customizedStateTypes a list of the types to listen\n+   */\n+  private void setTypesToListenInRoutingTableProvider(\n+      List<CustomizedStateType> customizedStateTypes) {\n+    List<String> enabledTypes = new ArrayList<>();\n+    _localVisibleCustomizedStateType.clear();\n+    for (CustomizedStateType type : customizedStateTypes) {\n+      enabledTypes.add(type.name());\n+      _localVisibleCustomizedStateType.add(type.name());\n+    }\n+    Map<PropertyType, List<String>> dataSource = new HashMap<>();\n+    dataSource.put(PropertyType.CUSTOMIZEDVIEW, enabledTypes);\n+    _routingTableProvider = new RoutingTableProvider(_spectator, dataSource);\n+  }\n+\n+  /**\n+   * First update of customized state", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3bb8e1dc9a715fb413ecae735dace047559dbc"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTU1NQ==", "bodyText": "This is not the right description. Aggregation config controls which customized states are aggregated into customized view, and routing table provider listens to that customized view. Routing table provider does not have the ability to make choice, and it'll listen to all changes in customized view.", "url": "https://github.com/apache/helix/pull/912#discussion_r398325555", "createdAt": "2020-03-26T05:29:11Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3bb8e1dc9a715fb413ecae735dace047559dbc"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTk3NA==", "bodyText": "customized state values -> customized view values.\nState is the raw data input, and view is the aggregated output.", "url": "https://github.com/apache/helix/pull/912#discussion_r398325974", "createdAt": "2020-03-26T05:30:51Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays\n+        .asList(CustomizedStateType.TYPE_A.name(), CustomizedStateType.TYPE_B.name(),\n+            CustomizedStateType.TYPE_C.name());\n+    CustomizedStateConfig.Builder customizedStateConfigBuilder =\n+        new CustomizedStateConfig.Builder();\n+    customizedStateConfigBuilder.setAggregationEnabledTypes(aggregationEnabledTypes);\n+    dataAccessor.updateProperty(dataAccessor.keyBuilder().customizedStateConfig(),\n+        customizedStateConfigBuilder.build());\n+\n+    _localCustomizedView = new HashMap<>();\n+    _localVisibleCustomizedStateType = new HashSet<>();\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _routingTableProvider.shutdown();\n+    _manager.disconnect();\n+    _spectator.disconnect();\n+  }\n+\n+  /**\n+   * Compare the customized state values between ZK and local record", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3bb8e1dc9a715fb413ecae735dace047559dbc"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNjk1OA==", "bodyText": "This is the right way to change aggregation enabled types config. In the following test, you should change this config to determine which state type should be aggregated and will be shown in customized view (then read by routing table provider).", "url": "https://github.com/apache/helix/pull/912#discussion_r398326958", "createdAt": "2020-03-26T05:34:28Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3bb8e1dc9a715fb413ecae735dace047559dbc"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MTUyNDQy", "url": "https://github.com/apache/helix/pull/912#pullrequestreview-384152442", "createdAt": "2020-03-30T19:12:44Z", "commit": {"oid": "cd3f2d4cd763fb5fa9d02ede09b1a055d15217c2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef9773b5dc4570496fb2a08c0820fba1d7e4bd91", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/ef9773b5dc4570496fb2a08c0820fba1d7e4bd91", "committedDate": "2020-03-31T06:15:45Z", "message": "Added integration test for customized view aggregation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "332ecb6161dc31fa20a8b49225097dc705a205a1", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/332ecb6161dc31fa20a8b49225097dc705a205a1", "committedDate": "2020-03-31T06:15:45Z", "message": "Modified test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2d6f5e7a955c9e179eefcd3654a17615ea8df7a", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/b2d6f5e7a955c9e179eefcd3654a17615ea8df7a", "committedDate": "2020-03-31T16:40:40Z", "message": "Fix set addAll UnsupportedOperationException"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cd3f2d4cd763fb5fa9d02ede09b1a055d15217c2", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/cd3f2d4cd763fb5fa9d02ede09b1a055d15217c2", "committedDate": "2020-03-27T04:25:27Z", "message": "Modified test"}, "afterCommit": {"oid": "b2d6f5e7a955c9e179eefcd3654a17615ea8df7a", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/b2d6f5e7a955c9e179eefcd3654a17615ea8df7a", "committedDate": "2020-03-31T16:40:40Z", "message": "Fix set addAll UnsupportedOperationException"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4730, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}