{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNDQzNDUy", "number": 744, "title": "Add read endpoints of metadata store directory service to helix rest", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nImplements #743\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nWe have metadata store directory service to help scale out zookeeper. Metadata store directory service provides REST APIs to access.\nThis ticket tracks the work of adding MSDS read endpoints to Helix REST.\nTests\n\n\n The following tests are written for this issue:\n\n\n3 tests in TestMetadataStoreDirectoryAccessor\n\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n\n[INFO] Tests run: 130, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 24.1 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 130, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  53.718 s\n[INFO] Finished at: 2020-02-10T23:51:37-08:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-11T02:13:45Z", "url": "https://github.com/apache/helix/pull/744", "merged": true, "mergeCommit": {"oid": "d750b09622dfd73adb7bceaaa82349d9a7151135"}, "closed": true, "closedAt": "2020-02-12T02:09:26Z", "author": {"login": "huizhilu"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDH2a_AH2gAyMzczNDQzNDUyOjA3NDI2MGYwNjIxODljNzZlNDZlYmU2MWY1ODBkNjk5ZGUyMjE3Yzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDbGXtgFqTM1NzExMzk2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/074260f062189c76e46ebe61f580d699de2217c9", "committedDate": "2020-02-11T01:56:38Z", "message": "Add read REST endpoints for metadata store directory service."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2Mzg4NzU5", "url": "https://github.com/apache/helix/pull/744#pullrequestreview-356388759", "createdAt": "2020-02-11T02:18:03Z", "commit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMjoxODowM1rOFn78cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMjoyNjozMlrOFn8CaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMDkxNA==", "bodyText": "Could we put these in MetadataStoreDirectoryConstants class?", "url": "https://github.com/apache/helix/pull/744#discussion_r377420914", "createdAt": "2020-02-11T02:18:03Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTQ4Mg==", "bodyText": "I think we use CamelCase for resource names:\n\n\"/clusters/{clusterName}/resources/{resourceName}/externalView\"\n\nShould we follow the Helix REST convention?", "url": "https://github.com/apache/helix/pull/744#discussion_r377421482", "createdAt": "2020-02-11T02:21:19Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTg1Mg==", "bodyText": "Just do a new HashMap()? Why do you need to put an empty list here? You override it anyways?", "url": "https://github.com/apache/helix/pull/744#discussion_r377421852", "createdAt": "2020-02-11T02:23:12Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTk4MQ==", "bodyText": "CamelCase?", "url": "https://github.com/apache/helix/pull/744#discussion_r377421981", "createdAt": "2020-02-11T02:23:49Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(_namespace.getName());\n+      responseMap.put(METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  @GET\n+  @Path(\"/sharding-keys\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjA2MQ==", "bodyText": "Also add realm.isEmpty()?", "url": "https://github.com/apache/helix/pull/744#discussion_r377422061", "createdAt": "2020-02-11T02:24:22Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(_namespace.getName());\n+      responseMap.put(METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getAllShardingKeysInRealm(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      if (realm == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjI2NQ==", "bodyText": "Why are we doing this for realm == null? Wouldn't this be considered an implicit behavior? Shouldn't we return notFound for the realm or bad arg exception?", "url": "https://github.com/apache/helix/pull/744#discussion_r377422265", "createdAt": "2020-02-11T02:25:36Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(_namespace.getName());\n+      responseMap.put(METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getAllShardingKeysInRealm(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      if (realm == null) {\n+        shardingKeys = getMetadataStoreDirectory().getAllShardingKeys(_namespace.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjQ0MA==", "bodyText": "if we return early, this else won't be necessary.", "url": "https://github.com/apache/helix/pull/744#discussion_r377422440", "createdAt": "2020-02-11T02:26:32Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(_namespace.getName());\n+      responseMap.put(METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getAllShardingKeysInRealm(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      if (realm == null) {\n+        shardingKeys = getMetadataStoreDirectory().getAllShardingKeys(_namespace.getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        shardingKeys =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "committedDate": "2020-02-11T06:04:41Z", "message": "Add unit tests."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c2d08bc4ea97235a46d2b08a5b108893c2bc020c", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/c2d08bc4ea97235a46d2b08a5b108893c2bc020c", "committedDate": "2020-02-11T06:01:45Z", "message": "Add unit tests."}, "afterCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd", "committedDate": "2020-02-11T06:04:41Z", "message": "Add unit tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDM0MDA2", "url": "https://github.com/apache/helix/pull/744#pullrequestreview-356434006", "createdAt": "2020-02-11T06:21:03Z", "commit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNjoyMTowM1rOFn-V6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNjozMzo1MlrOFn-f7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MDIwMA==", "bodyText": "Why does this show up as a new file? We already have this. Could you rebase from apache/zooscalability?", "url": "https://github.com/apache/helix/pull/744#discussion_r377460200", "createdAt": "2020-02-11T06:21:03Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/constant/MetadataStoreDirectoryConstants.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.apache.helix.rest.metadatastore.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Constants for metadata store directory service.\n+ */\n+public class MetadataStoreDirectoryConstants {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MDMwMA==", "bodyText": "Nit: in the \"JSON\" REST response...", "url": "https://github.com/apache/helix/pull/744#discussion_r377460300", "createdAt": "2020-02-11T06:21:41Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/constant/MetadataStoreDirectoryConstants.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.apache.helix.rest.metadatastore.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Constants for metadata store directory service.\n+ */\n+public class MetadataStoreDirectoryConstants {\n+  // Field name in the response of getting metadata store realms.\n+  public static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MDQ3Mg==", "bodyText": "We should put this in a different package.\nHow about ...server.resources.metadatastore; ?", "url": "https://github.com/apache/helix/pull/744#discussion_r377460472", "createdAt": "2020-02-11T06:22:44Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MTMzMQ==", "bodyText": "I don't have a strong opinion. In fact, \"-\" is used for most public APIs. The only reason to go with camelCase is because Helix REST is already using it.\nSince we plan on breaking this out into a separate module/service, I am fine with either unless others can make a case one way or the other.", "url": "https://github.com/apache/helix/pull/744#discussion_r377461331", "createdAt": "2020-02-11T06:27:07Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMTQ4Mg=="}, "originalCommit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MTM4MA==", "bodyText": "Nit: empty line?", "url": "https://github.com/apache/helix/pull/744#discussion_r377461380", "createdAt": "2020-02-11T06:27:24Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MTY2OQ==", "bodyText": "I feel that using \"..._KEY\" might be more intuitive than \"_NAME\". What do you think?", "url": "https://github.com/apache/helix/pull/744#discussion_r377461669", "createdAt": "2020-02-11T06:28:38Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/constant/MetadataStoreDirectoryConstants.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.apache.helix.rest.metadatastore.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Constants for metadata store directory service.\n+ */\n+public class MetadataStoreDirectoryConstants {\n+  // Field name in the response of getting metadata store realms.\n+  public static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+\n+  // Field name in the response of getting sharding keys.\n+  public static final String SHARDING_KEYS_NAME = \"shardingKeys\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MjAzNw==", "bodyText": "The comment helps. OK to resolve.", "url": "https://github.com/apache/helix/pull/744#discussion_r377462037", "createdAt": "2020-02-11T06:30:16Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private static final String METADATA_STORE_REALMS_NAME = \"metadataStoreRealms\";\n+  private static final String SHARDING_KEYS_NAME = \"shardingKeys\";\n+\n+  private final HelixRestNamespace _namespace =\n+      (HelixRestNamespace) _application.getProperties().get(ContextPropertyKeys.METADATA.name());\n+\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(METADATA_STORE_REALMS_NAME, Collections.emptyList());\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(_namespace.getName());\n+      responseMap.put(METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getAllShardingKeysInRealm(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      if (realm == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyMjA2MQ=="}, "originalCommit": {"oid": "074260f062189c76e46ebe61f580d699de2217c9"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MjIzMg==", "bodyText": "Should we make this a constant as well?", "url": "https://github.com/apache/helix/pull/744#discussion_r377462232", "createdAt": "2020-02-11T06:31:11Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());\n+      responseMap.put(\n+          MetadataStoreDirectoryConstants.METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n+   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n+   * a realm.\n+   *\n+   * @param realm Query param in endpoint path\n+   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   */\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n+      // to get all sharding keys in a namespace.\n+      if (realm == null) {\n+        shardingKeys =\n+            getMetadataStoreDirectory().getAllShardingKeys(getHelixNamespace().getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        // For endpoint: \"/sharding-keys?realm={realmName}\"\n+        shardingKeys = getMetadataStoreDirectory()\n+            .getAllShardingKeysInRealm(getHelixNamespace().getName(), realm);\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME and \"metadataStoreRealm\".\n+        responseMap = new HashMap<>(2);\n+        responseMap.put(\"metadataStoreRealm\", realm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MjQ1Ng==", "bodyText": "I believe you want to make _metadataStoreDirectory volatile for a correct implementation of double-checked locking.", "url": "https://github.com/apache/helix/pull/744#discussion_r377462456", "createdAt": "2020-02-11T06:32:07Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());\n+      responseMap.put(\n+          MetadataStoreDirectoryConstants.METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n+   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n+   * a realm.\n+   *\n+   * @param realm Query param in endpoint path\n+   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   */\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n+      // to get all sharding keys in a namespace.\n+      if (realm == null) {\n+        shardingKeys =\n+            getMetadataStoreDirectory().getAllShardingKeys(getHelixNamespace().getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        // For endpoint: \"/sharding-keys?realm={realmName}\"\n+        shardingKeys = getMetadataStoreDirectory()\n+            .getAllShardingKeysInRealm(getHelixNamespace().getName(), realm);\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME and \"metadataStoreRealm\".\n+        responseMap = new HashMap<>(2);\n+        responseMap.put(\"metadataStoreRealm\", realm);\n+      }\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    responseMap.put(MetadataStoreDirectoryConstants.SHARDING_KEYS_NAME, shardingKeys);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  private MetadataStoreDirectory getMetadataStoreDirectory() {\n+    if (_metadataStoreDirectory == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2MjY4OA==", "bodyText": "routing \"ZK\" address?", "url": "https://github.com/apache/helix/pull/744#discussion_r377462688", "createdAt": "2020-02-11T06:33:27Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());\n+      responseMap.put(\n+          MetadataStoreDirectoryConstants.METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n+   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n+   * a realm.\n+   *\n+   * @param realm Query param in endpoint path\n+   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   */\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n+      // to get all sharding keys in a namespace.\n+      if (realm == null) {\n+        shardingKeys =\n+            getMetadataStoreDirectory().getAllShardingKeys(getHelixNamespace().getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        // For endpoint: \"/sharding-keys?realm={realmName}\"\n+        shardingKeys = getMetadataStoreDirectory()\n+            .getAllShardingKeysInRealm(getHelixNamespace().getName(), realm);\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME and \"metadataStoreRealm\".\n+        responseMap = new HashMap<>(2);\n+        responseMap.put(\"metadataStoreRealm\", realm);\n+      }\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    responseMap.put(MetadataStoreDirectoryConstants.SHARDING_KEYS_NAME, shardingKeys);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  private MetadataStoreDirectory getMetadataStoreDirectory() {\n+    if (_metadataStoreDirectory == null) {\n+      synchronized (this) {\n+        if (_metadataStoreDirectory == null) {\n+          Map<String, String> routingZkAddressMap = ImmutableMap\n+              .of(getHelixNamespace().getName(), getHelixNamespace().getMetadataStoreAddress());\n+          try {\n+            _metadataStoreDirectory = new ZkMetadataStoreDirectory(routingZkAddressMap);\n+          } catch (InvalidRoutingDataException ex) {\n+            // In this case, the InvalidRoutingDataException should not happen because routing\n+            // ZK address is always valid here.\n+            LOG.warn(\"Unable to create metadata store directory for routing address: {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2Mjc2NA==", "bodyText": "how so? what if for some reason routingZkAddressMap gives some weird value like \"hellotest\"?", "url": "https://github.com/apache/helix/pull/744#discussion_r377462764", "createdAt": "2020-02-11T06:33:52Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/zookeeper/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.apache.helix.rest.server.resources.zookeeper;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreDirectoryConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MetadataStoreDirectoryAccessor.class);\n+\n+  private HelixRestNamespace _namespace;\n+  private MetadataStoreDirectory _metadataStoreDirectory;\n+\n+  /**\n+   * Gets all metadata store realms in a namespace with the endpoint.\n+   *\n+   * @return Json representation of all realms.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms\")\n+  public Response getAllMetadataStoreRealms() {\n+    Map<String, Collection<String>> responseMap = new HashMap<>(1);\n+    try {\n+      Collection<String> realms =\n+          getMetadataStoreDirectory().getAllMetadataStoreRealms(getHelixNamespace().getName());\n+      responseMap.put(\n+          MetadataStoreDirectoryConstants.METADATA_STORE_REALMS_NAME, realms);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n+   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n+   * a realm.\n+   *\n+   * @param realm Query param in endpoint path\n+   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   */\n+  @GET\n+  @Path(\"/sharding-keys\")\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n+    Map<String, Object> responseMap;\n+    Collection<String> shardingKeys;\n+    try {\n+      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n+      // to get all sharding keys in a namespace.\n+      if (realm == null) {\n+        shardingKeys =\n+            getMetadataStoreDirectory().getAllShardingKeys(getHelixNamespace().getName());\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME.\n+        responseMap = new HashMap<>(1);\n+      } else {\n+        // For endpoint: \"/sharding-keys?realm={realmName}\"\n+        shardingKeys = getMetadataStoreDirectory()\n+            .getAllShardingKeysInRealm(getHelixNamespace().getName(), realm);\n+        // To avoid allocating unnecessary resource, limit the map's capacity only for\n+        // SHARDING_KEYS_NAME and \"metadataStoreRealm\".\n+        responseMap = new HashMap<>(2);\n+        responseMap.put(\"metadataStoreRealm\", realm);\n+      }\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    responseMap.put(MetadataStoreDirectoryConstants.SHARDING_KEYS_NAME, shardingKeys);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  private MetadataStoreDirectory getMetadataStoreDirectory() {\n+    if (_metadataStoreDirectory == null) {\n+      synchronized (this) {\n+        if (_metadataStoreDirectory == null) {\n+          Map<String, String> routingZkAddressMap = ImmutableMap\n+              .of(getHelixNamespace().getName(), getHelixNamespace().getMetadataStoreAddress());\n+          try {\n+            _metadataStoreDirectory = new ZkMetadataStoreDirectory(routingZkAddressMap);\n+          } catch (InvalidRoutingDataException ex) {\n+            // In this case, the InvalidRoutingDataException should not happen because routing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbf6b2d6969dbe3727fc5b9c25c3e912b941bdd"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b7a5f0a903d0da9be118b8a83f288d584c225f3", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/4b7a5f0a903d0da9be118b8a83f288d584c225f3", "committedDate": "2020-02-11T07:46:25Z", "message": "Address comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0621315d9db56a08dc97b621561f15fd7cf65051", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/0621315d9db56a08dc97b621561f15fd7cf65051", "committedDate": "2020-02-11T08:44:18Z", "message": "Comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODkzMjA1", "url": "https://github.com/apache/helix/pull/744#pullrequestreview-356893205", "createdAt": "2020-02-11T18:31:22Z", "commit": {"oid": "0621315d9db56a08dc97b621561f15fd7cf65051"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODozMToyM1rOFoUO2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODozMToyM1rOFoUO2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxODg0Mg==", "bodyText": "It looks like there are a few endpoints missing such as:\ngetAllNamespaces\ngetAllMappingUnderPath\ngetMetadataStoreRealm\netc..\nIs there a reason these endpoints were left out? If they are unsupported, we could create the resource endpoints and but a TODO for them.", "url": "https://github.com/apache/helix/pull/744#discussion_r377818842", "createdAt": "2020-02-11T18:31:23Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.apache.helix.rest.server.resources.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0621315d9db56a08dc97b621561f15fd7cf65051"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2OTMwMTM0", "url": "https://github.com/apache/helix/pull/744#pullrequestreview-356930134", "createdAt": "2020-02-11T19:25:19Z", "commit": {"oid": "0621315d9db56a08dc97b621561f15fd7cf65051"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDM4MjA1", "url": "https://github.com/apache/helix/pull/744#pullrequestreview-357038205", "createdAt": "2020-02-11T22:17:43Z", "commit": {"oid": "0621315d9db56a08dc97b621561f15fd7cf65051"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxNzo0NFrOFobNJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxNzo0NFrOFobNJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzA5Mg==", "bodyText": "I am OK to have this Accessor extend AbstractResource from REST module. But keep in mind, when we starts split this metadata store module out from REST, how you handle the dependencies.", "url": "https://github.com/apache/helix/pull/744#discussion_r377933092", "createdAt": "2020-02-11T22:17:44Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.apache.helix.rest.server.resources.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.HelixRestUtils;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.helix.rest.server.resources.AbstractResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides REST endpoints for accessing metadata store directory service,\n+ * which responds to read/write requests of metadata store realms, sharding keys, etc..\n+ */\n+@Path(\"\")\n+public class MetadataStoreDirectoryAccessor extends AbstractResource {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0621315d9db56a08dc97b621561f15fd7cf65051"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0d5cc0f183291959e7e5e6d875803dc52efddb5", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/d0d5cc0f183291959e7e5e6d875803dc52efddb5", "committedDate": "2020-02-11T23:51:04Z", "message": "Use PostConstruct annotation to init namespace and metadataStoreDirectory."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTEzOTY0", "url": "https://github.com/apache/helix/pull/744#pullrequestreview-357113964", "createdAt": "2020-02-12T00:22:15Z", "commit": {"oid": "d0d5cc0f183291959e7e5e6d875803dc52efddb5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4942, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}