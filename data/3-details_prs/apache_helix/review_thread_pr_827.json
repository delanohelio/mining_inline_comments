{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMDM4MTg0", "number": 827, "reviewThreads": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzowOTowOVrODjpKAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoyMDoyNlrODlUC0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzAxMDU2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzowOTowOVrOFvkYzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzoyNTozNFrOFwFkNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMzU2Ng==", "bodyText": "This map is long and potentially introduces duplicate code since we have a similar code for the current state.\nCan we abstract a type for the stateMap that covers (resourceName -> (Partition -> (instanceName -> customizedState))) section? Then this map class can be used in both CustomizedStateOutput and CurrentStateOutput.", "url": "https://github.com/apache/helix/pull/827#discussion_r385423566", "createdAt": "2020-02-27T23:09:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "863c7bdf8c3b71e0ce39cc41e75e0f2e1f99131e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NzE1Nw==", "bodyText": "CurrentStateOutput has more maps that CustomizedStateOutput. And those maps are with different types of keys. I feel it's actually easier to know what the map has and what exactly each level of keys are by looking at the map. If we have another class of hierarchical map, we will still need to pass the types for the key, and how many levels there are, and if we only manipulate map in that class, it is harder to users to understand the map logic.", "url": "https://github.com/apache/helix/pull/827#discussion_r385967157", "createdAt": "2020-02-28T23:25:34Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMzU2Ng=="}, "originalCommit": {"oid": "863c7bdf8c3b71e0ce39cc41e75e0f2e1f99131e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzAzOTcwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzoyMzowMFrOFvkqeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMTozODozMVrOFwwNuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyODA4OA==", "bodyText": "nit, customizedStateName -> customizedStateType or type?", "url": "https://github.com/apache/helix/pull/827#discussion_r385428088", "createdAt": "2020-02-27T23:23:00Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedStateCache extends AbstractDataCache<CustomizedState> {\n+  private static final Logger LOG = LoggerFactory.getLogger(CurrentStateCache.class.getName());\n+\n+  // instance -> customizedStateType -> resource -> CustomizedState\n+  private Map<String, Map<String, Map<String, CustomizedState>>> _customizedStateMap;\n+  private Map<PropertyKey, CustomizedState> _customizedStateCache = Maps.newHashMap();\n+\n+  public CustomizedStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+  public CustomizedStateCache(ControlContextProvider contextProvider) {\n+    super(contextProvider);\n+    _customizedStateMap = Collections.emptyMap();\n+  }\n+\n+  /**\n+   * This refreshes the CustomizedStates data by re-fetching the data from zookeeper in an efficient\n+   * way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Set<String> aggregationEnabledTypes) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshCustomizedStatesCache(accessor, liveInstanceMap, aggregationEnabledTypes);\n+\n+    Map<String, Map<String, Map<String, CustomizedState>>> allCustomizedStateMap = new HashMap<>();\n+    for (PropertyKey key : _customizedStateCache.keySet()) {\n+      CustomizedState customizedState = _customizedStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (customizedState != null && params.length >= 4) {\n+        String instanceName = params[1];\n+        String customizedStateType = params[2];\n+        String resourceName = params[3];\n+        Map<String, Map<String, CustomizedState>> instanceCustomizedStateMap =\n+            allCustomizedStateMap.get(instanceName);\n+        if (instanceCustomizedStateMap == null) {\n+          instanceCustomizedStateMap = Maps.newHashMap();\n+          allCustomizedStateMap.put(instanceName, instanceCustomizedStateMap);\n+        }\n+        Map<String, CustomizedState> customizedStateNameCustomizedStateMap =\n+            instanceCustomizedStateMap.get(customizedStateType);\n+        if (customizedStateNameCustomizedStateMap == null) {\n+          customizedStateNameCustomizedStateMap = Maps.newHashMap();\n+          instanceCustomizedStateMap.put(customizedStateType,\n+              customizedStateNameCustomizedStateMap);\n+        }\n+        customizedStateNameCustomizedStateMap.put(resourceName, customizedState);\n+      }\n+    }\n+\n+    for (String instance : allCustomizedStateMap.keySet()) {\n+      allCustomizedStateMap.put(instance,\n+          Collections.unmodifiableMap(allCustomizedStateMap.get(instance)));\n+    }\n+    _customizedStateMap = Collections.unmodifiableMap(allCustomizedStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: CustomizedStateCache.refresh() for cluster \"\n+            + _controlContextProvider.getClusterName() + \", started at : \" + startTime + \", took \"\n+            + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Customized State refreshed : %s\", _customizedStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload customized states that has been changed from zk to local cache.\n+  private void refreshCustomizedStatesCache(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Set<String> aggregationEnabledTypes) {\n+    long start = System.currentTimeMillis();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    Set<PropertyKey> customizedStateKeys = new HashSet<>();\n+    List<String> resourceNames = new ArrayList<>();\n+    for (String instanceName : liveInstanceMap.keySet()) {\n+      for (String customizedStateName : aggregationEnabledTypes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "863c7bdf8c3b71e0ce39cc41e75e0f2e1f99131e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyODQyMA==", "bodyText": "And lamda shall fit here very well.", "url": "https://github.com/apache/helix/pull/827#discussion_r385428420", "createdAt": "2020-02-27T23:24:07Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedStateCache extends AbstractDataCache<CustomizedState> {\n+  private static final Logger LOG = LoggerFactory.getLogger(CurrentStateCache.class.getName());\n+\n+  // instance -> customizedStateType -> resource -> CustomizedState\n+  private Map<String, Map<String, Map<String, CustomizedState>>> _customizedStateMap;\n+  private Map<PropertyKey, CustomizedState> _customizedStateCache = Maps.newHashMap();\n+\n+  public CustomizedStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+  public CustomizedStateCache(ControlContextProvider contextProvider) {\n+    super(contextProvider);\n+    _customizedStateMap = Collections.emptyMap();\n+  }\n+\n+  /**\n+   * This refreshes the CustomizedStates data by re-fetching the data from zookeeper in an efficient\n+   * way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Set<String> aggregationEnabledTypes) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshCustomizedStatesCache(accessor, liveInstanceMap, aggregationEnabledTypes);\n+\n+    Map<String, Map<String, Map<String, CustomizedState>>> allCustomizedStateMap = new HashMap<>();\n+    for (PropertyKey key : _customizedStateCache.keySet()) {\n+      CustomizedState customizedState = _customizedStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (customizedState != null && params.length >= 4) {\n+        String instanceName = params[1];\n+        String customizedStateType = params[2];\n+        String resourceName = params[3];\n+        Map<String, Map<String, CustomizedState>> instanceCustomizedStateMap =\n+            allCustomizedStateMap.get(instanceName);\n+        if (instanceCustomizedStateMap == null) {\n+          instanceCustomizedStateMap = Maps.newHashMap();\n+          allCustomizedStateMap.put(instanceName, instanceCustomizedStateMap);\n+        }\n+        Map<String, CustomizedState> customizedStateNameCustomizedStateMap =\n+            instanceCustomizedStateMap.get(customizedStateType);\n+        if (customizedStateNameCustomizedStateMap == null) {\n+          customizedStateNameCustomizedStateMap = Maps.newHashMap();\n+          instanceCustomizedStateMap.put(customizedStateType,\n+              customizedStateNameCustomizedStateMap);\n+        }\n+        customizedStateNameCustomizedStateMap.put(resourceName, customizedState);\n+      }\n+    }\n+\n+    for (String instance : allCustomizedStateMap.keySet()) {\n+      allCustomizedStateMap.put(instance,\n+          Collections.unmodifiableMap(allCustomizedStateMap.get(instance)));\n+    }\n+    _customizedStateMap = Collections.unmodifiableMap(allCustomizedStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: CustomizedStateCache.refresh() for cluster \"\n+            + _controlContextProvider.getClusterName() + \", started at : \" + startTime + \", took \"\n+            + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Customized State refreshed : %s\", _customizedStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload customized states that has been changed from zk to local cache.\n+  private void refreshCustomizedStatesCache(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Set<String> aggregationEnabledTypes) {\n+    long start = System.currentTimeMillis();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    Set<PropertyKey> customizedStateKeys = new HashSet<>();\n+    List<String> resourceNames = new ArrayList<>();\n+    for (String instanceName : liveInstanceMap.keySet()) {\n+      for (String customizedStateName : aggregationEnabledTypes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyODA4OA=="}, "originalCommit": {"oid": "863c7bdf8c3b71e0ce39cc41e75e0f2e1f99131e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY2NTkxMg==", "bodyText": "It's moved to participantStateCache logic and updated.", "url": "https://github.com/apache/helix/pull/827#discussion_r386665912", "createdAt": "2020-03-02T21:38:31Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedStateCache extends AbstractDataCache<CustomizedState> {\n+  private static final Logger LOG = LoggerFactory.getLogger(CurrentStateCache.class.getName());\n+\n+  // instance -> customizedStateType -> resource -> CustomizedState\n+  private Map<String, Map<String, Map<String, CustomizedState>>> _customizedStateMap;\n+  private Map<PropertyKey, CustomizedState> _customizedStateCache = Maps.newHashMap();\n+\n+  public CustomizedStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+  public CustomizedStateCache(ControlContextProvider contextProvider) {\n+    super(contextProvider);\n+    _customizedStateMap = Collections.emptyMap();\n+  }\n+\n+  /**\n+   * This refreshes the CustomizedStates data by re-fetching the data from zookeeper in an efficient\n+   * way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Set<String> aggregationEnabledTypes) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshCustomizedStatesCache(accessor, liveInstanceMap, aggregationEnabledTypes);\n+\n+    Map<String, Map<String, Map<String, CustomizedState>>> allCustomizedStateMap = new HashMap<>();\n+    for (PropertyKey key : _customizedStateCache.keySet()) {\n+      CustomizedState customizedState = _customizedStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (customizedState != null && params.length >= 4) {\n+        String instanceName = params[1];\n+        String customizedStateType = params[2];\n+        String resourceName = params[3];\n+        Map<String, Map<String, CustomizedState>> instanceCustomizedStateMap =\n+            allCustomizedStateMap.get(instanceName);\n+        if (instanceCustomizedStateMap == null) {\n+          instanceCustomizedStateMap = Maps.newHashMap();\n+          allCustomizedStateMap.put(instanceName, instanceCustomizedStateMap);\n+        }\n+        Map<String, CustomizedState> customizedStateNameCustomizedStateMap =\n+            instanceCustomizedStateMap.get(customizedStateType);\n+        if (customizedStateNameCustomizedStateMap == null) {\n+          customizedStateNameCustomizedStateMap = Maps.newHashMap();\n+          instanceCustomizedStateMap.put(customizedStateType,\n+              customizedStateNameCustomizedStateMap);\n+        }\n+        customizedStateNameCustomizedStateMap.put(resourceName, customizedState);\n+      }\n+    }\n+\n+    for (String instance : allCustomizedStateMap.keySet()) {\n+      allCustomizedStateMap.put(instance,\n+          Collections.unmodifiableMap(allCustomizedStateMap.get(instance)));\n+    }\n+    _customizedStateMap = Collections.unmodifiableMap(allCustomizedStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: CustomizedStateCache.refresh() for cluster \"\n+            + _controlContextProvider.getClusterName() + \", started at : \" + startTime + \", took \"\n+            + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Customized State refreshed : %s\", _customizedStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload customized states that has been changed from zk to local cache.\n+  private void refreshCustomizedStatesCache(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Set<String> aggregationEnabledTypes) {\n+    long start = System.currentTimeMillis();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    Set<PropertyKey> customizedStateKeys = new HashSet<>();\n+    List<String> resourceNames = new ArrayList<>();\n+    for (String instanceName : liveInstanceMap.keySet()) {\n+      for (String customizedStateName : aggregationEnabledTypes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyODA4OA=="}, "originalCommit": {"oid": "863c7bdf8c3b71e0ce39cc41e75e0f2e1f99131e"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzA0NDc2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzoyNTozM1rOFvktdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzoyNTozM1rOFvktdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyODg1Mw==", "bodyText": "nit, Just call it keys or stateKeys? For shortening the code a little bit.", "url": "https://github.com/apache/helix/pull/827#discussion_r385428853", "createdAt": "2020-02-27T23:25:33Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedStateCache extends AbstractDataCache<CustomizedState> {\n+  private static final Logger LOG = LoggerFactory.getLogger(CurrentStateCache.class.getName());\n+\n+  // instance -> customizedStateType -> resource -> CustomizedState\n+  private Map<String, Map<String, Map<String, CustomizedState>>> _customizedStateMap;\n+  private Map<PropertyKey, CustomizedState> _customizedStateCache = Maps.newHashMap();\n+\n+  public CustomizedStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+  public CustomizedStateCache(ControlContextProvider contextProvider) {\n+    super(contextProvider);\n+    _customizedStateMap = Collections.emptyMap();\n+  }\n+\n+  /**\n+   * This refreshes the CustomizedStates data by re-fetching the data from zookeeper in an efficient\n+   * way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Set<String> aggregationEnabledTypes) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshCustomizedStatesCache(accessor, liveInstanceMap, aggregationEnabledTypes);\n+\n+    Map<String, Map<String, Map<String, CustomizedState>>> allCustomizedStateMap = new HashMap<>();\n+    for (PropertyKey key : _customizedStateCache.keySet()) {\n+      CustomizedState customizedState = _customizedStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (customizedState != null && params.length >= 4) {\n+        String instanceName = params[1];\n+        String customizedStateType = params[2];\n+        String resourceName = params[3];\n+        Map<String, Map<String, CustomizedState>> instanceCustomizedStateMap =\n+            allCustomizedStateMap.get(instanceName);\n+        if (instanceCustomizedStateMap == null) {\n+          instanceCustomizedStateMap = Maps.newHashMap();\n+          allCustomizedStateMap.put(instanceName, instanceCustomizedStateMap);\n+        }\n+        Map<String, CustomizedState> customizedStateNameCustomizedStateMap =\n+            instanceCustomizedStateMap.get(customizedStateType);\n+        if (customizedStateNameCustomizedStateMap == null) {\n+          customizedStateNameCustomizedStateMap = Maps.newHashMap();\n+          instanceCustomizedStateMap.put(customizedStateType,\n+              customizedStateNameCustomizedStateMap);\n+        }\n+        customizedStateNameCustomizedStateMap.put(resourceName, customizedState);\n+      }\n+    }\n+\n+    for (String instance : allCustomizedStateMap.keySet()) {\n+      allCustomizedStateMap.put(instance,\n+          Collections.unmodifiableMap(allCustomizedStateMap.get(instance)));\n+    }\n+    _customizedStateMap = Collections.unmodifiableMap(allCustomizedStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: CustomizedStateCache.refresh() for cluster \"\n+            + _controlContextProvider.getClusterName() + \", started at : \" + startTime + \", took \"\n+            + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Customized State refreshed : %s\", _customizedStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload customized states that has been changed from zk to local cache.\n+  private void refreshCustomizedStatesCache(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Set<String> aggregationEnabledTypes) {\n+    long start = System.currentTimeMillis();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    Set<PropertyKey> customizedStateKeys = new HashSet<>();\n+    List<String> resourceNames = new ArrayList<>();\n+    for (String instanceName : liveInstanceMap.keySet()) {\n+      for (String customizedStateName : aggregationEnabledTypes) {\n+        resourceNames =\n+            accessor.getChildNames(keyBuilder.customizedStates(instanceName, customizedStateName));\n+        for (String resourceName : resourceNames) {\n+          customizedStateKeys", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "863c7bdf8c3b71e0ce39cc41e75e0f2e1f99131e"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzE4Mjk1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMDozNjo1NlrOFvl_9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMDozNjo1NlrOFvl_9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ0OTk3Mw==", "bodyText": "As we discussed offline, we should either leverage propertyCache class or try to combine the common part of this cache and the current state cache.", "url": "https://github.com/apache/helix/pull/827#discussion_r385449973", "createdAt": "2020-02-28T00:36:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedStateCache extends AbstractDataCache<CustomizedState> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "863c7bdf8c3b71e0ce39cc41e75e0f2e1f99131e"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDUzMjM0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/AbstractDataCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzoyMjowOFrOFwFhKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzoyMjowOFrOFwFhKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NjM3Nw==", "bodyText": "Thanks for the change. Looks great.\nOne suggestion is that this change will reduce the genericity of AbstractDataCache. Can we add a middle class called \"AbstractParticipantStateCache\" as a child class of the AbstractDataCache?", "url": "https://github.com/apache/helix/pull/827#discussion_r385966377", "createdAt": "2020-02-28T23:22:08Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/AbstractDataCache.java", "diffHunk": "@@ -43,8 +47,13 @@\n \n   protected ControlContextProvider _controlContextProvider;\n \n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+\n   public AbstractDataCache(ControlContextProvider controlContextProvider) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbe6ef105370c7b8eb88b31006b6b5ebe7f9839"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDUzNTU3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/AbstractDataCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzoyNDowOFrOFwFjEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzoyNDowOFrOFwFjEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2Njg2Ng==", "bodyText": "You can keep the original name refresh() so it fits the style.", "url": "https://github.com/apache/helix/pull/827#discussion_r385966866", "createdAt": "2020-02-28T23:24:08Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/AbstractDataCache.java", "diffHunk": "@@ -104,6 +113,157 @@ public AbstractDataCache(ControlContextProvider controlContextProvider) {\n     return refreshedPropertyMap;\n   }\n \n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refreshParticipantStatesCache(HelixDataAccessor accessor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbe6ef105370c7b8eb88b31006b6b5ebe7f9839"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDU0MDQ1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzoyNzoyMVrOFwFl7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwMDoxMjo0NlrOFwGLng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NzU5Nw==", "bodyText": "nit, I think you can directly use CurrentStateCache.class", "url": "https://github.com/apache/helix/pull/827#discussion_r385967597", "createdAt": "2020-02-28T23:27:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.model.CustomizedState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedStateCache extends AbstractDataCache<CustomizedState> {\n+  private static final Logger LOG = LoggerFactory.getLogger(CurrentStateCache.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbe6ef105370c7b8eb88b31006b6b5ebe7f9839"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3NzI0Ng==", "bodyText": "Let's keep it separated, so that in the computation logic, there's no confusion.", "url": "https://github.com/apache/helix/pull/827#discussion_r385977246", "createdAt": "2020-02-29T00:12:46Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.model.CustomizedState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedStateCache extends AbstractDataCache<CustomizedState> {\n+  private static final Logger LOG = LoggerFactory.getLogger(CurrentStateCache.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NzU5Nw=="}, "originalCommit": {"oid": "abbe6ef105370c7b8eb88b31006b6b5ebe7f9839"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDU2NzQxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0NToyNVrOFwF10w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0NToyNVrOFwF10w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3MTY2Nw==", "bodyText": "duplicate and return is safer.", "url": "https://github.com/apache/helix/pull/827#discussion_r385971667", "createdAt": "2020-02-28T23:45:25Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;\n+\n+  public CustomizedStateOutput() {\n+    _customizedStateMap = new HashMap<>();\n+    _customizedStateMetaMap = new HashMap<>();\n+  }\n+\n+  public void setCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    if (!_customizedStateMap.containsKey(stateType)) {\n+      _customizedStateMap.put(stateType,\n+          new HashMap<String, Map<Partition, Map<String, String>>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n+      _customizedStateMap.get(stateType).put(resourceName,\n+          new HashMap<Partition, Map<String, String>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n+      _customizedStateMap.get(stateType).get(resourceName).put(partition,\n+          new HashMap<String, String>());\n+    }\n+    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition, instance), returns customized state\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @param instanceName\n+   * @return\n+   */\n+  public String getCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName) {\n+    Map<String, Map<Partition, Map<String, String>>> map = _customizedStateMap.get(stateType);\n+    if (map != null) {\n+      Map<Partition, Map<String, String>> resourceMap = map.get(resourceName);\n+      if (resourceMap != null) {\n+        Map<String, String> instanceStateMap = resourceMap.get(partition);\n+        if (instanceStateMap != null) {\n+          return instanceStateMap.get(instanceName);\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Given stateType, returns resource customized state map (resource -> parition -> instance ->\n+   * customizedState)\n+   * @param stateType\n+   * @return\n+   */\n+  public Map<String, Map<Partition, Map<String, String>>> getResourceCustomizedStateMap(\n+      String stateType) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      return _customizedStateMap.get(stateType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbe6ef105370c7b8eb88b31006b6b5ebe7f9839"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDU2ODE0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0NTo0NVrOFwF2Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0NTo0NVrOFwF2Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3MTc1OA==", "bodyText": "Same here. Please copy the map and then return.", "url": "https://github.com/apache/helix/pull/827#discussion_r385971758", "createdAt": "2020-02-28T23:45:45Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;\n+\n+  public CustomizedStateOutput() {\n+    _customizedStateMap = new HashMap<>();\n+    _customizedStateMetaMap = new HashMap<>();\n+  }\n+\n+  public void setCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    if (!_customizedStateMap.containsKey(stateType)) {\n+      _customizedStateMap.put(stateType,\n+          new HashMap<String, Map<Partition, Map<String, String>>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n+      _customizedStateMap.get(stateType).put(resourceName,\n+          new HashMap<Partition, Map<String, String>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n+      _customizedStateMap.get(stateType).get(resourceName).put(partition,\n+          new HashMap<String, String>());\n+    }\n+    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition, instance), returns customized state\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @param instanceName\n+   * @return\n+   */\n+  public String getCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName) {\n+    Map<String, Map<Partition, Map<String, String>>> map = _customizedStateMap.get(stateType);\n+    if (map != null) {\n+      Map<Partition, Map<String, String>> resourceMap = map.get(resourceName);\n+      if (resourceMap != null) {\n+        Map<String, String> instanceStateMap = resourceMap.get(partition);\n+        if (instanceStateMap != null) {\n+          return instanceStateMap.get(instanceName);\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Given stateType, returns resource customized state map (resource -> parition -> instance ->\n+   * customizedState)\n+   * @param stateType\n+   * @return\n+   */\n+  public Map<String, Map<Partition, Map<String, String>>> getResourceCustomizedStateMap(\n+      String stateType) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      return _customizedStateMap.get(stateType);\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource), returns (partition -> instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @return\n+   */\n+  public Map<Partition, Map<String, String>> getCustomizedStateMap(String stateType,\n+      String resourceName) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      Map<String, Map<Partition, Map<String, String>>> map = _customizedStateMap.get(stateType);\n+      if (map.containsKey(resourceName)) {\n+        return map.get(resourceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbe6ef105370c7b8eb88b31006b6b5ebe7f9839"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDU2OTA1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0NjoyM1rOFwF2rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0NjoyM1rOFwF2rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3MTg4Ng==", "bodyText": "This method should call getResourceCustomizedStateMap() to avoid duplicate code.", "url": "https://github.com/apache/helix/pull/827#discussion_r385971886", "createdAt": "2020-02-28T23:46:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;\n+\n+  public CustomizedStateOutput() {\n+    _customizedStateMap = new HashMap<>();\n+    _customizedStateMetaMap = new HashMap<>();\n+  }\n+\n+  public void setCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    if (!_customizedStateMap.containsKey(stateType)) {\n+      _customizedStateMap.put(stateType,\n+          new HashMap<String, Map<Partition, Map<String, String>>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n+      _customizedStateMap.get(stateType).put(resourceName,\n+          new HashMap<Partition, Map<String, String>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n+      _customizedStateMap.get(stateType).get(resourceName).put(partition,\n+          new HashMap<String, String>());\n+    }\n+    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition, instance), returns customized state\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @param instanceName\n+   * @return\n+   */\n+  public String getCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName) {\n+    Map<String, Map<Partition, Map<String, String>>> map = _customizedStateMap.get(stateType);\n+    if (map != null) {\n+      Map<Partition, Map<String, String>> resourceMap = map.get(resourceName);\n+      if (resourceMap != null) {\n+        Map<String, String> instanceStateMap = resourceMap.get(partition);\n+        if (instanceStateMap != null) {\n+          return instanceStateMap.get(instanceName);\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Given stateType, returns resource customized state map (resource -> parition -> instance ->\n+   * customizedState)\n+   * @param stateType\n+   * @return\n+   */\n+  public Map<String, Map<Partition, Map<String, String>>> getResourceCustomizedStateMap(\n+      String stateType) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      return _customizedStateMap.get(stateType);\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource), returns (partition -> instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @return\n+   */\n+  public Map<Partition, Map<String, String>> getCustomizedStateMap(String stateType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbe6ef105370c7b8eb88b31006b6b5ebe7f9839"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDU2OTg3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0Njo1M1rOFwF3Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0Njo1M1rOFwF3Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3MjAwNw==", "bodyText": "This method should call the other getCustomizedStateMap() to avoid duplicate code.\nBTW, can we have a better name to differentiate?", "url": "https://github.com/apache/helix/pull/827#discussion_r385972007", "createdAt": "2020-02-28T23:46:53Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;\n+\n+  public CustomizedStateOutput() {\n+    _customizedStateMap = new HashMap<>();\n+    _customizedStateMetaMap = new HashMap<>();\n+  }\n+\n+  public void setCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    if (!_customizedStateMap.containsKey(stateType)) {\n+      _customizedStateMap.put(stateType,\n+          new HashMap<String, Map<Partition, Map<String, String>>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n+      _customizedStateMap.get(stateType).put(resourceName,\n+          new HashMap<Partition, Map<String, String>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n+      _customizedStateMap.get(stateType).get(resourceName).put(partition,\n+          new HashMap<String, String>());\n+    }\n+    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition, instance), returns customized state\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @param instanceName\n+   * @return\n+   */\n+  public String getCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName) {\n+    Map<String, Map<Partition, Map<String, String>>> map = _customizedStateMap.get(stateType);\n+    if (map != null) {\n+      Map<Partition, Map<String, String>> resourceMap = map.get(resourceName);\n+      if (resourceMap != null) {\n+        Map<String, String> instanceStateMap = resourceMap.get(partition);\n+        if (instanceStateMap != null) {\n+          return instanceStateMap.get(instanceName);\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Given stateType, returns resource customized state map (resource -> parition -> instance ->\n+   * customizedState)\n+   * @param stateType\n+   * @return\n+   */\n+  public Map<String, Map<Partition, Map<String, String>>> getResourceCustomizedStateMap(\n+      String stateType) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      return _customizedStateMap.get(stateType);\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource), returns (partition -> instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @return\n+   */\n+  public Map<Partition, Map<String, String>> getCustomizedStateMap(String stateType,\n+      String resourceName) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      Map<String, Map<Partition, Map<String, String>>> map = _customizedStateMap.get(stateType);\n+      if (map.containsKey(resourceName)) {\n+        return map.get(resourceName);\n+      }\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition), returns (instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @return\n+   */\n+  public Map<String, String> getCustomizedStateMap(String stateType, String resourceName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbe6ef105370c7b8eb88b31006b6b5ebe7f9839"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDU3MDQwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0NzoxNFrOFwF3fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0NzoxNFrOFwF3fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3MjA5Mg==", "bodyText": "Always copy and then return.", "url": "https://github.com/apache/helix/pull/827#discussion_r385972092", "createdAt": "2020-02-28T23:47:14Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;\n+\n+  public CustomizedStateOutput() {\n+    _customizedStateMap = new HashMap<>();\n+    _customizedStateMetaMap = new HashMap<>();\n+  }\n+\n+  public void setCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    if (!_customizedStateMap.containsKey(stateType)) {\n+      _customizedStateMap.put(stateType,\n+          new HashMap<String, Map<Partition, Map<String, String>>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n+      _customizedStateMap.get(stateType).put(resourceName,\n+          new HashMap<Partition, Map<String, String>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n+      _customizedStateMap.get(stateType).get(resourceName).put(partition,\n+          new HashMap<String, String>());\n+    }\n+    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition, instance), returns customized state\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @param instanceName\n+   * @return\n+   */\n+  public String getCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName) {\n+    Map<String, Map<Partition, Map<String, String>>> map = _customizedStateMap.get(stateType);\n+    if (map != null) {\n+      Map<Partition, Map<String, String>> resourceMap = map.get(resourceName);\n+      if (resourceMap != null) {\n+        Map<String, String> instanceStateMap = resourceMap.get(partition);\n+        if (instanceStateMap != null) {\n+          return instanceStateMap.get(instanceName);\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Given stateType, returns resource customized state map (resource -> parition -> instance ->\n+   * customizedState)\n+   * @param stateType\n+   * @return\n+   */\n+  public Map<String, Map<Partition, Map<String, String>>> getResourceCustomizedStateMap(\n+      String stateType) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      return _customizedStateMap.get(stateType);\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource), returns (partition -> instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @return\n+   */\n+  public Map<Partition, Map<String, String>> getCustomizedStateMap(String stateType,\n+      String resourceName) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      Map<String, Map<Partition, Map<String, String>>> map = _customizedStateMap.get(stateType);\n+      if (map.containsKey(resourceName)) {\n+        return map.get(resourceName);\n+      }\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition), returns (instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @return\n+   */\n+  public Map<String, String> getCustomizedStateMap(String stateType, String resourceName,\n+      Partition partition) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      Map<String, Map<Partition, Map<String, String>>> map = _customizedStateMap.get(stateType);\n+      if (map.containsKey(resourceName)) {\n+        Map<Partition, Map<String, String>> partitionMap = map.get(resourceName);\n+        if (partitionMap != null) {\n+          return partitionMap.get(partition);\n+        }\n+      }\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  public Set<String> getAllStateTypes() {\n+    return _customizedStateMap.keySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbe6ef105370c7b8eb88b31006b6b5ebe7f9839"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTc2MTgzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo0ODo1NVrOFw0qzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo0ODo1NVrOFw0qzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczODg5NA==", "bodyText": "Add a simple comment for this class, please.", "url": "https://github.com/apache/helix/pull/827#discussion_r386738894", "createdAt": "2020-03-03T00:48:55Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTc2MjkxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo0OTozMlrOFw0reQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo0OTozMlrOFw0reQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczOTA2NQ==", "bodyText": "getName() is not preferred. Please just pass the class as the parameter.", "url": "https://github.com/apache/helix/pull/827#discussion_r386739065", "createdAt": "2020-03-03T00:49:32Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTc2ODA0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo1MjowNVrOFw0ufw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMDo1NjowMlrOFxWMaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczOTgzOQ==", "bodyText": "Do we really need these 2 constructors?", "url": "https://github.com/apache/helix/pull/827#discussion_r386739839", "createdAt": "2020-03-03T00:52:05Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.model.CustomizedState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedStateCache extends ParticipantStateCache<CustomizedState> {\n+  private static final Logger LOG = LoggerFactory.getLogger(CurrentStateCache.class.getName());\n+\n+  public CustomizedStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+  public CustomizedStateCache(ControlContextProvider contextProvider) {\n+    super(contextProvider);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI4ODE2OQ==", "bodyText": "Yeah, actually they're both used.", "url": "https://github.com/apache/helix/pull/827#discussion_r387288169", "createdAt": "2020-03-03T20:56:02Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CustomizedStateCache.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.model.CustomizedState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedStateCache extends ParticipantStateCache<CustomizedState> {\n+  private static final Logger LOG = LoggerFactory.getLogger(CurrentStateCache.class.getName());\n+\n+  public CustomizedStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+  public CustomizedStateCache(ControlContextProvider contextProvider) {\n+    super(contextProvider);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczOTgzOQ=="}, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTc2ODgwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo1MjozNVrOFw0u8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo1MjozNVrOFw0u8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczOTk1NQ==", "bodyText": "As an abstract class, usually, we only need one constructor for the children.", "url": "https://github.com/apache/helix/pull/827#discussion_r386739955", "createdAt": "2020-03-03T00:52:35Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTc3MzczOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo1NToxNFrOFw0x5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo1NToxNFrOFw0x5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDcwOA==", "bodyText": "Although it is an abstract class, level one for the instancename should be fixed. We can keep it here for clearer code.\nAs for level 2 and 3, we might want to comment it with an example for the other code readers.", "url": "https://github.com/apache/helix/pull/827#discussion_r386740708", "createdAt": "2020-03-03T00:55:14Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String keyLevel1 = params[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTc5MTc4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMTowNDozOVrOFw08lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMTowNDozOVrOFw08lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzQ0Ng==", "bodyText": "log error (or warning) if any mismatch keys.", "url": "https://github.com/apache/helix/pull/827#discussion_r386743446", "createdAt": "2020-03-03T01:04:39Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTc5Mzc1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMTowNTo0NVrOFw09ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMDo0NzoxNlrOFxV7Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0Mzc0Nw==", "bodyText": "nit, can we simplify this block a little bit. For example, putIfAbsent, etc.", "url": "https://github.com/apache/helix/pull/827#discussion_r386743747", "createdAt": "2020-03-03T01:05:45Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String keyLevel1 = params[1];\n+        String keyLevel2 = params[2];\n+        String keyLevel3 = params[3];\n+        Map<String, Map<String, T>> stateMapLevel1 =\n+            allParticipantStateMap.get(keyLevel1);\n+        if (stateMapLevel1 == null) {\n+          stateMapLevel1 = Maps.newHashMap();\n+          allParticipantStateMap.put(keyLevel1, stateMapLevel1);\n+        }\n+        Map<String, T> stateMapLevel2 = stateMapLevel1.get(keyLevel2);\n+        if (stateMapLevel2 == null) {\n+          stateMapLevel2 = Maps.newHashMap();\n+          stateMapLevel1.put(keyLevel2, stateMapLevel2);\n+        }\n+        stateMapLevel2.put(keyLevel3, participantState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI4Mzc4Mg==", "bodyText": "I tried a bit, but it cannot really be simplified by using putIfAbsent, as the next level map still need to use the previous map.", "url": "https://github.com/apache/helix/pull/827#discussion_r387283782", "createdAt": "2020-03-03T20:47:16Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String keyLevel1 = params[1];\n+        String keyLevel2 = params[2];\n+        String keyLevel3 = params[3];\n+        Map<String, Map<String, T>> stateMapLevel1 =\n+            allParticipantStateMap.get(keyLevel1);\n+        if (stateMapLevel1 == null) {\n+          stateMapLevel1 = Maps.newHashMap();\n+          allParticipantStateMap.put(keyLevel1, stateMapLevel1);\n+        }\n+        Map<String, T> stateMapLevel2 = stateMapLevel1.get(keyLevel2);\n+        if (stateMapLevel2 == null) {\n+          stateMapLevel2 = Maps.newHashMap();\n+          stateMapLevel1.put(keyLevel2, stateMapLevel2);\n+        }\n+        stateMapLevel2.put(keyLevel3, participantState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0Mzc0Nw=="}, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTc5ODQ3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMTowNzo1NlrOFw1Alw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMTowNzo1NlrOFw1Alw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NDQ3MQ==", "bodyText": "Since you are creating a new map every time already, is it still necessary to make it unmodifiable?", "url": "https://github.com/apache/helix/pull/827#discussion_r386744471", "createdAt": "2020-03-03T01:07:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String keyLevel1 = params[1];\n+        String keyLevel2 = params[2];\n+        String keyLevel3 = params[3];\n+        Map<String, Map<String, T>> stateMapLevel1 =\n+            allParticipantStateMap.get(keyLevel1);\n+        if (stateMapLevel1 == null) {\n+          stateMapLevel1 = Maps.newHashMap();\n+          allParticipantStateMap.put(keyLevel1, stateMapLevel1);\n+        }\n+        Map<String, T> stateMapLevel2 = stateMapLevel1.get(keyLevel2);\n+        if (stateMapLevel2 == null) {\n+          stateMapLevel2 = Maps.newHashMap();\n+          stateMapLevel1.put(keyLevel2, stateMapLevel2);\n+        }\n+        stateMapLevel2.put(keyLevel3, participantState);\n+      }\n+    }\n+\n+    for (String instance : allParticipantStateMap.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTgwMjUwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMToxMDoxMlrOFw1DFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMToxMTowNVrOFw1ENQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTExMQ==", "bodyText": "So for the first condition, the liveInstance is kind of the restrictedKeys, right? Can we put this logic to a protected method and leave it to the child class? This will help to cleanup the abstract class.", "url": "https://github.com/apache/helix/pull/827#discussion_r386745111", "createdAt": "2020-03-03T01:10:12Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String keyLevel1 = params[1];\n+        String keyLevel2 = params[2];\n+        String keyLevel3 = params[3];\n+        Map<String, Map<String, T>> stateMapLevel1 =\n+            allParticipantStateMap.get(keyLevel1);\n+        if (stateMapLevel1 == null) {\n+          stateMapLevel1 = Maps.newHashMap();\n+          allParticipantStateMap.put(keyLevel1, stateMapLevel1);\n+        }\n+        Map<String, T> stateMapLevel2 = stateMapLevel1.get(keyLevel2);\n+        if (stateMapLevel2 == null) {\n+          stateMapLevel2 = Maps.newHashMap();\n+          stateMapLevel1.put(keyLevel2, stateMapLevel2);\n+        }\n+        stateMapLevel2.put(keyLevel3, participantState);\n+      }\n+    }\n+\n+    for (String instance : allParticipantStateMap.keySet()) {\n+      allParticipantStateMap.put(instance, Collections.unmodifiableMap(allParticipantStateMap.get(instance)));\n+    }\n+    _participantStateMap = Collections.unmodifiableMap(allParticipantStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: participantStateCache.refresh() for cluster \" + _controlContextProvider.getClusterName()\n+            + \", started at : \" + startTime + \", took \" + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Participant State refreshed : %s\", _participantStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload participant states that has been changed from zk to local cache.\n+\n+  private void refreshParticipantStatesCacheFromZk(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled,\n+      Set<String> restrictedKeys) {\n+\n+    long start = System.currentTimeMillis();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    Set<PropertyKey> participantStateKeys = new HashSet<>();\n+    for (String instanceName : liveInstanceMap.keySet()) {\n+      LiveInstance liveInstance = liveInstanceMap.get(instanceName);\n+\n+      if (restrictedKeys.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTM5Nw==", "bodyText": "Basically you have an abstract method getParticipantStateKeys and called here. The children will implement this method separately with the different logic.", "url": "https://github.com/apache/helix/pull/827#discussion_r386745397", "createdAt": "2020-03-03T01:11:05Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String keyLevel1 = params[1];\n+        String keyLevel2 = params[2];\n+        String keyLevel3 = params[3];\n+        Map<String, Map<String, T>> stateMapLevel1 =\n+            allParticipantStateMap.get(keyLevel1);\n+        if (stateMapLevel1 == null) {\n+          stateMapLevel1 = Maps.newHashMap();\n+          allParticipantStateMap.put(keyLevel1, stateMapLevel1);\n+        }\n+        Map<String, T> stateMapLevel2 = stateMapLevel1.get(keyLevel2);\n+        if (stateMapLevel2 == null) {\n+          stateMapLevel2 = Maps.newHashMap();\n+          stateMapLevel1.put(keyLevel2, stateMapLevel2);\n+        }\n+        stateMapLevel2.put(keyLevel3, participantState);\n+      }\n+    }\n+\n+    for (String instance : allParticipantStateMap.keySet()) {\n+      allParticipantStateMap.put(instance, Collections.unmodifiableMap(allParticipantStateMap.get(instance)));\n+    }\n+    _participantStateMap = Collections.unmodifiableMap(allParticipantStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: participantStateCache.refresh() for cluster \" + _controlContextProvider.getClusterName()\n+            + \", started at : \" + startTime + \", took \" + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Participant State refreshed : %s\", _participantStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload participant states that has been changed from zk to local cache.\n+\n+  private void refreshParticipantStatesCacheFromZk(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled,\n+      Set<String> restrictedKeys) {\n+\n+    long start = System.currentTimeMillis();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    Set<PropertyKey> participantStateKeys = new HashSet<>();\n+    for (String instanceName : liveInstanceMap.keySet()) {\n+      LiveInstance liveInstance = liveInstanceMap.get(instanceName);\n+\n+      if (restrictedKeys.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTExMQ=="}, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTgwNzQ2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMToxMjozMVrOFw1F8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMDoxMToyMVrOFxU2WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTg0MA==", "bodyText": "Optional, both getParticipantStates() methods could be protected and let the children class wrap them and implement with more meaningful public methods.", "url": "https://github.com/apache/helix/pull/827#discussion_r386745840", "createdAt": "2020-03-03T01:12:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String keyLevel1 = params[1];\n+        String keyLevel2 = params[2];\n+        String keyLevel3 = params[3];\n+        Map<String, Map<String, T>> stateMapLevel1 =\n+            allParticipantStateMap.get(keyLevel1);\n+        if (stateMapLevel1 == null) {\n+          stateMapLevel1 = Maps.newHashMap();\n+          allParticipantStateMap.put(keyLevel1, stateMapLevel1);\n+        }\n+        Map<String, T> stateMapLevel2 = stateMapLevel1.get(keyLevel2);\n+        if (stateMapLevel2 == null) {\n+          stateMapLevel2 = Maps.newHashMap();\n+          stateMapLevel1.put(keyLevel2, stateMapLevel2);\n+        }\n+        stateMapLevel2.put(keyLevel3, participantState);\n+      }\n+    }\n+\n+    for (String instance : allParticipantStateMap.keySet()) {\n+      allParticipantStateMap.put(instance, Collections.unmodifiableMap(allParticipantStateMap.get(instance)));\n+    }\n+    _participantStateMap = Collections.unmodifiableMap(allParticipantStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: participantStateCache.refresh() for cluster \" + _controlContextProvider.getClusterName()\n+            + \", started at : \" + startTime + \", took \" + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Participant State refreshed : %s\", _participantStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload participant states that has been changed from zk to local cache.\n+\n+  private void refreshParticipantStatesCacheFromZk(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled,\n+      Set<String> restrictedKeys) {\n+\n+    long start = System.currentTimeMillis();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    Set<PropertyKey> participantStateKeys = new HashSet<>();\n+    for (String instanceName : liveInstanceMap.keySet()) {\n+      LiveInstance liveInstance = liveInstanceMap.get(instanceName);\n+\n+      if (restrictedKeys.isEmpty()) {\n+        String sessionId = liveInstance.getEphemeralOwner();\n+        List<String> currentStateNames =\n+            accessor.getChildNames(keyBuilder.currentStates(instanceName, sessionId));\n+\n+        for (String currentStateName : currentStateNames) {\n+          participantStateKeys\n+              .add(keyBuilder.currentState(instanceName, sessionId, currentStateName));\n+        }\n+      } else {\n+        List<String> resourceNames = new ArrayList<>();\n+        for (String customizedStateType : restrictedKeys) {\n+          resourceNames = accessor\n+              .getChildNames(keyBuilder.customizedStates(instanceName, customizedStateType));\n+          for (String resourceName : resourceNames) {\n+            participantStateKeys\n+                .add(keyBuilder.customizedState(instanceName, customizedStateType, resourceName));\n+          }\n+        }\n+      }\n+    }\n+    // All new entries from zk not cached locally yet should be read from ZK.\n+    Set<PropertyKey> reloadKeys = new HashSet<>(participantStateKeys);\n+    reloadKeys.removeAll(_participantStateCache.keySet());\n+\n+    Set<PropertyKey> cachedKeys = new HashSet<>(_participantStateCache.keySet());\n+    cachedKeys.retainAll(participantStateKeys);\n+\n+    Set<PropertyKey> reloadedKeys = new HashSet<>();\n+    Map<PropertyKey, T> newStateCache = Collections.unmodifiableMap(refreshProperties(accessor,\n+        reloadKeys, new ArrayList<>(cachedKeys), _participantStateCache, reloadedKeys));\n+\n+    if (snapshotEnabled) {\n+      refreshSnapshot(newStateCache, _participantStateCache, reloadedKeys);\n+    }\n+\n+    _participantStateCache = newStateCache;\n+\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(), \"# of participant state reload: \" + reloadKeys.size()\n+          + \", skipped:\" + (participantStateKeys.size() - reloadKeys.size()) + \". took \"\n+          + (System.currentTimeMillis() - start) + \" ms to reload new participant states for cluster: \"\n+          + _controlContextProvider.getClusterName() + \"and state: \" + this.getClass().getName());\n+    }\n+  }\n+\n+  protected void refreshSnapshot(Map<PropertyKey, T> newStateCache,\n+      Map<PropertyKey, T> participantStateCache, Set<PropertyKey> reloadedKeys) {\n+  }\n+\n+  /**\n+   * Return the whole participant state map.\n+   * @return\n+   */\n+  public Map<String, Map<String, Map<String, T>>> getParticipantStatesMap() {\n+    return Collections.unmodifiableMap(_participantStateMap);\n+  }\n+\n+  /**\n+   * Return all participant states for a certain level1 key.\n+   * @param keyLevel1\n+   * @return\n+   */\n+  public Map<String, Map<String, T>> getParticipantStates(String keyLevel1) {\n+    if (!_participantStateMap.containsKey(keyLevel1)) {\n+      return Collections.emptyMap();\n+    }\n+    return Collections.unmodifiableMap(_participantStateMap.get(keyLevel1));\n+  }\n+\n+  /**\n+   * Provides the participant state map for a certain level1 key and level2 key\n+   * @param keyLevel1\n+   * @param keyLevel2\n+   * @return\n+   */\n+  public Map<String, T> getParticipantState(String keyLevel1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI2NjEzNg==", "bodyText": "I changed the key names here. I feel it's ok to leave it here as it only returns some mapping.", "url": "https://github.com/apache/helix/pull/827#discussion_r387266136", "createdAt": "2020-03-03T20:11:21Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class.getName());\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  public ParticipantStateCache(String clusterName) {\n+    this(createDefaultControlContextProvider(clusterName));\n+  }\n+\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an efficient way\n+   *\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   *\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String keyLevel1 = params[1];\n+        String keyLevel2 = params[2];\n+        String keyLevel3 = params[3];\n+        Map<String, Map<String, T>> stateMapLevel1 =\n+            allParticipantStateMap.get(keyLevel1);\n+        if (stateMapLevel1 == null) {\n+          stateMapLevel1 = Maps.newHashMap();\n+          allParticipantStateMap.put(keyLevel1, stateMapLevel1);\n+        }\n+        Map<String, T> stateMapLevel2 = stateMapLevel1.get(keyLevel2);\n+        if (stateMapLevel2 == null) {\n+          stateMapLevel2 = Maps.newHashMap();\n+          stateMapLevel1.put(keyLevel2, stateMapLevel2);\n+        }\n+        stateMapLevel2.put(keyLevel3, participantState);\n+      }\n+    }\n+\n+    for (String instance : allParticipantStateMap.keySet()) {\n+      allParticipantStateMap.put(instance, Collections.unmodifiableMap(allParticipantStateMap.get(instance)));\n+    }\n+    _participantStateMap = Collections.unmodifiableMap(allParticipantStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: participantStateCache.refresh() for cluster \" + _controlContextProvider.getClusterName()\n+            + \", started at : \" + startTime + \", took \" + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Participant State refreshed : %s\", _participantStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload participant states that has been changed from zk to local cache.\n+\n+  private void refreshParticipantStatesCacheFromZk(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled,\n+      Set<String> restrictedKeys) {\n+\n+    long start = System.currentTimeMillis();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    Set<PropertyKey> participantStateKeys = new HashSet<>();\n+    for (String instanceName : liveInstanceMap.keySet()) {\n+      LiveInstance liveInstance = liveInstanceMap.get(instanceName);\n+\n+      if (restrictedKeys.isEmpty()) {\n+        String sessionId = liveInstance.getEphemeralOwner();\n+        List<String> currentStateNames =\n+            accessor.getChildNames(keyBuilder.currentStates(instanceName, sessionId));\n+\n+        for (String currentStateName : currentStateNames) {\n+          participantStateKeys\n+              .add(keyBuilder.currentState(instanceName, sessionId, currentStateName));\n+        }\n+      } else {\n+        List<String> resourceNames = new ArrayList<>();\n+        for (String customizedStateType : restrictedKeys) {\n+          resourceNames = accessor\n+              .getChildNames(keyBuilder.customizedStates(instanceName, customizedStateType));\n+          for (String resourceName : resourceNames) {\n+            participantStateKeys\n+                .add(keyBuilder.customizedState(instanceName, customizedStateType, resourceName));\n+          }\n+        }\n+      }\n+    }\n+    // All new entries from zk not cached locally yet should be read from ZK.\n+    Set<PropertyKey> reloadKeys = new HashSet<>(participantStateKeys);\n+    reloadKeys.removeAll(_participantStateCache.keySet());\n+\n+    Set<PropertyKey> cachedKeys = new HashSet<>(_participantStateCache.keySet());\n+    cachedKeys.retainAll(participantStateKeys);\n+\n+    Set<PropertyKey> reloadedKeys = new HashSet<>();\n+    Map<PropertyKey, T> newStateCache = Collections.unmodifiableMap(refreshProperties(accessor,\n+        reloadKeys, new ArrayList<>(cachedKeys), _participantStateCache, reloadedKeys));\n+\n+    if (snapshotEnabled) {\n+      refreshSnapshot(newStateCache, _participantStateCache, reloadedKeys);\n+    }\n+\n+    _participantStateCache = newStateCache;\n+\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(), \"# of participant state reload: \" + reloadKeys.size()\n+          + \", skipped:\" + (participantStateKeys.size() - reloadKeys.size()) + \". took \"\n+          + (System.currentTimeMillis() - start) + \" ms to reload new participant states for cluster: \"\n+          + _controlContextProvider.getClusterName() + \"and state: \" + this.getClass().getName());\n+    }\n+  }\n+\n+  protected void refreshSnapshot(Map<PropertyKey, T> newStateCache,\n+      Map<PropertyKey, T> participantStateCache, Set<PropertyKey> reloadedKeys) {\n+  }\n+\n+  /**\n+   * Return the whole participant state map.\n+   * @return\n+   */\n+  public Map<String, Map<String, Map<String, T>>> getParticipantStatesMap() {\n+    return Collections.unmodifiableMap(_participantStateMap);\n+  }\n+\n+  /**\n+   * Return all participant states for a certain level1 key.\n+   * @param keyLevel1\n+   * @return\n+   */\n+  public Map<String, Map<String, T>> getParticipantStates(String keyLevel1) {\n+    if (!_participantStateMap.containsKey(keyLevel1)) {\n+      return Collections.emptyMap();\n+    }\n+    return Collections.unmodifiableMap(_participantStateMap.get(keyLevel1));\n+  }\n+\n+  /**\n+   * Provides the participant state map for a certain level1 key and level2 key\n+   * @param keyLevel1\n+   * @param keyLevel2\n+   * @return\n+   */\n+  public Map<String, T> getParticipantState(String keyLevel1,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTg0MA=="}, "originalCommit": {"oid": "a22e9cdfe53d15a870bf03973da4a8296a90b17d"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjkxNjg0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/CurrentStateCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo0NToxOFrOFx5Lbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTo1NToxOFrOFx7hAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MTM1OA==", "bodyText": "The original logic is actually confusing here. Passing an empty new map here is much easier for people to understand.\nSince it won't change the logic, I suggest you just change it to make it clean : )", "url": "https://github.com/apache/helix/pull/827#discussion_r387861358", "createdAt": "2020-03-04T18:45:18Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CurrentStateCache.java", "diffHunk": "@@ -55,149 +46,33 @@ public CurrentStateCache(String clusterName) {\n \n   public CurrentStateCache(ControlContextProvider contextProvider) {\n     super(contextProvider);\n-    _currentStateMap = Collections.emptyMap();\n-    _snapshot = new CurrentStateSnapshot(_currentStateCache);\n+    _snapshot = new CurrentStateSnapshot(_participantStateCache);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1953ef1a96b29fc51334d9aa7d9fb8f953298b2d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5OTY0OA==", "bodyText": "I changed the map in ParticipantCache.", "url": "https://github.com/apache/helix/pull/827#discussion_r387899648", "createdAt": "2020-03-04T19:55:18Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CurrentStateCache.java", "diffHunk": "@@ -55,149 +46,33 @@ public CurrentStateCache(String clusterName) {\n \n   public CurrentStateCache(ControlContextProvider contextProvider) {\n     super(contextProvider);\n-    _currentStateMap = Collections.emptyMap();\n-    _snapshot = new CurrentStateSnapshot(_currentStateCache);\n+    _snapshot = new CurrentStateSnapshot(_participantStateCache);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MTM1OA=="}, "originalCommit": {"oid": "1953ef1a96b29fc51334d9aa7d9fb8f953298b2d"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjkyNDU5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/CurrentStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo0Nzo0MVrOFx5QpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo0Nzo0MVrOFx5QpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MjY5Mg==", "bodyText": "If the input participantStateKeys is always empty and is a return value, why not just let this method return a set for the keys?", "url": "https://github.com/apache/helix/pull/827#discussion_r387862692", "createdAt": "2020-03-04T18:47:41Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/CurrentStateCache.java", "diffHunk": "@@ -55,149 +46,33 @@ public CurrentStateCache(String clusterName) {\n \n   public CurrentStateCache(ControlContextProvider contextProvider) {\n     super(contextProvider);\n-    _currentStateMap = Collections.emptyMap();\n-    _snapshot = new CurrentStateSnapshot(_currentStateCache);\n+    _snapshot = new CurrentStateSnapshot(_participantStateCache);\n   }\n \n-  /**\n-   * This refreshes the CurrentStates data by re-fetching the data from zookeeper in an efficient\n-   * way\n-   *\n-   * @param accessor\n-   * @param liveInstanceMap map of all liveInstances in cluster\n-   *\n-   * @return\n-   */\n-  public boolean refresh(HelixDataAccessor accessor,\n-      Map<String, LiveInstance> liveInstanceMap) {\n-    long startTime = System.currentTimeMillis();\n-\n-    refreshCurrentStatesCache(accessor, liveInstanceMap);\n-    Map<String, Map<String, Map<String, CurrentState>>> allCurStateMap = new HashMap<>();\n-    for (PropertyKey key : _currentStateCache.keySet()) {\n-      CurrentState currentState = _currentStateCache.get(key);\n-      String[] params = key.getParams();\n-      if (currentState != null && params.length >= 4) {\n-        String instanceName = params[1];\n-        String sessionId = params[2];\n-        String stateName = params[3];\n-        Map<String, Map<String, CurrentState>> instanceCurStateMap =\n-            allCurStateMap.get(instanceName);\n-        if (instanceCurStateMap == null) {\n-          instanceCurStateMap = Maps.newHashMap();\n-          allCurStateMap.put(instanceName, instanceCurStateMap);\n-        }\n-        Map<String, CurrentState> sessionCurStateMap = instanceCurStateMap.get(sessionId);\n-        if (sessionCurStateMap == null) {\n-          sessionCurStateMap = Maps.newHashMap();\n-          instanceCurStateMap.put(sessionId, sessionCurStateMap);\n-        }\n-        sessionCurStateMap.put(stateName, currentState);\n-      }\n-    }\n-\n-    for (String instance : allCurStateMap.keySet()) {\n-      allCurStateMap.put(instance, Collections.unmodifiableMap(allCurStateMap.get(instance)));\n-    }\n-    _currentStateMap = Collections.unmodifiableMap(allCurStateMap);\n-\n-    long endTime = System.currentTimeMillis();\n-    LogUtil.logInfo(LOG, genEventInfo(),\n-        \"END: CurrentStateCache.refresh() for cluster \" + _controlContextProvider.getClusterName()\n-            + \", started at : \" + startTime + \", took \" + (endTime - startTime) + \" ms\");\n-    if (LOG.isDebugEnabled()) {\n-      LogUtil.logDebug(LOG, genEventInfo(),\n-          String.format(\"Current State refreshed : %s\", _currentStateMap.toString()));\n+  protected void refreshSnapshot(Map<PropertyKey, CurrentState> newStateCache,\n+      Map<PropertyKey, CurrentState> participantStateCache, Set<PropertyKey> reloadedKeys) {\n+    if (_initialized) {\n+      _snapshot = new CurrentStateSnapshot(newStateCache, participantStateCache, reloadedKeys);\n+    } else {\n+      _snapshot = new CurrentStateSnapshot(newStateCache);\n+      _initialized = true;\n     }\n-    return true;\n   }\n \n-  // reload current states that has been changed from zk to local cache.\n-  private void refreshCurrentStatesCache(HelixDataAccessor accessor,\n-      Map<String, LiveInstance> liveInstanceMap) {\n-\n-    long start = System.currentTimeMillis();\n+  public void PopulateParticipantKeys(HelixDataAccessor accessor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1953ef1a96b29fc51334d9aa7d9fb8f953298b2d"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjkzMzQyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo1MDozMVrOFx5WiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo1MDo0N1rOFx5XIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NDIwMQ==", "bodyText": "This should be an abstract method with no implementation. So the child class is required to implement it.", "url": "https://github.com/apache/helix/pull/827#discussion_r387864201", "createdAt": "2020-03-04T18:50:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represent a cache that holds a certain participant side state of for the whole cluster.\n+ */\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class);\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an\n+   * efficient way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    // There should be 4 levels of keys. The first one is the cluster name, the second one is the\n+    // instance name, the third one is a customized key (could be session Id or customized state\n+    // type), the fourth one is the resourceName\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String instanceName = params[1];\n+        String customizedName = params[2];\n+        String resourceName = params[3];\n+        Map<String, Map<String, T>> instanceMap = allParticipantStateMap.get(instanceName);\n+        if (instanceMap == null) {\n+          instanceMap = Maps.newHashMap();\n+          allParticipantStateMap.put(instanceName, instanceMap);\n+        }\n+        Map<String, T> customizedMap = instanceMap.get(customizedName);\n+        if (customizedMap == null) {\n+          customizedMap = Maps.newHashMap();\n+          instanceMap.put(customizedName, customizedMap);\n+        }\n+        customizedMap.put(resourceName, participantState);\n+      } else {\n+        LogUtil.logError(LOG, genEventInfo(),\n+            \"Invalid key found in the participant state cache\" + key);\n+      }\n+    }\n+\n+    _participantStateMap = Collections.unmodifiableMap(allParticipantStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: participantStateCache.refresh() for cluster \"\n+            + _controlContextProvider.getClusterName() + \", started at : \" + startTime + \", took \"\n+            + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Participant State refreshed : %s\", _participantStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload participant states that has been changed from zk to local cache.\n+  private void refreshParticipantStatesCacheFromZk(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled,\n+      Set<String> restrictedKeys) {\n+\n+    long start = System.currentTimeMillis();\n+    Set<PropertyKey> participantStateKeys = new HashSet<>();\n+    PopulateParticipantKeys(accessor, participantStateKeys, liveInstanceMap, restrictedKeys);\n+\n+    // All new entries from zk not cached locally yet should be read from ZK.\n+    Set<PropertyKey> reloadKeys = new HashSet<>(participantStateKeys);\n+    reloadKeys.removeAll(_participantStateCache.keySet());\n+\n+    Set<PropertyKey> cachedKeys = new HashSet<>(_participantStateCache.keySet());\n+    cachedKeys.retainAll(participantStateKeys);\n+\n+    Set<PropertyKey> reloadedKeys = new HashSet<>();\n+    Map<PropertyKey, T> newStateCache = Collections.unmodifiableMap(refreshProperties(accessor,\n+        reloadKeys, new ArrayList<>(cachedKeys), _participantStateCache, reloadedKeys));\n+\n+    if (snapshotEnabled) {\n+      refreshSnapshot(newStateCache, _participantStateCache, reloadedKeys);\n+    }\n+\n+    _participantStateCache = newStateCache;\n+\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(), \"# of participant state reload: \" + reloadKeys.size()\n+          + \", skipped:\" + (participantStateKeys.size() - reloadKeys.size()) + \". took \"\n+          + (System.currentTimeMillis() - start)\n+          + \" ms to reload new participant states for cluster: \"\n+          + _controlContextProvider.getClusterName() + \"and state: \" + this.getClass().getName());\n+    }\n+  }\n+\n+  public void PopulateParticipantKeys(HelixDataAccessor accessor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1953ef1a96b29fc51334d9aa7d9fb8f953298b2d"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NDM1NA==", "bodyText": "Usually, this class should be protected only. Since it is only called in side this class.", "url": "https://github.com/apache/helix/pull/827#discussion_r387864354", "createdAt": "2020-03-04T18:50:47Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represent a cache that holds a certain participant side state of for the whole cluster.\n+ */\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class);\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an\n+   * efficient way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    // There should be 4 levels of keys. The first one is the cluster name, the second one is the\n+    // instance name, the third one is a customized key (could be session Id or customized state\n+    // type), the fourth one is the resourceName\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String instanceName = params[1];\n+        String customizedName = params[2];\n+        String resourceName = params[3];\n+        Map<String, Map<String, T>> instanceMap = allParticipantStateMap.get(instanceName);\n+        if (instanceMap == null) {\n+          instanceMap = Maps.newHashMap();\n+          allParticipantStateMap.put(instanceName, instanceMap);\n+        }\n+        Map<String, T> customizedMap = instanceMap.get(customizedName);\n+        if (customizedMap == null) {\n+          customizedMap = Maps.newHashMap();\n+          instanceMap.put(customizedName, customizedMap);\n+        }\n+        customizedMap.put(resourceName, participantState);\n+      } else {\n+        LogUtil.logError(LOG, genEventInfo(),\n+            \"Invalid key found in the participant state cache\" + key);\n+      }\n+    }\n+\n+    _participantStateMap = Collections.unmodifiableMap(allParticipantStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: participantStateCache.refresh() for cluster \"\n+            + _controlContextProvider.getClusterName() + \", started at : \" + startTime + \", took \"\n+            + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Participant State refreshed : %s\", _participantStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload participant states that has been changed from zk to local cache.\n+  private void refreshParticipantStatesCacheFromZk(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled,\n+      Set<String> restrictedKeys) {\n+\n+    long start = System.currentTimeMillis();\n+    Set<PropertyKey> participantStateKeys = new HashSet<>();\n+    PopulateParticipantKeys(accessor, participantStateKeys, liveInstanceMap, restrictedKeys);\n+\n+    // All new entries from zk not cached locally yet should be read from ZK.\n+    Set<PropertyKey> reloadKeys = new HashSet<>(participantStateKeys);\n+    reloadKeys.removeAll(_participantStateCache.keySet());\n+\n+    Set<PropertyKey> cachedKeys = new HashSet<>(_participantStateCache.keySet());\n+    cachedKeys.retainAll(participantStateKeys);\n+\n+    Set<PropertyKey> reloadedKeys = new HashSet<>();\n+    Map<PropertyKey, T> newStateCache = Collections.unmodifiableMap(refreshProperties(accessor,\n+        reloadKeys, new ArrayList<>(cachedKeys), _participantStateCache, reloadedKeys));\n+\n+    if (snapshotEnabled) {\n+      refreshSnapshot(newStateCache, _participantStateCache, reloadedKeys);\n+    }\n+\n+    _participantStateCache = newStateCache;\n+\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(), \"# of participant state reload: \" + reloadKeys.size()\n+          + \", skipped:\" + (participantStateKeys.size() - reloadKeys.size()) + \". took \"\n+          + (System.currentTimeMillis() - start)\n+          + \" ms to reload new participant states for cluster: \"\n+          + _controlContextProvider.getClusterName() + \"and state: \" + this.getClass().getName());\n+    }\n+  }\n+\n+  public void PopulateParticipantKeys(HelixDataAccessor accessor,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NDIwMQ=="}, "originalCommit": {"oid": "1953ef1a96b29fc51334d9aa7d9fb8f953298b2d"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjkzNzQyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo1MTo0M1rOFx5ZMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo1MTo0M1rOFx5ZMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NDg4Mw==", "bodyText": "This one as well. Try to use more abstract methods if the implementation is not possible in this abstract class.", "url": "https://github.com/apache/helix/pull/827#discussion_r387864883", "createdAt": "2020-03-04T18:51:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represent a cache that holds a certain participant side state of for the whole cluster.\n+ */\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class);\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an\n+   * efficient way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Boolean snapshotEnabled, Set<String> restrictedKeys) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled, restrictedKeys);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    // There should be 4 levels of keys. The first one is the cluster name, the second one is the\n+    // instance name, the third one is a customized key (could be session Id or customized state\n+    // type), the fourth one is the resourceName\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String instanceName = params[1];\n+        String customizedName = params[2];\n+        String resourceName = params[3];\n+        Map<String, Map<String, T>> instanceMap = allParticipantStateMap.get(instanceName);\n+        if (instanceMap == null) {\n+          instanceMap = Maps.newHashMap();\n+          allParticipantStateMap.put(instanceName, instanceMap);\n+        }\n+        Map<String, T> customizedMap = instanceMap.get(customizedName);\n+        if (customizedMap == null) {\n+          customizedMap = Maps.newHashMap();\n+          instanceMap.put(customizedName, customizedMap);\n+        }\n+        customizedMap.put(resourceName, participantState);\n+      } else {\n+        LogUtil.logError(LOG, genEventInfo(),\n+            \"Invalid key found in the participant state cache\" + key);\n+      }\n+    }\n+\n+    _participantStateMap = Collections.unmodifiableMap(allParticipantStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: participantStateCache.refresh() for cluster \"\n+            + _controlContextProvider.getClusterName() + \", started at : \" + startTime + \", took \"\n+            + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Participant State refreshed : %s\", _participantStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload participant states that has been changed from zk to local cache.\n+  private void refreshParticipantStatesCacheFromZk(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled,\n+      Set<String> restrictedKeys) {\n+\n+    long start = System.currentTimeMillis();\n+    Set<PropertyKey> participantStateKeys = new HashSet<>();\n+    PopulateParticipantKeys(accessor, participantStateKeys, liveInstanceMap, restrictedKeys);\n+\n+    // All new entries from zk not cached locally yet should be read from ZK.\n+    Set<PropertyKey> reloadKeys = new HashSet<>(participantStateKeys);\n+    reloadKeys.removeAll(_participantStateCache.keySet());\n+\n+    Set<PropertyKey> cachedKeys = new HashSet<>(_participantStateCache.keySet());\n+    cachedKeys.retainAll(participantStateKeys);\n+\n+    Set<PropertyKey> reloadedKeys = new HashSet<>();\n+    Map<PropertyKey, T> newStateCache = Collections.unmodifiableMap(refreshProperties(accessor,\n+        reloadKeys, new ArrayList<>(cachedKeys), _participantStateCache, reloadedKeys));\n+\n+    if (snapshotEnabled) {\n+      refreshSnapshot(newStateCache, _participantStateCache, reloadedKeys);\n+    }\n+\n+    _participantStateCache = newStateCache;\n+\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(), \"# of participant state reload: \" + reloadKeys.size()\n+          + \", skipped:\" + (participantStateKeys.size() - reloadKeys.size()) + \". took \"\n+          + (System.currentTimeMillis() - start)\n+          + \" ms to reload new participant states for cluster: \"\n+          + _controlContextProvider.getClusterName() + \"and state: \" + this.getClass().getName());\n+    }\n+  }\n+\n+  public void PopulateParticipantKeys(HelixDataAccessor accessor,\n+      Set<PropertyKey> participantStateKeys, Map<String, LiveInstance> liveInstanceMap,\n+      Set<String> restrictedKeys) {\n+  }\n+\n+  protected void refreshSnapshot(Map<PropertyKey, T> newStateCache,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1953ef1a96b29fc51334d9aa7d9fb8f953298b2d"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjk3MDcwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTowMTozOFrOFx5uXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTowMTozOFrOFx5uXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3MDMwMw==", "bodyText": "As we talked offline, let's try to hide restrictedKeys as an internal field and don't require the caller to pass on every refresh call.", "url": "https://github.com/apache/helix/pull/827#discussion_r387870303", "createdAt": "2020-03-04T19:01:38Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represent a cache that holds a certain participant side state of for the whole cluster.\n+ */\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class);\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = Collections.emptyMap();\n+  }\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an\n+   * efficient way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Boolean snapshotEnabled, Set<String> restrictedKeys) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1953ef1a96b29fc51334d9aa7d9fb8f953298b2d"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDUwNjAxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxMToxNlrOFyIe7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxMToxNlrOFyIe7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExMjEwOQ==", "bodyText": "Should this boolean be fixed once the class is coded? Overall, I don't think we need it. Just call refreshSnapshot() anyway. If there is no such implementation, the child class won't implement it anyway.", "url": "https://github.com/apache/helix/pull/827#discussion_r388112109", "createdAt": "2020-03-05T07:11:16Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Represent a cache that holds a certain participant side state of for the whole cluster.\n+ */\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class);\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = new HashMap<>();\n+  }\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an\n+   * efficient way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Boolean snapshotEnabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572f7a3a369f1c604205e0b1d3fd55caeb71934"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDUwODQ0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxMjozOFrOFyIgfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxMjozOFrOFyIgfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExMjUxMQ==", "bodyText": "Since the customized state cache won't support snapshot for now, just comment on this method as OPTIONAL to be implemented. If the child class does not support snapshot, just do nothing. And we don't need the boolean to differentiate.\nWe might want to support it later though.", "url": "https://github.com/apache/helix/pull/827#discussion_r388112511", "createdAt": "2020-03-05T07:12:38Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/common/caches/ParticipantStateCache.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.apache.helix.common.caches;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import com.google.common.collect.Maps;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.controllers.ControlContextProvider;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Represent a cache that holds a certain participant side state of for the whole cluster.\n+ */\n+public abstract class ParticipantStateCache<T> extends AbstractDataCache {\n+  private static Logger LOG = LoggerFactory.getLogger(ParticipantStateCache.class);\n+  protected Map<String, Map<String, Map<String, T>>> _participantStateMap;\n+\n+  protected Map<PropertyKey, T> _participantStateCache = Maps.newHashMap();\n+\n+  public ParticipantStateCache(ControlContextProvider controlContextProvider) {\n+    super(controlContextProvider);\n+    _participantStateMap = new HashMap<>();\n+  }\n+\n+  /**\n+   * This refreshes the participant state cache data by re-fetching the data from zookeeper in an\n+   * efficient way\n+   * @param accessor\n+   * @param liveInstanceMap map of all liveInstances in cluster\n+   * @return\n+   */\n+  public boolean refresh(HelixDataAccessor accessor, Map<String, LiveInstance> liveInstanceMap,\n+      Boolean snapshotEnabled) {\n+    long startTime = System.currentTimeMillis();\n+\n+    refreshParticipantStatesCacheFromZk(accessor, liveInstanceMap, snapshotEnabled);\n+    Map<String, Map<String, Map<String, T>>> allParticipantStateMap = new HashMap<>();\n+    // There should be 4 levels of keys. The first one is the cluster name, the second one is the\n+    // instance name, the third one is a customized key (could be session Id or customized state\n+    // type), the fourth one is the resourceName\n+    for (PropertyKey key : _participantStateCache.keySet()) {\n+      T participantState = _participantStateCache.get(key);\n+      String[] params = key.getParams();\n+      if (participantState != null && params.length >= 4) {\n+        String instanceName = params[1];\n+        String customizedName = params[2];\n+        String resourceName = params[3];\n+        Map<String, Map<String, T>> instanceMap = allParticipantStateMap.get(instanceName);\n+        if (instanceMap == null) {\n+          instanceMap = Maps.newHashMap();\n+          allParticipantStateMap.put(instanceName, instanceMap);\n+        }\n+        Map<String, T> customizedMap = instanceMap.get(customizedName);\n+        if (customizedMap == null) {\n+          customizedMap = Maps.newHashMap();\n+          instanceMap.put(customizedName, customizedMap);\n+        }\n+        customizedMap.put(resourceName, participantState);\n+      } else {\n+        LogUtil.logError(LOG, genEventInfo(), \"Invalid key found in the participant state cache\" + key);\n+      }\n+    }\n+\n+    _participantStateMap = Collections.unmodifiableMap(allParticipantStateMap);\n+\n+    long endTime = System.currentTimeMillis();\n+    LogUtil.logInfo(LOG, genEventInfo(),\n+        \"END: participantStateCache.refresh() for cluster \" + _controlContextProvider.getClusterName()\n+            + \", started at : \" + startTime + \", took \" + (endTime - startTime) + \" ms\");\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          String.format(\"Participant State refreshed : %s\", _participantStateMap.toString()));\n+    }\n+    return true;\n+  }\n+\n+  // reload participant states that has been changed from zk to local cache.\n+  private void refreshParticipantStatesCacheFromZk(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap, Boolean snapshotEnabled) {\n+\n+    long start = System.currentTimeMillis();\n+    Set<PropertyKey> participantStateKeys = PopulateParticipantKeys(accessor, liveInstanceMap);\n+\n+    // All new entries from zk not cached locally yet should be read from ZK.\n+    Set<PropertyKey> reloadKeys = new HashSet<>(participantStateKeys);\n+    reloadKeys.removeAll(_participantStateCache.keySet());\n+\n+    Set<PropertyKey> cachedKeys = new HashSet<>(_participantStateCache.keySet());\n+    cachedKeys.retainAll(participantStateKeys);\n+\n+    Set<PropertyKey> reloadedKeys = new HashSet<>();\n+    Map<PropertyKey, T> newStateCache = Collections.unmodifiableMap(\n+        refreshProperties(accessor, reloadKeys, new ArrayList<>(cachedKeys), _participantStateCache, reloadedKeys));\n+\n+    if (snapshotEnabled) {\n+      refreshSnapshot(newStateCache, _participantStateCache, reloadedKeys);\n+    }\n+\n+    _participantStateCache = newStateCache;\n+\n+    if (LOG.isDebugEnabled()) {\n+      LogUtil.logDebug(LOG, genEventInfo(),\n+          \"# of participant state reload: \" + reloadKeys.size() + \", skipped:\" + (participantStateKeys.size()\n+              - reloadKeys.size()) + \". took \" + (System.currentTimeMillis() - start)\n+              + \" ms to reload new participant states for cluster: \" + _controlContextProvider.getClusterName()\n+              + \"and state: \" + this.getClass().getName());\n+    }\n+  }\n+\n+  protected abstract Set<PropertyKey> PopulateParticipantKeys(HelixDataAccessor accessor,\n+      Map<String, LiveInstance> liveInstanceMap);\n+\n+  protected abstract void refreshSnapshot(Map<PropertyKey, T> newStateCache, Map<PropertyKey, T> participantStateCache,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572f7a3a369f1c604205e0b1d3fd55caeb71934"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDUxOTM4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxODoyN1rOFyInHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxODoyN1rOFyInHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExNDIwNg==", "bodyText": "Intuitively, this one should be called getCustomizedStateMap()", "url": "https://github.com/apache/helix/pull/827#discussion_r388114206", "createdAt": "2020-03-05T07:18:27Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;\n+\n+  public CustomizedStateOutput() {\n+    _customizedStateMap = new HashMap<>();\n+    _customizedStateMetaMap = new HashMap<>();\n+  }\n+\n+  public void setCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    if (!_customizedStateMap.containsKey(stateType)) {\n+      _customizedStateMap.put(stateType,\n+          new HashMap<String, Map<Partition, Map<String, String>>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n+      _customizedStateMap.get(stateType).put(resourceName,\n+          new HashMap<Partition, Map<String, String>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n+      _customizedStateMap.get(stateType).get(resourceName).put(partition,\n+          new HashMap<String, String>());\n+    }\n+    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+  }\n+\n+  /**\n+   * Given stateType, returns resource customized state map (resource -> parition -> instance ->\n+   * customizedState)\n+   * @param stateType\n+   * @return\n+   */\n+  public Map<String, Map<Partition, Map<String, String>>> getResourceCustomizedStateMap(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572f7a3a369f1c604205e0b1d3fd55caeb71934"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDUyMDA0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxODo0NFrOFyIngw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxODo0NFrOFyIngw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExNDMwNw==", "bodyText": "Intuitively, this one should be called getResourceCustomizedStateMap()", "url": "https://github.com/apache/helix/pull/827#discussion_r388114307", "createdAt": "2020-03-05T07:18:44Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;\n+\n+  public CustomizedStateOutput() {\n+    _customizedStateMap = new HashMap<>();\n+    _customizedStateMetaMap = new HashMap<>();\n+  }\n+\n+  public void setCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    if (!_customizedStateMap.containsKey(stateType)) {\n+      _customizedStateMap.put(stateType,\n+          new HashMap<String, Map<Partition, Map<String, String>>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n+      _customizedStateMap.get(stateType).put(resourceName,\n+          new HashMap<Partition, Map<String, String>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n+      _customizedStateMap.get(stateType).get(resourceName).put(partition,\n+          new HashMap<String, String>());\n+    }\n+    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+  }\n+\n+  /**\n+   * Given stateType, returns resource customized state map (resource -> parition -> instance ->\n+   * customizedState)\n+   * @param stateType\n+   * @return\n+   */\n+  public Map<String, Map<Partition, Map<String, String>>> getResourceCustomizedStateMap(\n+      String stateType) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      return Collections.unmodifiableMap(_customizedStateMap.get(stateType));\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource), returns (partition -> instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @return\n+   */\n+  public Map<Partition, Map<String, String>> getPartitionCustomizedStateMap(String stateType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572f7a3a369f1c604205e0b1d3fd55caeb71934"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDUyMDQwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxODo1NlrOFyIntw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxODo1NlrOFyIntw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExNDM1OQ==", "bodyText": "Intuitively, this one should be called getPartitionCustomizedStateMap()", "url": "https://github.com/apache/helix/pull/827#discussion_r388114359", "createdAt": "2020-03-05T07:18:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;\n+\n+  public CustomizedStateOutput() {\n+    _customizedStateMap = new HashMap<>();\n+    _customizedStateMetaMap = new HashMap<>();\n+  }\n+\n+  public void setCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    if (!_customizedStateMap.containsKey(stateType)) {\n+      _customizedStateMap.put(stateType,\n+          new HashMap<String, Map<Partition, Map<String, String>>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n+      _customizedStateMap.get(stateType).put(resourceName,\n+          new HashMap<Partition, Map<String, String>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n+      _customizedStateMap.get(stateType).get(resourceName).put(partition,\n+          new HashMap<String, String>());\n+    }\n+    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+  }\n+\n+  /**\n+   * Given stateType, returns resource customized state map (resource -> parition -> instance ->\n+   * customizedState)\n+   * @param stateType\n+   * @return\n+   */\n+  public Map<String, Map<Partition, Map<String, String>>> getResourceCustomizedStateMap(\n+      String stateType) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      return Collections.unmodifiableMap(_customizedStateMap.get(stateType));\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource), returns (partition -> instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @return\n+   */\n+  public Map<Partition, Map<String, String>> getPartitionCustomizedStateMap(String stateType,\n+      String resourceName) {\n+    if (getResourceCustomizedStateMap(stateType).containsKey(resourceName)) {\n+      return Collections\n+          .unmodifiableMap(getResourceCustomizedStateMap(stateType).get(resourceName));\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition), returns (instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @return\n+   */\n+  public Map<String, String> getInstanceCustomizedStateMap(String stateType, String resourceName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572f7a3a369f1c604205e0b1d3fd55caeb71934"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDUyMTY4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxOTo0MFrOFyIoeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoxOTo0MFrOFyIoeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExNDU1Mg==", "bodyText": "This one can be called getReplicaCustomizedState()", "url": "https://github.com/apache/helix/pull/827#discussion_r388114552", "createdAt": "2020-03-05T07:19:40Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;\n+\n+  public CustomizedStateOutput() {\n+    _customizedStateMap = new HashMap<>();\n+    _customizedStateMetaMap = new HashMap<>();\n+  }\n+\n+  public void setCustomizedState(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    if (!_customizedStateMap.containsKey(stateType)) {\n+      _customizedStateMap.put(stateType,\n+          new HashMap<String, Map<Partition, Map<String, String>>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n+      _customizedStateMap.get(stateType).put(resourceName,\n+          new HashMap<Partition, Map<String, String>>());\n+    }\n+    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n+      _customizedStateMap.get(stateType).get(resourceName).put(partition,\n+          new HashMap<String, String>());\n+    }\n+    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+  }\n+\n+  /**\n+   * Given stateType, returns resource customized state map (resource -> parition -> instance ->\n+   * customizedState)\n+   * @param stateType\n+   * @return\n+   */\n+  public Map<String, Map<Partition, Map<String, String>>> getResourceCustomizedStateMap(\n+      String stateType) {\n+    if (_customizedStateMap.containsKey(stateType)) {\n+      return Collections.unmodifiableMap(_customizedStateMap.get(stateType));\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource), returns (partition -> instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @return\n+   */\n+  public Map<Partition, Map<String, String>> getPartitionCustomizedStateMap(String stateType,\n+      String resourceName) {\n+    if (getResourceCustomizedStateMap(stateType).containsKey(resourceName)) {\n+      return Collections\n+          .unmodifiableMap(getResourceCustomizedStateMap(stateType).get(resourceName));\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition), returns (instance-> customizedState) map\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @return\n+   */\n+  public Map<String, String> getInstanceCustomizedStateMap(String stateType, String resourceName,\n+      Partition partition) {\n+    if (getResourceCustomizedStateMap(stateType).containsKey(resourceName)\n+        && getPartitionCustomizedStateMap(stateType, resourceName).containsKey(partition)) {\n+      return Collections\n+          .unmodifiableMap(getPartitionCustomizedStateMap(stateType, resourceName).get(partition));\n+\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * given (stateType, resource, partition, instance), returns customized state\n+   * @param stateType\n+   * @param resourceName\n+   * @param partition\n+   * @param instanceName\n+   * @return\n+   */\n+  public String getCustomizedState(String stateType, String resourceName, Partition partition,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572f7a3a369f1c604205e0b1d3fd55caeb71934"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDUyMzA1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoyMDoyNlrOFyIpUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzoyMDoyNlrOFyIpUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExNDc2OA==", "bodyText": "How this is used? I would suggest adding this only when we have the usage in the PR.", "url": "https://github.com/apache/helix/pull/827#discussion_r388114768", "createdAt": "2020-03-05T07:20:26Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.Partition;\n+\n+public class CustomizedStateOutput {\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+\n+  private final Map<String, CustomizedState> _customizedStateMetaMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572f7a3a369f1c604205e0b1d3fd55caeb71934"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1698, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}