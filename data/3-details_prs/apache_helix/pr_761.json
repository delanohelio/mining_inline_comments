{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MTY1MTE2", "number": 761, "title": "Add REST read endpoints to helix-rest for metadata store directory", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nImplements #752\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nWe have metadata store directory service to help scale out zookeeper. Metadata store directory service provides REST APIs to access.\nThis PR adds remaining MSDS read endpoints to Helix REST.\nTests\n\n\n The following tests are written for this issue:\n\n\ntestGetRealmShardingKeysUnderPath\n\n\ntestGetShardingKeysUnderPath\n\n\ntestGetMetadataStoreRealmWithShardingKey\n\n\ntestGetAllNamespaces\n\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n\n[INFO] Tests run: 127, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 26.348 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 127, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:01 min\n[INFO] Finished at: 2020-02-21T17:08:04-08:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-14T01:12:56Z", "url": "https://github.com/apache/helix/pull/761", "merged": true, "mergeCommit": {"oid": "2d5b77f5020b1b0c1cd211536ef653450a4cfeec"}, "closed": true, "closedAt": "2020-02-23T02:12:54Z", "author": {"login": "huizhilu"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcEFKV2AFqTM1ODY2MTQ2Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcG5MGbAFqTM2MzA0NTM2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjYxNDY3", "url": "https://github.com/apache/helix/pull/761#pullrequestreview-358661467", "createdAt": "2020-02-14T01:20:12Z", "commit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToyMDoxMlrOFppBUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToyMjowMlrOFppDEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODAxNw==", "bodyText": "Remove else clause.", "url": "https://github.com/apache/helix/pull/761#discussion_r379208017", "createdAt": "2020-02-14T01:20:12Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {\n     try {\n-      Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n-\n-      responseMap = new HashMap<>(1);\n-      responseMap.put(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+      if (shardingKey == null) {\n+        Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n+        Map<String, Collection<String>> responseMap =\n+            ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+        return JSONRepresentation(responseMap);\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODIzNA==", "bodyText": "Shall we define different response object instead of using plain Response.", "url": "https://github.com/apache/helix/pull/761#discussion_r379208234", "createdAt": "2020-02-14T01:21:05Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ==", "bodyText": "This logic is very complex. Can we leverage the default value to simplify the logic?", "url": "https://github.com/apache/helix/pull/761#discussion_r379208465", "createdAt": "2020-02-14T01:22:02Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -111,41 +132,56 @@ public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   }\n \n   /**\n-   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n-   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n-   * a realm.\n+   * Gets all sharding keys mapped at paths:\n+   * - \"HTTP GET /sharding-keys\" which returns all sharding keys in a namespace.\n+   * - \"HTTP GET /sharding-keys?realm={realm}\" which returns sharding keys in the realm.\n+   * - \"HTTP GET /sharding-keys?prefix={prefix}\" which returns sharding keys that have the prefix.\n+   * -- JSON response example for this path:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *    }, {\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/e\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/b\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/a\"\n+   *  }]\n+   * }\n+   *\n+   * - \"HTTP GET /sharding-keys?realm={realm}&prefix={prefix}\" which returns sharding keys in the\n+   * realm and that have the prefix.\n    *\n-   * @param realm Query param in endpoint path\n-   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   * @param realm Query param in endpoint path: metadata store realm.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return Json representation for the sharding keys.\n    */\n   @GET\n   @Path(\"/sharding-keys\")\n-  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n-    Map<String, Object> responseMap;\n-    Collection<String> shardingKeys;\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm,\n+      @QueryParam(\"prefix\") String prefix) {\n     try {\n-      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n-      // to get all sharding keys in a namespace.\n-      if (realm == null) {\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeys(_namespace);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS.\n-        responseMap = new HashMap<>(1);\n+      if (realm == null && prefix == null) {\n+        // For endpoint: \"/sharding-keys\" to get all sharding keys in a namespace.\n+        return getAllShardingKeys();\n+      } else if (prefix == null) {\n+        // For endpoint: \"/sharding-keys?realm={realm}\"\n+        return getAllShardingKeysInRealm(realm);\n+      } else if (realm == null) {\n+        // For endpoint: \"/sharding-keys?prefix={prefix}\"\n+        return getAllShardingKeysUnderPath(prefix);\n       } else {\n-        // For endpoint: \"/sharding-keys?realm={realmName}\"\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeysInRealm(_namespace, realm);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS and SINGLE_METADATA_STORE_REALM.\n-        responseMap = new HashMap<>(2);\n-        responseMap.put(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM, realm);\n+        // For endpoint: \"/sharding-keys?realm={realm}&prefix={prefix}\"\n+        return getRealmShardingKeysUnderPath(realm, prefix);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjczMjM2", "url": "https://github.com/apache/helix/pull/761#pullrequestreview-358673236", "createdAt": "2020-02-14T02:03:25Z", "commit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMjowMzoyNVrOFppoag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMjo1MToyNlrOFpqQCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxODAyNg==", "bodyText": "SHARDING_KEY_PREFIX's naming got me thinking for a little bit and I couldn't figure it out. Could we rename this?\nI think something like SHARDING_KEY_PATH_PREFIX would be more descriptive. To also help with understanding, could we please add where it's going to be used? (like getAllMappingUnderPath() for example).", "url": "https://github.com/apache/helix/pull/761#discussion_r379218026", "createdAt": "2020-02-14T02:03:25Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -28,14 +28,21 @@\n   // Leader election ZNode for ZkRoutingDataWriter\n   public static final String LEADER_ELECTION_ZNODE = \"/_ZK_ROUTING_DATA_WRITER_LEADER\";\n \n+  // Field name in JSON REST response of getting all metadata store namespaces.\n+  public static final String METADATA_STORE_NAMESPACES = \"namespaces\";\n+\n   // Field name in JSON REST response of getting metadata store realms in one namespace.\n   public static final String METADATA_STORE_REALMS = \"metadataStoreRealms\";\n \n   // Field name in JSON REST response of getting sharding keys in one realm.\n-  public static final String SINGLE_METADATA_STORE_REALM = \"metadataStoreRealm\";\n+  public static final String SINGLE_METADATA_STORE_REALM = \"realm\";\n \n   // Field name in JSON REST response of getting sharding keys.\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n+  // Field name in JSON REST response related to one single sharding key.\n+  public static final String SINGLE_SHARDING_KEY = \"shardingKey\";\n \n+  // Field name in JSON REST response of getting sharding keys with prefix.\n+  public static final String SHARDING_KEY_PREFIX = \"prefix\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxODM2NQ==", "bodyText": "Is this else needed?", "url": "https://github.com/apache/helix/pull/761#discussion_r379218365", "createdAt": "2020-02-14T02:05:06Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {\n     try {\n-      Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n-\n-      responseMap = new HashMap<>(1);\n-      responseMap.put(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+      if (shardingKey == null) {\n+        Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n+        Map<String, Collection<String>> responseMap =\n+            ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+        return JSONRepresentation(responseMap);\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxODY4NA==", "bodyText": "could we also document the difference in behavior depending on whether the query param is given?", "url": "https://github.com/apache/helix/pull/761#discussion_r379218684", "createdAt": "2020-02-14T02:06:40Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyMzkyMg==", "bodyText": "Since this path resource seems to be doing two things, should we rename this to getMetadataStoreRealm()?", "url": "https://github.com/apache/helix/pull/761#discussion_r379223922", "createdAt": "2020-02-14T02:31:13Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNzkwOQ==", "bodyText": "Or better yet, should we consider breaking this up into two different path resources to eliminate if-elses?", "url": "https://github.com/apache/helix/pull/761#discussion_r379227909", "createdAt": "2020-02-14T02:50:13Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -66,24 +67,44 @@ private void postConstruct() {\n   }\n \n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyODE3MA==", "bodyText": "I have a feeling that this path resource is again doing too many things. Do you think we should consider breaking this up into different path resources?", "url": "https://github.com/apache/helix/pull/761#discussion_r379228170", "createdAt": "2020-02-14T02:51:26Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -111,41 +132,56 @@ public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   }\n \n   /**\n-   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n-   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n-   * a realm.\n+   * Gets all sharding keys mapped at paths:\n+   * - \"HTTP GET /sharding-keys\" which returns all sharding keys in a namespace.\n+   * - \"HTTP GET /sharding-keys?realm={realm}\" which returns sharding keys in the realm.\n+   * - \"HTTP GET /sharding-keys?prefix={prefix}\" which returns sharding keys that have the prefix.\n+   * -- JSON response example for this path:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *    }, {\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/e\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/b\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/a\"\n+   *  }]\n+   * }\n+   *\n+   * - \"HTTP GET /sharding-keys?realm={realm}&prefix={prefix}\" which returns sharding keys in the\n+   * realm and that have the prefix.\n    *\n-   * @param realm Query param in endpoint path\n-   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   * @param realm Query param in endpoint path: metadata store realm.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return Json representation for the sharding keys.\n    */\n   @GET\n   @Path(\"/sharding-keys\")\n-  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n-    Map<String, Object> responseMap;\n-    Collection<String> shardingKeys;\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 117}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d14437c0c47338ae90422644d3ba5ec24391729c", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/d14437c0c47338ae90422644d3ba5ec24391729c", "committedDate": "2020-02-14T07:08:10Z", "message": "Add getRealmShardingKeys endpoint."}, "afterCommit": {"oid": "2683c3acd706878f78a4d9b9619b122da9b62db8", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/2683c3acd706878f78a4d9b9619b122da9b62db8", "committedDate": "2020-02-14T07:29:19Z", "message": "Add getRealmShardingKeys endpoint."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzQzMjcy", "url": "https://github.com/apache/helix/pull/761#pullrequestreview-360743272", "createdAt": "2020-02-18T23:16:36Z", "commit": {"oid": "f0e4734ac029985e0b82c9e2b9dc03c868b0ea1b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzoxNjozN1rOFrV86g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzoxNjozN1rOFrV86g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5Mjc0Ng==", "bodyText": "Given my understanding to the status code, badRequest is more suitable than notFound in this situation. What notFound entails is that this url is not matched to anything, however in this situation, the url is correctly connecting to the endpoint. Returning notFound might cause confusion.\nI understand that badRequest is not perfect in this case either, but it should be more suitable than notFound. If you have a better idea, I'm happy to discuss. (Ref: https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)", "url": "https://github.com/apache/helix/pull/761#discussion_r380992746", "createdAt": "2020-02-18T23:16:37Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -111,41 +135,74 @@ public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   }\n \n   /**\n-   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n-   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n-   * a realm.\n+   * Gets all sharding keys mapped at paths:\n+   * - \"HTTP GET /sharding-keys\" which returns all sharding keys in a namespace.\n+   * - \"HTTP GET /sharding-keys?realm={realm}\" which returns sharding keys in the realm.\n+   * - \"HTTP GET /sharding-keys?prefix={prefix}\" which returns sharding keys that have the prefix.\n+   * -- JSON response example for this path:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *    }, {\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/e\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/b\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/a\"\n+   *  }]\n+   * }\n    *\n-   * @param realm Query param in endpoint path\n-   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   * - \"HTTP GET /sharding-keys?realm={realm}&prefix={prefix}\" which returns sharding keys in the\n+   * realm and that have the prefix.\n+   *\n+   * @param realm Query param in endpoint path: metadata store realm.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return Json representation for the sharding keys.\n    */\n   @GET\n   @Path(\"/sharding-keys\")\n-  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n-    Map<String, Object> responseMap;\n-    Collection<String> shardingKeys;\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm,\n+      @QueryParam(\"prefix\") String prefix) {\n     try {\n-      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n-      // to get all sharding keys in a namespace.\n-      if (realm == null) {\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeys(_namespace);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS.\n-        responseMap = new HashMap<>(1);\n+      if (realm == null && prefix == null) {\n+        // For endpoint: \"/sharding-keys\" to get all sharding keys in a namespace.\n+        return getAllShardingKeys();\n+      } else if (prefix == null) {\n+        // For endpoint: \"/sharding-keys?realm={realm}\"\n+        return getAllShardingKeysInRealm(realm);\n+      } else if (realm == null) {\n+        // For endpoint: \"/sharding-keys?prefix={prefix}\"\n+        return getAllShardingKeysUnderPath(prefix);\n       } else {\n-        // For endpoint: \"/sharding-keys?realm={realmName}\"\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeysInRealm(_namespace, realm);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS and SINGLE_METADATA_STORE_REALM.\n-        responseMap = new HashMap<>(2);\n-        responseMap.put(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM, realm);\n+        // For endpoint: \"/sharding-keys?realm={realm}&prefix={prefix}\"\n+        return getRealmShardingKeysUnderPath(realm, prefix);\n       }\n     } catch (NoSuchElementException ex) {\n       return notFound(ex.getMessage());\n     }\n+  }\n \n-    responseMap.put(MetadataStoreRoutingConstants.SHARDING_KEYS, shardingKeys);\n-\n-    return JSONRepresentation(responseMap);\n+  /**\n+   * Gets all path-based sharding keys for a queried realm at endpoint:\n+   * \"GET /metadata-store-realms/{realm}/sharding-keys\". This endpoint is equivalent to\n+   * the endpoint: \"GET /sharding-keys?realm={realm}\".\n+   *\n+   * @param realm Queried metadata store realm to get sharding keys.\n+   * @return All path-based sharding keys in the queried realm.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms/{realm}/sharding-keys\")\n+  public Response getRealmShardingKeys(@PathParam(\"realm\") String realm) {\n+    try {\n+      return getAllShardingKeysInRealm(realm);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0e4734ac029985e0b82c9e2b9dc03c868b0ea1b"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzQ1NDE0", "url": "https://github.com/apache/helix/pull/761#pullrequestreview-360745414", "createdAt": "2020-02-18T23:21:59Z", "commit": {"oid": "f0e4734ac029985e0b82c9e2b9dc03c868b0ea1b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzoyMTo1OVrOFrWDag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzozMjoyOFrOFrWP5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5NDQxMA==", "bodyText": "There is a good way to simplify the logic here utilizing the default values as @dasahcc has mentioned. If the prefix is not provided, consider assigning \"/\" to the prefix variable and use the same logic as the situation where prefix exists.", "url": "https://github.com/apache/helix/pull/761#discussion_r380994410", "createdAt": "2020-02-18T23:21:59Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -111,41 +132,56 @@ public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   }\n \n   /**\n-   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n-   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n-   * a realm.\n+   * Gets all sharding keys mapped at paths:\n+   * - \"HTTP GET /sharding-keys\" which returns all sharding keys in a namespace.\n+   * - \"HTTP GET /sharding-keys?realm={realm}\" which returns sharding keys in the realm.\n+   * - \"HTTP GET /sharding-keys?prefix={prefix}\" which returns sharding keys that have the prefix.\n+   * -- JSON response example for this path:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *    }, {\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/e\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/b\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/a\"\n+   *  }]\n+   * }\n+   *\n+   * - \"HTTP GET /sharding-keys?realm={realm}&prefix={prefix}\" which returns sharding keys in the\n+   * realm and that have the prefix.\n    *\n-   * @param realm Query param in endpoint path\n-   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   * @param realm Query param in endpoint path: metadata store realm.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return Json representation for the sharding keys.\n    */\n   @GET\n   @Path(\"/sharding-keys\")\n-  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n-    Map<String, Object> responseMap;\n-    Collection<String> shardingKeys;\n+  public Response getShardingKeys(@QueryParam(\"realm\") String realm,\n+      @QueryParam(\"prefix\") String prefix) {\n     try {\n-      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n-      // to get all sharding keys in a namespace.\n-      if (realm == null) {\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeys(_namespace);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS.\n-        responseMap = new HashMap<>(1);\n+      if (realm == null && prefix == null) {\n+        // For endpoint: \"/sharding-keys\" to get all sharding keys in a namespace.\n+        return getAllShardingKeys();\n+      } else if (prefix == null) {\n+        // For endpoint: \"/sharding-keys?realm={realm}\"\n+        return getAllShardingKeysInRealm(realm);\n+      } else if (realm == null) {\n+        // For endpoint: \"/sharding-keys?prefix={prefix}\"\n+        return getAllShardingKeysUnderPath(prefix);\n       } else {\n-        // For endpoint: \"/sharding-keys?realm={realmName}\"\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeysInRealm(_namespace, realm);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS and SINGLE_METADATA_STORE_REALM.\n-        responseMap = new HashMap<>(2);\n-        responseMap.put(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM, realm);\n+        // For endpoint: \"/sharding-keys?realm={realm}&prefix={prefix}\"\n+        return getRealmShardingKeysUnderPath(realm, prefix);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQ2NQ=="}, "originalCommit": {"oid": "6e317a5bd7826842a1b5dee6fc12d13ce37b8ac3"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5NzYwNQ==", "bodyText": "When verifying a map, I'd make sure that \"it contains the right elements and only the right elements\". Therefore I usually perform a check on map length - without it if the map returns something extra and unexpected, the test cases would still incorrectly pass.", "url": "https://github.com/apache/helix/pull/761#discussion_r380997605", "createdAt": "2020-02-18T23:32:28Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/test/java/org/apache/helix/rest/server/resources/zookeeper/TestMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -110,7 +110,33 @@ public void beforeClass() throws Exception {\n     _metadataStoreDirectory = new ZkMetadataStoreDirectory(routingZkAddrMap);\n   }\n \n+  /*\n+   * Tests REST endpoint: \"GET /namespaces/{namespace}/metadata-store-namespaces\"\n+   */\n   @Test\n+  public void testGetAllNamespaces() throws IOException {\n+    String responseBody = get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-namespaces\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // It is safe to cast the object and suppress warnings.\n+    @SuppressWarnings(\"unchecked\")\n+    Map<String, Collection<String>> queriedNamespacesMap =\n+        OBJECT_MAPPER.readValue(responseBody, Map.class);\n+\n+    Assert.assertTrue(\n+        queriedNamespacesMap.containsKey(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0e4734ac029985e0b82c9e2b9dc03c868b0ea1b"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71615fc1ed94b60173003e88641a202149899b55", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/71615fc1ed94b60173003e88641a202149899b55", "committedDate": "2020-02-21T02:56:29Z", "message": "Add REST read endpoints to Helix REST for metada store directory service."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38b54b45d60892f510b39aae8ba08ac0629ad49d", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/38b54b45d60892f510b39aae8ba08ac0629ad49d", "committedDate": "2020-02-21T02:58:13Z", "message": "Add getRealmShardingKeys endpoint."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5e5b49f8e95db279894ad4572f74266e02bb663", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/c5e5b49f8e95db279894ad4572f74266e02bb663", "committedDate": "2020-02-21T02:58:13Z", "message": "Format long lines."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10aa4d6c8a96169374e18786654369ccc5eb123a", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/10aa4d6c8a96169374e18786654369ccc5eb123a", "committedDate": "2020-02-21T02:58:13Z", "message": "Check exact fields in JSON response in unit tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "163c35c81cf770ddabdf355a6bd6c76931f69a17", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/163c35c81cf770ddabdf355a6bd6c76931f69a17", "committedDate": "2020-02-21T02:58:13Z", "message": "Comment."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "13bd3c882497b3321393b190193642b1a75ddde2", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/13bd3c882497b3321393b190193642b1a75ddde2", "committedDate": "2020-02-20T01:23:06Z", "message": "Close MSD before MetadataStoreDirectoryAccessor is destroyed."}, "afterCommit": {"oid": "96c7ad934d3b78aabee5fcf215d98e3a470673b8", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/96c7ad934d3b78aabee5fcf215d98e3a470673b8", "committedDate": "2020-02-21T02:58:13Z", "message": "Close MSD before MetadataStoreDirectoryAccessor is destroyed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2ec40295b11736e68d8da5b51beeae628694962", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/d2ec40295b11736e68d8da5b51beeae628694962", "committedDate": "2020-02-21T03:01:43Z", "message": "Close MSD before MetadataStoreDirectoryAccessor is destroyed."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "96c7ad934d3b78aabee5fcf215d98e3a470673b8", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/96c7ad934d3b78aabee5fcf215d98e3a470673b8", "committedDate": "2020-02-21T02:58:13Z", "message": "Close MSD before MetadataStoreDirectoryAccessor is destroyed."}, "afterCommit": {"oid": "d2ec40295b11736e68d8da5b51beeae628694962", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/d2ec40295b11736e68d8da5b51beeae628694962", "committedDate": "2020-02-21T03:01:43Z", "message": "Close MSD before MetadataStoreDirectoryAccessor is destroyed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d207dd53f1b78caa2c55a6f739a18830900ef6e2", "author": {"user": {"login": "huizhilu", "name": "Huizhi Lu"}}, "url": "https://github.com/apache/helix/commit/d207dd53f1b78caa2c55a6f739a18830900ef6e2", "committedDate": "2020-02-22T00:51:10Z", "message": "Remove query param realm in endpoint to get all sharding keys."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDQ1MzYw", "url": "https://github.com/apache/helix/pull/761#pullrequestreview-363045360", "createdAt": "2020-02-22T19:07:26Z", "commit": {"oid": "d207dd53f1b78caa2c55a6f739a18830900ef6e2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4961, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}