{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNjM0MTE5", "number": 720, "title": "Add MetadataStoreDirectory and ZkMetadataStoreDirectory", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #721\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nMetadataStoreDirectory is an object that provides Metadata Store Directory APIs (routing APIs, CRUD of routing data, etc.). Helix REST will use this object to serve Metadata Store Directory Service REST endpoints.\nAlso, it will make appropriate changes to the ZK access layer to listen on changes on the routing data.\nChangelist:\n\nRefactor AbstractTestClass to make multi-ZK setup work\nAdd implementation of MetadataStoreDirectory\nAdd TestZkMetadataStoreDirectory\n\nTests\n\n The following tests are written for this issue:\n\nTestZkMetadataStoreDirectory\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\nhelix-rest:\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:04 min\n[INFO] Finished at: 2020-02-05T10:31:41-08:00\n[INFO] ------------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-04T03:54:46Z", "url": "https://github.com/apache/helix/pull/720", "merged": true, "mergeCommit": {"oid": "ce14139f505d95ba397214e073ba0056c63924bf"}, "closed": true, "closedAt": "2020-02-05T19:12:51Z", "author": {"login": "narendly"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBGKOGAFqTM1MzIxNjc2OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBbA6BAFqTM1Mzk2ODE4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjE2NzY5", "url": "https://github.com/apache/helix/pull/720#pullrequestreview-353216769", "createdAt": "2020-02-04T18:50:35Z", "commit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODo1MDozNlrOFlfcTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODo1MDozNlrOFlfcTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1Njc4Mw==", "bodyText": "Ditto the point above about method naming.", "url": "https://github.com/apache/helix/pull/720#discussion_r374856783", "createdAt": "2020-02-04T18:50:36Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.Watcher;\n+\n+\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory {\n+  // TODO: enable the line below when implementation is complete\n+//  private final MetadataStoreRoutingDataAccessor _routingDataAccessor;\n+  private MetadataStoreRoutingData _routingData;\n+\n+  public ZkMetadataStoreDirectory(String zkAddress) {\n+//    _routingDataAccessor = new ZkRoutingDataAccessor(zkAddress, this); // dependency injection\n+    // 1. Create a RoutingDataTrieNode using routingDataAccessor\n+    // _routingData = constructRoutingData(_routingDataAccessor);\n+  }\n+\n+  @Override\n+  public List<String> getAllNamespaces() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllMetadataStoreRealms(String namespace) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllShardingKeys(String namespace) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllShardingKeysInRealm(String namespace, String realm) {\n+    return null;\n+  }\n+\n+  @Override\n+  public Map<String, String> getAllShardingKeysUnderPath(String namespace, String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjI5NzU4", "url": "https://github.com/apache/helix/pull/720#pullrequestreview-353229758", "createdAt": "2020-02-04T19:10:45Z", "commit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxOToxMDo0NVrOFlgEOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxOToxMDo0NVrOFlgEOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2NzAwMQ==", "bodyText": "Responding to a point raised by @pkuwm earlier during the design phase, the naming of this method should be changed to getAllMappingUnderPath. See https://github.com/apache/helix/pull/706/files#diff-184698fcbd1600d535a7b9f7996ca9f6R37 for reference as it has been changed for the underlying class.\nThe reason behind this proposal is that getAllShardingKeysInRealm returns a list of sharding keys, while this method returns a mapping of sharding keys to realm addresses. If this method has the same prefix of \"getAllShardkingKeys\" it's easy to cause confusion on the usage.", "url": "https://github.com/apache/helix/pull/720#discussion_r374867001", "createdAt": "2020-02-04T19:10:45Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  List<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  List<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  List<String> getAllShardingKeys(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace and the realm.\n+   * @param namespace\n+   * @param realm\n+   * @return\n+   */\n+  List<String> getAllShardingKeysInRealm(String namespace, String realm);\n+\n+  /**\n+   * Returns all sharding keys that have the given path as the prefix substring.\n+   * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e,\n+   * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\", \"/a/b/d\"].\n+   * @param namespace\n+   * @param path\n+   * @return\n+   */\n+  Map<String, String> getAllShardingKeysUnderPath(String namespace, String path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjY1OTA4", "url": "https://github.com/apache/helix/pull/720#pullrequestreview-353265908", "createdAt": "2020-02-04T20:07:24Z", "commit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDowNzoyNFrOFlhyCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDoxNTo1OFrOFliCAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTExMg==", "bodyText": "Do we need this?", "url": "https://github.com/apache/helix/pull/720#discussion_r374895112", "createdAt": "2020-02-04T20:07:24Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.Watcher;\n+\n+\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory {\n+  // TODO: enable the line below when implementation is complete\n+//  private final MetadataStoreRoutingDataAccessor _routingDataAccessor;\n+  private MetadataStoreRoutingData _routingData;\n+\n+  public ZkMetadataStoreDirectory(String zkAddress) {\n+//    _routingDataAccessor = new ZkRoutingDataAccessor(zkAddress, this); // dependency injection\n+    // 1. Create a RoutingDataTrieNode using routingDataAccessor\n+    // _routingData = constructRoutingData(_routingDataAccessor);\n+  }\n+\n+  @Override\n+  public List<String> getAllNamespaces() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllMetadataStoreRealms(String namespace) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllShardingKeys(String namespace) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAllShardingKeysInRealm(String namespace, String realm) {\n+    return null;\n+  }\n+\n+  @Override\n+  public Map<String, String> getAllShardingKeysUnderPath(String namespace, String path) {\n+    return null;\n+  }\n+\n+  @Override\n+  public String getMetadataStoreRealm(String namespace, String shardingKey) {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean addNamespace(String namespace) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean deleteNamespace(String namespace) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean addMetadataStoreRealm(String namespace, String realm) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean deleteMetadataStoreRealm(String namespace, String realm) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean addShardingKey(String namespace, String realm, String shardingKey) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean deleteShardingKey(String namespace, String realm, String shardingKey) {\n+    return false;\n+  }\n+\n+  @Override\n+  public void updateRoutingData() {\n+    // call constructRoutingData() here.\n+  }\n+\n+//  /**\n+//   * Reconstructs MetadataStoreRoutingData by reading from the metadata store.\n+//   * @param routingDataAccessor\n+//   * @return\n+//   */\n+//  private MetadataStoreRoutingData constructRoutingData(MetadataStoreRoutingDataAccessor routingDataAccessor) {\n+//    /**\n+//     * Trie construction logic\n+//     */\n+//\n+//    // 1. Construct\n+//    // 2. Update the in-memory reference when complete\n+//    _routingData = newRoutingData;\n+//  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NzIzNQ==", "bodyText": "If the code is not used, let's remove it.", "url": "https://github.com/apache/helix/pull/720#discussion_r374897235", "createdAt": "2020-02-04T20:11:56Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.zookeeper.Watcher;\n+\n+\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory {\n+  // TODO: enable the line below when implementation is complete\n+//  private final MetadataStoreRoutingDataAccessor _routingDataAccessor;\n+  private MetadataStoreRoutingData _routingData;\n+\n+  public ZkMetadataStoreDirectory(String zkAddress) {\n+//    _routingDataAccessor = new ZkRoutingDataAccessor(zkAddress, this); // dependency injection\n+    // 1. Create a RoutingDataTrieNode using routingDataAccessor\n+    // _routingData = constructRoutingData(_routingDataAccessor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NzU0OQ==", "bodyText": "Will this return complete path of keys?", "url": "https://github.com/apache/helix/pull/720#discussion_r374897549", "createdAt": "2020-02-04T20:12:36Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  List<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  List<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  List<String> getAllShardingKeys(String namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5OTIwMg==", "bodyText": "It is better in the Interface level to explain the namespace, realms and sharding keys. Reviewers may not have context on what are they.", "url": "https://github.com/apache/helix/pull/720#discussion_r374899202", "createdAt": "2020-02-04T20:15:58Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+public interface MetadataStoreDirectory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a23d8e4c3cc413ca2f3976ff0cbeeee8d8aafbf2", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/a23d8e4c3cc413ca2f3976ff0cbeeee8d8aafbf2", "committedDate": "2020-02-05T02:05:06Z", "message": "Add MetadataStoreDirectory and ZkMetadataStoreDirectory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b778f78cd13139c0151da9552768656347946255", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/b778f78cd13139c0151da9552768656347946255", "committedDate": "2020-02-05T02:05:06Z", "message": "Change design"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e50311a39cc5cee392667464065d1c7fbc53662d", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/e50311a39cc5cee392667464065d1c7fbc53662d", "committedDate": "2020-02-05T04:52:45Z", "message": "Implement listeners"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffe551c88ba3e298231ac721cd8ccaf658ec248a", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/ffe551c88ba3e298231ac721cd8ccaf658ec248a", "committedDate": "2020-02-05T06:22:43Z", "message": "finish implementation with tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8409ab87f1c1945b95c3b98967928ea4cda758f4", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/8409ab87f1c1945b95c3b98967928ea4cda758f4", "committedDate": "2020-02-04T03:58:18Z", "message": "Change design"}, "afterCommit": {"oid": "ffe551c88ba3e298231ac721cd8ccaf658ec248a", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/ffe551c88ba3e298231ac721cd8ccaf658ec248a", "committedDate": "2020-02-05T06:22:43Z", "message": "finish implementation with tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/85aea4d86f569d091212e9e4f35594267a0636b2", "committedDate": "2020-02-05T06:25:33Z", "message": "Fix type"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNTMxOTkz", "url": "https://github.com/apache/helix/pull/720#pullrequestreview-353531993", "createdAt": "2020-02-05T08:22:39Z", "commit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoyMjozOVrOFlvFVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoyNjo0NlrOFlvLlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzA0Ng==", "bodyText": "What if it does not exist? Shall we return null String or throw exception? If throw exception, we should have signature here.", "url": "https://github.com/apache/helix/pull/720#discussion_r375113046", "createdAt": "2020-02-05T08:22:39Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+\n+/**\n+ * MetadataStoreDirectory interface that provides methods that are used to route requests to appropriate metadata store realm.\n+ *\n+ * namespace: tied to a namespace used in Helix REST (Metadata Store Directory Service endpoints will be served by Helix REST deployables)\n+ * realm: a metadata store deployable/ensemble. for example, if an application wishes to use 3 ZK quorums, then each ZK quorum would be considered a realm (ZK realm)\n+ * metadata store path sharding key: assuming the metadata store uses a file system APIs, this sharding key denotes the key that maps to a particular metadata store realm. an example of a key is a cluster name mapping to a particular ZK realm (ZK address)\n+ */\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  Collection<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeys(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace and the realm.\n+   * @param namespace\n+   * @param realm\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeysInRealm(String namespace, String realm);\n+\n+  /**\n+   * Returns all sharding keys that have the given path as the prefix substring.\n+   * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e,\n+   * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\": \"realm\", \"/a/b/d\": \"realm].\n+   * @param namespace\n+   * @param path\n+   * @return\n+   */\n+  Map<String, String> getAllMappingUnderPath(String namespace, String path);\n+\n+  /**\n+   * Returns the name of the metadata store realm based on the namespace and the sharding key given.\n+   * @param namespace\n+   * @param shardingKey\n+   * @return\n+   */\n+  String getMetadataStoreRealm(String namespace, String shardingKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzM0Ng==", "bodyText": "This is not like to be a REST level operation, right? Does REST support this operation now? It would be dangerous that MDSD support add/delete namespaces.", "url": "https://github.com/apache/helix/pull/720#discussion_r375113346", "createdAt": "2020-02-05T08:23:22Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+\n+/**\n+ * MetadataStoreDirectory interface that provides methods that are used to route requests to appropriate metadata store realm.\n+ *\n+ * namespace: tied to a namespace used in Helix REST (Metadata Store Directory Service endpoints will be served by Helix REST deployables)\n+ * realm: a metadata store deployable/ensemble. for example, if an application wishes to use 3 ZK quorums, then each ZK quorum would be considered a realm (ZK realm)\n+ * metadata store path sharding key: assuming the metadata store uses a file system APIs, this sharding key denotes the key that maps to a particular metadata store realm. an example of a key is a cluster name mapping to a particular ZK realm (ZK address)\n+ */\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  Collection<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeys(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace and the realm.\n+   * @param namespace\n+   * @param realm\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeysInRealm(String namespace, String realm);\n+\n+  /**\n+   * Returns all sharding keys that have the given path as the prefix substring.\n+   * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e,\n+   * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\": \"realm\", \"/a/b/d\": \"realm].\n+   * @param namespace\n+   * @param path\n+   * @return\n+   */\n+  Map<String, String> getAllMappingUnderPath(String namespace, String path);\n+\n+  /**\n+   * Returns the name of the metadata store realm based on the namespace and the sharding key given.\n+   * @param namespace\n+   * @param shardingKey\n+   * @return\n+   */\n+  String getMetadataStoreRealm(String namespace, String shardingKey);\n+\n+  /**\n+   * NOTE: The following CRUD methods are idempotent.\n+   */\n+  /**\n+   * Creates a namespace in the routing metadata store.\n+   * @param namespace\n+   * @return true if successful or if the namespace already exists. false if not successful.\n+   */\n+  boolean addNamespace(String namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNDY0Nw==", "bodyText": "Do we consider close operation is idempotent? If yes, we can think about extend the interface AutoCloseable. Then user can use try-with-resources.", "url": "https://github.com/apache/helix/pull/720#discussion_r375114647", "createdAt": "2020-02-05T08:26:46Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+\n+/**\n+ * MetadataStoreDirectory interface that provides methods that are used to route requests to appropriate metadata store realm.\n+ *\n+ * namespace: tied to a namespace used in Helix REST (Metadata Store Directory Service endpoints will be served by Helix REST deployables)\n+ * realm: a metadata store deployable/ensemble. for example, if an application wishes to use 3 ZK quorums, then each ZK quorum would be considered a realm (ZK realm)\n+ * metadata store path sharding key: assuming the metadata store uses a file system APIs, this sharding key denotes the key that maps to a particular metadata store realm. an example of a key is a cluster name mapping to a particular ZK realm (ZK address)\n+ */\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  Collection<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeys(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace and the realm.\n+   * @param namespace\n+   * @param realm\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeysInRealm(String namespace, String realm);\n+\n+  /**\n+   * Returns all sharding keys that have the given path as the prefix substring.\n+   * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e,\n+   * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\": \"realm\", \"/a/b/d\": \"realm].\n+   * @param namespace\n+   * @param path\n+   * @return\n+   */\n+  Map<String, String> getAllMappingUnderPath(String namespace, String path);\n+\n+  /**\n+   * Returns the name of the metadata store realm based on the namespace and the sharding key given.\n+   * @param namespace\n+   * @param shardingKey\n+   * @return\n+   */\n+  String getMetadataStoreRealm(String namespace, String shardingKey);\n+\n+  /**\n+   * NOTE: The following CRUD methods are idempotent.\n+   */\n+  /**\n+   * Creates a namespace in the routing metadata store.\n+   * @param namespace\n+   * @return true if successful or if the namespace already exists. false if not successful.\n+   */\n+  boolean addNamespace(String namespace);\n+\n+  /**\n+   * Deletes a namespace in the routing metadata store.\n+   * @param namespace\n+   * @return true if successful or if the namespace does not exist. false otherwise.\n+   */\n+  boolean deleteNamespace(String namespace);\n+\n+  /**\n+   * Creates a realm. If the namespace does not exist, it creates one.\n+   * @param namespace\n+   * @param realm\n+   * @return true if successful or if the realm already exists. false otherwise.\n+   */\n+  boolean addMetadataStoreRealm(String namespace, String realm);\n+\n+  /**\n+   * Deletes a realm.\n+   * @param namespace\n+   * @param realm\n+   * @return true if successful or the realm or namespace does not exist. false otherwise.\n+   */\n+  boolean deleteMetadataStoreRealm(String namespace, String realm);\n+\n+  /**\n+   * Creates a mapping between the sharding key to the realm in the given namespace.\n+   * @param namespace\n+   * @param realm\n+   * @param shardingKey\n+   * @return false if failed\n+   */\n+  boolean addShardingKey(String namespace, String realm, String shardingKey);\n+\n+  /**\n+   * Deletes the mapping between the sharding key to the realm in the given namespace.\n+   * @param namespace\n+   * @param realm\n+   * @param shardingKey\n+   * @return false if failed; true if the deletion is successful or the key does not exist.\n+   */\n+  boolean deleteShardingKey(String namespace, String realm, String shardingKey);\n+\n+  /**\n+   * Close MetadataStoreDirectory.\n+   */\n+  void close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzOTI2MTUy", "url": "https://github.com/apache/helix/pull/720#pullrequestreview-353926152", "createdAt": "2020-02-05T18:03:18Z", "commit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxODowMzoxOFrOFmBq1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxODoxOToyNFrOFmCKwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNzU1Ng==", "bodyText": "What if this namespace key does not exists? Could NPE happens?", "url": "https://github.com/apache/helix/pull/720#discussion_r375417556", "createdAt": "2020-02-05T18:03:18Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.HelixManagerProperties;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update callback.\n+ */\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n+\n+  // TODO: enable the line below when implementation is complete\n+  // The following maps' keys represent the namespace\n+  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  private final Map<String, String> _routingZkAddressMap;\n+  // <namespace, <realm, <list of sharding keys>> mappings\n+  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+\n+  /**\n+   * Creates a ZkMetadataStoreDirectory based on the given routing ZK addresses.\n+   * @param routingZkAddressMap (namespace, routing ZK connect string)\n+   * @throws InvalidRoutingDataException\n+   */\n+  public ZkMetadataStoreDirectory(Map<String, String> routingZkAddressMap)\n+      throws InvalidRoutingDataException {\n+    if (routingZkAddressMap == null || routingZkAddressMap.isEmpty()) {\n+      throw new InvalidRoutingDataException(\"Routing ZK Addresses given are invalid!\");\n+    }\n+    _routingDataReaderMap = new HashMap<>();\n+    _routingZkAddressMap = routingZkAddressMap;\n+    _realmToShardingKeysMap = new ConcurrentHashMap<>();\n+    _routingDataMap = new ConcurrentHashMap<>();\n+\n+    // Create RoutingDataReaders\n+    for (Map.Entry<String, String> routingEntry : _routingZkAddressMap.entrySet()) {\n+      _routingDataReaderMap.put(routingEntry.getKey(),\n+          new ZkRoutingDataReader(routingEntry.getKey(), routingEntry.getValue(), this));\n+\n+      // Populate realmToShardingKeys with ZkRoutingDataReader\n+      _realmToShardingKeysMap.put(routingEntry.getKey(),\n+          _routingDataReaderMap.get(routingEntry.getKey()).getRoutingData());\n+    }\n+  }\n+\n+  @Override\n+  public Collection<String> getAllNamespaces() {\n+    return Collections.unmodifiableCollection(_routingZkAddressMap.keySet());\n+  }\n+\n+  @Override\n+  public Collection<String> getAllMetadataStoreRealms(String namespace) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    return Collections.unmodifiableCollection(_realmToShardingKeysMap.get(namespace).keySet());\n+  }\n+\n+  @Override\n+  public Collection<String> getAllShardingKeys(String namespace) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    Set<String> allShardingKeys = new HashSet<>();\n+    _realmToShardingKeysMap.get(namespace).values().forEach(keys -> allShardingKeys.addAll(keys));\n+    return allShardingKeys;\n+  }\n+\n+  @Override\n+  public Collection<String> getAllShardingKeysInRealm(String namespace, String realm) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    if (!_realmToShardingKeysMap.get(namespace).containsKey(realm)) {\n+      throw new NoSuchElementException(\n+          \"Realm \" + realm + \" does not exist in namespace \" + namespace);\n+    }\n+    return Collections.unmodifiableCollection(_realmToShardingKeysMap.get(namespace).get(realm));\n+  }\n+\n+  @Override\n+  public Map<String, String> getAllMappingUnderPath(String namespace, String path) {\n+    // TODO: get it from routingData\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public String getMetadataStoreRealm(String namespace, String shardingKey) {\n+    // TODO: get it from routingData\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addNamespace(String namespace) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteNamespace(String namespace) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addMetadataStoreRealm(String namespace, String realm) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteMetadataStoreRealm(String namespace, String realm) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addShardingKey(String namespace, String realm, String shardingKey) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteShardingKey(String namespace, String realm, String shardingKey) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Callback for updating the cached routing data.\n+   * Note: this method should not synchronize on the class or the map. We do not want namespaces blocking each other.\n+   * Threadsafe map is used for _realmToShardingKeysMap.\n+   * The global consistency of the in-memory routing data is not a requirement (eventual consistency is enough).\n+   * @param namespace\n+   */\n+  @Override\n+  public void updateRoutingData(String namespace) {\n+    // Safe to ignore the callback if routingDataMap is null.\n+    // If routingDataMap is null, then it will be populated by the constructor anyway\n+    // If routingDataMap is not null, then it's safe for the callback function to update it\n+    try {\n+      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyMTQ4MQ==", "bodyText": "This is more like an internal method to refresh internal cached data? Then refreshRoutingData could be a better name. Otherwise, it will be confused with users operation.", "url": "https://github.com/apache/helix/pull/720#discussion_r375421481", "createdAt": "2020-02-05T18:11:19Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.helix.HelixManagerProperties;\n+import org.apache.helix.manager.zk.ZNRecordSerializer;\n+import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n+import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.client.HelixZkClient.ZkClientConfig;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update callback.\n+ */\n+public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n+\n+  // TODO: enable the line below when implementation is complete\n+  // The following maps' keys represent the namespace\n+  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  private final Map<String, String> _routingZkAddressMap;\n+  // <namespace, <realm, <list of sharding keys>> mappings\n+  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+\n+  /**\n+   * Creates a ZkMetadataStoreDirectory based on the given routing ZK addresses.\n+   * @param routingZkAddressMap (namespace, routing ZK connect string)\n+   * @throws InvalidRoutingDataException\n+   */\n+  public ZkMetadataStoreDirectory(Map<String, String> routingZkAddressMap)\n+      throws InvalidRoutingDataException {\n+    if (routingZkAddressMap == null || routingZkAddressMap.isEmpty()) {\n+      throw new InvalidRoutingDataException(\"Routing ZK Addresses given are invalid!\");\n+    }\n+    _routingDataReaderMap = new HashMap<>();\n+    _routingZkAddressMap = routingZkAddressMap;\n+    _realmToShardingKeysMap = new ConcurrentHashMap<>();\n+    _routingDataMap = new ConcurrentHashMap<>();\n+\n+    // Create RoutingDataReaders\n+    for (Map.Entry<String, String> routingEntry : _routingZkAddressMap.entrySet()) {\n+      _routingDataReaderMap.put(routingEntry.getKey(),\n+          new ZkRoutingDataReader(routingEntry.getKey(), routingEntry.getValue(), this));\n+\n+      // Populate realmToShardingKeys with ZkRoutingDataReader\n+      _realmToShardingKeysMap.put(routingEntry.getKey(),\n+          _routingDataReaderMap.get(routingEntry.getKey()).getRoutingData());\n+    }\n+  }\n+\n+  @Override\n+  public Collection<String> getAllNamespaces() {\n+    return Collections.unmodifiableCollection(_routingZkAddressMap.keySet());\n+  }\n+\n+  @Override\n+  public Collection<String> getAllMetadataStoreRealms(String namespace) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    return Collections.unmodifiableCollection(_realmToShardingKeysMap.get(namespace).keySet());\n+  }\n+\n+  @Override\n+  public Collection<String> getAllShardingKeys(String namespace) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    Set<String> allShardingKeys = new HashSet<>();\n+    _realmToShardingKeysMap.get(namespace).values().forEach(keys -> allShardingKeys.addAll(keys));\n+    return allShardingKeys;\n+  }\n+\n+  @Override\n+  public Collection<String> getAllShardingKeysInRealm(String namespace, String realm) {\n+    if (!_realmToShardingKeysMap.containsKey(namespace)) {\n+      throw new NoSuchElementException(\"Namespace \" + namespace + \" does not exist!\");\n+    }\n+    if (!_realmToShardingKeysMap.get(namespace).containsKey(realm)) {\n+      throw new NoSuchElementException(\n+          \"Realm \" + realm + \" does not exist in namespace \" + namespace);\n+    }\n+    return Collections.unmodifiableCollection(_realmToShardingKeysMap.get(namespace).get(realm));\n+  }\n+\n+  @Override\n+  public Map<String, String> getAllMappingUnderPath(String namespace, String path) {\n+    // TODO: get it from routingData\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public String getMetadataStoreRealm(String namespace, String shardingKey) {\n+    // TODO: get it from routingData\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addNamespace(String namespace) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteNamespace(String namespace) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addMetadataStoreRealm(String namespace, String realm) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteMetadataStoreRealm(String namespace, String realm) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean addShardingKey(String namespace, String realm, String shardingKey) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean deleteShardingKey(String namespace, String realm, String shardingKey) {\n+    // TODO implement when MetadataStoreRoutingDataWriter is ready\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Callback for updating the cached routing data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyNDk5OA==", "bodyText": "Can you share why we need to unsubscribe all here?", "url": "https://github.com/apache/helix/pull/720#discussion_r375424998", "createdAt": "2020-02-05T18:17:57Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkRoutingDataReader.java", "diffHunk": "@@ -22,54 +22,161 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+\n+import org.I0Itec.zkclient.IZkChildListener;\n+import org.I0Itec.zkclient.IZkDataListener;\n import org.I0Itec.zkclient.exception.ZkNoNodeException;\n import org.apache.helix.ZNRecord;\n import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.client.DedicatedZkClientFactory;\n import org.apache.helix.manager.zk.client.HelixZkClient;\n+import org.apache.helix.manager.zk.zookeeper.IZkStateListener;\n+import org.apache.helix.rest.metadatastore.constant.MetadataStoreRoutingConstants;\n import org.apache.helix.rest.metadatastore.exceptions.InvalidRoutingDataException;\n+import org.apache.zookeeper.Watcher;\n \n-public class ZkRoutingDataReader implements MetadataStoreRoutingDataReader {\n-  static final String ROUTING_DATA_PATH = \"/METADATA_STORE_ROUTING_DATA\";\n-  static final String ZNRECORD_LIST_FIELD_KEY = \"ZK_PATH_SHARDING_KEYS\";\n \n+public class ZkRoutingDataReader implements MetadataStoreRoutingDataReader, IZkDataListener, IZkChildListener, IZkStateListener {\n+  private final String _namespace;\n   private final String _zkAddress;\n   private final HelixZkClient _zkClient;\n+  private final RoutingDataListener _routingDataListener;\n+\n+  public ZkRoutingDataReader(String namespace, String zkAddress) {\n+    this(namespace, zkAddress, null);\n+  }\n \n-  public ZkRoutingDataReader(String zkAddress) {\n+  public ZkRoutingDataReader(String namespace, String zkAddress,\n+      RoutingDataListener routingDataListener) {\n+    if (namespace == null || namespace.isEmpty()) {\n+      throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n+    }\n+    _namespace = namespace;\n+    if (zkAddress == null || zkAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\"Zk address cannot be null or empty!\");\n+    }\n     _zkAddress = zkAddress;\n-    _zkClient = DedicatedZkClientFactory.getInstance().buildZkClient(\n-        new HelixZkClient.ZkConnectionConfig(zkAddress),\n-        new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+    _routingDataListener = routingDataListener;\n+    if (_routingDataListener != null) {\n+      // Subscribe child changes\n+      _zkClient.subscribeChildChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, this);\n+      // Subscribe data changes\n+      for (String child : _zkClient.getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+        _zkClient\n+            .subscribeDataChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child,\n+                this);\n+      }\n+    }\n   }\n \n-  public Map<String, List<String>> getRoutingData() throws InvalidRoutingDataException {\n+  /**\n+   * Returns (realm, list of ZK path sharding keys) mappings.\n+   * @return\n+   * @throws InvalidRoutingDataException\n+   */\n+  public Map<String, List<String>> getRoutingData()\n+      throws InvalidRoutingDataException {\n     Map<String, List<String>> routingData = new HashMap<>();\n     List<String> children;\n     try {\n-      children = _zkClient.getChildren(ROUTING_DATA_PATH);\n+      children = _zkClient.getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);\n     } catch (ZkNoNodeException e) {\n-      throw new InvalidRoutingDataException(\"Routing data directory ZNode \" + ROUTING_DATA_PATH\n-          + \" does not exist. Routing ZooKeeper address: \" + _zkAddress);\n+      throw new InvalidRoutingDataException(\n+          \"Routing data directory ZNode \" + MetadataStoreRoutingConstants.ROUTING_DATA_PATH\n+              + \" does not exist. Routing ZooKeeper address: \" + _zkAddress);\n     }\n     if (children == null || children.isEmpty()) {\n       throw new InvalidRoutingDataException(\n           \"There are no metadata store realms defined. Routing ZooKeeper address: \" + _zkAddress);\n     }\n     for (String child : children) {\n-      ZNRecord record = _zkClient.readData(ROUTING_DATA_PATH + \"/\" + child);\n-      List<String> shardingKeys = record.getListField(ZNRECORD_LIST_FIELD_KEY);\n+      ZNRecord record =\n+          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child);\n+      List<String> shardingKeys =\n+          record.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n       if (shardingKeys == null || shardingKeys.isEmpty()) {\n-        throw new InvalidRoutingDataException(\"Realm address ZNode \" + ROUTING_DATA_PATH + \"/\"\n-            + child + \" does not have a value for key \" + ZNRECORD_LIST_FIELD_KEY\n-            + \". Routing ZooKeeper address: \" + _zkAddress);\n+        throw new InvalidRoutingDataException(\n+            \"Realm address ZNode \" + MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child\n+                + \" does not have a value for key \"\n+                + MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY\n+                + \". Routing ZooKeeper address: \" + _zkAddress);\n       }\n       routingData.put(child, shardingKeys);\n     }\n     return routingData;\n   }\n \n-  public void close() {\n+  public synchronized void close() {\n+    _zkClient.unsubscribeAll();\n     _zkClient.close();\n   }\n+\n+  @Override\n+  public synchronized void handleDataChange(String s, Object o)\n+      throws Exception {\n+    if (_zkClient.isClosed()) {\n+      return;\n+    }\n+    _routingDataListener.updateRoutingData(_namespace);\n+  }\n+\n+  @Override\n+  public synchronized void handleDataDeleted(String s)\n+      throws Exception {\n+    if (_zkClient.isClosed()) {\n+      return;\n+    }\n+    _zkClient.unsubscribeAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyNTcyOA==", "bodyText": "I think I was confused with existing REST namespace? Because I saw you are subscribing to namespace. Will that be a ZNode?", "url": "https://github.com/apache/helix/pull/720#discussion_r375425728", "createdAt": "2020-02-05T18:19:24Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/MetadataStoreDirectory.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.rest.metadatastore;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+\n+/**\n+ * MetadataStoreDirectory interface that provides methods that are used to route requests to appropriate metadata store realm.\n+ *\n+ * namespace: tied to a namespace used in Helix REST (Metadata Store Directory Service endpoints will be served by Helix REST deployables)\n+ * realm: a metadata store deployable/ensemble. for example, if an application wishes to use 3 ZK quorums, then each ZK quorum would be considered a realm (ZK realm)\n+ * metadata store path sharding key: assuming the metadata store uses a file system APIs, this sharding key denotes the key that maps to a particular metadata store realm. an example of a key is a cluster name mapping to a particular ZK realm (ZK address)\n+ */\n+public interface MetadataStoreDirectory {\n+\n+  /**\n+   * Retrieves all existing namespaces in the routing metadata store.\n+   * @return\n+   */\n+  Collection<String> getAllNamespaces();\n+\n+  /**\n+   * Returns all metadata store realms in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllMetadataStoreRealms(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace.\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeys(String namespace);\n+\n+  /**\n+   * Returns all path-based sharding keys in the given namespace and the realm.\n+   * @param namespace\n+   * @param realm\n+   * @return\n+   */\n+  Collection<String> getAllShardingKeysInRealm(String namespace, String realm);\n+\n+  /**\n+   * Returns all sharding keys that have the given path as the prefix substring.\n+   * E.g) Given that there are sharding keys: /a/b/c, /a/b/d, /a/e,\n+   * getAllShardingKeysUnderPath(namespace, \"/a/b\") returns [\"/a/b/c\": \"realm\", \"/a/b/d\": \"realm].\n+   * @param namespace\n+   * @param path\n+   * @return\n+   */\n+  Map<String, String> getAllMappingUnderPath(String namespace, String path);\n+\n+  /**\n+   * Returns the name of the metadata store realm based on the namespace and the sharding key given.\n+   * @param namespace\n+   * @param shardingKey\n+   * @return\n+   */\n+  String getMetadataStoreRealm(String namespace, String shardingKey);\n+\n+  /**\n+   * NOTE: The following CRUD methods are idempotent.\n+   */\n+  /**\n+   * Creates a namespace in the routing metadata store.\n+   * @param namespace\n+   * @return true if successful or if the namespace already exists. false if not successful.\n+   */\n+  boolean addNamespace(String namespace);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzM0Ng=="}, "originalCommit": {"oid": "85aea4d86f569d091212e9e4f35594267a0636b2"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfdc6bdb95846b9f9a90223c07935447d70f4db9", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/dfdc6bdb95846b9f9a90223c07935447d70f4db9", "committedDate": "2020-02-05T18:58:42Z", "message": "Fix test failure and addres comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzOTY4MTg0", "url": "https://github.com/apache/helix/pull/720#pullrequestreview-353968184", "createdAt": "2020-02-05T19:08:26Z", "commit": {"oid": "dfdc6bdb95846b9f9a90223c07935447d70f4db9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4924, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}