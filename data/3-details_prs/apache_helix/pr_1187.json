{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NTg3OTg1", "number": 1187, "title": "Add latency metric support for customized view aggregation", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #1214\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis PR adds support for latency metric reporting between the time when user updates customized state for a partition using CustomizedStateProvider, and the time this change shows up in aggregated customized view and written to zk. With that, we can 1. compare this latency with other pipeline latencies, so we know if this newly added feature saturate our controller or not 2. get an understanding of the pipeline performance 3. better monitor this feature and diagnose any problems in the future\n\n The following tests are written for this issue:\n\nAdded:\n\nTestCustomizedViewMonitor\nTestCustomizedViewStage -> testLatencyMetricReporting\n\nModified:\n\nTestCustomizedStateUpdate\nTestCustomizedViewAggregation\n\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO]\n[INFO] Results:\n[INFO]\n[WARNING] Tests run: 1168, Failures: 0, Errors: 0, Skipped: 1\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:13 h\n[INFO] Finished at: 2020-08-13T19:47:48-07:00\n[INFO] ------------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-07-29T17:46:02Z", "url": "https://github.com/apache/helix/pull/1187", "merged": true, "mergeCommit": {"oid": "918039bf5cdf1ce40c8e47910738ba541d4958e6"}, "closed": true, "closedAt": "2020-08-14T03:43:42Z", "author": {"login": "mgao0"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc64QKxAFqTQ1OTYyNTM2OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-qTn5AFqTQ2NzI1MzI1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjI1MzY4", "url": "https://github.com/apache/helix/pull/1187#pullrequestreview-459625368", "createdAt": "2020-08-02T06:57:30Z", "commit": {"oid": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwNjo1NzozMFrOG6izbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwNzoyNTo1OVrOG6i91g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MDgxMw==", "bodyText": "static final?", "url": "https://github.com/apache/helix/pull/1187#discussion_r464040813", "createdAt": "2020-08-02T06:57:30Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,63 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MTI2Mw==", "bodyText": "Often, the only use for the ERROR level within a certain application is when a valuable business use case cannot be completed due to technical issues or a bug.\nI'd prefer not to use this logging level too generously because that would add too much noise to the logs and reduce the significance of a single ERROR event.\nThe WARN level should be used when something bad happened, but the application still has the chance to heal itself or the issue can wait a day or two to be fixed.", "url": "https://github.com/apache/helix/pull/1187#discussion_r464041263", "createdAt": "2020-08-02T07:01:39Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,63 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;\n+    switch (propertyName) {\n+      case CURRENT_STATE:\n+        mapToUpdate = _customizedStateMap;\n+        break;\n+      case START_TIME:\n+        mapToUpdate = _startTimeMap;\n+        break;\n+      default:\n+        LOG.error(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MjIxNA==", "bodyText": "We could make it simpler and cleaner by adopting computeIfAbsent:\nmapToUpdate.computeIfAbsent(stateType, k -> new HashMap<>())\n  .computeIfAbsent(resourceName, k -> new HashMap<>())\n  .computeIfAbsent(partition, k -> new HashMap<>())\n  .put(instanceName, state);", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042214", "createdAt": "2020-08-02T07:12:38Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,63 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;\n+    switch (propertyName) {\n+      case CURRENT_STATE:\n+        mapToUpdate = _customizedStateMap;\n+        break;\n+      case START_TIME:\n+        mapToUpdate = _startTimeMap;\n+        break;\n+      default:\n+        LOG.error(\n+            \"The customized state property is not supported, could not update customized state output.\");\n+        return;\n+    }\n+    if (!mapToUpdate.containsKey(stateType)) {\n+      mapToUpdate.put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n     }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n+    if (!mapToUpdate.get(stateType).containsKey(resourceName)) {\n+      mapToUpdate.get(stateType).put(resourceName, new HashMap<Partition, Map<String, String>>());\n     }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    if (!mapToUpdate.get(stateType).get(resourceName).containsKey(partition)) {\n+      mapToUpdate.get(stateType).get(resourceName).put(partition, new HashMap<String, String>());\n     }\n-    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+    mapToUpdate.get(stateType).get(resourceName).get(partition).put(instanceName, state);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MjQ1NQ==", "bodyText": "I suggest warn level.", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042455", "createdAt": "2020-08-02T07:15:03Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -152,6 +161,31 @@ private void computeCustomizedStateView(final Resource resource, final String st\n     if (curCustomizedView == null || !curCustomizedView.getRecord().equals(view.getRecord())) {\n       // Add customized view to the list which will be written to ZK later.\n       updatedCustomizedViews.add(view);\n+      updatedStartTimestamps.put(resourceName,\n+          customizedStateOutput.getResourceStartTimeMap(stateType, resourceName));\n     }\n   }\n+\n+  private CustomizedViewMonitor getOrCreateMonitor(ClusterEvent event) {\n+    String clusterName = event.getClusterName();\n+    if (_monitors.get(clusterName) == null) {\n+      _monitors.put(clusterName, new CustomizedViewMonitor(clusterName));\n+    }\n+    return _monitors.get(clusterName);\n+  }\n+\n+  private void asyncReportLatency(ExecutorService threadPool, CustomizedViewMonitor monitor,\n+      List<CustomizedView> updatedCustomizedViews, Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, String>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long curTime) {\n+    AbstractBaseStage.asyncExecute(threadPool, () -> {\n+      try {\n+        monitor.reportLatency(updatedCustomizedViews, curCustomizedViews, updatedStartTimestamps,\n+            updateSuccess, curTime);\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to report UpdateToAggregationLatency metric.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MjYwNg==", "bodyText": "The latest helix-style doesn't format two empty lines. Maybe good to update helix-style in your IntelliJ.", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042606", "createdAt": "2020-08-02T07:16:43Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import com.google.common.collect.MapDifference;\n+import com.google.common.collect.Maps;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.collections.Lists;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MjYzNQ==", "bodyText": "static final", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042635", "createdAt": "2020-08-02T07:16:53Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import com.google.common.collect.MapDifference;\n+import com.google.common.collect.Maps;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.collections.Lists;\n+\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0Mjc4NQ==", "bodyText": "Apache License?", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042785", "createdAt": "2020-08-02T07:18:31Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.apache.helix.monitoring.mbeans;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MzQ3OA==", "bodyText": "It seems we need to consider concurrency?", "url": "https://github.com/apache/helix/pull/1187#discussion_r464043478", "createdAt": "2020-08-02T07:25:59Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import com.google.common.collect.MapDifference;\n+import com.google.common.collect.Maps;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.collections.Lists;\n+\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName =\n+        String.format(\"%s.%s\", MonitorDomainNames.RoutingTableProvider.name(), _clusterName);\n+    _updateToAggregationLatencyGauge = new HistogramDynamicMetric(\"UpdateToAggregationLatencyGauge\",\n+        new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  private void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjU1Mzc3", "url": "https://github.com/apache/helix/pull/1187#pullrequestreview-461255377", "createdAt": "2020-08-05T00:06:30Z", "commit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMDowNjozMFrOG71k8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMToxNjo1NFrOG72u9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Njk3OA==", "bodyText": "CustomizedView -> AggregatedView ? In this case, we can transfer EV TEV metrics to this domain in the future.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465396978", "createdAt": "2020-08-05T00:06:30Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/InstanceType.java", "diffHunk": "@@ -37,7 +37,8 @@\n       MonitorDomainNames.ClusterStatus.name(),\n       MonitorDomainNames.HelixZkClient.name(),\n       MonitorDomainNames.HelixCallback.name(),\n-      MonitorDomainNames.Rebalancer.name()\n+      MonitorDomainNames.Rebalancer.name(),\n+      MonitorDomainNames.CustomizedView.name()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NzQ3MQ==", "bodyText": "Will it be simpler if you set the start time inside setCustomizedState()? Are there any other cases that you want to update the state but don't touch the start time?\nThis will help to reduce duplicate code.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465397471", "createdAt": "2020-08-05T00:08:16Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -86,6 +86,9 @@ private void updateCustomizedStates(String instanceName, String customizedStateT\n           customizedStateOutput\n               .setCustomizedState(customizedStateType, resourceName, partition, instanceName,\n                   customizedState.getState(partitionName));\n+          customizedStateOutput", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Nzg5Nw==", "bodyText": "Can you process the long type inside the method? Converting the type in the caller is not clean. If you have multiple callers, then you will need to convert every time.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465397897", "createdAt": "2020-08-05T00:09:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -86,6 +86,9 @@ private void updateCustomizedStates(String instanceName, String customizedStateT\n           customizedStateOutput\n               .setCustomizedState(customizedStateType, resourceName, partition, instanceName,\n                   customizedState.getState(partitionName));\n+          customizedStateOutput\n+              .setStartTime(customizedStateType, resourceName, partition, instanceName,\n+                  String.valueOf(customizedState.getStartTime(partitionName)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5OTcxNg==", "bodyText": "It is called set start time, but you put a \"state\" in the parameter. It looks strange.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465399716", "createdAt": "2020-08-05T00:16:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMDE1MQ==", "bodyText": "These are duplicate logic with the switch block in getCustomizedStateProperty().", "url": "https://github.com/apache/helix/pull/1187#discussion_r465400151", "createdAt": "2020-08-05T00:17:48Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;\n+    switch (propertyName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMDQyNg==", "bodyText": "Why not save the Long type for the startTime here?", "url": "https://github.com/apache/helix/pull/1187#discussion_r465400426", "createdAt": "2020-08-05T00:18:47Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMTI4Ng==", "bodyText": "I know we are doing this style (separate maps for different fields) everywhere, but I am thinking if we can make it better. Either using the Pair or make a private class will definitely help to simplify the code here.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465401286", "createdAt": "2020-08-05T00:22:04Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMjU1NQ==", "bodyText": "Do you really need to clone the success array?", "url": "https://github.com/apache/helix/pull/1187#discussion_r465402555", "createdAt": "2020-08-05T00:26:36Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -107,8 +114,11 @@ public void execute(final ClusterEvent event) throws Exception {\n           }\n           // add/update customized-views from zk and cache\n           if (updatedCustomizedViews.size() > 0) {\n-            dataAccessor.setChildren(keys, updatedCustomizedViews);\n+            boolean[] success = dataAccessor.setChildren(keys, updatedCustomizedViews);\n             cache.updateCustomizedViews(stateType, updatedCustomizedViews);\n+            asyncReportLatency(cache.getAsyncTasksThreadPool(), getOrCreateMonitor(event),\n+                new ArrayList<>(updatedCustomizedViews), curCustomizedViewsCopy,\n+                new HashMap<>(updatedStartTimestamps), success.clone(), System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwOTYzMw==", "bodyText": "I think we shall make stage object stateless. So this monitor map shall be in the cache.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465409633", "createdAt": "2020-08-05T00:53:47Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -35,17 +37,20 @@\n import org.apache.helix.controller.LogUtil;\n import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AbstractBaseStage;\n import org.apache.helix.controller.pipeline.AsyncWorkerType;\n import org.apache.helix.controller.pipeline.StageException;\n import org.apache.helix.model.CustomizedView;\n import org.apache.helix.model.Partition;\n import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.CustomizedViewMonitor;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n   private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+  private Map<String, CustomizedViewMonitor> _monitors = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNTkyNA==", "bodyText": "Once we put this map into the cache object, concurrent control is necessary for this method.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465415924", "createdAt": "2020-08-05T01:16:54Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -152,6 +163,33 @@ private void computeCustomizedStateView(final Resource resource, final String st\n     if (curCustomizedView == null || !curCustomizedView.getRecord().equals(view.getRecord())) {\n       // Add customized view to the list which will be written to ZK later.\n       updatedCustomizedViews.add(view);\n+      updatedStartTimestamps.put(resourceName,\n+          customizedStateOutput.getResourceStartTimeMap(stateType, resourceName));\n     }\n   }\n+\n+  private CustomizedViewMonitor getOrCreateMonitor(ClusterEvent event) throws JMException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMzM3OTE5", "url": "https://github.com/apache/helix/pull/1187#pullrequestreview-461337919", "createdAt": "2020-08-05T04:51:06Z", "commit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDo1MTowNlrOG76F8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNToyNToxMlrOG76rWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MDk2Mw==", "bodyText": "Good change!", "url": "https://github.com/apache/helix/pull/1187#discussion_r465470963", "createdAt": "2020-08-05T04:51:06Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;\n+    switch (propertyName) {\n+      case CURRENT_STATE:\n+        mapToUpdate = _customizedStateMap;\n+        break;\n+      case START_TIME:\n+        mapToUpdate = _startTimeMap;\n+        break;\n+      default:\n+        LOG.warn(\n+            \"The customized state property is not supported, could not update customized state output.\");\n+        return;\n     }\n-    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+\n+    mapToUpdate.computeIfAbsent(stateType, k -> new HashMap<>())\n+        .computeIfAbsent(resourceName, k -> new HashMap<>())\n+        .computeIfAbsent(partition, k -> new HashMap<>())\n+        .put(instanceName, state);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MjY4OA==", "bodyText": "Can we rename mapToUpdate and the following readFromMap to be more meaningful and following convention.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465472688", "createdAt": "2020-08-05T04:56:58Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NDgzMw==", "bodyText": "As you never use this variable in other places, just move it to line 120.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465474833", "createdAt": "2020-08-05T05:05:03Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -97,7 +103,8 @@ public void execute(final ClusterEvent event) throws Exception {\n       for (Resource resource : resourceMap.values()) {\n         try {\n           computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n-              updatedCustomizedViews);\n+              updatedCustomizedViews, updatedStartTimestamps);\n+          Map<String, CustomizedView> curCustomizedViewsCopy = new HashMap<>(curCustomizedViews);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NTExNQ==", "bodyText": "Have you run the whole integration tests? I'm a bit concerned about the extra memory cost. Do you need to whole curCustomizedViewCopy? The ones that are corresponding to the updatedViews should be fine, right? as you only need those timestamps to compare.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465475115", "createdAt": "2020-08-05T05:06:02Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -107,8 +114,11 @@ public void execute(final ClusterEvent event) throws Exception {\n           }\n           // add/update customized-views from zk and cache\n           if (updatedCustomizedViews.size() > 0) {\n-            dataAccessor.setChildren(keys, updatedCustomizedViews);\n+            boolean[] success = dataAccessor.setChildren(keys, updatedCustomizedViews);\n             cache.updateCustomizedViews(stateType, updatedCustomizedViews);\n+            asyncReportLatency(cache.getAsyncTasksThreadPool(), getOrCreateMonitor(event),\n+                new ArrayList<>(updatedCustomizedViews), curCustomizedViewsCopy,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NjU4NQ==", "bodyText": "-> timestamp, one word.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465476585", "createdAt": "2020-08-05T05:11:20Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.CustomizedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, String>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long endTime) {\n+    if (updatedCustomizedViews == null || curCustomizedViews == null\n+        || updatedStartTimestamps == null) {\n+      LOG.warn(\"Cannot find updated time stamps for customized states, input parameter is null.\");\n+      return;\n+    }\n+\n+    List<Long> collectedTimestamps = new ArrayList<>();\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      if (!updateSuccess[i]) {\n+        continue;\n+      }\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+      CustomizedView oldCV =\n+          curCustomizedViews.getOrDefault(resourceName, new CustomizedView(resourceName));\n+      if (newCV.getRecord().equals(oldCV.getRecord())) {\n+        continue;\n+      }\n+\n+      Map<String, Map<String, String>> newPartitionStateMaps = newCV.getRecord().getMapFields();\n+      Map<String, Map<String, String>> oldPartitionStateMaps = oldCV.getRecord().getMapFields();\n+      Map<Partition, Map<String, String>> partitionStartTimeMaps =\n+          updatedStartTimestamps.getOrDefault(resourceName, Collections.emptyMap());\n+\n+      for (Map.Entry<String, Map<String, String>> partitionStateMapEntry : newPartitionStateMaps\n+          .entrySet()) {\n+        String partitionName = partitionStateMapEntry.getKey();\n+        Map<String, String> newStateMap = partitionStateMapEntry.getValue();\n+        Map<String, String> oldStateMap =\n+            oldPartitionStateMaps.getOrDefault(partitionName, Collections.emptyMap());\n+        if (!newStateMap.equals(oldStateMap)) {\n+          Map<String, String> partitionStartTimeMap = partitionStartTimeMaps\n+              .getOrDefault(new Partition(partitionName), Collections.emptyMap());\n+\n+          for (Map.Entry<String, String> stateMapEntry : newStateMap.entrySet()) {\n+            String instanceName = stateMapEntry.getKey();\n+            if (!stateMapEntry.getValue().equals(oldStateMap.get(instanceName))) {\n+              try {\n+                long timestamp = Long.parseLong(partitionStartTimeMap.get(instanceName));\n+                if (timestamp > 0) {\n+                  collectedTimestamps.add(timestamp);\n+                } else {\n+                  LOG.warn(\n+                      \"Failed to find customized state update time stamp for reos, the number should be positive.\");\n+                }\n+              } catch (NumberFormatException e) {\n+                LOG.warn(\"Error occurs while parsing customized state update time stamp\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3ODA2OA==", "bodyText": "Is this still necessary? The updated customized views should have been compared and filtered.", "url": "https://github.com/apache/helix/pull/1187#discussion_r465478068", "createdAt": "2020-08-05T05:16:32Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.CustomizedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, String>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long endTime) {\n+    if (updatedCustomizedViews == null || curCustomizedViews == null\n+        || updatedStartTimestamps == null) {\n+      LOG.warn(\"Cannot find updated time stamps for customized states, input parameter is null.\");\n+      return;\n+    }\n+\n+    List<Long> collectedTimestamps = new ArrayList<>();\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      if (!updateSuccess[i]) {\n+        continue;\n+      }\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+      CustomizedView oldCV =\n+          curCustomizedViews.getOrDefault(resourceName, new CustomizedView(resourceName));\n+      if (newCV.getRecord().equals(oldCV.getRecord())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3ODg0Nw==", "bodyText": "typo?", "url": "https://github.com/apache/helix/pull/1187#discussion_r465478847", "createdAt": "2020-08-05T05:19:32Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.CustomizedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, String>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long endTime) {\n+    if (updatedCustomizedViews == null || curCustomizedViews == null\n+        || updatedStartTimestamps == null) {\n+      LOG.warn(\"Cannot find updated time stamps for customized states, input parameter is null.\");\n+      return;\n+    }\n+\n+    List<Long> collectedTimestamps = new ArrayList<>();\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      if (!updateSuccess[i]) {\n+        continue;\n+      }\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+      CustomizedView oldCV =\n+          curCustomizedViews.getOrDefault(resourceName, new CustomizedView(resourceName));\n+      if (newCV.getRecord().equals(oldCV.getRecord())) {\n+        continue;\n+      }\n+\n+      Map<String, Map<String, String>> newPartitionStateMaps = newCV.getRecord().getMapFields();\n+      Map<String, Map<String, String>> oldPartitionStateMaps = oldCV.getRecord().getMapFields();\n+      Map<Partition, Map<String, String>> partitionStartTimeMaps =\n+          updatedStartTimestamps.getOrDefault(resourceName, Collections.emptyMap());\n+\n+      for (Map.Entry<String, Map<String, String>> partitionStateMapEntry : newPartitionStateMaps\n+          .entrySet()) {\n+        String partitionName = partitionStateMapEntry.getKey();\n+        Map<String, String> newStateMap = partitionStateMapEntry.getValue();\n+        Map<String, String> oldStateMap =\n+            oldPartitionStateMaps.getOrDefault(partitionName, Collections.emptyMap());\n+        if (!newStateMap.equals(oldStateMap)) {\n+          Map<String, String> partitionStartTimeMap = partitionStartTimeMaps\n+              .getOrDefault(new Partition(partitionName), Collections.emptyMap());\n+\n+          for (Map.Entry<String, String> stateMapEntry : newStateMap.entrySet()) {\n+            String instanceName = stateMapEntry.getKey();\n+            if (!stateMapEntry.getValue().equals(oldStateMap.get(instanceName))) {\n+              try {\n+                long timestamp = Long.parseLong(partitionStartTimeMap.get(instanceName));\n+                if (timestamp > 0) {\n+                  collectedTimestamps.add(timestamp);\n+                } else {\n+                  LOG.warn(\n+                      \"Failed to find customized state update time stamp for reos, the number should be positive.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4MDUzOQ==", "bodyText": "Can you explain what is verified as 0?", "url": "https://github.com/apache/helix/pull/1187#discussion_r465480539", "createdAt": "2020-08-05T05:25:12Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestCustomizedViewStage.java", "diffHunk": "@@ -112,4 +110,60 @@ public void testCachedCustomizedViews() throws Exception {\n     deleteLiveInstances(clusterName);\n     deleteCluster(clusterName);\n   }\n+\n+  @Test\n+  public void testLatencyMetricReporting() throws Exception {\n+    String clusterName = \"CLUSTER_\" + TestHelper.getTestMethodName();\n+\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n+    HelixManager manager = new DummyClusterManager(clusterName, accessor);\n+\n+    // ideal state: node0 is MASTER, node1 is SLAVE\n+    // replica=2 means 1 master and 1 slave\n+    setupIdealState(clusterName, new int[]{0, 1}, new String[]{\"TestDB\"}, 1, 2);\n+    setupLiveInstances(clusterName, new int[]{0, 1});\n+    setupStateModel(clusterName);\n+\n+    ClusterEvent event = new ClusterEvent(clusterName, ClusterEventType.Unknown);\n+    ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n+    event.addAttribute(AttributeName.helixmanager.name(), manager);\n+    event.addAttribute(AttributeName.ControllerDataProvider.name(), cache);\n+\n+    CustomizedStateConfig config = new CustomizedStateConfig();\n+    List<String> aggregationEnabledTypes = new ArrayList<>();\n+    aggregationEnabledTypes.add(CUSTOMIZED_STATE_NAME);\n+    config.setAggregationEnabledTypes(aggregationEnabledTypes);\n+\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    accessor.setProperty(keyBuilder.customizedStateConfig(), config);\n+\n+    CustomizedState customizedState = new CustomizedState(RESOURCE_NAME);\n+    customizedState.setState(PARTITION_NAME, \"STATE\");\n+    customizedState.setStartTime(PARTITION_NAME, 0);\n+    accessor.setProperty(\n+        keyBuilder.customizedState(INSTANCE_NAME, CUSTOMIZED_STATE_NAME, RESOURCE_NAME),\n+        customizedState);\n+\n+    Pipeline dataRefresh = new Pipeline();\n+    dataRefresh.addStage(new ReadClusterDataStage());\n+    runPipeline(event, dataRefresh);\n+    runStage(event, new ResourceComputationStage());\n+    runStage(event, new CustomizedStateComputationStage());\n+    runStage(event, new CustomizedViewAggregationStage());\n+\n+    ObjectName objectName = new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", clusterName));\n+    ObjectInstance monitor = _server.getObjectInstance(objectName);\n+    Assert.assertNotNull(monitor);\n+    TestHelper.verify(() -> (long) _server.getAttribute(objectName,\n+        CustomizedViewMonitor.UPDATE_TO_AGGREGATION_LATENCY_GAUGE + \".Max\") == 0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2568e8a5308b21ff171831700a9bdbdde8ba9cae", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/2568e8a5308b21ff171831700a9bdbdde8ba9cae", "committedDate": "2020-08-07T01:02:30Z", "message": "add metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "717c8b82ed7dbce7780bd2c05c0ddb18197c409a", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/717c8b82ed7dbce7780bd2c05c0ddb18197c409a", "committedDate": "2020-08-07T01:02:30Z", "message": "Modified implementation and add test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e79fd2381dd2265c74fb4c1036d6cc70892d830", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/4e79fd2381dd2265c74fb4c1036d6cc70892d830", "committedDate": "2020-08-07T01:02:30Z", "message": "Modify existing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "512f65bf3234874a83426cc62cac22d37ae99be6", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/512f65bf3234874a83426cc62cac22d37ae99be6", "committedDate": "2020-08-07T01:04:50Z", "message": "Modify aggregation stage and move monitor to cache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94b664732cce9b1e297e82aefb142735657eb1a4", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/94b664732cce9b1e297e82aefb142735657eb1a4", "committedDate": "2020-08-06T19:37:10Z", "message": "Modify aggregation stage and move monitor to cache"}, "afterCommit": {"oid": "512f65bf3234874a83426cc62cac22d37ae99be6", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/512f65bf3234874a83426cc62cac22d37ae99be6", "committedDate": "2020-08-07T01:04:50Z", "message": "Modify aggregation stage and move monitor to cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMDU4MTQ5", "url": "https://github.com/apache/helix/pull/1187#pullrequestreview-463058149", "createdAt": "2020-08-07T06:14:11Z", "commit": {"oid": "512f65bf3234874a83426cc62cac22d37ae99be6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwNjoxNDoxMVrOG9NwMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwNjoyNDo0OVrOG9N91w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MTY0OA==", "bodyText": "Can we log somewhere how many updates are failed? It's useful information.", "url": "https://github.com/apache/helix/pull/1187#discussion_r466841648", "createdAt": "2020-08-07T06:14:11Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -112,14 +115,18 @@ public void execute(final ClusterEvent event) throws Exception {\n       }\n       // add/update customized-views from zk and cache\n       if (updatedCustomizedViews.size() > 0) {\n-        dataAccessor.setChildren(keys, updatedCustomizedViews);\n+        boolean[] success = dataAccessor.setChildren(keys, updatedCustomizedViews);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "512f65bf3234874a83426cc62cac22d37ae99be6"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MjQ0MQ==", "bodyText": "You commented as not necessary?", "url": "https://github.com/apache/helix/pull/1187#discussion_r466842441", "createdAt": "2020-08-07T06:16:37Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestCustomizedViewStage.java", "diffHunk": "@@ -112,4 +110,60 @@ public void testCachedCustomizedViews() throws Exception {\n     deleteLiveInstances(clusterName);\n     deleteCluster(clusterName);\n   }\n+\n+  @Test\n+  public void testLatencyMetricReporting() throws Exception {\n+    String clusterName = \"CLUSTER_\" + TestHelper.getTestMethodName();\n+\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n+    HelixManager manager = new DummyClusterManager(clusterName, accessor);\n+\n+    // ideal state: node0 is MASTER, node1 is SLAVE\n+    // replica=2 means 1 master and 1 slave\n+    setupIdealState(clusterName, new int[]{0, 1}, new String[]{\"TestDB\"}, 1, 2);\n+    setupLiveInstances(clusterName, new int[]{0, 1});\n+    setupStateModel(clusterName);\n+\n+    ClusterEvent event = new ClusterEvent(clusterName, ClusterEventType.Unknown);\n+    ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n+    event.addAttribute(AttributeName.helixmanager.name(), manager);\n+    event.addAttribute(AttributeName.ControllerDataProvider.name(), cache);\n+\n+    CustomizedStateConfig config = new CustomizedStateConfig();\n+    List<String> aggregationEnabledTypes = new ArrayList<>();\n+    aggregationEnabledTypes.add(CUSTOMIZED_STATE_NAME);\n+    config.setAggregationEnabledTypes(aggregationEnabledTypes);\n+\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    accessor.setProperty(keyBuilder.customizedStateConfig(), config);\n+\n+    CustomizedState customizedState = new CustomizedState(RESOURCE_NAME);\n+    customizedState.setState(PARTITION_NAME, \"STATE\");\n+    customizedState.setStartTime(PARTITION_NAME, 0);\n+    accessor.setProperty(\n+        keyBuilder.customizedState(INSTANCE_NAME, CUSTOMIZED_STATE_NAME, RESOURCE_NAME),\n+        customizedState);\n+\n+    Pipeline dataRefresh = new Pipeline();\n+    dataRefresh.addStage(new ReadClusterDataStage());\n+    runPipeline(event, dataRefresh);\n+    runStage(event, new ResourceComputationStage());\n+    runStage(event, new CustomizedStateComputationStage());\n+    runStage(event, new CustomizedViewAggregationStage());\n+\n+    ObjectName objectName = new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Cluster\", clusterName));\n+    ObjectInstance monitor = _server.getObjectInstance(objectName);\n+    Assert.assertNotNull(monitor);\n+    TestHelper.verify(() -> (long) _server.getAttribute(objectName,\n+        CustomizedViewMonitor.UPDATE_TO_AGGREGATION_LATENCY_GAUGE + \".Max\") != 0,\n+        TestHelper.WAIT_DURATION);\n+\n+    if (manager.isConnected()) {\n+      manager.disconnect(); // For DummyClusterManager, this is not necessary", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "512f65bf3234874a83426cc62cac22d37ae99be6"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0NTE0Mw==", "bodyText": "Is getOrDefault necessary? You already new one in aggregation stage.", "url": "https://github.com/apache/helix/pull/1187#discussion_r466845143", "createdAt": "2020-08-07T06:24:49Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, Long>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long endTime) {\n+    if (updatedCustomizedViews == null || curCustomizedViews == null\n+        || updatedStartTimestamps == null) {\n+      LOG.warn(\"Cannot find updated time stamps for customized states, input parameter is null.\");\n+      return;\n+    }\n+\n+    List<Long> collectedTimestamps = new ArrayList<>();\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      if (!updateSuccess[i]) {\n+        continue;\n+      }\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+      CustomizedView oldCV =\n+          curCustomizedViews.getOrDefault(resourceName, new CustomizedView(resourceName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "512f65bf3234874a83426cc62cac22d37ae99be6"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfc72a7bb55393cd8fb96da3f5a78915e017a623", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/dfc72a7bb55393cd8fb96da3f5a78915e017a623", "committedDate": "2020-08-07T17:43:22Z", "message": "Update logging"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Njc1NTc3", "url": "https://github.com/apache/helix/pull/1187#pullrequestreview-464675577", "createdAt": "2020-08-11T00:39:33Z", "commit": {"oid": "dfc72a7bb55393cd8fb96da3f5a78915e017a623"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMDozOTozNFrOG-kZ2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMDo0Nzo1MVrOG-kiwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MTMzNg==", "bodyText": "Besides cluster name, can we also have customized View as part of the key? Maybe type = customized view? This is mainly for future extension.", "url": "https://github.com/apache/helix/pull/1187#discussion_r468261336", "createdAt": "2020-08-11T00:39:34Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Cluster\", _clusterName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc72a7bb55393cd8fb96da3f5a78915e017a623"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MjM5NA==", "bodyText": "Please mention a little bit more about the parameter usage here. Basically we only update the timestamp if the state has been changed, right?", "url": "https://github.com/apache/helix/pull/1187#discussion_r468262394", "createdAt": "2020-08-11T00:43:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc72a7bb55393cd8fb96da3f5a78915e017a623"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MzYxOA==", "bodyText": "On my second thought, let's follow the convention (refer to _clusterStatusMonitor) and put it in GenericHelixController. What do you think?\nThe problem with the cache is that this object won't be available if we change to pass the snapshot later.\nIn general, we should always use the event to carry the monitors. And GenericHelixController is one of the easiest options.", "url": "https://github.com/apache/helix/pull/1187#discussion_r468263618", "createdAt": "2020-08-11T00:47:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -79,6 +82,7 @@\n   // Maintain a set of all ChangeTypes for change detection\n   private Set<HelixConstants.ChangeType> _refreshedChangeTypes;\n   private Set<String> _aggregationEnabledTypes = new HashSet<>();\n+  private Map<String, CustomizedViewMonitor> _customizedViewMonitors = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc72a7bb55393cd8fb96da3f5a78915e017a623"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f3c64970732b82477a37ba1e0455f9cb22f63c5", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/1f3c64970732b82477a37ba1e0455f9cb22f63c5", "committedDate": "2020-08-11T22:49:38Z", "message": "Move monitor from cache to cluster status monitor"}, "afterCommit": {"oid": "1813eecb8e015c400e7c88c24c6e635e67301541", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/1813eecb8e015c400e7c88c24c6e635e67301541", "committedDate": "2020-08-11T23:57:37Z", "message": "Move monitor from cache to cluster status monitor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1813eecb8e015c400e7c88c24c6e635e67301541", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/1813eecb8e015c400e7c88c24c6e635e67301541", "committedDate": "2020-08-11T23:57:37Z", "message": "Move monitor from cache to cluster status monitor"}, "afterCommit": {"oid": "db48ed9d8ca7b94d141bbc15c72955dd39dc50a5", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/db48ed9d8ca7b94d141bbc15c72955dd39dc50a5", "committedDate": "2020-08-12T19:00:01Z", "message": "Move monitor from cache to cluster status monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "committedDate": "2020-08-12T19:02:10Z", "message": "Move monitor from cache to cluster status monitor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "db48ed9d8ca7b94d141bbc15c72955dd39dc50a5", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/db48ed9d8ca7b94d141bbc15c72955dd39dc50a5", "committedDate": "2020-08-12T19:00:01Z", "message": "Move monitor from cache to cluster status monitor"}, "afterCommit": {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "committedDate": "2020-08-12T19:02:10Z", "message": "Move monitor from cache to cluster status monitor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzQ4NDU2", "url": "https://github.com/apache/helix/pull/1187#pullrequestreview-466348456", "createdAt": "2020-08-12T23:44:28Z", "commit": {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMzo0NDoyOFrOG_2j_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMDowNjowOVrOG_2-kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYwNzQyMQ==", "bodyText": "This should match the ObjectName", "url": "https://github.com/apache/helix/pull/1187#discussion_r469607421", "createdAt": "2020-08-12T23:44:28Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+  private ClusterStatusMonitor _clusterStatusMonitor;\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYwNzY1NA==", "bodyText": "nit, remove the \"CustomizedView\" hard code.", "url": "https://github.com/apache/helix/pull/1187#discussion_r469607654", "createdAt": "2020-08-12T23:45:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+  private ClusterStatusMonitor _clusterStatusMonitor;\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s,%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Type\",\n+            \"CustomizedView\", \"Cluster\", _clusterName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYwOTYxMw==", "bodyText": "So this is a single metric for all the states. I'm thinking if we will need per-resource metrics in the future?\nThe thing is that, if you do per-resource for now, we can always get the global latency data by aggregating on the readers' side. But if you do the global latency, then there is no way we can get per-resource latency.", "url": "https://github.com/apache/helix/pull/1187#discussion_r469609613", "createdAt": "2020-08-12T23:51:14Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+  private ClusterStatusMonitor _clusterStatusMonitor;\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s,%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Type\",\n+            \"CustomizedView\", \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * Latency reporting excludes: updating a customized state that is the same as previous customized state,\n+   * deleting a customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput.\n+   * START_TIME field is automatically updated when a customized state for a partition is updated by CustomizedStateProvider.\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxMTAxMg==", "bodyText": "System.currentTimeMillis() can be inside asyncReportLatency.", "url": "https://github.com/apache/helix/pull/1187#discussion_r469611012", "createdAt": "2020-08-12T23:55:55Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -112,15 +119,22 @@ public void execute(final ClusterEvent event) throws Exception {\n       }\n       // add/update customized-views from zk and cache\n       if (updatedCustomizedViews.size() > 0) {\n-        dataAccessor.setChildren(keys, updatedCustomizedViews);\n+        boolean[] success = dataAccessor.setChildren(keys, updatedCustomizedViews);\n         cache.updateCustomizedViews(stateType, updatedCustomizedViews);\n+        asyncReportLatency(cache.getAsyncTasksThreadPool(),\n+            event.getAttribute(AttributeName.clusterStatusMonitor.name()),\n+            new ArrayList<>(updatedCustomizedViews), curCustomizedViewsCopy,\n+            new HashMap<>(updatedStartTimestamps), success, System.currentTimeMillis(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNDIyNA==", "bodyText": "As we discussed, since this stage is already async stage, we don't need to introduce these complicities, we can make the report logic synchronizely done in this stage.", "url": "https://github.com/apache/helix/pull/1187#discussion_r469614224", "createdAt": "2020-08-13T00:06:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -88,7 +93,9 @@ public void execute(final ClusterEvent event) throws Exception {\n     // update customized view\n     for (String stateType : customizedStateOutput.getAllStateTypes()) {\n       List<CustomizedView> updatedCustomizedViews = new ArrayList<>();\n+      Map<String, Map<Partition, Map<String, Long>>> updatedStartTimestamps = new HashMap<>();\n       Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      Map<String, CustomizedView> curCustomizedViewsCopy = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b9ca288466dffce324583ae0a8941e48316cc9b", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/7b9ca288466dffce324583ae0a8941e48316cc9b", "committedDate": "2020-08-13T00:53:44Z", "message": "Make reporting latency synchronous"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTc0MDg2", "url": "https://github.com/apache/helix/pull/1187#pullrequestreview-467174086", "createdAt": "2020-08-13T22:30:46Z", "commit": {"oid": "7b9ca288466dffce324583ae0a8941e48316cc9b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjozMDo0NlrOHAf4eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMDo1NjowMlrOHAjs9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NDQwOQ==", "bodyText": "nit, could it be null?", "url": "https://github.com/apache/helix/pull/1187#discussion_r470284409", "createdAt": "2020-08-13T22:30:46Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+  private ClusterStatusMonitor _clusterStatusMonitor;\n+  private static final String TYPE_KEY = \"Type\";\n+  private static final String CLUSTER_KEY = \"Cluster\";\n+  private static final String CUSTOMIZED_VIEW = \"CustomizedView\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String\n+        .format(\"%s:%s=%s,%s=%s\", MonitorDomainNames.AggregatedView.name(), TYPE_KEY,\n+            CUSTOMIZED_VIEW, CLUSTER_KEY, _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanObjectName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanObjectName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s,%s=%s\", MonitorDomainNames.AggregatedView.name(), TYPE_KEY,\n+            CUSTOMIZED_VIEW, CLUSTER_KEY, _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  public void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b9ca288466dffce324583ae0a8941e48316cc9b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0MjQ5NA==", "bodyText": "Seems no other callers, make it private? In that case, no need to make it unmodifiableMap", "url": "https://github.com/apache/helix/pull/1187#discussion_r470342494", "createdAt": "2020-08-14T00:49:30Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -65,6 +70,11 @@ public void setCustomizedState(String stateType, String resourceName, Partition\n     return Collections.emptyMap();\n   }\n \n+  public Map<String, Map<Partition, Map<String, Long>>> getStartTimeMap(String stateType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b9ca288466dffce324583ae0a8941e48316cc9b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0NjQ5OA==", "bodyText": "If the resource is newly created, will the oldCV contain the object?", "url": "https://github.com/apache/helix/pull/1187#discussion_r470346498", "createdAt": "2020-08-14T00:55:17Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -152,6 +162,68 @@ private void computeCustomizedStateView(final Resource resource, final String st\n     if (curCustomizedView == null || !curCustomizedView.getRecord().equals(view.getRecord())) {\n       // Add customized view to the list which will be written to ZK later.\n       updatedCustomizedViews.add(view);\n+      updatedStartTimestamps.put(resourceName,\n+          customizedStateOutput.getResourceStartTimeMap(stateType, resourceName));\n+    }\n+  }\n+\n+  private void reportLatency(ClusterEvent event, List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, Long>>> updatedStartTimestamps,\n+      boolean[] updateSuccess) {\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+    if (clusterStatusMonitor == null) {\n+      return;\n+    }\n+    long curTime = System.currentTimeMillis();\n+    String clusterName = event.getClusterName();\n+    CustomizedViewMonitor customizedViewMonitor =\n+        clusterStatusMonitor.getOrCreateCustomizedViewMonitor(clusterName);\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+\n+      if (!updateSuccess[i]) {\n+        LOG.warn(\"Customized views are not updated successfully for resource {} on cluster {}\",\n+            resourceName, clusterName);\n+        continue;\n+      }\n+\n+      CustomizedView oldCV =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b9ca288466dffce324583ae0a8941e48316cc9b"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0Njk5Ng==", "bodyText": "On the other hand, if the resource is removed, then this loop won't check the latency of that resource? But I think this is OK, since there is no start time to track anyway.", "url": "https://github.com/apache/helix/pull/1187#discussion_r470346996", "createdAt": "2020-08-14T00:56:02Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -152,6 +162,68 @@ private void computeCustomizedStateView(final Resource resource, final String st\n     if (curCustomizedView == null || !curCustomizedView.getRecord().equals(view.getRecord())) {\n       // Add customized view to the list which will be written to ZK later.\n       updatedCustomizedViews.add(view);\n+      updatedStartTimestamps.put(resourceName,\n+          customizedStateOutput.getResourceStartTimeMap(stateType, resourceName));\n+    }\n+  }\n+\n+  private void reportLatency(ClusterEvent event, List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, Long>>> updatedStartTimestamps,\n+      boolean[] updateSuccess) {\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+    if (clusterStatusMonitor == null) {\n+      return;\n+    }\n+    long curTime = System.currentTimeMillis();\n+    String clusterName = event.getClusterName();\n+    CustomizedViewMonitor customizedViewMonitor =\n+        clusterStatusMonitor.getOrCreateCustomizedViewMonitor(clusterName);\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+\n+      if (!updateSuccess[i]) {\n+        LOG.warn(\"Customized views are not updated successfully for resource {} on cluster {}\",\n+            resourceName, clusterName);\n+        continue;\n+      }\n+\n+      CustomizedView oldCV =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0NjQ5OA=="}, "originalCommit": {"oid": "7b9ca288466dffce324583ae0a8941e48316cc9b"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9e17e010d33a58b53006d2fbee129960500288d", "author": {"user": {"login": "mgao0", "name": "Molly Gao"}}, "url": "https://github.com/apache/helix/commit/f9e17e010d33a58b53006d2fbee129960500288d", "committedDate": "2020-08-14T01:14:44Z", "message": "Fix for comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MjUzMjUx", "url": "https://github.com/apache/helix/pull/1187#pullrequestreview-467253251", "createdAt": "2020-08-14T01:26:50Z", "commit": {"oid": "f9e17e010d33a58b53006d2fbee129960500288d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4603, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}