{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxOTg5Mjg3", "number": 1078, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMDo0MDoxNlrOEFvgyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoyMzowNVrOEG3RPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDU2Nzc4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/constraints/PartitionMovementConstraint.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMDo0MDoxNlrOGkHUIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODoyNzo0MVrOGlR77w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUyMTc2Mw==", "bodyText": "Maybe  block Comments here?", "url": "https://github.com/apache/helix/pull/1078#discussion_r440521763", "createdAt": "2020-06-16T00:40:16Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/constraints/PartitionMovementConstraint.java", "diffHunk": "@@ -40,31 +40,53 @@\n class PartitionMovementConstraint extends SoftConstraint {\n   private static final double MAX_SCORE = 1f;\n   private static final double MIN_SCORE = 0f;\n-  //TODO: these factors will be tuned based on user's preference\n-  // This factor indicates the default score that is evaluated if only partition allocation matches\n-  // (states are different).\n-  private static final double ALLOCATION_MATCH_FACTOR = 0.5;\n+  // The scale factor to adjust score when the proposed allocation partially matches the assignment\n+  // plan but will require a state transition (with partition movement).\n+  // TODO: these factors will be tuned based on user's preference\n+  private static final double STATE_TRANSITION_COST_FACTOR = 0.5;\n+  private static final double MOVEMENT_COST_FACTOR = 0.25;\n \n   PartitionMovementConstraint() {\n     super(MAX_SCORE, MIN_SCORE);\n   }\n \n+  /**\n+   * @return 1 if the proposed assignment completely matches the previous best possible assignment\n+   *         (or baseline assignment if the replica is newly added).\n+   *         STATE_TRANSITION_COST_FACTOR if the proposed assignment's allocation matches the\n+   *         previous Best Possible assignment (or baseline assignment if the replica is newly\n+   *         added) but state does not match.\n+   *         MOVEMENT_COST_FACTOR if the proposed assignment's allocation matches the baseline\n+   *         assignment only, but not matches the previous best possible assignment.\n+   *         0 if the proposed assignment is a pure random movement.\n+   */\n   @Override\n   protected double getAssignmentScore(AssignableNode node, AssignableReplica replica,\n       ClusterContext clusterContext) {\n-    // Prioritize the previous Best Possible assignment\n     Map<String, String> bestPossibleAssignment =\n         getStateMap(replica, clusterContext.getBestPossibleAssignment());\n-    if (!bestPossibleAssignment.isEmpty()) {\n-      return calculateAssignmentScale(node, replica, bestPossibleAssignment);\n-    }\n-    // else, compare the baseline only if the best possible assignment does not contain the replica\n     Map<String, String> baselineAssignment =\n         getStateMap(replica, clusterContext.getBaselineAssignment());\n-    if (!baselineAssignment.isEmpty()) {\n-      return calculateAssignmentScale(node, replica, baselineAssignment);\n+    String nodeName = node.getInstanceName();\n+    String state = replica.getReplicaState();\n+\n+    if (bestPossibleAssignment.isEmpty()) {\n+      // If bestPossibleAssignment of the replica is empty, indicating this is a new replica.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "769aee1d492f689e7636456b1c5e675af9b0930c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0NDM2Nw==", "bodyText": "Thanks for the review, usually we use the block for the method/class java doc.\nThese are 2 lines of comments so it does not help much, IMHO.", "url": "https://github.com/apache/helix/pull/1078#discussion_r441744367", "createdAt": "2020-06-17T18:27:41Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/constraints/PartitionMovementConstraint.java", "diffHunk": "@@ -40,31 +40,53 @@\n class PartitionMovementConstraint extends SoftConstraint {\n   private static final double MAX_SCORE = 1f;\n   private static final double MIN_SCORE = 0f;\n-  //TODO: these factors will be tuned based on user's preference\n-  // This factor indicates the default score that is evaluated if only partition allocation matches\n-  // (states are different).\n-  private static final double ALLOCATION_MATCH_FACTOR = 0.5;\n+  // The scale factor to adjust score when the proposed allocation partially matches the assignment\n+  // plan but will require a state transition (with partition movement).\n+  // TODO: these factors will be tuned based on user's preference\n+  private static final double STATE_TRANSITION_COST_FACTOR = 0.5;\n+  private static final double MOVEMENT_COST_FACTOR = 0.25;\n \n   PartitionMovementConstraint() {\n     super(MAX_SCORE, MIN_SCORE);\n   }\n \n+  /**\n+   * @return 1 if the proposed assignment completely matches the previous best possible assignment\n+   *         (or baseline assignment if the replica is newly added).\n+   *         STATE_TRANSITION_COST_FACTOR if the proposed assignment's allocation matches the\n+   *         previous Best Possible assignment (or baseline assignment if the replica is newly\n+   *         added) but state does not match.\n+   *         MOVEMENT_COST_FACTOR if the proposed assignment's allocation matches the baseline\n+   *         assignment only, but not matches the previous best possible assignment.\n+   *         0 if the proposed assignment is a pure random movement.\n+   */\n   @Override\n   protected double getAssignmentScore(AssignableNode node, AssignableReplica replica,\n       ClusterContext clusterContext) {\n-    // Prioritize the previous Best Possible assignment\n     Map<String, String> bestPossibleAssignment =\n         getStateMap(replica, clusterContext.getBestPossibleAssignment());\n-    if (!bestPossibleAssignment.isEmpty()) {\n-      return calculateAssignmentScale(node, replica, bestPossibleAssignment);\n-    }\n-    // else, compare the baseline only if the best possible assignment does not contain the replica\n     Map<String, String> baselineAssignment =\n         getStateMap(replica, clusterContext.getBaselineAssignment());\n-    if (!baselineAssignment.isEmpty()) {\n-      return calculateAssignmentScale(node, replica, baselineAssignment);\n+    String nodeName = node.getInstanceName();\n+    String state = replica.getReplicaState();\n+\n+    if (bestPossibleAssignment.isEmpty()) {\n+      // If bestPossibleAssignment of the replica is empty, indicating this is a new replica.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUyMTc2Mw=="}, "originalCommit": {"oid": "769aee1d492f689e7636456b1c5e675af9b0930c"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDU3MDU4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/constraints/PartitionMovementConstraint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMDo0MTo1NVrOGkHWAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMDo0MTo1NVrOGkHWAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUyMjI0Mg==", "bodyText": "Maybe trailing Comments?", "url": "https://github.com/apache/helix/pull/1078#discussion_r440522242", "createdAt": "2020-06-16T00:41:55Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/constraints/PartitionMovementConstraint.java", "diffHunk": "@@ -77,15 +99,16 @@ protected double getAssignmentScore(AssignableNode node, AssignableReplica repli\n     return assignment.get(resourceName).getReplicaMap(new Partition(partitionName));\n   }\n \n-  private double calculateAssignmentScale(AssignableNode node, AssignableReplica replica,\n+  private double calculateAssignmentScore(String nodeName, String state,\n       Map<String, String> instanceToStateMap) {\n-    String instanceName = node.getInstanceName();\n-    if (!instanceToStateMap.containsKey(instanceName)) {\n-      return 0;\n-    } else {\n-      return (instanceToStateMap.get(instanceName).equals(replica.getReplicaState()) ? 1 :\n-          ALLOCATION_MATCH_FACTOR);\n+    if (instanceToStateMap.containsKey(nodeName)) {\n+      return state.equals(instanceToStateMap.get(nodeName)) ?\n+          // if state matches, no state transition required for the proposed assignment\n+          1 :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "769aee1d492f689e7636456b1c5e675af9b0930c"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjMyNDQ2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/constraints/PartitionMovementConstraint.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoyMzowNVrOGl7GGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxOTo1Mjo0M1rOGl-Bmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxODcxNA==", "bodyText": "If I understand it correctly, when score == 0, should this be same as bestpossible is Empty()? Then score should be calculateAssignmentScore(nodeName, state, baselineAssignment);", "url": "https://github.com/apache/helix/pull/1078#discussion_r442418714", "createdAt": "2020-06-18T18:23:05Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/constraints/PartitionMovementConstraint.java", "diffHunk": "@@ -40,31 +40,53 @@\n class PartitionMovementConstraint extends SoftConstraint {\n   private static final double MAX_SCORE = 1f;\n   private static final double MIN_SCORE = 0f;\n-  //TODO: these factors will be tuned based on user's preference\n-  // This factor indicates the default score that is evaluated if only partition allocation matches\n-  // (states are different).\n-  private static final double ALLOCATION_MATCH_FACTOR = 0.5;\n+  // The scale factor to adjust score when the proposed allocation partially matches the assignment\n+  // plan but will require a state transition (with partition movement).\n+  // TODO: these factors will be tuned based on user's preference\n+  private static final double STATE_TRANSITION_COST_FACTOR = 0.5;\n+  private static final double MOVEMENT_COST_FACTOR = 0.25;\n \n   PartitionMovementConstraint() {\n     super(MAX_SCORE, MIN_SCORE);\n   }\n \n+  /**\n+   * @return 1 if the proposed assignment completely matches the previous best possible assignment\n+   *         (or baseline assignment if the replica is newly added).\n+   *         STATE_TRANSITION_COST_FACTOR if the proposed assignment's allocation matches the\n+   *         previous Best Possible assignment (or baseline assignment if the replica is newly\n+   *         added) but state does not match.\n+   *         MOVEMENT_COST_FACTOR if the proposed assignment's allocation matches the baseline\n+   *         assignment only, but not matches the previous best possible assignment.\n+   *         0 if the proposed assignment is a pure random movement.\n+   */\n   @Override\n   protected double getAssignmentScore(AssignableNode node, AssignableReplica replica,\n       ClusterContext clusterContext) {\n-    // Prioritize the previous Best Possible assignment\n     Map<String, String> bestPossibleAssignment =\n         getStateMap(replica, clusterContext.getBestPossibleAssignment());\n-    if (!bestPossibleAssignment.isEmpty()) {\n-      return calculateAssignmentScale(node, replica, bestPossibleAssignment);\n-    }\n-    // else, compare the baseline only if the best possible assignment does not contain the replica\n     Map<String, String> baselineAssignment =\n         getStateMap(replica, clusterContext.getBaselineAssignment());\n-    if (!baselineAssignment.isEmpty()) {\n-      return calculateAssignmentScale(node, replica, baselineAssignment);\n+    String nodeName = node.getInstanceName();\n+    String state = replica.getReplicaState();\n+\n+    if (bestPossibleAssignment.isEmpty()) {\n+      // If bestPossibleAssignment of the replica is empty, indicating this is a new replica.\n+      // Then the baseline is the only reference.\n+      return calculateAssignmentScore(nodeName, state, baselineAssignment);\n+    } else {\n+      // Else, for minimizing partition movements or state transitions, prioritize the proposed\n+      // assignment that matches the previous Best Possible assignment.\n+      double score = calculateAssignmentScore(nodeName, state, bestPossibleAssignment);\n+      // If no Best Possible assignment matches, check the baseline assignment.\n+      if (score == 0 && baselineAssignment.containsKey(nodeName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8380d626a9821c465a7a6e16e66c4d5fe9f7054"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NjcxNQ==", "bodyText": "Not exactly, if the bestpossible does not contain this node with the replica (but it is not empty), then it will still be a zero score.\nThe first if condition is for the new partitions. Where there is no bestpossible at all. So no other nodes will compete for the nodes in the baseline regarding LESS_MOVEMENT. In this case, we want to specially handle to enforce the LESS_MOVEMENT constraint.\nThe second else condition is for the existing partitions. In which a partition may exist in both assignments. So we need to prioritize the best possible (because it is less cost regarding movement).", "url": "https://github.com/apache/helix/pull/1078#discussion_r442466715", "createdAt": "2020-06-18T19:52:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/constraints/PartitionMovementConstraint.java", "diffHunk": "@@ -40,31 +40,53 @@\n class PartitionMovementConstraint extends SoftConstraint {\n   private static final double MAX_SCORE = 1f;\n   private static final double MIN_SCORE = 0f;\n-  //TODO: these factors will be tuned based on user's preference\n-  // This factor indicates the default score that is evaluated if only partition allocation matches\n-  // (states are different).\n-  private static final double ALLOCATION_MATCH_FACTOR = 0.5;\n+  // The scale factor to adjust score when the proposed allocation partially matches the assignment\n+  // plan but will require a state transition (with partition movement).\n+  // TODO: these factors will be tuned based on user's preference\n+  private static final double STATE_TRANSITION_COST_FACTOR = 0.5;\n+  private static final double MOVEMENT_COST_FACTOR = 0.25;\n \n   PartitionMovementConstraint() {\n     super(MAX_SCORE, MIN_SCORE);\n   }\n \n+  /**\n+   * @return 1 if the proposed assignment completely matches the previous best possible assignment\n+   *         (or baseline assignment if the replica is newly added).\n+   *         STATE_TRANSITION_COST_FACTOR if the proposed assignment's allocation matches the\n+   *         previous Best Possible assignment (or baseline assignment if the replica is newly\n+   *         added) but state does not match.\n+   *         MOVEMENT_COST_FACTOR if the proposed assignment's allocation matches the baseline\n+   *         assignment only, but not matches the previous best possible assignment.\n+   *         0 if the proposed assignment is a pure random movement.\n+   */\n   @Override\n   protected double getAssignmentScore(AssignableNode node, AssignableReplica replica,\n       ClusterContext clusterContext) {\n-    // Prioritize the previous Best Possible assignment\n     Map<String, String> bestPossibleAssignment =\n         getStateMap(replica, clusterContext.getBestPossibleAssignment());\n-    if (!bestPossibleAssignment.isEmpty()) {\n-      return calculateAssignmentScale(node, replica, bestPossibleAssignment);\n-    }\n-    // else, compare the baseline only if the best possible assignment does not contain the replica\n     Map<String, String> baselineAssignment =\n         getStateMap(replica, clusterContext.getBaselineAssignment());\n-    if (!baselineAssignment.isEmpty()) {\n-      return calculateAssignmentScale(node, replica, baselineAssignment);\n+    String nodeName = node.getInstanceName();\n+    String state = replica.getReplicaState();\n+\n+    if (bestPossibleAssignment.isEmpty()) {\n+      // If bestPossibleAssignment of the replica is empty, indicating this is a new replica.\n+      // Then the baseline is the only reference.\n+      return calculateAssignmentScore(nodeName, state, baselineAssignment);\n+    } else {\n+      // Else, for minimizing partition movements or state transitions, prioritize the proposed\n+      // assignment that matches the previous Best Possible assignment.\n+      double score = calculateAssignmentScore(nodeName, state, bestPossibleAssignment);\n+      // If no Best Possible assignment matches, check the baseline assignment.\n+      if (score == 0 && baselineAssignment.containsKey(nodeName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxODcxNA=="}, "originalCommit": {"oid": "e8380d626a9821c465a7a6e16e66c4d5fe9f7054"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1153, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}