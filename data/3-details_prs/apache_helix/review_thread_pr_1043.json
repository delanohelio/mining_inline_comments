{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1Mzg2Njk5", "number": 1043, "reviewThreads": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNzoxMDoyM1rOEBFzvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQwMTozODo1OVrOEHRGXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTc5MTk3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNzoxMDoyM1rOGcxHTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoyNjo0NFrOGjUbGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ==", "bodyText": "LinkedHashMap implements Map interface. I suggest keeping Map.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432817999", "createdAt": "2020-05-30T07:10:23Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5MTE3NA==", "bodyText": "TFTR.\nPlease correct me if I am wrong. I think Map does not guarantee the order in which pairs were inserted into the map. When constructing the topology tree, it is important to maintain the original order for the path.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432891174", "createdAt": "2020-05-30T22:10:25Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMzM5NQ==", "bodyText": "Let's use Map? Making the function signature LinkedHashMap doesn't necessarily guarantee the map has the right order.", "url": "https://github.com/apache/helix/pull/1043#discussion_r433003395", "createdAt": "2020-06-01T00:51:39Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3Mzk4Ng==", "bodyText": "For private function like this, can we assume caller will strictly follow the instruction (of course with more detailed comment added) and guarantee the map has the right order? Or we could do one of the following to guarantee order:\n\npass in a separate array (or LinkedHashSet as line 63 in the old code) to keep the order of the key\nadd a lamda function to sorting internally.\n\nTHX", "url": "https://github.com/apache/helix/pull/1043#discussion_r433473986", "createdAt": "2020-06-01T20:34:15Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMDk5Mg==", "bodyText": "If it's a private method, then you can explicitly state that in the JavaDoc and use Map to declare. We want to avoid unnecessary sorting/computation if we can be sure that the parameters are well-formed.", "url": "https://github.com/apache/helix/pull/1043#discussion_r433520992", "createdAt": "2020-06-01T22:22:07Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyNzQzNg==", "bodyText": "That make sense. Will update the pr.", "url": "https://github.com/apache/helix/pull/1043#discussion_r433527436", "createdAt": "2020-06-01T22:41:50Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIxNTkzMA==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r434215930", "createdAt": "2020-06-02T22:46:36Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Nzk2MA==", "bodyText": "I talked with Xiaoyuan, since the method logic requires the input map has a fixed iterate order, I suggest her to use the explicit type. Please note that if you input a Map instantiate by HashMap, then the method won't work as expected!", "url": "https://github.com/apache/helix/pull/1043#discussion_r439687960", "createdAt": "2020-06-13T00:26:44Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTc5MzIzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNzoxMzozNVrOGcxH-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMjoxMDozOFrOGc1lNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxODE3MQ==", "bodyText": "I suggest using Map interface as type.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432818171", "createdAt": "2020-05-30T07:13:35Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5MTE4OA==", "bodyText": "Same as above.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432891188", "createdAt": "2020-05-30T22:10:38Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxODE3MQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTc5NDU4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNzoxNjo1M1rOGcxIqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMzoyMToxOFrOGc10dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxODM0Nw==", "bodyText": "Instead of String.format, I suggest parameterized logging: logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\nString.format is slower. And parameterized logging eliminates string concatenation if WARN level logging is not enabled.\nSame for the other logging you changed in this PR.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432818347", "createdAt": "2020-05-30T07:16:53Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTA5Mg==", "bodyText": "TFTR. Fixed.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432895092", "createdAt": "2020-05-30T23:21:18Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxODM0Nw=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTgwOTI0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNzo0NjowOFrOGcxP8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMTo1NDoyOFrOGmiGHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyMDIwOA==", "bodyText": "In what case the IllegalArgumentException is thrown from getDomainAsMap? Is this same behavior with the old condition check?", "url": "https://github.com/apache/helix/pull/1043#discussion_r432820208", "createdAt": "2020-05-30T07:46:08Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Mzk1MQ==", "bodyText": "GetDomainAsMap will throw IllegalArgumentException if\n\nThe Splitter.on() param matches the empty string.\nHas duplicate Key.\nFor example the controller does not know how to categorize the instance if user specified two different rack.\n\nThere is one behavior change (witch I should have documented in the pr description) is that, GetDomainAsMap won't throw exception if either key or value is an empty string. I think the new behavior is reasonable since\n\nWe ignore keys in DOMAIN that are not defined in ClusterConfig. When we have empty key, they should be treated as non-defined key. Instead of throw exception, it is ok to just ignore them. They are no harm to the topology tree anyway.\nWe will use default values for keys that are defined in ClusterConfig but missing InstanceConfig.DOMAIN. If there is an empty value defined, we should use the default value as well.\n\nThere will be a warning log if the keys mismatch with each other.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432893951", "createdAt": "2020-05-30T23:00:12Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyMDIwOA=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NzY5Mg==", "bodyText": "I kept the original implementation for performance.", "url": "https://github.com/apache/helix/pull/1043#discussion_r443057692", "createdAt": "2020-06-19T21:54:28Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyMDIwOA=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTgxMDI4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNzo0ODoyM1rOGcxQeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMjo0NTowNFrOGeGaCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyMDM0NQ==", "bodyText": "I suggest making \"Helix_default_\" a constant because the constant eliminates redundant string objects: constant is only one string object but this would create one string each time.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432820345", "createdAt": "2020-05-30T07:48:23Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Mjk0MA==", "bodyText": "TFTR. Will update.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432892940", "createdAt": "2020-05-30T22:42:48Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyMDM0NQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIxNTQzNQ==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r434215435", "createdAt": "2020-06-02T22:45:04Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyMDM0NQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzEyNjkwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDoxMjoyNVrOGc8KLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwMDo1NjozNFrOGfdBeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5ODk1OQ==", "bodyText": "I'd like to know the rationale of setting default value. Basically if the \"domain\" field is not set, we throw an exception, but if the \"domain\" is set with a random value, we think it is fine and give it a default zone value. How do we know it doesn't cause problem for rebalance.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432998959", "createdAt": "2020-06-01T00:12:25Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length()==0) {\n+              value = _defaultPathPrefix + key;\n+            }\n+            instanceTopologyMap.put(key, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3MDgxMg==", "bodyText": "TFTR.\nThat's a good point. We probably should revisit the old sanity check logic and modify if needed.\nOne minor correcting. If the \"domain\" is set with a random value with no k-v split identifier found ('=' in this case), we will throw IllegalArgumentException.", "url": "https://github.com/apache/helix/pull/1043#discussion_r433470812", "createdAt": "2020-06-01T20:27:29Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length()==0) {\n+              value = _defaultPathPrefix + key;\n+            }\n+            instanceTopologyMap.put(key, value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5ODk1OQ=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzNDU1Mw==", "bodyText": "There will be a following PR for this issue.  May I suggest using this PR solely for code clean up? We probably should schedule a discussion to revisit the old sanity check logic and modify if needed.\nTHX", "url": "https://github.com/apache/helix/pull/1043#discussion_r435634553", "createdAt": "2020-06-05T00:56:34Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length()==0) {\n+              value = _defaultPathPrefix + key;\n+            }\n+            instanceTopologyMap.put(key, value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5ODk1OQ=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzE0NjE4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDozNzoyMlrOGc8Uyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMjo0NjoxMFrOGeGbjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMTY3NQ==", "bodyText": "Please review the convention for defining constant Strings in Java.\nhttps://stackoverflow.com/questions/9639007/defining-constant-string-in-java\nWith that said, is this prefix necessary?", "url": "https://github.com/apache/helix/pull/1043#discussion_r433001675", "createdAt": "2020-06-01T00:37:22Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -55,16 +55,10 @@\n   private final List<String> _liveInstances;\n   private final Map<String, InstanceConfig> _instanceConfigMap;\n   private final ClusterConfig _clusterConfig;\n-  private final boolean _topologyAwareEnabled;\n+  private final String _defaultPathPrefix = \"Helix_default_\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIxNTgyMA==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r434215820", "createdAt": "2020-06-02T22:46:10Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -55,16 +55,10 @@\n   private final List<String> _liveInstances;\n   private final Map<String, InstanceConfig> _instanceConfigMap;\n   private final ClusterConfig _clusterConfig;\n-  private final boolean _topologyAwareEnabled;\n+  private final String _defaultPathPrefix = \"Helix_default_\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMTY3NQ=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzE1MzQ1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDo0NTozOFrOGc8Ywg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzozMDoxNVrOGddSEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjY5MA==", "bodyText": "@xyuanlu\nLet's use a Map to declare?\nAnd what you said about LinkedHashMap is true, but Map is a higher-level construct (interface) and LinkedHashMap is an implementation. Even if you wanted a LinkedHashMap instance, how do you guarantee that the map has the right order? If you want to be 100% sure about the order, you have two options:\n\nMake it crystal clear that the user must pass in ordered map (TreeMap or LinkedHashMap)\ndo your own sorting internally.\n\nWith that said, what you said about using LinkedHashMap for declaration implies that maybe we should review the difference between declaration and implementation. Here's a helpful explanation: https://stackoverflow.com/questions/11715485/what-is-the-difference-between-declaration-and-definition-in-java", "url": "https://github.com/apache/helix/pull/1043#discussion_r433002690", "createdAt": "2020-06-01T00:45:38Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NzY0Nw==", "bodyText": "TFTR.\nPlease correct me if I am wrong. As a general rule, we're supposed use its interface in declaration rather than the actual implementation like the following.\nMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\nThe reason behind this is that the implementation of these interfaces is usually not relevant when handling them in the following logic. However, in my understanding, in some special cases like this, if we need a map when order is important, it is better to use a more specific interface or an implementation to explicitly state that the order is important. Or maybe still use the general interface with comment?", "url": "https://github.com/apache/helix/pull/1043#discussion_r433467647", "createdAt": "2020-06-01T20:21:03Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjY5MA=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMDAzNA==", "bodyText": "Yes, what you said about using the interface is on point.\nI understand where you are coming from - you want to make it explicit that the parameter that's being passed in is ordered. But let's revisit what I said above - making the declaration LinkedHashMap does not help you in that case.\nLinkedHashMap's ordering is not deterministic. It does not enforce the right ordering you need in the map. So you aren't really enforcing anything there other than the map will have some order.\nIf you want to enforce some sort of ordering of elements, you should sort internally. Say you need it sorted by alphabetical order, then you should convert this map into a TreeMap.\nAlternatively, stating that the topology map must be ordered in some way is also acceptable in JavaDoc, but in that case, the right thing to do is to be able to detect if the ordering has a problem, be able to throw an exception of some sort, alerting the user.", "url": "https://github.com/apache/helix/pull/1043#discussion_r433520034", "createdAt": "2020-06-01T22:19:12Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjY5MA=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0MTY1MA==", "bodyText": "For this in class variable defined here in a private function for class constructor, i guess it is safe to assume the order will be maintained as expected  since this private function has the full control of this object. Of course, more detailed comment/doc should be added.", "url": "https://github.com/apache/helix/pull/1043#discussion_r433541650", "createdAt": "2020-06-01T23:30:15Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjY5MA=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzE1Mzk0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDo0NjowNlrOGc8Y_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwMDozNDozNlrOGfctIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjc1MA==", "bodyText": "Let's use Map instead...", "url": "https://github.com/apache/helix/pull/1043#discussion_r433002750", "createdAt": "2020-06-01T00:46:06Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNzMwMA==", "bodyText": "I am planning to extract this function into a public util function.  It's better to explicitly state that the order is important or maybe still use the general map interface with comment?", "url": "https://github.com/apache/helix/pull/1043#discussion_r433517300", "createdAt": "2020-06-01T22:11:07Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjc1MA=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMDQxOQ==", "bodyText": "That is acceptable, but what is this order exactly? How should users order the map when passing topology map in?\nWould it be better to sort it yourself - would that be easier for the user and be safer?", "url": "https://github.com/apache/helix/pull/1043#discussion_r433520419", "createdAt": "2020-06-01T22:20:26Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjc1MA=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMjYyOQ==", "bodyText": "This is an out parameter. So the order will be kept when k-v pairs are added to the LinkedHashMap in this function. Forcing the caller to pass in a LinkedHashMap will  guarantee the order in which pairs were inserted into the map when user uses the map later.", "url": "https://github.com/apache/helix/pull/1043#discussion_r433522629", "createdAt": "2020-06-01T22:26:46Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjc1MA=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyOTM0Ng==", "bodyText": "I changed the out param to a return value. It would be more clear and the definition in the caller can be changed to Map interface.", "url": "https://github.com/apache/helix/pull/1043#discussion_r435629346", "createdAt": "2020-06-05T00:34:36Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjc1MA=="}, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwOTQ5MjM0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDowMToxMFrOGe1CIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDo1ODo0OFrOGe13HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3OTM2Mw==", "bodyText": "Helix usually have all capitalized strings as our naming convention. Is this newly introduced or exists before?", "url": "https://github.com/apache/helix/pull/1043#discussion_r434979363", "createdAt": "2020-06-04T04:01:10Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -55,16 +55,10 @@\n   private final List<String> _liveInstances;\n   private final Map<String, InstanceConfig> _instanceConfigMap;\n   private final ClusterConfig _clusterConfig;\n-  private final boolean _topologyAwareEnabled;\n+  private static final String DEFAULT_PATH_PREFIX = \"Helix_default_\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4OTAzMA==", "bodyText": "TFTR.\nI kept the same way as it is. I think we probably should not change the default behavior when doing code clean up.\nIn old code line 105:\n104          for (String type : _types) {\n105            defaultDomainPathValues.put(type, \"Helix_default\" + type);\n106            lastType = type;\n107          }", "url": "https://github.com/apache/helix/pull/1043#discussion_r434989030", "createdAt": "2020-06-04T04:42:38Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -55,16 +55,10 @@\n   private final List<String> _liveInstances;\n   private final Map<String, InstanceConfig> _instanceConfigMap;\n   private final ClusterConfig _clusterConfig;\n-  private final boolean _topologyAwareEnabled;\n+  private static final String DEFAULT_PATH_PREFIX = \"Helix_default_\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3OTM2Mw=="}, "originalCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MjkyNQ==", "bodyText": "Why it is PATH_PREFIX, I think it should be the VALUE_PREFIX. Of course, the value prefix is not a good name either. Let's call it DEFAULT_DOMAIN_PREFIX. And add some comments to indicate what's the usage.", "url": "https://github.com/apache/helix/pull/1043#discussion_r434992925", "createdAt": "2020-06-04T04:58:48Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -55,16 +55,10 @@\n   private final List<String> _liveInstances;\n   private final Map<String, InstanceConfig> _instanceConfigMap;\n   private final ClusterConfig _clusterConfig;\n-  private final boolean _topologyAwareEnabled;\n+  private static final String DEFAULT_PATH_PREFIX = \"Helix_default_\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3OTM2Mw=="}, "originalCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwOTQ5NDczOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDowMjo0NlrOGe1DkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDo0MzowN1rOGe1oVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3OTcyOA==", "bodyText": "Why not change this to be while clause since this already lost advantage of for loop for instantiation.", "url": "https://github.com/apache/helix/pull/1043#discussion_r434979728", "createdAt": "2020-06-04T04:02:46Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,42 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        for (; lastValidTypeIdx >= 0; --lastValidTypeIdx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4OTE0Mg==", "bodyText": "Will update.\nTHX", "url": "https://github.com/apache/helix/pull/1043#discussion_r434989142", "createdAt": "2020-06-04T04:43:07Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,42 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        for (; lastValidTypeIdx >= 0; --lastValidTypeIdx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3OTcyOA=="}, "originalCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTUxMzk5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDowMDozMVrOGiKIOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDowMDozMVrOGiKIOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MDcxNA==", "bodyText": "This logic cannot handle the following case correctly,\n\"/domain/rack///node/\"", "url": "https://github.com/apache/helix/pull/1043#discussion_r438470714", "createdAt": "2020-06-11T00:00:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTU4Njk2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDo0MzoyMVrOGiK0Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMToyMDoyMlrOGjR7IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTk5NQ==", "bodyText": "This operation is more expansive than the original code. What's the purpose of modifying this part? It does not seem to be simpler.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438481995", "createdAt": "2020-06-11T00:43:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {\n+          if (topologyStr[lastValidTypeIdx].length() != 0) {\n+            break;\n           }\n+          --lastValidTypeIdx;\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (lastValidTypeIdx < 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyStr[lastValidTypeIdx];\n+        _faultZoneType = clusterConfig.getFaultZoneType();\n+        if (_faultZoneType == null) {\n+          _faultZoneType = _endNodeType;\n+        }\n+        if (Arrays.stream(topologyStr).noneMatch(type -> type.equals(_faultZoneType))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MjE1Mw==", "bodyText": "Note this operation is called many times during the rebalance, so any incremental delay is impactful. Must be very careful, or the rebalance latency will be increased.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438482153", "createdAt": "2020-06-11T00:44:10Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {\n+          if (topologyStr[lastValidTypeIdx].length() != 0) {\n+            break;\n           }\n+          --lastValidTypeIdx;\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (lastValidTypeIdx < 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyStr[lastValidTypeIdx];\n+        _faultZoneType = clusterConfig.getFaultZoneType();\n+        if (_faultZoneType == null) {\n+          _faultZoneType = _endNodeType;\n+        }\n+        if (Arrays.stream(topologyStr).noneMatch(type -> type.equals(_faultZoneType))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTk5NQ=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUwNTU2MQ==", "bodyText": "TFTR. Please correct me if I am wrong.\nComparing to previous approach (set. contains()), the stream.noneMatch() does introduced a o(n)worst case complexity.\nHowever, since there is no new LinkedHashSet created, it saved a O(n) time for constructing the LinkedHashSet and a O(n) space complexity for the object itself.\nIt is better to pass the already parsed array to computeInstanceTopologyMap so we do not compute again in line 274. However, I think we could just use the original array topologyStr, no need to introduce another LinkedHashSet.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438505561", "createdAt": "2020-06-11T02:17:41Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {\n+          if (topologyStr[lastValidTypeIdx].length() != 0) {\n+            break;\n           }\n+          --lastValidTypeIdx;\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (lastValidTypeIdx < 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyStr[lastValidTypeIdx];\n+        _faultZoneType = clusterConfig.getFaultZoneType();\n+        if (_faultZoneType == null) {\n+          _faultZoneType = _endNodeType;\n+        }\n+        if (Arrays.stream(topologyStr).noneMatch(type -> type.equals(_faultZoneType))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTk5NQ=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUwNjU4NQ==", "bodyText": "One more optimization. We could put this check in the else branch for line 97. If we already set the _faultZoneType to be the same as _endNodeType, then _faultZoneType must belongs to topologyStr.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438506585", "createdAt": "2020-06-11T02:21:53Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {\n+          if (topologyStr[lastValidTypeIdx].length() != 0) {\n+            break;\n           }\n+          --lastValidTypeIdx;\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (lastValidTypeIdx < 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyStr[lastValidTypeIdx];\n+        _faultZoneType = clusterConfig.getFaultZoneType();\n+        if (_faultZoneType == null) {\n+          _faultZoneType = _endNodeType;\n+        }\n+        if (Arrays.stream(topologyStr).noneMatch(type -> type.equals(_faultZoneType))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTk5NQ=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTg2Mg==", "bodyText": "Considering the case \"/domain/rack///node/\", you will need to process the array. So either you have a new array or a LinkedHashSet. The latter can save us some time here.\nI was thinking about these 2 points together. And my conclusion is that keep the original logic is better : )", "url": "https://github.com/apache/helix/pull/1043#discussion_r439065862", "createdAt": "2020-06-11T20:55:28Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {\n+          if (topologyStr[lastValidTypeIdx].length() != 0) {\n+            break;\n           }\n+          --lastValidTypeIdx;\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (lastValidTypeIdx < 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyStr[lastValidTypeIdx];\n+        _faultZoneType = clusterConfig.getFaultZoneType();\n+        if (_faultZoneType == null) {\n+          _faultZoneType = _endNodeType;\n+        }\n+        if (Arrays.stream(topologyStr).noneMatch(type -> type.equals(_faultZoneType))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTk5NQ=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0NzAwOQ==", "bodyText": "Had an offline discussion. Although the time consumed here in the constructor is the same, it is better to have a smaller loop with no empty string when creating the domain k-v map for all instance. Having extra empty string in the for loop may introduce performance issue considering the number of instance.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439647009", "createdAt": "2020-06-12T21:20:22Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {\n+          if (topologyStr[lastValidTypeIdx].length() != 0) {\n+            break;\n           }\n+          --lastValidTypeIdx;\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (lastValidTypeIdx < 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyStr[lastValidTypeIdx];\n+        _faultZoneType = clusterConfig.getFaultZoneType();\n+        if (_faultZoneType == null) {\n+          _faultZoneType = _endNodeType;\n+        }\n+        if (Arrays.stream(topologyStr).noneMatch(type -> type.equals(_faultZoneType))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTk5NQ=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTU5NDExOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDo0NzozMFrOGiK4Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMToyMDozMFrOGjR7Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MzA0Mg==", "bodyText": "In this case, please convert the pathNameMap to be a LinkedHashMap input.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438483042", "createdAt": "2020-06-11T00:47:30Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n+        }\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int numOfmatchedKeys = 0;\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length() == 0) {\n+              value = DEFAULT_PATH_PREFIX + key;\n+            } else {\n+              numOfmatchedKeys++;\n+            }\n+            instanceTopologyMap.put(key, value);\n+          }\n+        }\n+        if (numOfmatchedKeys != domainAsMap.size()) {\n+          logger.warn(\n+              \"Key-value pairs in InstanceConfig.Domain {} do not align with keys in ClusterConfig.Topology {}\",\n+              domain, topologyKeys.toString());\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return instanceTopologyMap;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n+   * Input param 'pathNameMap' must have a certain order where the order of the keys should be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0NzA1MA==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439647050", "createdAt": "2020-06-12T21:20:30Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n+        }\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int numOfmatchedKeys = 0;\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length() == 0) {\n+              value = DEFAULT_PATH_PREFIX + key;\n+            } else {\n+              numOfmatchedKeys++;\n+            }\n+            instanceTopologyMap.put(key, value);\n+          }\n+        }\n+        if (numOfmatchedKeys != domainAsMap.size()) {\n+          logger.warn(\n+              \"Key-value pairs in InstanceConfig.Domain {} do not align with keys in ClusterConfig.Topology {}\",\n+              domain, topologyKeys.toString());\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return instanceTopologyMap;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n+   * Input param 'pathNameMap' must have a certain order where the order of the keys should be", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MzA0Mg=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYwMDIyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDo1MTowMFrOGiK8CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMTozMDowMlrOGjSHHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4Mzk3Nw==", "bodyText": "This should be LinkedHashMap", "url": "https://github.com/apache/helix/pull/1043#discussion_r438483977", "createdAt": "2020-06-11T00:51:00Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUxMDkzOQ==", "bodyText": "Shouldn't we use interface for declaration (as previous comments suggested)?\nOr in this specific case it's better to explicitly state the ordering is important?", "url": "https://github.com/apache/helix/pull/1043#discussion_r438510939", "createdAt": "2020-06-11T02:40:18Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4Mzk3Nw=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NzAxMA==", "bodyText": "If your later usage assumes anything about the iteration order, then we should make this Map explicitly an ordered one.\nAnd addEndNode() will require an ordered map. I suggest you change the addEndNode() signature so others won't be able to pass any non-ordered map. With that change, you have to change this Map to LinkedHashMap here.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439067010", "createdAt": "2020-06-11T20:57:49Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4Mzk3Nw=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1MDA3Nw==", "bodyText": "updated", "url": "https://github.com/apache/helix/pull/1043#discussion_r439650077", "createdAt": "2020-06-12T21:30:02Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4Mzk3Nw=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYwNzYzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDo1NToyOVrOGiLApw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMTozMDoyMVrOGjSHnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NTE1OQ==", "bodyText": "This is duplicate code, let's have a private method to check if the node is enabled or not.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438485159", "createdAt": "2020-06-11T00:55:29Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1MDIwNw==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439650207", "createdAt": "2020-06-12T21:30:21Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NTE1OQ=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYwODU5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDo1NjowNFrOGiLBLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMTozMDoyNlrOGjSHsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NTI5Mg==", "bodyText": "This comment is not right.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438485292", "createdAt": "2020-06-11T00:56:04Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1MDIyNQ==", "bodyText": "Updated", "url": "https://github.com/apache/helix/pull/1043#discussion_r439650225", "createdAt": "2020-06-12T21:30:26Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NTI5Mg=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYxMTk3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDo1ODowOVrOGiLDJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMTozMDozNFrOGjSH2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NTc5OQ==", "bodyText": "Why not directly call domainAsMap = instanceConfig.getDomainAsMap();?", "url": "https://github.com/apache/helix/pull/1043#discussion_r438485799", "createdAt": "2020-06-11T00:58:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1MDI2Nw==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439650267", "createdAt": "2020-06-12T21:30:34Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NTc5OQ=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYxNTQ2OnYy", "diffSide": "LEFT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowMDoyOVrOGiLFbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMToxMTo0NlrOGjRwEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NjM4Mg==", "bodyText": "I would prefer to keep it. A LinkedHashSet or ArrayList would be much easier to handle compared with array.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438486382", "createdAt": "2020-06-11T01:00:29Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0NDE3OQ==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439644179", "createdAt": "2020-06-12T21:11:46Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NjM4Mg=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYxNjc0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowMToxNVrOGiLGNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMTozMDo1M1rOGjSIOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NjU4Mg==", "bodyText": "Could you just input the String[] topologyStr (or a LinkedHashSet which I would recommend) to this method so you don't do the calculation again?", "url": "https://github.com/apache/helix/pull/1043#discussion_r438486582", "createdAt": "2020-06-11T01:01:15Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n+        }\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1MDM2Mg==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439650362", "createdAt": "2020-06-12T21:30:53Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n+        }\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NjU4Mg=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYyMTIyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowNDowOVrOGiLI9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMTozMTowMVrOGjSIeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NzI4Ng==", "bodyText": "Mention here that the default domain value has been used. Otherwise, this warning looks like a major problem.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438487286", "createdAt": "2020-06-11T01:04:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n+        }\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int numOfmatchedKeys = 0;\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length() == 0) {\n+              value = DEFAULT_PATH_PREFIX + key;\n+            } else {\n+              numOfmatchedKeys++;\n+            }\n+            instanceTopologyMap.put(key, value);\n+          }\n+        }\n+        if (numOfmatchedKeys != domainAsMap.size()) {\n+          logger.warn(\n+              \"Key-value pairs in InstanceConfig.Domain {} do not align with keys in ClusterConfig.Topology {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1MDQyNg==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439650426", "createdAt": "2020-06-12T21:31:01Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n+        }\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int numOfmatchedKeys = 0;\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length() == 0) {\n+              value = DEFAULT_PATH_PREFIX + key;\n+            } else {\n+              numOfmatchedKeys++;\n+            }\n+            instanceTopologyMap.put(key, value);\n+          }\n+        }\n+        if (numOfmatchedKeys != domainAsMap.size()) {\n+          logger.warn(\n+              \"Key-value pairs in InstanceConfig.Domain {} do not align with keys in ClusterConfig.Topology {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NzI4Ng=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYyMzAzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowNToxNFrOGiLKAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMTozMTowNlrOGjSImQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NzU1NA==", "bodyText": "instance -> instanceName", "url": "https://github.com/apache/helix/pull/1043#discussion_r438487554", "createdAt": "2020-06-11T01:05:14Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1MDQ1Nw==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439650457", "createdAt": "2020-06-12T21:31:06Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NzU1NA=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTA0MTQ4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDowMTo0OVrOGjUNBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDozMzoxNFrOGjUeVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDM1OQ==", "bodyText": "Does \"_clusterTopologyKeys.get(_clusterTopologyKeys.size() - 1)\"  works the same? But you won't need lastValidTypeIdx in that way.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439684359", "createdAt": "2020-06-13T00:01:49Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +78,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n+    _clusterTopologyKeys = new LinkedHashSet<>();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = 0;\n+        for (int i = 0; i < topologyKeys.length; i++) {\n+          if (topologyKeys[i].length() != 0) {\n+            _clusterTopologyKeys.add(topologyKeys[i]);\n+            lastValidTypeIdx = i;\n           }\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (_clusterTopologyKeys.size() == 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyKeys[lastValidTypeIdx];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4ODc5MA==", "bodyText": "I am not sure if there is a get() function for LinkedHashSet.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html#method.summary", "url": "https://github.com/apache/helix/pull/1043#discussion_r439688790", "createdAt": "2020-06-13T00:33:14Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +78,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n+    _clusterTopologyKeys = new LinkedHashSet<>();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = 0;\n+        for (int i = 0; i < topologyKeys.length; i++) {\n+          if (topologyKeys[i].length() != 0) {\n+            _clusterTopologyKeys.add(topologyKeys[i]);\n+            lastValidTypeIdx = i;\n           }\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (_clusterTopologyKeys.size() == 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyKeys[lastValidTypeIdx];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDM1OQ=="}, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTA1MTk5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoxMjo0MFrOGjUTVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo1MTo0NVrOGjVt2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTk3Mg==", "bodyText": "nit, just put in the try block. It is not used outside.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439685972", "createdAt": "2020-06-13T00:12:40Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTE0NA==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439709144", "createdAt": "2020-06-13T04:51:45Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTk3Mg=="}, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTA1MzE5OnYy", "diffSide": "LEFT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoxNDowNVrOGjUUDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo0MjowMVrOGjVrsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjE1Nw==", "bodyText": "Where do you update this map? I didn't see in your latest version.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439686157", "createdAt": "2020-06-13T00:14:05Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +78,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n+    _clusterTopologyKeys = new LinkedHashSet<>();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = 0;\n+        for (int i = 0; i < topologyKeys.length; i++) {\n+          if (topologyKeys[i].length() != 0) {\n+            _clusterTopologyKeys.add(topologyKeys[i]);\n+            lastValidTypeIdx = i;\n           }\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (_clusterTopologyKeys.size() == 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODU5NA==", "bodyText": "Updated", "url": "https://github.com/apache/helix/pull/1043#discussion_r439708594", "createdAt": "2020-06-13T04:42:01Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +78,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n+    _clusterTopologyKeys = new LinkedHashSet<>();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = 0;\n+        for (int i = 0; i < topologyKeys.length; i++) {\n+          if (topologyKeys[i].length() != 0) {\n+            _clusterTopologyKeys.add(topologyKeys[i]);\n+            lastValidTypeIdx = i;\n           }\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (_clusterTopologyKeys.size() == 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjE1Nw=="}, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTA1Njk4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoxODoyM1rOGjUWXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo1MTozNFrOGjVtwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njc0OA==", "bodyText": "It won't be null, I guess. Don't overprotect the code, it may hide issues.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439686748", "createdAt": "2020-06-13T00:18:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+                  instanceConfig.getDomainAsString(), instanceName), e);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        if (domainAsMap == null || domainAsMap.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTEyMg==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439709122", "createdAt": "2020-06-13T04:51:34Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+                  instanceConfig.getDomainAsString(), instanceName), e);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        if (domainAsMap == null || domainAsMap.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njc0OA=="}, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 263}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTA1NzA3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoxODozMlrOGjUWbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo1MToyN1rOGjVttw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njc2Nw==", "bodyText": "It won't be null. Don't overprotect the code, it may hide issues.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439686767", "createdAt": "2020-06-13T00:18:32Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTExMQ==", "bodyText": "Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439709111", "createdAt": "2020-06-13T04:51:27Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njc2Nw=="}, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTA2MTg4OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoyMzo0MlrOGjUZTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo1MToxMVrOGjVtrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NzUwMw==", "bodyText": "I see you want a lazy initialization. It's good design.\nBut since you are modifying the input parameter implicitly, it might be clearer to just refer to _defaultDomainPathValues. Otherwise, there is an implicit assumption that the caller needs to pass the same map for all the calls.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439687503", "createdAt": "2020-06-13T00:23:42Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+                  instanceConfig.getDomainAsString(), instanceName), e);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        if (domainAsMap == null || domainAsMap.isEmpty()) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n+        }\n+        int numOfMatchedKeys = 0;\n+        for (String key : clusterTopologyKeys) {\n+          // if a key does not exist in the instance domain config, using the default domain value.\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            value =\n+                defaultDomainPathValuesCache.computeIfAbsent(key, k -> (DEFAULT_DOMAIN_PREFIX + key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTEwMw==", "bodyText": "I changed it back to initialing the map in the constrictor. CPU profiler shows the overhead of having a lamda function here is too heavy.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439709103", "createdAt": "2020-06-13T04:51:11Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+                  instanceConfig.getDomainAsString(), instanceName), e);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        if (domainAsMap == null || domainAsMap.isEmpty()) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n+        }\n+        int numOfMatchedKeys = 0;\n+        for (String key : clusterTopologyKeys) {\n+          // if a key does not exist in the instance domain config, using the default domain value.\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            value =\n+                defaultDomainPathValuesCache.computeIfAbsent(key, k -> (DEFAULT_DOMAIN_PREFIX + key));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NzUwMw=="}, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTA2MjgyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoyNDo0NFrOGjUZ3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo0MjoxM1rOGjVrug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NzY0NA==", "bodyText": "Add the corresponding comment as you did for the other 2 conditions above.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439687644", "createdAt": "2020-06-13T00:24:44Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+                  instanceConfig.getDomainAsString(), instanceName), e);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        if (domainAsMap == null || domainAsMap.isEmpty()) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n+        }\n+        int numOfMatchedKeys = 0;\n+        for (String key : clusterTopologyKeys) {\n+          // if a key does not exist in the instance domain config, using the default domain value.\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            value =\n+                defaultDomainPathValuesCache.computeIfAbsent(key, k -> (DEFAULT_DOMAIN_PREFIX + key));\n+          } else {\n+            numOfMatchedKeys++;\n+          }\n+          instanceTopologyMap.put(key, value);\n+        }\n+        if (numOfMatchedKeys != domainAsMap.size()) {\n+          logger.warn(\n+              \"Key-value pairs in InstanceConfig.Domain {} do not align with keys in ClusterConfig.Topology \"\n+                  + \"{}, using default domain value instead\", instanceConfig.getDomainAsString(),\n+              clusterTopologyKeys.toString());\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODYwMg==", "bodyText": "Updated", "url": "https://github.com/apache/helix/pull/1043#discussion_r439708602", "createdAt": "2020-06-13T04:42:13Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+                  instanceConfig.getDomainAsString(), instanceName), e);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        if (domainAsMap == null || domainAsMap.isEmpty()) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n+        }\n+        int numOfMatchedKeys = 0;\n+        for (String key : clusterTopologyKeys) {\n+          // if a key does not exist in the instance domain config, using the default domain value.\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            value =\n+                defaultDomainPathValuesCache.computeIfAbsent(key, k -> (DEFAULT_DOMAIN_PREFIX + key));\n+          } else {\n+            numOfMatchedKeys++;\n+          }\n+          instanceTopologyMap.put(key, value);\n+        }\n+        if (numOfMatchedKeys != domainAsMap.size()) {\n+          logger.warn(\n+              \"Key-value pairs in InstanceConfig.Domain {} do not align with keys in ClusterConfig.Topology \"\n+                  + \"{}, using default domain value instead\", instanceConfig.getDomainAsString(),\n+              clusterTopologyKeys.toString());\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NzY0NA=="}, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3OTE0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1Nzo1M1rOGlcFzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMTo1NjozMFrOGmiIEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDczMg==", "bodyText": "Isn't this block the same logic as getDomainAsMap()?", "url": "https://github.com/apache/helix/pull/1043#discussion_r441910732", "createdAt": "2020-06-18T00:57:53Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +191,122 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      try {\n+        LinkedHashMap<String, String> instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys)\n+      throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMDYwNQ==", "bodyText": "I kept the original logic (before code clean up) here. One difference is that getDomainAsMap wont throw exception if key or value is empty.", "url": "https://github.com/apache/helix/pull/1043#discussion_r442400605", "createdAt": "2020-06-18T17:49:58Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +191,122 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      try {\n+        LinkedHashMap<String, String> instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys)\n+      throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDczMg=="}, "originalCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3NDY4MA==", "bodyText": "You can check once you get the map in the same way. Please try to avoid duplicate logic.", "url": "https://github.com/apache/helix/pull/1043#discussion_r442474680", "createdAt": "2020-06-18T20:08:11Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +191,122 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      try {\n+        LinkedHashMap<String, String> instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys)\n+      throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDczMg=="}, "originalCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODE5Mg==", "bodyText": "As our offline discussion. I updated the InstanceConfig.getDomainAsMap.", "url": "https://github.com/apache/helix/pull/1043#discussion_r443058192", "createdAt": "2020-06-19T21:56:30Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +191,122 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      try {\n+        LinkedHashMap<String, String> instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys)\n+      throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDczMg=="}, "originalCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE4MTkzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1OTo1MlrOGlcHoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNzo1MDoxOVrOGl6AQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMTIwMQ==", "bodyText": "Remove", "url": "https://github.com/apache/helix/pull/1043#discussion_r441911201", "createdAt": "2020-06-18T00:59:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +191,122 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      try {\n+        LinkedHashMap<String, String> instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys)\n+      throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap = new HashMap<>();\n+        String[] pathPairs = instanceConfig.getDomainAsString().trim().split(\",\");\n+        for (String pair : pathPairs) {\n+          String[] values = pair.trim().split(\"=\");\n+          if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+            throw new IllegalArgumentException(String.format(\n+                \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n+                pair, instanceName));\n+          }\n+          domainAsMap.put(values[0], values[1]);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        int numOfMatchedKeys = 0;\n+        for (String key : clusterTopologyKeys) {\n+          // if a key does not exist in the instance domain config, using the default domain value.\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            value = _defaultDomainPathValues.get(key);\n+                //defaultDomainPathValuesCache.computeIfAbsent(key, k -> (DEFAULT_DOMAIN_PREFIX + key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMDgzNA==", "bodyText": "Forgot to remove the comment. Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r442400834", "createdAt": "2020-06-18T17:50:19Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +191,122 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      try {\n+        LinkedHashMap<String, String> instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys)\n+      throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap = new HashMap<>();\n+        String[] pathPairs = instanceConfig.getDomainAsString().trim().split(\",\");\n+        for (String pair : pathPairs) {\n+          String[] values = pair.trim().split(\"=\");\n+          if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+            throw new IllegalArgumentException(String.format(\n+                \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n+                pair, instanceName));\n+          }\n+          domainAsMap.put(values[0], values[1]);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        int numOfMatchedKeys = 0;\n+        for (String key : clusterTopologyKeys) {\n+          // if a key does not exist in the instance domain config, using the default domain value.\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            value = _defaultDomainPathValues.get(key);\n+                //defaultDomainPathValuesCache.computeIfAbsent(key, k -> (DEFAULT_DOMAIN_PREFIX + key));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMTIwMQ=="}, "originalCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MDU1NjQ3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQwMTozODo1OVrOGmkGXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQwMjowMzo1MVrOGmkM7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MDUyNA==", "bodyText": "We shall trim at the final values level but not the above layers. What do you think?", "url": "https://github.com/apache/helix/pull/1043#discussion_r443090524", "createdAt": "2020-06-20T01:38:59Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java", "diffHunk": "@@ -150,12 +150,22 @@ public String getDomainAsString() {\n    */\n   public Map<String, String> getDomainAsMap() {\n     String domain = getDomainAsString();\n+    Map<String, String> domainAsMap = new HashMap<>();\n     if (domain == null || domain.isEmpty()) {\n-      return Collections.emptyMap();\n+      return domainAsMap;\n+    }\n+\n+    String[] pathPairs = domain.trim().split(\",\");\n+    for (String pair : pathPairs) {\n+      String[] values = pair.trim().split(\"=\");\n+      if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        throw new IllegalArgumentException(\n+            String.format(\"Domain-Value pair %s is not valid.\", pair));\n+      }\n+      domainAsMap.put(values[0], values[1]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e496ec67055f6068250dc6912c4550bbecc128f3"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MTUwOQ==", "bodyText": "I think if the value or key is null, then this pair shouldn't be count as a valid input.\nSince currently the callers of this function only checks if key exists in the returned map and uses the corresponding value.\ndomainAsMap.getOrDefault(key, \"Default_\" + key\nSo I think the user all assume that all k-v pairs in  returned map are valid (not null).\nThus, I think we should throw exception for empty value. (Original version already handles no splitter and null key errors).", "url": "https://github.com/apache/helix/pull/1043#discussion_r443091509", "createdAt": "2020-06-20T01:53:01Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java", "diffHunk": "@@ -150,12 +150,22 @@ public String getDomainAsString() {\n    */\n   public Map<String, String> getDomainAsMap() {\n     String domain = getDomainAsString();\n+    Map<String, String> domainAsMap = new HashMap<>();\n     if (domain == null || domain.isEmpty()) {\n-      return Collections.emptyMap();\n+      return domainAsMap;\n+    }\n+\n+    String[] pathPairs = domain.trim().split(\",\");\n+    for (String pair : pathPairs) {\n+      String[] values = pair.trim().split(\"=\");\n+      if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        throw new IllegalArgumentException(\n+            String.format(\"Domain-Value pair %s is not valid.\", pair));\n+      }\n+      domainAsMap.put(values[0], values[1]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MDUyNA=="}, "originalCommit": {"oid": "e496ec67055f6068250dc6912c4550bbecc128f3"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MTc5MA==", "bodyText": "Consider this case:\n\"a = b, c = d\", the current logic will have a map of {\"a \": \" b\", \"c \" : \" d\"} (notice the space), and what we expect is {\"a\": \"b\", \"c\" : \"d\"}.", "url": "https://github.com/apache/helix/pull/1043#discussion_r443091790", "createdAt": "2020-06-20T01:57:22Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java", "diffHunk": "@@ -150,12 +150,22 @@ public String getDomainAsString() {\n    */\n   public Map<String, String> getDomainAsMap() {\n     String domain = getDomainAsString();\n+    Map<String, String> domainAsMap = new HashMap<>();\n     if (domain == null || domain.isEmpty()) {\n-      return Collections.emptyMap();\n+      return domainAsMap;\n+    }\n+\n+    String[] pathPairs = domain.trim().split(\",\");\n+    for (String pair : pathPairs) {\n+      String[] values = pair.trim().split(\"=\");\n+      if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        throw new IllegalArgumentException(\n+            String.format(\"Domain-Value pair %s is not valid.\", pair));\n+      }\n+      domainAsMap.put(values[0], values[1]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MDUyNA=="}, "originalCommit": {"oid": "e496ec67055f6068250dc6912c4550bbecc128f3"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MjIwNw==", "bodyText": "Oh I got what you are saying. Yes thats correct. Updated.", "url": "https://github.com/apache/helix/pull/1043#discussion_r443092207", "createdAt": "2020-06-20T02:03:51Z", "author": {"login": "xyuanlu"}, "path": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java", "diffHunk": "@@ -150,12 +150,22 @@ public String getDomainAsString() {\n    */\n   public Map<String, String> getDomainAsMap() {\n     String domain = getDomainAsString();\n+    Map<String, String> domainAsMap = new HashMap<>();\n     if (domain == null || domain.isEmpty()) {\n-      return Collections.emptyMap();\n+      return domainAsMap;\n+    }\n+\n+    String[] pathPairs = domain.trim().split(\",\");\n+    for (String pair : pathPairs) {\n+      String[] values = pair.trim().split(\"=\");\n+      if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        throw new IllegalArgumentException(\n+            String.format(\"Domain-Value pair %s is not valid.\", pair));\n+      }\n+      domainAsMap.put(values[0], values[1]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MDUyNA=="}, "originalCommit": {"oid": "e496ec67055f6068250dc6912c4550bbecc128f3"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1103, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}