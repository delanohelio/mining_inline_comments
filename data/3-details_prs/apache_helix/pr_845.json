{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNjY5MzUz", "number": 845, "title": "Async write operation should not throw Exception for serializing error", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\n#805\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis change will make the async write operations return error through the async callback instead of throwing exceptions. This change will fix the batch write/create failure due to one single node serializing failure.\nIn addition, according to serializer interface definition, change ZK related serializers to throw ZkMarshallingError instead of ZkClientException.\nTests\n\n The following tests are written for this issue:\n\ntestAsyncWriteOperations\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\nFailed tests:\nTestJobQueueCleanUp.testJobQueueAutoCleanUp \u00bb ThreadTimeout Method org.testng....\nTestWorkflowTermination.testWorkflowJobFail:251->verifyWorkflowCleanup:257 expected: but was:\nTests run: 1086, Failures: 2, Errors: 0, Skipped: 0\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\nretrun:\nTests run: 8, Failures: 0, Errors: 0, Skipped: 0\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 57.613 s\n[INFO] Finished at: 2020-03-02T16:43:29-08:00\n[INFO] ------------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation (Optional)\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-03-02T23:55:23Z", "url": "https://github.com/apache/helix/pull/845", "merged": true, "mergeCommit": {"oid": "496d573811a8ffddac31b8a3081d504cfaf134d1"}, "closed": true, "closedAt": "2020-03-03T01:25:26Z", "author": {"login": "jiajunwang"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJ1ZjmgH2gAyMzgyNjY5MzUzOmY0YWMzZDMxZWUzNDgwZmZiNDU3YWFiZTU3ZjhiMDQ4MDE5MWRiZWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcJ395LgH2gAyMzgyNjY5MzUzOjQxMjJkMWRkYzg4MzA3NmNkYTdlZjkyOGRkYWFjMTQ4NGY0MzMzY2Y=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/f4ac3d31ee3480ffb457aabe57f8b0480191dbef", "committedDate": "2020-03-02T22:24:17Z", "message": "Async write operation should not throw Exception for serializing error.\n\nThis change will make the async write operations return error through the async callback instead of throwing exceptions. This change will fix the batch write/create failure due to one single node serializing failure.\nIn addition, according to serializer interface definition, change ZK related serializers to throw ZkMarshallingError instead of ZkClientException."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjMyMTgy", "url": "https://github.com/apache/helix/pull/845#pullrequestreview-367632182", "createdAt": "2020-03-03T00:43:20Z", "commit": {"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo0MzoyMFrOFw0kgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMTowMzo1N1rOFw071A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNzI4MQ==", "bodyText": "Don't forget to remove unused import for ZkClientException", "url": "https://github.com/apache/helix/pull/845#discussion_r386737281", "createdAt": "2020-03-03T00:43:20Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZNRecordSizeLimit.java", "diffHunk": "@@ -516,7 +514,7 @@ public void testZNRecordStreamingSerializerWriteSizeLimit() throws Exception {\n       try {\n         zkClient.writeData(path, largeRecord);\n         Assert.fail(\"Data should not written to ZK because data size exceeds writeSizeLimit!\");\n-      } catch (ZkClientException expected) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNzk3OQ==", "bodyText": "You prefer 1204 over 1024? :)", "url": "https://github.com/apache/helix/pull/845#discussion_r386737979", "createdAt": "2020-03-03T00:45:39Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -745,4 +749,65 @@ public void testWaitForEstablishedSession() {\n     // Recover zk server for later tests.\n     _zkServer.start();\n   }\n+\n+  @Test\n+  public void testAsyncWriteOperations() {\n+    ZkClient zkClient = new ZkClient(ZK_ADDR);\n+    String originSizeLimit =\n+        System.getProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+    System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES, \"2000\");\n+    try {\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+      ZNRecord oversizeZNRecord = new ZNRecord(\"Oversize\");\n+      StringBuilder sb = new StringBuilder(1204);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MTE4Ng==", "bodyText": "Nit: maybe it is good to use verify() and Assert to make sure the path is deleted? Do we also need to consider deleting \"/tmp\" if it did not exist originally as you would create it?", "url": "https://github.com/apache/helix/pull/845#discussion_r386741186", "createdAt": "2020-03-03T00:56:41Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -745,4 +749,65 @@ public void testWaitForEstablishedSession() {\n     // Recover zk server for later tests.\n     _zkServer.start();\n   }\n+\n+  @Test\n+  public void testAsyncWriteOperations() {\n+    ZkClient zkClient = new ZkClient(ZK_ADDR);\n+    String originSizeLimit =\n+        System.getProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+    System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES, \"2000\");\n+    try {\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+      ZNRecord oversizeZNRecord = new ZNRecord(\"Oversize\");\n+      StringBuilder sb = new StringBuilder(1204);\n+      Random ran = new Random();\n+      for (int i = 0; i < 1024; i++) {\n+        sb.append(ran.nextInt(26) + 'a');\n+      }\n+      String buf = sb.toString();\n+      for (int i = 0; i < 1024; i++) {\n+        oversizeZNRecord.setSimpleField(Integer.toString(i), buf);\n+      }\n+\n+      // ensure /tmp exists for the test\n+      if (!zkClient.exists(\"/tmp\")) {\n+        zkClient.create(\"/tmp\", null, CreateMode.PERSISTENT);\n+      }\n+\n+      org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.CreateCallbackHandler\n+          createCallback = new org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.CreateCallbackHandler();\n+      zkClient.asyncCreate(\"/tmp/async\", null, CreateMode.PERSISTENT, createCallback);\n+      createCallback.waitForSuccess();\n+      Assert.assertEquals(createCallback.getRc(), 0);\n+\n+      // try to create oversize node, should fail\n+      zkClient.asyncCreate(\"/tmp/asyncOversize\", oversizeZNRecord, CreateMode.PERSISTENT,\n+          createCallback);\n+      createCallback.waitForSuccess();\n+      Assert.assertEquals(createCallback.getRc(), KeeperException.Code.MarshallingError);\n+\n+      ZNRecord normalZNRecord = new ZNRecord(\"normal\");\n+      normalZNRecord.setSimpleField(\"key\", buf);\n+\n+      org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.SetDataCallbackHandler\n+          setDataCallbackHandler = new org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.SetDataCallbackHandler();\n+      zkClient.asyncSetData(\"/tmp/async\", normalZNRecord, -1, setDataCallbackHandler);\n+      setDataCallbackHandler.waitForSuccess();\n+      Assert.assertEquals(setDataCallbackHandler.getRc(), 0);\n+\n+      zkClient.asyncSetData(\"/tmp/async\", oversizeZNRecord, -1, setDataCallbackHandler);\n+      setDataCallbackHandler.waitForSuccess();\n+      Assert.assertEquals(setDataCallbackHandler.getRc(), KeeperException.Code.MarshallingError);\n+    } finally {\n+      if (originSizeLimit == null) {\n+        System.clearProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+      } else {\n+        System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES,\n+            originSizeLimit);\n+      }\n+      zkClient.delete(\"/tmp/async\");\n+      zkClient.delete(\"/tmp/asyncOversize\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzI1Mg==", "bodyText": "Nit: It seems this is redundant? Do you want to make the byte[] array final? If so, you may do declare data as final without initializing it to null.\nfinal byte[] data;", "url": "https://github.com/apache/helix/pull/845#discussion_r386743252", "createdAt": "2020-03-03T01:03:57Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1720,33 +1721,43 @@ public Stat writeDataGetStat(final String path, Object datat, final int expected\n   public void asyncCreate(final String path, Object datat, final CreateMode mode,\n       final ZkAsyncCallbacks.CreateCallbackHandler cb) {\n     final long startT = System.currentTimeMillis();\n-    final byte[] data = (datat == null ? null : serialize(datat, path));\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        ((ZkConnection) getConnection()).getZookeeper()\n-            .create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE,\n-                // Arrays.asList(DEFAULT_ACL),\n-                mode, cb, new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT,\n-                    data == null ? 0 : data.length, false));\n-        return null;\n-      }\n+    byte[] data = null;\n+    try {\n+      data = (datat == null ? null : serialize(datat, path));\n+    } catch (ZkMarshallingError e) {\n+      cb.processResult(KeeperException.Code.MARSHALLINGERROR.intValue(), path,\n+          new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT, 0, false), null);\n+      return;\n+    }\n+    final byte[] finalData = data;\n+    retryUntilConnected(() -> {\n+      ((ZkConnection) getConnection()).getZookeeper()\n+          .create(path, finalData, ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+              // Arrays.asList(DEFAULT_ACL),\n+              mode, cb, new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT,\n+                  finalData == null ? 0 : finalData.length, false));\n+      return null;\n     });\n   }\n \n   // Async Data Accessors\n   public void asyncSetData(final String path, Object datat, final int version,\n       final ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n     final long startT = System.currentTimeMillis();\n-    final byte[] data = serialize(datat, path);\n-    retryUntilConnected(new Callable<Object>() {\n-      @Override\n-      public Object call() throws Exception {\n-        ((ZkConnection) getConnection()).getZookeeper().setData(path, data, version, cb,\n-            new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT,\n-                data == null ? 0 : data.length, false));\n-        return null;\n-      }\n+    byte[] data = null;\n+    try {\n+      data = serialize(datat, path);\n+    } catch (ZkMarshallingError e) {\n+      cb.processResult(KeeperException.Code.MARSHALLINGERROR.intValue(), path,\n+          new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT, 0, false), null);\n+      return;\n+    }\n+    final byte[] finalData = data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjQwNDI3", "url": "https://github.com/apache/helix/pull/845#pullrequestreview-367640427", "createdAt": "2020-03-03T01:08:11Z", "commit": {"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMTowODoxMVrOFw1A4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMToxMDozM1rOFw1DbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NDU0NQ==", "bodyText": "Nit: Do you also want to check before and after: if the node exists or not to double check the node is not created?", "url": "https://github.com/apache/helix/pull/845#discussion_r386744545", "createdAt": "2020-03-03T01:08:11Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -745,4 +749,65 @@ public void testWaitForEstablishedSession() {\n     // Recover zk server for later tests.\n     _zkServer.start();\n   }\n+\n+  @Test\n+  public void testAsyncWriteOperations() {\n+    ZkClient zkClient = new ZkClient(ZK_ADDR);\n+    String originSizeLimit =\n+        System.getProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+    System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES, \"2000\");\n+    try {\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+      ZNRecord oversizeZNRecord = new ZNRecord(\"Oversize\");\n+      StringBuilder sb = new StringBuilder(1204);\n+      Random ran = new Random();\n+      for (int i = 0; i < 1024; i++) {\n+        sb.append(ran.nextInt(26) + 'a');\n+      }\n+      String buf = sb.toString();\n+      for (int i = 0; i < 1024; i++) {\n+        oversizeZNRecord.setSimpleField(Integer.toString(i), buf);\n+      }\n+\n+      // ensure /tmp exists for the test\n+      if (!zkClient.exists(\"/tmp\")) {\n+        zkClient.create(\"/tmp\", null, CreateMode.PERSISTENT);\n+      }\n+\n+      org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.CreateCallbackHandler\n+          createCallback = new org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks.CreateCallbackHandler();\n+      zkClient.asyncCreate(\"/tmp/async\", null, CreateMode.PERSISTENT, createCallback);\n+      createCallback.waitForSuccess();\n+      Assert.assertEquals(createCallback.getRc(), 0);\n+\n+      // try to create oversize node, should fail\n+      zkClient.asyncCreate(\"/tmp/asyncOversize\", oversizeZNRecord, CreateMode.PERSISTENT,\n+          createCallback);\n+      createCallback.waitForSuccess();\n+      Assert.assertEquals(createCallback.getRc(), KeeperException.Code.MarshallingError);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTE5Nw==", "bodyText": "Random is good to make sure compressed data is not that small!", "url": "https://github.com/apache/helix/pull/845#discussion_r386745197", "createdAt": "2020-03-03T01:10:33Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestRawZkClient.java", "diffHunk": "@@ -745,4 +749,65 @@ public void testWaitForEstablishedSession() {\n     // Recover zk server for later tests.\n     _zkServer.start();\n   }\n+\n+  @Test\n+  public void testAsyncWriteOperations() {\n+    ZkClient zkClient = new ZkClient(ZK_ADDR);\n+    String originSizeLimit =\n+        System.getProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES);\n+    System.setProperty(ZkSystemPropertyKeys.ZK_SERIALIZER_ZNRECORD_WRITE_SIZE_LIMIT_BYTES, \"2000\");\n+    try {\n+      zkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+      ZNRecord oversizeZNRecord = new ZNRecord(\"Oversize\");\n+      StringBuilder sb = new StringBuilder(1204);\n+      Random ran = new Random();\n+      for (int i = 0; i < 1024; i++) {\n+        sb.append(ran.nextInt(26) + 'a');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4ac3d31ee3480ffb457aabe57f8b0480191dbef"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4122d1ddc883076cda7ef928ddaac1484f4333cf", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/4122d1ddc883076cda7ef928ddaac1484f4333cf", "committedDate": "2020-03-03T01:23:47Z", "message": "Address comment"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4635, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}