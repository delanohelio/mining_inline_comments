{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NjkzMTg4", "number": 1452, "title": "thread leakage checker and memory usage reporter #1226", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nfix #1226\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nAdd thread leakage checker and memory usage reporter. The two\nutility would be invoke before and after test classes. The would\nhelp to detect/monitor resource/memory usage of the unit test.\nTests\n\n The following tests are written for this issue:\n\n(List the names of added unit/integration tests)\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n2020-10-08T07:55:24.0931119Z\n2020-10-08T07:55:24.4922133Z [ERROR] Failures:\n2020-10-08T07:55:24.4923510Z [ERROR]   TestDisableCustomCodeRunner.test:236 expected: but was:\n2020-10-08T07:55:24.4925729Z [ERROR]   TestClusterStatusMonitorLifecycle.testClusterStatusMonitorLifecycle:290 expected: but was:\n2020-10-08T07:55:24.4928050Z [ERROR] Tests run: 1213, Failures: 2, Errors: 0, Skipped: 0\nre-run would work.\nDocumentation (Optional)\n\nIn case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCommits\n\nMy commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\nMy diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-10-08T06:31:00Z", "url": "https://github.com/apache/helix/pull/1452", "merged": true, "mergeCommit": {"oid": "00d4fd831180f72e15c620486dd401efdffac7a0"}, "closed": true, "closedAt": "2020-10-09T21:19:13Z", "author": {"login": "kaisun2000"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQbh6TAH2gAyNDk5NjkzMTg4OjgzYjAzMWU1M2ZmZDkyMzEwZDJkOTMzMmU5ZjVjMWJiNzNlMWIxNDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQ7nHkgFqTUwNTk0Nzc5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "committedDate": "2020-10-08T06:24:30Z", "message": "fix #1226\nAdd thread leakage checker and memory usage reporter. The two\nutility would be invoke before and after test classes. The would\nhelp to detect/monitor resource/memory usage of the unit test."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MTM5Njk1", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505139695", "createdAt": "2020-10-08T20:26:38Z", "commit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDoyNjozOVrOHevKxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDoyNjozOVrOHevKxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5MjEzMg==", "bodyText": "minor: int -> long?", "url": "https://github.com/apache/helix/pull/1452#discussion_r501992132", "createdAt": "2020-10-08T20:26:39Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -127,8 +129,22 @@\n   protected Map<String, ClusterSetup> _clusterSetupMap = new HashMap<>();\n   protected Map<String, BaseDataAccessor> _baseDataAccessorMap = new HashMap<>();\n \n+  static public void reportPhysicalMemory() {\n+    com.sun.management.OperatingSystemMXBean os = (com.sun.management.OperatingSystemMXBean)\n+        java.lang.management.ManagementFactory.getOperatingSystemMXBean();\n+    long physicalMemorySize = os.getTotalPhysicalMemorySize();\n+    System.out.println(\"************ SYSTEM Physical Memory:\"  + physicalMemorySize);\n+\n+    int MB = 1024 * 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MTQxMTE4", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505141118", "createdAt": "2020-10-08T20:28:44Z", "commit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDoyODo0NFrOHevO1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDoyODo0NFrOHevO1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5MzE3NA==", "bodyText": "Will this method being called by all sub test classes?", "url": "https://github.com/apache/helix/pull/1452#discussion_r501993174", "createdAt": "2020-10-08T20:28:44Z", "author": {"login": "lei-xia"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -710,7 +726,9 @@ protected Message createMessage(Message.MessageType type, String msgId, String f\n   }\n \n   @AfterClass\n-  public void cleanupLiveInstanceOwners() {\n+  public void cleanupLiveInstanceOwners() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MTUyNDkx", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505152491", "createdAt": "2020-10-08T20:45:31Z", "commit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDo0NTozMlrOHevxcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDo1MzozNFrOHewBag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMjAzMw==", "bodyText": "Isn't the 32 too small as initial value? We have a lot more than that right?", "url": "https://github.com/apache/helix/pull/1452#discussion_r502002033", "createdAt": "2020-10-08T20:45:32Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMzQyNg==", "bodyText": "Can you give some explanation of the default value? Otherwise, it's a bit hard to follow. E.g., whey ForkJoin is default to 2?", "url": "https://github.com/apache/helix/pull/1452#discussion_r502003426", "createdAt": "2020-10-08T20:48:16Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZkServerThrdPattern =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZkSessionThrdPattern =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] ForkJoinThrdPattern = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TimerThrdPattern = new String[]{\"time\"};\n+  private static final String[] TaskStateModelThrdPattern = new String[]{\"TaskStateModel\"};\n+\n+  private static enum ThreadCategory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNDcxMw==", "bodyText": "nit: can you use more character for \"category\", catThreadCnt is not quit self explanatory.", "url": "https://github.com/apache/helix/pull/1452#discussion_r502004713", "createdAt": "2020-10-08T20:50:41Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZkServerThrdPattern =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZkSessionThrdPattern =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] ForkJoinThrdPattern = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TimerThrdPattern = new String[]{\"time\"};\n+  private static final String[] TaskStateModelThrdPattern = new String[]{\"TaskStateModel\"};\n+\n+  private static enum ThreadCategory {\n+    ZkServer(\"zookeeper server threads\", 4, 100, ZkServerThrdPattern),\n+    ZkSession(\"zkclient/zooKeeper session threads\", 12, 12, ZkSessionThrdPattern),\n+    ForkJoin(\"fork join pool threads\", 2, 10, ForkJoinThrdPattern),\n+    Timer(\"timer threads\", 0, 2, TimerThrdPattern),\n+    TaskStateModel(\"TaskStateModel threads\", 0, 0, TaskStateModelThrdPattern),\n+    Other(\"Other threads\", 0, 3, new String[]{\"\"});\n+\n+    private String _description;\n+    private List<String> _pattern;\n+    private int _warningLimit;\n+    private int _limit;\n+\n+    public String getDescription() {\n+      return _description;\n+    }\n+\n+    public Predicate<String> getMatchPred() {\n+      if (this.name() != ThreadCategory.Other.name()) {\n+        Predicate<String> pred = target -> {\n+          for (String p : _pattern) {\n+            if (target.toLowerCase().contains(p.toLowerCase())) {\n+              return true;\n+            }\n+          }\n+          return false;\n+        };\n+        return pred;\n+      }\n+\n+      List<Predicate<String>> predicateList = new ArrayList<>();\n+      for (ThreadCategory threadCategory : ThreadCategory.values()) {\n+        if (threadCategory == ThreadCategory.Other) {\n+          continue;\n+        }\n+        predicateList.add(threadCategory.getMatchPred());\n+      }\n+      Predicate<String> pred = target -> {\n+        for (Predicate<String> p : predicateList) {\n+          if (p.test(target)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      };\n+\n+      return pred;\n+    }\n+\n+    public int getWarningLimit() {\n+      return _warningLimit;\n+    }\n+\n+    public int getLimit() {\n+      return _limit;\n+    }\n+\n+    private ThreadCategory(String description, int warningLimit, int limit, String[] patterns) {\n+      _description = description;\n+      _pattern = Arrays.asList(patterns);\n+      _warningLimit = warningLimit;\n+      _limit = limit;\n+    }\n+  }\n+\n+  public static boolean afterClassCheck(String classname) {\n+    ZkTestBase.reportPhysicalMemory();\n+    // step 1: get all active threads\n+    List<Thread> threads = getAllThreads();\n+    System.out.println(classname + \" has active threads cnt:\" + threads.size());\n+\n+    // step 2: categorize threads\n+    Map<String, List<Thread>> threadByName = null;\n+    Map<ThreadCategory, Integer> threadByCnt = new HashMap<>();\n+    Map<ThreadCategory, Set<Thread>> threadByCat = new HashMap<>();\n+    try {\n+      threadByName = threads.\n+          stream().\n+          filter(p -> p.getThreadGroup() != null && p.getThreadGroup().getName() != null\n+              &&  ! \"system\".equals(p.getThreadGroup().getName())).\n+          collect(Collectors.groupingBy(p -> p.getName()));\n+    } catch (Exception e) {\n+      System.out.println(\"filtering thread failure with exception:\" + e.getStackTrace());\n+    }\n+\n+    threadByName.entrySet().stream().forEach(entry -> {\n+      String key = entry.getKey(); // thread name\n+      Arrays.asList(ThreadCategory.values()).stream().forEach(category -> {\n+        if (category.getMatchPred().test(key)) {\n+          Integer count = threadByCnt.containsKey(category) ? threadByCnt.get(category) : 0;\n+          threadByCnt.put(category, count + entry.getValue().size());\n+          Set<Thread> thisSet = threadByCat.getOrDefault(category, new HashSet<>());\n+          thisSet.addAll(entry.getValue());\n+          threadByCat.put(category, thisSet);\n+        }\n+      });\n+    });\n+\n+    // step 3: enforce checking policy\n+    boolean checkStatus = true;\n+    for (ThreadCategory threadCategory : ThreadCategory.values()) {\n+      int limit = threadCategory.getLimit();\n+      int warningLimit = threadCategory.getWarningLimit();\n+\n+      Integer catThreadCnt = threadByCnt.get(threadCategory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNDk4NQ==", "bodyText": "Comments said \"10\", but I think \"100\" makes more sense.", "url": "https://github.com/apache/helix/pull/1452#discussion_r502004985", "createdAt": "2020-10-08T20:51:08Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZkServerThrdPattern =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZkSessionThrdPattern =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] ForkJoinThrdPattern = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TimerThrdPattern = new String[]{\"time\"};\n+  private static final String[] TaskStateModelThrdPattern = new String[]{\"TaskStateModel\"};\n+\n+  private static enum ThreadCategory {\n+    ZkServer(\"zookeeper server threads\", 4, 100, ZkServerThrdPattern),\n+    ZkSession(\"zkclient/zooKeeper session threads\", 12, 12, ZkSessionThrdPattern),\n+    ForkJoin(\"fork join pool threads\", 2, 10, ForkJoinThrdPattern),\n+    Timer(\"timer threads\", 0, 2, TimerThrdPattern),\n+    TaskStateModel(\"TaskStateModel threads\", 0, 0, TaskStateModelThrdPattern),\n+    Other(\"Other threads\", 0, 3, new String[]{\"\"});\n+\n+    private String _description;\n+    private List<String> _pattern;\n+    private int _warningLimit;\n+    private int _limit;\n+\n+    public String getDescription() {\n+      return _description;\n+    }\n+\n+    public Predicate<String> getMatchPred() {\n+      if (this.name() != ThreadCategory.Other.name()) {\n+        Predicate<String> pred = target -> {\n+          for (String p : _pattern) {\n+            if (target.toLowerCase().contains(p.toLowerCase())) {\n+              return true;\n+            }\n+          }\n+          return false;\n+        };\n+        return pred;\n+      }\n+\n+      List<Predicate<String>> predicateList = new ArrayList<>();\n+      for (ThreadCategory threadCategory : ThreadCategory.values()) {\n+        if (threadCategory == ThreadCategory.Other) {\n+          continue;\n+        }\n+        predicateList.add(threadCategory.getMatchPred());\n+      }\n+      Predicate<String> pred = target -> {\n+        for (Predicate<String> p : predicateList) {\n+          if (p.test(target)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      };\n+\n+      return pred;\n+    }\n+\n+    public int getWarningLimit() {\n+      return _warningLimit;\n+    }\n+\n+    public int getLimit() {\n+      return _limit;\n+    }\n+\n+    private ThreadCategory(String description, int warningLimit, int limit, String[] patterns) {\n+      _description = description;\n+      _pattern = Arrays.asList(patterns);\n+      _warningLimit = warningLimit;\n+      _limit = limit;\n+    }\n+  }\n+\n+  public static boolean afterClassCheck(String classname) {\n+    ZkTestBase.reportPhysicalMemory();\n+    // step 1: get all active threads\n+    List<Thread> threads = getAllThreads();\n+    System.out.println(classname + \" has active threads cnt:\" + threads.size());\n+\n+    // step 2: categorize threads\n+    Map<String, List<Thread>> threadByName = null;\n+    Map<ThreadCategory, Integer> threadByCnt = new HashMap<>();\n+    Map<ThreadCategory, Set<Thread>> threadByCat = new HashMap<>();\n+    try {\n+      threadByName = threads.\n+          stream().\n+          filter(p -> p.getThreadGroup() != null && p.getThreadGroup().getName() != null\n+              &&  ! \"system\".equals(p.getThreadGroup().getName())).\n+          collect(Collectors.groupingBy(p -> p.getName()));\n+    } catch (Exception e) {\n+      System.out.println(\"filtering thread failure with exception:\" + e.getStackTrace());\n+    }\n+\n+    threadByName.entrySet().stream().forEach(entry -> {\n+      String key = entry.getKey(); // thread name\n+      Arrays.asList(ThreadCategory.values()).stream().forEach(category -> {\n+        if (category.getMatchPred().test(key)) {\n+          Integer count = threadByCnt.containsKey(category) ? threadByCnt.get(category) : 0;\n+          threadByCnt.put(category, count + entry.getValue().size());\n+          Set<Thread> thisSet = threadByCat.getOrDefault(category, new HashSet<>());\n+          thisSet.addAll(entry.getValue());\n+          threadByCat.put(category, thisSet);\n+        }\n+      });\n+    });\n+\n+    // step 3: enforce checking policy\n+    boolean checkStatus = true;\n+    for (ThreadCategory threadCategory : ThreadCategory.values()) {\n+      int limit = threadCategory.getLimit();\n+      int warningLimit = threadCategory.getWarningLimit();\n+\n+      Integer catThreadCnt = threadByCnt.get(threadCategory);\n+      if (catThreadCnt != null) {\n+        boolean dumpThread = false;\n+        if (catThreadCnt > limit) {\n+          checkStatus = false;\n+          System.out.println(\n+              \"Failure \" + threadCategory.getDescription() + \" has \" + catThreadCnt + \" thread\");\n+          dumpThread = true;\n+        } else if (catThreadCnt > warningLimit) {\n+          System.out.println(\n+              \"Warning \" + threadCategory.getDescription() + \" has \" + catThreadCnt + \" thread\");\n+          dumpThread = true;\n+        } else {\n+          System.out.println(threadCategory.getDescription() + \" has \" + catThreadCnt + \" thread\");\n+        }\n+        if (!dumpThread) {\n+          continue;\n+        }\n+        // print first 10 thread names\n+        int i = 0;\n+        for (Thread t : threadByCat.get(threadCategory)) {\n+          System.out.println(i + \" thread:\" + t.getName());\n+          i++;\n+          if (i == 100) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNjEyMg==", "bodyText": "Just to make sure, having this check here should cover all tests.", "url": "https://github.com/apache/helix/pull/1452#discussion_r502006122", "createdAt": "2020-10-08T20:53:34Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -719,6 +737,17 @@ public void cleanupLiveInstanceOwners() {\n       clientMap.clear();\n     }\n     _liveInstanceOwners.clear();\n+\n+    boolean status = false;\n+    try {\n+      status = ThreadLeakageChecker.afterClassCheck(testClassName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e8b5718a2bf45f29bc75004b159028f30a9c91d", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/4e8b5718a2bf45f29bc75004b159028f30a9c91d", "committedDate": "2020-10-08T21:36:50Z", "message": "address review comments from Meng and Lei"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MjAyNjI0", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505202624", "createdAt": "2020-10-08T22:14:05Z", "commit": {"oid": "4e8b5718a2bf45f29bc75004b159028f30a9c91d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MjQ3MjAx", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505247201", "createdAt": "2020-10-08T23:38:09Z", "commit": {"oid": "4e8b5718a2bf45f29bc75004b159028f30a9c91d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzozODowOVrOHe0h9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzozODowOVrOHe0h9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3OTk5MA==", "bodyText": "@kaisun2000 Can you add Apache License ?", "url": "https://github.com/apache/helix/pull/1452#discussion_r502079990", "createdAt": "2020-10-08T23:38:09Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8b5718a2bf45f29bc75004b159028f30a9c91d"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MjQ4NDAw", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505248400", "createdAt": "2020-10-08T23:41:50Z", "commit": {"oid": "4e8b5718a2bf45f29bc75004b159028f30a9c91d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo0MTo1MVrOHe0mKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo0MTo1MVrOHe0mKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4MTA2Nw==", "bodyText": "Is this needed?", "url": "https://github.com/apache/helix/pull/1452#discussion_r502081067", "createdAt": "2020-10-08T23:41:51Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -33,6 +33,7 @@\n import javax.management.MBeanServerConnection;\n import javax.management.ObjectName;\n \n+import bsh.This;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8b5718a2bf45f29bc75004b159028f30a9c91d"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MjQ5NzQ0", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505249744", "createdAt": "2020-10-08T23:46:06Z", "commit": {"oid": "4e8b5718a2bf45f29bc75004b159028f30a9c91d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo0NjowNlrOHe0qvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo0NjowNlrOHe0qvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4MjIzOA==", "bodyText": "I didn't mean to be picky, but I suggest we still follow the constant style: static final String[] THIS_IS_CONSTANT", "url": "https://github.com/apache/helix/pull/1452#discussion_r502082238", "createdAt": "2020-10-08T23:46:06Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZkServerThrdPattern =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZkSessionThrdPattern =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] ForkJoinThrdPattern = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TimerThrdPattern = new String[]{\"time\"};\n+  private static final String[] TaskStateModelThrdPattern = new String[]{\"TaskStateModel\"};\n+\n+  private static enum ThreadCategory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8b5718a2bf45f29bc75004b159028f30a9c91d"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "976ffbb115d477d40249eb88c1e7d831c7b8f796", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/976ffbb115d477d40249eb88c1e7d831c7b8f796", "committedDate": "2020-10-09T00:10:29Z", "message": "address hz's comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MjU4NjY4", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505258668", "createdAt": "2020-10-09T00:14:50Z", "commit": {"oid": "976ffbb115d477d40249eb88c1e7d831c7b8f796"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDoxNDo1MFrOHe1Igw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDozMToxOFrOHe1YmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4OTg1OQ==", "bodyText": "Please comment on what is this checker doing.", "url": "https://github.com/apache/helix/pull/1452#discussion_r502089859", "createdAt": "2020-10-09T00:14:50Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976ffbb115d477d40249eb88c1e7d831c7b8f796"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MDY0OA==", "bodyText": "Please put the comment into the class. Code reviewers in the future shall not depend on this Github PR to understand the logic.", "url": "https://github.com/apache/helix/pull/1452#discussion_r502090648", "createdAt": "2020-10-09T00:17:50Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZkServerThrdPattern =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZkSessionThrdPattern =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] ForkJoinThrdPattern = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TimerThrdPattern = new String[]{\"time\"};\n+  private static final String[] TaskStateModelThrdPattern = new String[]{\"TaskStateModel\"};\n+\n+  private static enum ThreadCategory {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMzQyNg=="}, "originalCommit": {"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MjY4NA==", "bodyText": "Any thoughts on how we are going to maintain these hardcoded patterns?", "url": "https://github.com/apache/helix/pull/1452#discussion_r502092684", "createdAt": "2020-10-09T00:26:00Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZKSERVER_THRD_PATTERN =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZKSESSION_THRD_PATTERN =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] FORKJOIN_THRD_PATTERN = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TIMER_THRD_PATTERN = new String[]{\"time\"};\n+  private static final String[] TASKSTATEMODEL_THRD_PATTERN = new String[]{\"TaskStateModel\"};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976ffbb115d477d40249eb88c1e7d831c7b8f796"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5Mjg4Nw==", "bodyText": "Another question, does it only work for sequentially run tests?\nIf so, please note in the comment.", "url": "https://github.com/apache/helix/pull/1452#discussion_r502092887", "createdAt": "2020-10-09T00:26:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4OTg1OQ=="}, "originalCommit": {"oid": "976ffbb115d477d40249eb88c1e7d831c7b8f796"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MzQ3Nw==", "bodyText": "Please remove this output. I think with no leakage found, we don't need this information.", "url": "https://github.com/apache/helix/pull/1452#discussion_r502093477", "createdAt": "2020-10-09T00:29:26Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -710,7 +725,9 @@ protected Message createMessage(Message.MessageType type, String msgId, String f\n   }\n \n   @AfterClass\n-  public void cleanupLiveInstanceOwners() {\n+  public void cleanupLiveInstanceOwners() throws InterruptedException {\n+    String testClassName = this.getShortClassName();\n+    System.out.println(\"AfterClass:\" + testClassName + \" afterclass of ZkTestBase called!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976ffbb115d477d40249eb88c1e7d831c7b8f796"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MzczOQ==", "bodyText": "Why system out print instead of log? If I redirect the test log into a file for debugging, I won't see this information.", "url": "https://github.com/apache/helix/pull/1452#discussion_r502093739", "createdAt": "2020-10-09T00:30:20Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -719,6 +736,17 @@ public void cleanupLiveInstanceOwners() {\n       clientMap.clear();\n     }\n     _liveInstanceOwners.clear();\n+\n+    boolean status = false;\n+    try {\n+      status = ThreadLeakageChecker.afterClassCheck(testClassName);\n+    } catch (Exception e) {\n+      System.out.println(\"ThreadLeakageChecker exception:\" + e.getStackTrace());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976ffbb115d477d40249eb88c1e7d831c7b8f796"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5Mzk3Ng==", "bodyText": "Same comments as the ZkTestBase class.", "url": "https://github.com/apache/helix/pull/1452#discussion_r502093976", "createdAt": "2020-10-09T00:31:18Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/test/java/org/apache/helix/integration/multizk/TestMultiZkHelixJavaApis.java", "diffHunk": "@@ -170,6 +171,9 @@ public void beforeClass() throws Exception {\n \n   @AfterClass\n   public void afterClass() throws Exception {\n+    String testClassName = getClass().getSimpleName();\n+    System.out.println(\"AfterClass: \" + testClassName + \" of TestMultiZkHelixJavaApis called.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976ffbb115d477d40249eb88c1e7d831c7b8f796"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e67334efc6ac10f9d50ffee3240d774b90fe012d", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/e67334efc6ac10f9d50ffee3240d774b90fe012d", "committedDate": "2020-10-09T01:20:07Z", "message": "address JJ's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71f8f0667149f26e0c623662f7f641f5bc6bebb1", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/71f8f0667149f26e0c623662f7f641f5bc6bebb1", "committedDate": "2020-10-09T01:25:47Z", "message": "address one more logging."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODk5ODU2", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505899856", "createdAt": "2020-10-09T18:24:26Z", "commit": {"oid": "71f8f0667149f26e0c623662f7f641f5bc6bebb1"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d0d97e14cc1db3dc984edcea9e2a1e4c8fbabed", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/5d0d97e14cc1db3dc984edcea9e2a1e4c8fbabed", "committedDate": "2020-10-09T19:40:51Z", "message": "added todo to remove system.out and once we achieve 0 thread"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1OTQ3Nzk5", "url": "https://github.com/apache/helix/pull/1452#pullrequestreview-505947799", "createdAt": "2020-10-09T19:47:09Z", "commit": {"oid": "5d0d97e14cc1db3dc984edcea9e2a1e4c8fbabed"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4341, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}