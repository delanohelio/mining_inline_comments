{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMDU3NjA1", "number": 994, "title": "Remove the scheduling decision based on PreviousAssignment", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR title:\nFixes #984\n\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\nIn this commit, several parts of the code have been removed in order to avoid\nmaking scheduling decision based on PreviousAssignment. Instead we are relying on\nthe CurrentState.\nIn order to facilitate this, the tasks that reaches the terminal state\n(Error, Time_out, Aborted and completed) will be dropped and rescheduled in later\npipeline if needed (If they need to be rescheduled). This helps us to reduce the\nnumber of existing current states for each task.\n\nTests\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n[INFO] Results:\n[INFO]\n[ERROR] Failures:\n[ERROR]   TestWorkflowTermination.testWorkflowJobFail:251->verifyWorkflowCleanup:257 expected: but was:\n[ERROR]   TestWorkflowTimeout.testWorkflowTimeoutWhenWorkflowCompleted:116 expected: but was:\n[INFO]\n[ERROR] Tests run: 1144, Failures: 2, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:21 h\n[INFO] Finished at: 2020-05-01T15:25:20-07:00\n[INFO] ------------------------------------------------------------------------\n\nThe failed tests has passed when I ran it individually.\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-05-04T16:34:25Z", "url": "https://github.com/apache/helix/pull/994", "merged": true, "mergeCommit": {"oid": "4bbead3f68669ba92985e4bf4b4e71ed7a1c1efa"}, "closed": true, "closedAt": "2020-05-26T23:49:43Z", "author": {"login": "alirezazamani"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcdFms4gH2gAyNDEzMDU3NjA1OjRmZmFjODFmN2NhODBkZDAyZDJhYjdiNjNlODMzNjFjOWIwZmRiNzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclL6RWgFqTQxODcwNjEyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "committedDate": "2020-05-01T18:01:41Z", "message": "Remove the scheduling decsion based on PreviousAssignment\n\nIn this commit, the our previous logic which was based on PreviousAssignment,\nhas been changed. Instread, the scheduling is mostly based on CurrentState."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NjczOTY0", "url": "https://github.com/apache/helix/pull/994#pullrequestreview-409673964", "createdAt": "2020-05-12T03:29:56Z", "commit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMzoyOTo1NlrOGT0xSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMzo1MDozMlrOGT1E_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MDcxNA==", "bodyText": "Did you mean \"that are in either INIT or DROPPED states\"?", "url": "https://github.com/apache/helix/pull/994#discussion_r423440714", "createdAt": "2020-05-12T03:29:56Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -99,16 +99,15 @@ public void updatePreviousAssignedTasksStatus(\n       }\n \n       // If not an excluded instance, we must instantiate its entry in assignedPartitions\n-      Set<Integer> pSet = prevInstanceToTaskAssignments.get(instance);\n+      Set<Integer> pSet = currentInstanceToTaskAssignments.get(instance);\n \n       // We need to remove all task pId's to be dropped because we already made an assignment in\n       // paMap above for them to be dropped. The following does this.\n       if (tasksToDrop.containsKey(instance)) {\n         pSet.removeAll(tasksToDrop.get(instance));\n       }\n \n-      // Used to keep track of partitions that are in one of the final states: COMPLETED, TIMED_OUT,\n-      // TASK_ERROR, ERROR.\n+      // Used to keep track of partitions that are in one the INIT or DROPPED states.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MTM4MA==", "bodyText": "I don't know if this would be the correct thing to do.\nSure, once a task is complete, it could be dropped from the node, but you also want to keep the state of the task in COMPLETED in JobContext.\nI'm afraid doing this might cause the otherwise-completed task's state to change to DROPPED. Then we would have no way of knowing if this task just got dropped or completed and dropped.", "url": "https://github.com/apache/helix/pull/994#discussion_r423441380", "createdAt": "2020-05-12T03:32:37Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -242,16 +230,16 @@ public void updatePreviousAssignedTasksStatus(\n         }\n           break;\n         case COMPLETED: {\n-          // The task has completed on this partition. Mark as such in the context object.\n-          donePartitions.add(pId);\n+          // The task has completed on this partition. Drop it from the instance and add it to assignedPartitions in\n+          // order to avoid scheduling it again in this pipeline.\n+          assignedPartitions.get(instance).add(pId);\n+          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.DROPPED.name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MTYzMA==", "bodyText": "Again, I am not sure if this would cause the JobContext to have the wrong state for the task partitions. Did you check? What state does the task go into between being dropped and getting rescheduled? (It should be ERROR or TASK_ABORTED, or whatever it was before being dropped)", "url": "https://github.com/apache/helix/pull/994#discussion_r423441630", "createdAt": "2020-05-12T03:33:36Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -263,7 +251,11 @@ public void updatePreviousAssignedTasksStatus(\n         case TASK_ABORTED:\n \n         case ERROR: {\n-          donePartitions.add(pId); // The task may be rescheduled on a different instance.\n+          // First make this task which is in terminal state to be dropped.\n+          // Later on, in next pipeline in handleAdditionalAssignments, the task will be retried if possible.\n+          // (meaning it is not ABORTED and max number of attempts has not been reached yet)\n+          assignedPartitions.get(instance).add(pId);\n+          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.DROPPED.name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MjE0NQ==", "bodyText": "the assignedParticipant \"field\" in JobContext needs to be updated...", "url": "https://github.com/apache/helix/pull/994#discussion_r423442145", "createdAt": "2020-05-12T03:35:53Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MjQyMA==", "bodyText": "... because this will prevent the controller from being stuck in a race condition when there are two current states found for a single task.\n-> Okay, but what kind of race condition are we talking about?", "url": "https://github.com/apache/helix/pull/994#discussion_r423442420", "createdAt": "2020-05-12T03:37:08Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to stuck in race condition while there is two", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MzE5Nw==", "bodyText": "Does this help us avoid the race condition?", "url": "https://github.com/apache/helix/pull/994#discussion_r423443197", "createdAt": "2020-05-12T03:39:45Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to stuck in race condition while there is two\n+    // current states. In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MzU3OQ==", "bodyText": "-> update context while its current state exists...\nBut why do we not want to update the context when there's a current state for it? Shouldn't we update the context based on the latest current state?", "url": "https://github.com/apache/helix/pull/994#discussion_r423443579", "createdAt": "2020-05-12T03:41:21Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to stuck in race condition while there is two\n+    // current states. In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.\n     jobCtx.setAssignedParticipant(pId, instance);\n-    jobCtx.setPartitionState(pId, currentState);\n-    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n-    if (taskMsg != null) {\n-      jobCtx.setPartitionInfo(pId, taskMsg);\n+    // If job context needs to be updated with new state, update it accordingly\n+    // This check is necessary because we are relying on current state and we do not want to update\n+    // context as long as current state existed. We just want to update context information", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0Mzg0Mw==", "bodyText": "This condition checks whether jobContext's state is out of date or not, right?", "url": "https://github.com/apache/helix/pull/994#discussion_r423443843", "createdAt": "2020-05-12T03:42:28Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to stuck in race condition while there is two\n+    // current states. In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.\n     jobCtx.setAssignedParticipant(pId, instance);\n-    jobCtx.setPartitionState(pId, currentState);\n-    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n-    if (taskMsg != null) {\n-      jobCtx.setPartitionInfo(pId, taskMsg);\n+    // If job context needs to be updated with new state, update it accordingly\n+    // This check is necessary because we are relying on current state and we do not want to update\n+    // context as long as current state existed. We just want to update context information\n+    // (specially finish time) once.\n+    if (!currentState.equals(jobCtx.getPartitionState(pId))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTE1OQ==", "bodyText": "\"add these pIds to result\" and update their states in JobContext in updatePreviousAssignedTasksStatus method...", "url": "https://github.com/apache/helix/pull/994#discussion_r423445159", "createdAt": "2020-05-12T03:48:04Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -380,72 +379,38 @@ private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions,\n \n   /**\n    * @param liveInstances\n-   * @param prevAssignment task partition -> (instance -> state)\n-   * @param allTaskPartitions all task partitionIds\n    * @param currStateOutput currentStates to make sure currentStates copied over expired sessions\n    *          are accounted for\n    * @param jobName job name\n    * @param tasksToDrop instance -> pId's, to gather all pIds that need to be dropped\n    * @return instance -> partitionIds from previous assignment, if the instance is still live\n    */\n-  protected static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments(\n-      Iterable<String> liveInstances, ResourceAssignment prevAssignment,\n-      Set<Integer> allTaskPartitions, CurrentStateOutput currStateOutput, String jobName,\n+  protected static Map<String, SortedSet<Integer>> getCurrentInstanceToTaskAssignments(\n+      Iterable<String> liveInstances, CurrentStateOutput currStateOutput, String jobName,\n       Map<String, Set<Integer>> tasksToDrop) {\n     Map<String, SortedSet<Integer>> result = new HashMap<>();\n     for (String instance : liveInstances) {\n       result.put(instance, new TreeSet<>());\n     }\n \n-    // First, add all task partitions from prevAssignment\n-    // TODO: Remove this portion to get rid of prevAssignment from Task Framework\n-    for (Partition partition : prevAssignment.getMappedPartitions()) {\n-      int pId = TaskUtil.getPartitionId(partition.getPartitionName());\n-      if (allTaskPartitions.contains(pId)) {\n-        Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition);\n-        for (String instance : replicaMap.keySet()) {\n-          SortedSet<Integer> pIdSet = result.get(instance);\n-          if (pIdSet != null) {\n-            pIdSet.add(pId);\n-          }\n-        }\n-      }\n-    }\n-\n-    // Generate prevInstanceToTaskAssignment with CurrentStateOutput as source of truth\n-\n-    // Add all pIds existing in CurrentStateOutput as well because task currentStates copied over\n-    // from previous sessions won't show up in prevInstanceToTaskAssignments\n-    // We need to add these back here in order for these task partitions to be dropped (after a\n-    // copy-over, the Controller will send a message to drop the state currentState)\n-    // partitions: (partition -> instance -> currentState)\n+    // Generate currentInstanceToTaskAssignment with CurrentStateOutput as source of truth\n+    // Add all pIds existing in CurrentStateOutput\n+    // We need to add these pIds here and make decision about the existing tasks with current state\n+    // in updatePreviousAssignedTasksStatus method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTMxNg==", "bodyText": "This comment isn't giving any information. Why must we?", "url": "https://github.com/apache/helix/pull/994#discussion_r423445316", "createdAt": "2020-05-12T03:48:42Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -380,72 +379,38 @@ private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions,\n \n   /**\n    * @param liveInstances\n-   * @param prevAssignment task partition -> (instance -> state)\n-   * @param allTaskPartitions all task partitionIds\n    * @param currStateOutput currentStates to make sure currentStates copied over expired sessions\n    *          are accounted for\n    * @param jobName job name\n    * @param tasksToDrop instance -> pId's, to gather all pIds that need to be dropped\n    * @return instance -> partitionIds from previous assignment, if the instance is still live\n    */\n-  protected static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments(\n-      Iterable<String> liveInstances, ResourceAssignment prevAssignment,\n-      Set<Integer> allTaskPartitions, CurrentStateOutput currStateOutput, String jobName,\n+  protected static Map<String, SortedSet<Integer>> getCurrentInstanceToTaskAssignments(\n+      Iterable<String> liveInstances, CurrentStateOutput currStateOutput, String jobName,\n       Map<String, Set<Integer>> tasksToDrop) {\n     Map<String, SortedSet<Integer>> result = new HashMap<>();\n     for (String instance : liveInstances) {\n       result.put(instance, new TreeSet<>());\n     }\n \n-    // First, add all task partitions from prevAssignment\n-    // TODO: Remove this portion to get rid of prevAssignment from Task Framework\n-    for (Partition partition : prevAssignment.getMappedPartitions()) {\n-      int pId = TaskUtil.getPartitionId(partition.getPartitionName());\n-      if (allTaskPartitions.contains(pId)) {\n-        Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition);\n-        for (String instance : replicaMap.keySet()) {\n-          SortedSet<Integer> pIdSet = result.get(instance);\n-          if (pIdSet != null) {\n-            pIdSet.add(pId);\n-          }\n-        }\n-      }\n-    }\n-\n-    // Generate prevInstanceToTaskAssignment with CurrentStateOutput as source of truth\n-\n-    // Add all pIds existing in CurrentStateOutput as well because task currentStates copied over\n-    // from previous sessions won't show up in prevInstanceToTaskAssignments\n-    // We need to add these back here in order for these task partitions to be dropped (after a\n-    // copy-over, the Controller will send a message to drop the state currentState)\n-    // partitions: (partition -> instance -> currentState)\n+    // Generate currentInstanceToTaskAssignment with CurrentStateOutput as source of truth\n+    // Add all pIds existing in CurrentStateOutput\n+    // We need to add these pIds here and make decision about the existing tasks with current state\n+    // in updatePreviousAssignedTasksStatus method\n     Map<Partition, Map<String, String>> partitions = currStateOutput.getCurrentStateMap(jobName);\n     for (Map.Entry<Partition, Map<String, String>> entry : partitions.entrySet()) {\n       // Get all (instance -> currentState) mappings\n       for (Map.Entry<String, String> instanceToCurrState : entry.getValue().entrySet()) {\n         String instance = instanceToCurrState.getKey();\n         String requestedState =\n             currStateOutput.getRequestedState(jobName, entry.getKey(), instance);\n-        TaskPartitionState currState = TaskPartitionState.valueOf(instanceToCurrState.getValue());\n         int pId = TaskUtil.getPartitionId(entry.getKey().getPartitionName());\n \n         if (result.containsKey(instance)) {\n-          // We must add all active task pIds back here because dropping transition could overwrite\n-          // an active transition in paMap\n-          // Add all task partitions in the following states:\n-          // currState = INIT, requestedState = RUNNING (bootstrap)\n-          // currState = RUNNING, requestedState = ANY (active)\n-          // ** for tasks that are just in INIT state, we do not add them here because old\n-          // Participants, upon connection reset, set tasks' currentStates to INIT. We cannot\n-          // consider those tasks active **\n-          if (currState == TaskPartitionState.INIT && requestedState != null\n-              && requestedState.equals(TaskPartitionState.RUNNING.name())\n-              || currState == TaskPartitionState.RUNNING) {\n-            result.get(instance).add(pId);\n-          }\n-\n+          // We must add all pIds back here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTQzNQ==", "bodyText": "Nit: This dot isn't necessary...\nIf anything, repeat again what \"a task needs to be dropped\" means. This is trying to drop tasks on a reconnected instance with a new sessionId that have all of their requestedState == DROPPED.", "url": "https://github.com/apache/helix/pull/994#discussion_r423445435", "createdAt": "2020-05-12T03:49:16Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -380,72 +379,38 @@ private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions,\n \n   /**\n    * @param liveInstances\n-   * @param prevAssignment task partition -> (instance -> state)\n-   * @param allTaskPartitions all task partitionIds\n    * @param currStateOutput currentStates to make sure currentStates copied over expired sessions\n    *          are accounted for\n    * @param jobName job name\n    * @param tasksToDrop instance -> pId's, to gather all pIds that need to be dropped\n    * @return instance -> partitionIds from previous assignment, if the instance is still live\n    */\n-  protected static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments(\n-      Iterable<String> liveInstances, ResourceAssignment prevAssignment,\n-      Set<Integer> allTaskPartitions, CurrentStateOutput currStateOutput, String jobName,\n+  protected static Map<String, SortedSet<Integer>> getCurrentInstanceToTaskAssignments(\n+      Iterable<String> liveInstances, CurrentStateOutput currStateOutput, String jobName,\n       Map<String, Set<Integer>> tasksToDrop) {\n     Map<String, SortedSet<Integer>> result = new HashMap<>();\n     for (String instance : liveInstances) {\n       result.put(instance, new TreeSet<>());\n     }\n \n-    // First, add all task partitions from prevAssignment\n-    // TODO: Remove this portion to get rid of prevAssignment from Task Framework\n-    for (Partition partition : prevAssignment.getMappedPartitions()) {\n-      int pId = TaskUtil.getPartitionId(partition.getPartitionName());\n-      if (allTaskPartitions.contains(pId)) {\n-        Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition);\n-        for (String instance : replicaMap.keySet()) {\n-          SortedSet<Integer> pIdSet = result.get(instance);\n-          if (pIdSet != null) {\n-            pIdSet.add(pId);\n-          }\n-        }\n-      }\n-    }\n-\n-    // Generate prevInstanceToTaskAssignment with CurrentStateOutput as source of truth\n-\n-    // Add all pIds existing in CurrentStateOutput as well because task currentStates copied over\n-    // from previous sessions won't show up in prevInstanceToTaskAssignments\n-    // We need to add these back here in order for these task partitions to be dropped (after a\n-    // copy-over, the Controller will send a message to drop the state currentState)\n-    // partitions: (partition -> instance -> currentState)\n+    // Generate currentInstanceToTaskAssignment with CurrentStateOutput as source of truth\n+    // Add all pIds existing in CurrentStateOutput\n+    // We need to add these pIds here and make decision about the existing tasks with current state\n+    // in updatePreviousAssignedTasksStatus method\n     Map<Partition, Map<String, String>> partitions = currStateOutput.getCurrentStateMap(jobName);\n     for (Map.Entry<Partition, Map<String, String>> entry : partitions.entrySet()) {\n       // Get all (instance -> currentState) mappings\n       for (Map.Entry<String, String> instanceToCurrState : entry.getValue().entrySet()) {\n         String instance = instanceToCurrState.getKey();\n         String requestedState =\n             currStateOutput.getRequestedState(jobName, entry.getKey(), instance);\n-        TaskPartitionState currState = TaskPartitionState.valueOf(instanceToCurrState.getValue());\n         int pId = TaskUtil.getPartitionId(entry.getKey().getPartitionName());\n \n         if (result.containsKey(instance)) {\n-          // We must add all active task pIds back here because dropping transition could overwrite\n-          // an active transition in paMap\n-          // Add all task partitions in the following states:\n-          // currState = INIT, requestedState = RUNNING (bootstrap)\n-          // currState = RUNNING, requestedState = ANY (active)\n-          // ** for tasks that are just in INIT state, we do not add them here because old\n-          // Participants, upon connection reset, set tasks' currentStates to INIT. We cannot\n-          // consider those tasks active **\n-          if (currState == TaskPartitionState.INIT && requestedState != null\n-              && requestedState.equals(TaskPartitionState.RUNNING.name())\n-              || currState == TaskPartitionState.RUNNING) {\n-            result.get(instance).add(pId);\n-          }\n-\n+          // We must add all pIds back here\n+          result.get(instance).add(pId);\n           // Check if this task needs to be dropped. If so, we need to add to tasksToDrop no matter\n-          // what its current state is so that it will be dropped\n+          // what its current state is so that it will be dropped.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTc1OA==", "bodyText": "\"from CurrentStateOutput\"", "url": "https://github.com/apache/helix/pull/994#discussion_r423445758", "createdAt": "2020-05-12T03:50:32Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -462,10 +427,10 @@ private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions,\n    * If partition is missing from prevInstanceToTaskAssignments (e.g. previous assignment is\n    * deleted) it is added from context. Otherwise, the context won't be updated.\n    * @param jobCtx Job Context\n-   * @param prevInstanceToTaskAssignments instance -> partitionIds from previous assignment\n+   * @param currentInstanceToTaskAssignments instance -> partitionIds from current assignment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMTk5NzMw", "url": "https://github.com/apache/helix/pull/994#pullrequestreview-411199730", "createdAt": "2020-05-13T18:41:05Z", "commit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjAyNTA3", "url": "https://github.com/apache/helix/pull/994#pullrequestreview-411202507", "createdAt": "2020-05-13T18:44:48Z", "commit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo0NDo0OVrOGU-5Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo0NDo0OVrOGU-5Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NTE3MA==", "bodyText": "Why you remove the done partition from COMPLETED state? Then this partition will not be removed from pSet, right?", "url": "https://github.com/apache/helix/pull/994#discussion_r424655170", "createdAt": "2020-05-13T18:44:49Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -242,16 +230,16 @@ public void updatePreviousAssignedTasksStatus(\n         }\n           break;\n         case COMPLETED: {\n-          // The task has completed on this partition. Mark as such in the context object.\n-          donePartitions.add(pId);\n+          // The task has completed on this partition. Drop it from the instance and add it to assignedPartitions in\n+          // order to avoid scheduling it again in this pipeline.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70", "committedDate": "2020-05-18T18:03:02Z", "message": "Address the comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODM4MDQ0", "url": "https://github.com/apache/helix/pull/994#pullrequestreview-414838044", "createdAt": "2020-05-19T21:30:41Z", "commit": {"oid": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTozMDo0MlrOGXzXVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0MDo1M1rOGXzp6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMTk5MA==", "bodyText": "Should this function be renamed?", "url": "https://github.com/apache/helix/pull/994#discussion_r427611990", "createdAt": "2020-05-19T21:30:42Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -238,21 +238,20 @@ private ResourceAssignment computeResourceMapping(String jobResource,\n     // These dropping transitions will be prioritized above all task state transition assignments\n     Map<String, Set<Integer>> tasksToDrop = new HashMap<>();\n \n-    Map<String, SortedSet<Integer>> prevInstanceToTaskAssignments =\n-        getPrevInstanceToTaskAssignments(liveInstances, prevTaskToInstanceStateAssignment,\n-            allPartitions, currStateOutput, jobResource, tasksToDrop);\n+    Map<String, SortedSet<Integer>> currentInstanceToTaskAssignments =\n+        getCurrentInstanceToTaskAssignments(liveInstances, currStateOutput, jobResource, tasksToDrop);\n \n-    updateInstanceToTaskAssignmentsFromContext(jobCtx, prevInstanceToTaskAssignments);\n+    updateInstanceToTaskAssignmentsFromContext(jobCtx, currentInstanceToTaskAssignments);\n \n     long currentTime = System.currentTimeMillis();\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"All partitions: \" + allPartitions + \" taskAssignment: \"\n-          + prevInstanceToTaskAssignments + \" excludedInstances: \" + excludedInstances);\n+          + currentInstanceToTaskAssignments + \" excludedInstances: \" + excludedInstances);\n     }\n \n     // Release resource for tasks in terminal state\n-    updatePreviousAssignedTasksStatus(prevInstanceToTaskAssignments, excludedInstances, jobResource,\n+    updatePreviousAssignedTasksStatus(currentInstanceToTaskAssignments, excludedInstances, jobResource,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjI4NQ==", "bodyText": "Would it be a problem that this skipping check is now done after markPartitionCompleted/markPartitionError?", "url": "https://github.com/apache/helix/pull/994#discussion_r427616285", "createdAt": "2020-05-19T21:39:56Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -121,17 +120,6 @@ public void updatePreviousAssignedTasksStatus(\n               instance, pId);\n           continue;\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjc0Ng==", "bodyText": "Is there a possibility that a message exists without state changes?", "url": "https://github.com/apache/helix/pull/994#discussion_r427616746", "createdAt": "2020-05-19T21:40:53Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,59 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assignedParticipant field needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to assign the task to the wrong participant\n+    // for targeted tasks when two CurrentStates exist for one task.\n+    // In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.\n     jobCtx.setAssignedParticipant(pId, instance);\n-    jobCtx.setPartitionState(pId, currentState);\n-    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n-    if (taskMsg != null) {\n-      jobCtx.setPartitionInfo(pId, taskMsg);\n+    // If job context needs to be updated with new state, update it accordingly\n+    // This check is necessary because we are relying on current state and we do not want to update\n+    // context as long as current state existed. We just want to update context information\n+    // (specially finish time) once.\n+    // This condition checks whether jobContext's state is out of date or not.\n+    if (!currentState.equals(jobCtx.getPartitionState(pId))) {\n+      jobCtx.setPartitionState(pId, currentState);\n+      String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n+      if (taskMsg != null) {\n+        jobCtx.setPartitionInfo(pId, taskMsg);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3ODQ4Mjc0", "url": "https://github.com/apache/helix/pull/994#pullrequestreview-417848274", "createdAt": "2020-05-25T19:08:23Z", "commit": {"oid": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTowODoyM1rOGaIMjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTowODoyM1rOGaIMjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MDQ0NQ==", "bodyText": "@alirezazamani Another concern here:\nIs it possible for a task to be retried so fast (on the participant side) that it ends up being in the same state? For example,\ntask_error -> (controller reschedules it) -> (controller sends messages, error -> init, init -> running, running -> complete) -> participant processes message so quickly but it goes into task_error again, and by the time controller gets to this task, the states are the same as the previous run. Basically, controller sees task_error ->  task_error.\nIs that going to be an issue? I guess partition id is set before this check so that will be updated accordingly, but what about finish time or the time at which the task was marked as error?", "url": "https://github.com/apache/helix/pull/994#discussion_r430050445", "createdAt": "2020-05-25T19:08:23Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,59 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assignedParticipant field needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to assign the task to the wrong participant\n+    // for targeted tasks when two CurrentStates exist for one task.\n+    // In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.\n     jobCtx.setAssignedParticipant(pId, instance);\n-    jobCtx.setPartitionState(pId, currentState);\n-    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n-    if (taskMsg != null) {\n-      jobCtx.setPartitionInfo(pId, taskMsg);\n+    // If job context needs to be updated with new state, update it accordingly\n+    // This check is necessary because we are relying on current state and we do not want to update\n+    // context as long as current state existed. We just want to update context information\n+    // (specially finish time) once.\n+    // This condition checks whether jobContext's state is out of date or not.\n+    if (!currentState.equals(jobCtx.getPartitionState(pId))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NzA2MTI3", "url": "https://github.com/apache/helix/pull/994#pullrequestreview-418706127", "createdAt": "2020-05-26T21:53:53Z", "commit": {"oid": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4807, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}